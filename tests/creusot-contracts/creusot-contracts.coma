module M_cell__permcell__impl_PermCellOwn_T__id_ghost (* cell::permcell::PermCellOwn<T> *)
  use creusot.prelude.Any
  
  type t_PermCellOwn_T
  
  type t_Id
  
  function id_T (self: t_PermCellOwn_T) : t_Id
  
  let rec into_ghost_Id (self: t_Id) (return (x: t_Id)) = any
    [ return (result: t_Id) -> {result = self} (! return {result}) ]
  
  predicate inv_PermCellOwn_T (_1: t_PermCellOwn_T)
  
  predicate invariant_ref_PermCellOwn_T [@inline:trivial] (self: t_PermCellOwn_T) = inv_PermCellOwn_T self
  
  meta "rewrite_def" predicate invariant_ref_PermCellOwn_T
  
  predicate inv_ref_PermCellOwn_T [@inline:trivial] (_1: t_PermCellOwn_T) = invariant_ref_PermCellOwn_T _1
  
  meta "rewrite_def" predicate inv_ref_PermCellOwn_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec id_ghost_T (self: t_PermCellOwn_T) (return (x: t_Id)) =
    {[@expl:id_ghost 'self' type invariant] inv_ref_PermCellOwn_T self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- id_T self ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_ghost_Id {_3} (fun (_ret: t_Id) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_Id = Any.any_l () | & self: t_PermCellOwn_T = self | & _3: t_Id = Any.any_l () ])
    [ return (result: t_Id) -> {[@expl:id_ghost ensures] result = id_T self} (! return {result}) ]
end
module M_cell__permcell__impl_PermCell_T_1__id_ghost (* cell::permcell::PermCell<T> *)
  use creusot.prelude.Any
  
  type t_PermCell_T
  
  type t_Id
  
  function id_T (self: t_PermCell_T) : t_Id
  
  let rec into_ghost_Id (self: t_Id) (return (x: t_Id)) = any
    [ return (result: t_Id) -> {result = self} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec id_ghost_T (self: t_PermCell_T) (return (x: t_Id)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- id_T self ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = into_ghost_Id {_3} (fun (_ret: t_Id) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_Id = Any.any_l () | & self: t_PermCell_T = self | & _3: t_Id = Any.any_l () ])
    [ return (result: t_Id) -> {[@expl:id_ghost ensures] result = id_T self} (! return {result}) ]
end
module M_cell__permcell__impl_PermCell_T_2__take (* cell::permcell::PermCell<T> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition_default (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition_default () args]. (let () = args in true)
      -> precondition_default () args
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once_default () args res]. postcondition_once_default () args res
      -> (let () = args in inv_T res)
  
  let rec default_T (return (x: t_T)) = {[@expl:default requires] precondition_default () ()}
    any [ return (result: t_T) -> {postcondition_once_default () () result} (! return {result}) ]
  
  type t_PermCell_T
  
  type t_PermCellOwn_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  function val_T (self: t_PermCellOwn_T) : t_T
  
  predicate invariant_PermCellOwn_T [@inline:trivial] (self: t_PermCellOwn_T) = inv_ref_T (val_T self)
  
  meta "rewrite_def" predicate invariant_PermCellOwn_T
  
  predicate inv_PermCellOwn_T (_1: t_PermCellOwn_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_PermCellOwn_T [inv_PermCellOwn_T x]. inv_PermCellOwn_T x
      = invariant_PermCellOwn_T x
  
  predicate invariant_ref_PermCellOwn_T [@inline:trivial] (self: MutBorrow.t t_PermCellOwn_T) =
    inv_PermCellOwn_T self.current /\ inv_PermCellOwn_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PermCellOwn_T
  
  predicate inv_ref_PermCellOwn_T [@inline:trivial] (_1: MutBorrow.t t_PermCellOwn_T) = invariant_ref_PermCellOwn_T _1
  
  meta "rewrite_def" predicate inv_ref_PermCellOwn_T
  
  predicate invariant_Ghost_ref_PermCellOwn_T [@inline:trivial] (self: MutBorrow.t t_PermCellOwn_T) =
    inv_ref_PermCellOwn_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PermCellOwn_T
  
  predicate inv_Ghost_ref_PermCellOwn_T [@inline:trivial] (_1: MutBorrow.t t_PermCellOwn_T) =
    invariant_Ghost_ref_PermCellOwn_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PermCellOwn_T
  
  type t_Id
  
  function id_T (self: t_PermCell_T) : t_Id
  
  function id_T'0 (self: t_PermCellOwn_T) : t_Id
  
  function view_PermCellOwn_T [@inline:trivial] (self: t_PermCellOwn_T) : t_T = val_T self
  
  meta "rewrite_def" function view_PermCellOwn_T
  
  function fin_Ghost_ref_PermCellOwn_T [@inline:trivial] (self: MutBorrow.t t_PermCellOwn_T) : t_PermCellOwn_T =
    self.final
  
  meta "rewrite_def" function fin_Ghost_ref_PermCellOwn_T
  
  let rec replace_T (self: t_PermCell_T) (perm: MutBorrow.t t_PermCellOwn_T) (val': t_T) (return (x: t_T)) =
    {[@expl:replace 'perm' type invariant] inv_Ghost_ref_PermCellOwn_T perm}
    {[@expl:replace 'val' type invariant] inv_T val'}
    {[@expl:replace requires] id_T self = id_T'0 perm.current}
    any
    [ return (result: t_T) -> {inv_T result}
      {val' = view_PermCellOwn_T (fin_Ghost_ref_PermCellOwn_T perm)}
      {result = view_PermCellOwn_T perm.current}
      {id_T self = id_T'0 (fin_Ghost_ref_PermCellOwn_T perm)}
      (! return {result}) ]
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut_default () args () res]. postcondition_mut_default () args () res
      -> (let () = args in inv_T res)
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: (), res: t_T [postcondition_default () args res]. postcondition_default () args res
      -> (let () = args in inv_T res)
  
  function fn_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take_T (self: t_PermCell_T) (perm: MutBorrow.t t_PermCellOwn_T) (return (x: t_T)) =
    {[@expl:take 'perm' type invariant] inv_Ghost_ref_PermCellOwn_T perm}
    {[@expl:take requires] id_T self = id_T'0 perm.current}
    (! bb0
    [ bb0 = s0 [ s0 = default_T (fun (_ret: t_T) -> [ &_9 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = replace_T {self} {perm} {_9} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: t_T = Any.any_l ()
    | & self: t_PermCell_T = self
    | & perm: MutBorrow.t t_PermCellOwn_T = perm
    | & _9: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:take result type invariant] inv_T result}
      {[@expl:take ensures #0] id_T self = id_T'0 (fin_Ghost_ref_PermCellOwn_T perm)}
      {[@expl:take ensures #1] result = view_PermCellOwn_T perm.current}
      {[@expl:take ensures #2] postcondition_default () () (view_PermCellOwn_T (fin_Ghost_ref_PermCellOwn_T perm))}
      (! return {result}) ]
end
module M_ghost__fn_ghost__impl_Clone_for_FnGhostWrapper_F__clone (* <ghost::fn_ghost::FnGhostWrapper<F> as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_F (_1: t_F)
  
  predicate invariant_ref_F [@inline:trivial] (self: t_F) = inv_F self
  
  meta "rewrite_def" predicate invariant_ref_F
  
  predicate inv_ref_F [@inline:trivial] (_1: t_F) = invariant_ref_F _1
  
  meta "rewrite_def" predicate inv_ref_F
  
  predicate precondition_clone (self: ()) (args: t_F)
  
  axiom precondition_fndef: forall args: t_F [precondition_clone () args]. (let self_ = args in inv_ref_F self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef:
    forall args: t_F, res: t_F [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_F res)
  
  let rec clone_F (self_: t_F) (return (x: t_F)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_F) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  predicate invariant_ref_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) = inv_FnGhostWrapper_F self
  
  meta "rewrite_def" predicate invariant_ref_FnGhostWrapper_F
  
  predicate inv_ref_FnGhostWrapper_F [@inline:trivial] (_1: t_FnGhostWrapper_F) = invariant_ref_FnGhostWrapper_F _1
  
  meta "rewrite_def" predicate inv_ref_FnGhostWrapper_F
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_F, res: t_F [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_F res)
  
  function fn_mut_once_clone (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_F, res: t_F. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1:
    forall args: t_F, res: t_F [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_F res)
  
  function fn_once_clone (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_F, res: t_F. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) : t_F = self.f0
  
  meta "rewrite_def" function view_FnGhostWrapper_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_FnGhostWrapper_F (self: t_FnGhostWrapper_F) (return (x: t_FnGhostWrapper_F)) =
    {[@expl:clone 'self' type invariant] inv_ref_FnGhostWrapper_F self}
    (! bb0
    [ bb0 = s0 [ s0 = clone_F {self.f0} (fun (_ret: t_F) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { f0 = _3 } ] s1 | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: t_FnGhostWrapper_F = Any.any_l () | & self: t_FnGhostWrapper_F = self | & _3: t_F = Any.any_l () ])
    [ return (result: t_FnGhostWrapper_F) -> {[@expl:clone result type invariant] inv_FnGhostWrapper_F result}
      {[@expl:clone ensures] postcondition_clone () (view_FnGhostWrapper_F self) (view_FnGhostWrapper_F result)}
      (! return {result}) ]
end
module M_ghost__fn_ghost__impl_FnGhostWrapper_F__new (* ghost::fn_ghost::FnGhostWrapper<F> *)
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  function view_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) : t_F = self.f0
  
  meta "rewrite_def" function view_FnGhostWrapper_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec __new_F (f: t_F) (return (x: t_FnGhostWrapper_F)) = {[@expl:__new 'f' type invariant] inv_F f}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { f0 = f } ] s1 | s1 = bb2 ] | bb2 = return {_0} ]
    [ & _0: t_FnGhostWrapper_F = Any.any_l () | & f: t_F = f ])
    [ return (result: t_FnGhostWrapper_F) -> {[@expl:__new result type invariant] inv_FnGhostWrapper_F result}
      {[@expl:__new ensures] view_FnGhostWrapper_F result = f}
      (! return {result}) ]
end
module M_ghost__local_invariant__impl_LocalInvariantExt_for_Ghost_ref_LocalInvariant_T__open (* <ghost::Ghost<&'a ghost::local_invariant::LocalInvariant<T>> as ghost::local_invariant::LocalInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Set
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_LocalInvariant_T
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  predicate inv_F (_1: t_F)
  
  predicate contains_Namespace [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = Set.mem e self
  
  meta "rewrite_def" predicate contains_Namespace
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains (self: t_Tokens) (namespace: t_Namespace) = contains_Namespace (namespaces self) namespace
  
  function namespace_T (self: t_LocalInvariant_T) : t_Namespace
  
  type t_T
  
  type t_Public
  
  predicate protocol_T (self: t_T) (data: t_Public)
  
  function public_T (self: t_LocalInvariant_T) : t_Public
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Ghost_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_T
  
  predicate inv_Ghost_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_Ghost_ref_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_T
  
  predicate precondition_F (self: t_F) (args: MutBorrow.t t_T)
  
  predicate postcondition_once_F (self: t_F) (args: MutBorrow.t t_T) (result: t_A)
  
  function fin_Ghost_ref_T [@inline:trivial] (self: MutBorrow.t t_T) : t_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_T
  
  predicate inv_A (_1: t_A)
  
  let rec open_T (this: t_LocalInvariant_T) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open 'f' type invariant] inv_F f}
    {[@expl:open requires #0] contains tokens (namespace_T this)}
    {[@expl:open requires #1] forall t: MutBorrow.t t_T. protocol_T t.current (public_T this) /\ inv_Ghost_ref_T t
      -> precondition_F f t
      /\ (forall res: t_A. postcondition_once_F f t res -> protocol_T (fin_Ghost_ref_T t) (public_T this))}
    any
    [ return (result: t_A) -> {inv_A result}
      {exists t: MutBorrow.t t_T. protocol_T t.current (public_T this) /\ postcondition_once_F f t result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open_Ghost_ref_LocalInvariant_T (self: t_LocalInvariant_T) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open 'f' type invariant] inv_F f}
    {[@expl:open requires #0] contains tokens (namespace_T self)}
    {[@expl:open requires #1] forall t: MutBorrow.t t_T. protocol_T t.current (public_T self) /\ inv_Ghost_ref_T t
      -> precondition_F f t
      /\ (forall res: t_A. postcondition_once_F f t res -> protocol_T (fin_Ghost_ref_T t) (public_T self))}
    (! bb0
    [ bb0 = s0 [ s0 = open_T {self} {tokens} {f} (fun (_ret: t_A) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: t_A = Any.any_l () | & self: t_LocalInvariant_T = self | & tokens: t_Tokens = tokens | & f: t_F = f ])
    [ return (result: t_A) -> {[@expl:open result type invariant] inv_A result}
      {[@expl:open ensures] exists t: MutBorrow.t t_T. protocol_T t.current (public_T self)
        /\ postcondition_once_F f t result}
      (! return {result}) ]
end
module M_ghost__local_invariant__impl_LocalInvariantExt_for_Ghost_ref_T__open (* <ghost::Ghost<&'a T> as ghost::local_invariant::LocalInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Ghost_ref_T [@inline:trivial] (self: t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_T
  
  predicate inv_Ghost_ref_T [@inline:trivial] (_1: t_T) = invariant_Ghost_ref_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_T
  
  predicate invariant_ref_Ghost_ref_T [@inline:trivial] (self: t_T) = inv_Ghost_ref_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_T
  
  predicate inv_ref_Ghost_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_Ghost_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_T
  
  predicate invariant_ref_ref_T [@inline:trivial] (self: t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_T
  
  predicate inv_ref_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_T
  
  let rec deref_Ghost_ref_T (self: t_T) (return (x: t_T)) =
    {[@expl:deref 'self' type invariant] inv_ref_Ghost_ref_T self}
    any [ return (result: t_T) -> {inv_ref_ref_T result} {result = self} (! return {result}) ]
  
  type t_Target
  
  predicate precondition_deref (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_deref () args]. (let self_ = args in false)
      -> precondition_deref () args
  
  predicate inv_Target (_1: t_Target)
  
  predicate invariant_ref_Target [@inline:trivial] (self: t_Target) = inv_Target self
  
  meta "rewrite_def" predicate invariant_ref_Target
  
  predicate inv_ref_Target [@inline:trivial] (_1: t_Target) = invariant_ref_Target _1
  
  meta "rewrite_def" predicate inv_ref_Target
  
  predicate postcondition_once_deref (self: ()) (args: t_T) (result: t_Target)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_Target [postcondition_once_deref () args res]. postcondition_once_deref () args res
      -> (let self_ = args in inv_ref_Target res)
  
  let rec deref_T (self_: t_T) (return (x: t_Target)) = {[@expl:deref requires] precondition_deref () self_}
    any [ return (result: t_Target) -> {postcondition_once_deref () self_ result} (! return {result}) ]
  
  predicate invariant_Ghost_ref_Target [@inline:trivial] (self: t_Target) = inv_ref_Target self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_Target
  
  predicate inv_Ghost_ref_Target [@inline:trivial] (_1: t_Target) = invariant_Ghost_ref_Target _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_Target
  
  let rec new_ref_Target (x: t_Target) (return (x'0: t_Target)) = {[@expl:new 'x' type invariant] inv_ref_Target x}
    any [ return (result: t_Target) -> {inv_Ghost_ref_Target result} {result = x} (! return {result}) ]
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  type tup3_Ghost_ref_Target_Ghost_Tokens_F = { f0: t_Target; f1: t_Tokens; f2: t_F }
  
  predicate precondition_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F)
  
  axiom precondition_fndef'0:
    forall args: tup3_Ghost_ref_Target_Ghost_Tokens_F [precondition_open () args]. (let {f0 = self; f1 = tokens; f2 = f} = args in false)
      -> precondition_open () args
  
  predicate inv_A (_1: t_A)
  
  predicate postcondition_once_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A [postcondition_once_open () args res]. postcondition_once_open () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  let rec open_Ghost_ref_Target (self: t_Target) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open requires] precondition_open () { f0 = self; f1 = tokens; f2 = f }}
    any
    [ return (result: t_A) -> {postcondition_once_open () { f0 = self; f1 = tokens; f2 = f } result}
      (! return {result}) ]
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_deref [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_deref
  
  predicate postcondition_mut_deref (self: ()) (args: t_T) (result_state: ()) (result: t_Target)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_Target [postcondition_mut_deref () args () res]. postcondition_mut_deref () args () res
      -> (let self_ = args in inv_ref_Target res)
  
  function fn_mut_once_deref (self: ()) (args: t_T) (res: t_Target) : ()
  
  axiom fn_mut_once_deref_spec: forall self: (), args: t_T, res: t_Target. postcondition_once_deref self args res
      = (exists res_state: (). postcondition_mut_deref self args res_state res /\ resolve_deref res_state)
  
  predicate hist_inv_deref [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_deref
  
  function hist_inv_trans_deref (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_deref_spec: forall self: (), b: (), c: (). hist_inv_deref self b
      -> hist_inv_deref b c -> hist_inv_deref self c
  
  function hist_inv_refl_deref (self: ()) : ()
  
  axiom hist_inv_refl_deref_spec: forall self: (). hist_inv_deref self self
  
  function postcondition_mut_hist_inv_deref (self: ()) (args: t_T) (res_state: ()) (res: t_Target) : ()
  
  axiom postcondition_mut_hist_inv_deref_spec:
    forall self: (), args: t_T, res_state: (), res: t_Target. postcondition_mut_deref self args res_state res
      -> hist_inv_deref self res_state
  
  function fn_hist_inv_deref (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_deref_spec: forall self: (), res_state: (). hist_inv_deref self res_state = (self = res_state)
  
  predicate postcondition_deref (self: ()) (args: t_T) (result: t_Target)
  
  axiom postcondition_fndef'2:
    forall args: t_T, res: t_Target [postcondition_deref () args res]. postcondition_deref () args res
      -> (let self_ = args in inv_ref_Target res)
  
  function fn_once_deref (self: ()) (args: t_T) (res: t_Target) : ()
  
  axiom fn_once_deref_spec: forall self: (), args: t_T, res: t_Target. postcondition_once_deref self args res
      = (postcondition_deref self args res /\ resolve_deref self)
  
  function fn_mut_deref (self: ()) (args: t_T) (res_state: ()) (res: t_Target) : ()
  
  axiom fn_mut_deref_spec:
    forall self: (), args: t_T, res_state: (), res: t_Target. postcondition_mut_deref self args res_state res
      = (postcondition_deref self args res /\ self = res_state)
  
  function new_ref_Target'0 (x: t_Target) : t_Target
  
  axiom new_ref_Target_spec: forall x: t_Target. new_ref_Target'0 x = x
  
  predicate resolve_open [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_open
  
  predicate postcondition_mut_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'3:
    forall args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A [postcondition_mut_open () args () res]. postcondition_mut_open () args () res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  function fn_mut_once_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (res: t_A) : ()
  
  axiom fn_mut_once_open_spec:
    forall self: (), args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A. postcondition_once_open self args res
      = (exists res_state: (). postcondition_mut_open self args res_state res /\ resolve_open res_state)
  
  predicate hist_inv_open [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_open
  
  function hist_inv_trans_open (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_open_spec: forall self: (), b: (), c: (). hist_inv_open self b
      -> hist_inv_open b c -> hist_inv_open self c
  
  function hist_inv_refl_open (self: ()) : ()
  
  axiom hist_inv_refl_open_spec: forall self: (). hist_inv_open self self
  
  function postcondition_mut_hist_inv_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_open_spec:
    forall self: (), args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res_state: (), res: t_A. postcondition_mut_open self args res_state res
      -> hist_inv_open self res_state
  
  function fn_hist_inv_open (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_open_spec: forall self: (), res_state: (). hist_inv_open self res_state = (self = res_state)
  
  predicate postcondition_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (result: t_A)
  
  axiom postcondition_fndef'4:
    forall args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A [postcondition_open () args res]. postcondition_open () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  function fn_once_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (res: t_A) : ()
  
  axiom fn_once_open_spec:
    forall self: (), args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A. postcondition_once_open self args res
      = (postcondition_open self args res /\ resolve_open self)
  
  function fn_mut_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_open_spec:
    forall self: (), args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res_state: (), res: t_A. postcondition_mut_open self args res_state res
      = (postcondition_open self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open_Ghost_ref_T (self: t_T) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open 'self' type invariant] inv_Ghost_ref_T self}
    {[@expl:open 'f' type invariant] inv_F f}
    {[@expl:open requires #0] precondition_deref () self}
    {[@expl:open requires #1] forall this: t_Target. postcondition_deref () self this
      -> precondition_open () { f0 = new_ref_Target'0 this; f1 = tokens; f2 = f }}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_13 <- self ] s1 | s1 = deref_Ghost_ref_T {_13} (fun (_ret: t_T) -> [ &_11 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = deref_T {_11} (fun (_ret: t_Target) -> [ &_9 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = new_ref_Target {_9} (fun (_ret: t_Target) -> [ &this <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = open_Ghost_ref_Target {this} {tokens} {f} (fun (_ret: t_A) -> [ &_0 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: t_A = Any.any_l ()
    | & self: t_T = self
    | & tokens: t_Tokens = tokens
    | & f: t_F = f
    | & this: t_Target = Any.any_l ()
    | & _9: t_Target = Any.any_l ()
    | & _11: t_T = Any.any_l ()
    | & _13: t_T = Any.any_l () ])
    [ return (result: t_A) -> {[@expl:open result type invariant] inv_A result}
      {[@expl:open ensures] exists this: t_Target. postcondition_deref () self this
        /\ postcondition_open () { f0 = new_ref_Target'0 this; f1 = tokens; f2 = f } result}
      (! return {result}) ]
end
module M_ghost__local_invariant__impl_LocalInvariantExt_for_ref_Ghost_L__open (* <&'a ghost::Ghost<L> as ghost::local_invariant::LocalInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_L
  
  predicate inv_L (_1: t_L)
  
  predicate invariant_Ghost_L [@inline:trivial] (self: t_L) = inv_L self
  
  meta "rewrite_def" predicate invariant_Ghost_L
  
  predicate inv_Ghost_L [@inline:trivial] (_1: t_L) = invariant_Ghost_L _1
  
  meta "rewrite_def" predicate inv_Ghost_L
  
  predicate invariant_ref_Ghost_L [@inline:trivial] (self: t_L) = inv_Ghost_L self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_L
  
  predicate inv_ref_Ghost_L [@inline:trivial] (_1: t_L) = invariant_ref_Ghost_L _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_L
  
  predicate invariant_ref_L [@inline:trivial] (self: t_L) = inv_L self
  
  meta "rewrite_def" predicate invariant_ref_L
  
  predicate inv_ref_L [@inline:trivial] (_1: t_L) = invariant_ref_L _1
  
  meta "rewrite_def" predicate inv_ref_L
  
  predicate invariant_Ghost_ref_L [@inline:trivial] (self: t_L) = inv_ref_L self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_L
  
  predicate inv_Ghost_ref_L [@inline:trivial] (_1: t_L) = invariant_Ghost_ref_L _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_L
  
  let rec borrow_L (self: t_L) (return (x: t_L)) = {[@expl:borrow 'self' type invariant] inv_ref_Ghost_L self}
    any [ return (result: t_L) -> {inv_Ghost_ref_L result} {result = self} (! return {result}) ]
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  type tup3_Ghost_ref_L_Ghost_Tokens_F = { f0: t_L; f1: t_Tokens; f2: t_F }
  
  predicate precondition_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F)
  
  axiom precondition_fndef:
    forall args: tup3_Ghost_ref_L_Ghost_Tokens_F [precondition_open () args]. (let {f0 = self; f1 = tokens; f2 = f} = args in false)
      -> precondition_open () args
  
  predicate inv_A (_1: t_A)
  
  predicate postcondition_once_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (result: t_A)
  
  axiom postcondition_fndef:
    forall args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A [postcondition_once_open () args res]. postcondition_once_open () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  let rec open_Ghost_ref_L (self: t_L) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open requires] precondition_open () { f0 = self; f1 = tokens; f2 = f }}
    any
    [ return (result: t_A) -> {postcondition_once_open () { f0 = self; f1 = tokens; f2 = f } result}
      (! return {result}) ]
  
  predicate inv_F (_1: t_F)
  
  function new_ref_L (x: t_L) : t_L
  
  axiom new_ref_L_spec: forall x: t_L. new_ref_L x = x
  
  predicate resolve_open [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_open
  
  predicate postcondition_mut_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A [postcondition_mut_open () args () res]. postcondition_mut_open () args () res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  function fn_mut_once_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (res: t_A) : ()
  
  axiom fn_mut_once_open_spec:
    forall self: (), args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A. postcondition_once_open self args res
      = (exists res_state: (). postcondition_mut_open self args res_state res /\ resolve_open res_state)
  
  predicate hist_inv_open [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_open
  
  function hist_inv_trans_open (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_open_spec: forall self: (), b: (), c: (). hist_inv_open self b
      -> hist_inv_open b c -> hist_inv_open self c
  
  function hist_inv_refl_open (self: ()) : ()
  
  axiom hist_inv_refl_open_spec: forall self: (). hist_inv_open self self
  
  function postcondition_mut_hist_inv_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_open_spec:
    forall self: (), args: tup3_Ghost_ref_L_Ghost_Tokens_F, res_state: (), res: t_A. postcondition_mut_open self args res_state res
      -> hist_inv_open self res_state
  
  function fn_hist_inv_open (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_open_spec: forall self: (), res_state: (). hist_inv_open self res_state = (self = res_state)
  
  predicate postcondition_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A [postcondition_open () args res]. postcondition_open () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  function fn_once_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (res: t_A) : ()
  
  axiom fn_once_open_spec:
    forall self: (), args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A. postcondition_once_open self args res
      = (postcondition_open self args res /\ resolve_open self)
  
  function fn_mut_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_open_spec:
    forall self: (), args: tup3_Ghost_ref_L_Ghost_Tokens_F, res_state: (), res: t_A. postcondition_mut_open self args res_state res
      = (postcondition_open self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open_ref_Ghost_L (self: t_L) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@expl:open 'self' type invariant] inv_ref_Ghost_L self}
    {[@expl:open 'f' type invariant] inv_F f}
    {[@expl:open requires] precondition_open () { f0 = new_ref_L self; f1 = tokens; f2 = f }}
    (! bb0
    [ bb0 = s0 [ s0 = borrow_L {self} (fun (_ret: t_L) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = open_Ghost_ref_L {_6} {tokens} {f} (fun (_ret: t_A) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_A = Any.any_l ()
    | & self: t_L = self
    | & tokens: t_Tokens = tokens
    | & f: t_F = f
    | & _6: t_L = Any.any_l () ])
    [ return (result: t_A) -> {[@expl:open result type invariant] inv_A result}
      {[@expl:open ensures] postcondition_open () { f0 = new_ref_L self; f1 = tokens; f2 = f } result}
      (! return {result}) ]
end
module M_ghost__ptr_own__impl_PtrOwn_T_0__new (* ghost::ptr_own::PtrOwn<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn_T
  
  type tup2_ptr_T_Ghost_PtrOwn_T = { f0: Opaque.ptr; f1: t_PtrOwn_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate is_null_ptr_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_T (self: t_PtrOwn_T) : Opaque.ptr
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_T : UInt64.t
  
  axiom align_of_T_spec: (0: UInt64.t) <> align_of_T
    /\ UInt64.bw_and align_of_T (UInt64.sub align_of_T (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_T_spec'0: Int.mod size_of_T (UInt64.t'int align_of_T) = 0
  
  predicate is_aligned_T [@inline:trivial] (ptr: Opaque.ptr) = is_aligned_to_ptr_T ptr align_of_T
  
  meta "rewrite_def" predicate is_aligned_T
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  predicate ptr_is_aligned_opaque_T (self: t_PtrOwn_T) = is_aligned_ptr_T (ptr_T self)
  
  predicate metadata_matches_T [@inline:trivial] (_value: t_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_T
  
  function val_T (self: t_PtrOwn_T) : t_T
  
  function metadata_T (_1: Opaque.ptr) : ()
  
  function size_of_val_T [@inline:trivial] (val': t_T) : int = size_of_T
  
  meta "rewrite_def" function size_of_val_T
  
  axiom size_of_val_T_spec: forall val': t_T. 0 <= size_of_val_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_PtrOwn_T (self: t_PtrOwn_T) =
    not is_null_ptr_T (ptr_T self)
    /\ ptr_is_aligned_opaque_T self
    /\ metadata_matches_T (val_T self) (metadata_T (ptr_T self))
    /\ size_of_val_T (val_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_T self)) + size_of_val_T (val_T self) <= UInt64.t'int const_MAX'0
    /\ inv_ref_T (val_T self)
  
  predicate inv_PtrOwn_T (_1: t_PtrOwn_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_T [inv_PtrOwn_T x]. inv_PtrOwn_T x = invariant_PtrOwn_T x
  
  predicate invariant_Ghost_PtrOwn_T [@inline:trivial] (self: t_PtrOwn_T) = inv_PtrOwn_T self
  
  meta "rewrite_def" predicate invariant_Ghost_PtrOwn_T
  
  predicate inv_Ghost_PtrOwn_T [@inline:trivial] (_1: t_PtrOwn_T) = invariant_Ghost_PtrOwn_T _1
  
  meta "rewrite_def" predicate inv_Ghost_PtrOwn_T
  
  predicate inv_tup2_ptr_T_Ghost_PtrOwn_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_PtrOwn_T) = inv_Ghost_PtrOwn_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_PtrOwn_T
  
  let rec from_box_T (val': t_T) (return (x: tup2_ptr_T_Ghost_PtrOwn_T)) =
    {[@expl:from_box 'val' type invariant] inv_Box_T_Global val'}
    any
    [ return (result: tup2_ptr_T_Ghost_PtrOwn_T) -> {inv_tup2_ptr_T_Ghost_PtrOwn_T result}
      {ptr_T result.f1 = result.f0 /\ val_T result.f1 = val'}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_T (v: t_T) (return (x: tup2_ptr_T_Ghost_PtrOwn_T)) = {[@expl:new 'v' type invariant] inv_T v}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = from_box_T {v} (fun (_ret: tup2_ptr_T_Ghost_PtrOwn_T) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ] [ & _0: tup2_ptr_T_Ghost_PtrOwn_T = Any.any_l () | & v: t_T = v ])
    [ return (result: tup2_ptr_T_Ghost_PtrOwn_T) ->
    {[@expl:new result type invariant] inv_tup2_ptr_T_Ghost_PtrOwn_T result}
      {[@expl:new ensures] ptr_T result.f1 = result.f0 /\ val_T result.f1 = v}
      (! return {result}) ]
end
module M_ghost__ptr_own__impl_PtrOwn_T_1__drop (* ghost::ptr_own::PtrOwn<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_PtrOwn_T
  
  type t_T
  
  predicate is_null_ptr_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_T (self: t_PtrOwn_T) : Opaque.ptr
  
  predicate is_aligned_T (ptr: Opaque.ptr)
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  predicate ptr_is_aligned_opaque_T (self: t_PtrOwn_T) = is_aligned_ptr_T (ptr_T self)
  
  type t_Metadata
  
  predicate metadata_matches_T (_value: t_T) (_metadata: t_Metadata)
  
  function val_T (self: t_PtrOwn_T) : t_T
  
  function metadata_T (_1: Opaque.ptr) : t_Metadata
  
  function size_of_val_T (val': t_T) : int
  
  axiom size_of_val_T_spec: forall val': t_T. 0 <= size_of_val_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_PtrOwn_T (self: t_PtrOwn_T) =
    not is_null_ptr_T (ptr_T self)
    /\ ptr_is_aligned_opaque_T self
    /\ metadata_matches_T (val_T self) (metadata_T (ptr_T self))
    /\ size_of_val_T (val_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_T self)) + size_of_val_T (val_T self) <= UInt64.t'int const_MAX'0
    /\ inv_ref_T (val_T self)
  
  predicate inv_PtrOwn_T (_1: t_PtrOwn_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_T [inv_PtrOwn_T x]. inv_PtrOwn_T x = invariant_PtrOwn_T x
  
  predicate invariant_Ghost_PtrOwn_T [@inline:trivial] (self: t_PtrOwn_T) = inv_PtrOwn_T self
  
  meta "rewrite_def" predicate invariant_Ghost_PtrOwn_T
  
  predicate inv_Ghost_PtrOwn_T [@inline:trivial] (_1: t_PtrOwn_T) = invariant_Ghost_PtrOwn_T _1
  
  meta "rewrite_def" predicate inv_Ghost_PtrOwn_T
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  let rec to_box_T (ptr: Opaque.ptr) (own: t_PtrOwn_T) (return (x: t_T)) =
    {[@expl:to_box 'own' type invariant] inv_Ghost_PtrOwn_T own}
    {[@expl:to_box requires] ptr = ptr_T own}
    any [ return (result: t_T) -> {inv_Box_T_Global result} {result = val_T own} (! return {result}) ]
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Box_T_Global [@inline:trivial] (_1: t_T) = resolve_T _1
  
  meta "rewrite_def" predicate resolve_Box_T_Global
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec drop_T (ptr: Opaque.ptr) (own: t_PtrOwn_T) (return (x: ())) =
    {[@expl:drop 'own' type invariant] inv_Ghost_PtrOwn_T own}
    {[@expl:drop requires] ptr = ptr_T own}
    (! bb0
    [ bb0 = s0 [ s0 = to_box_T {ptr} {own} (fun (_ret: t_T) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv_Box_T_Global _4} s1 | s1 = -{resolve_Box_T_Global _4}- s2 | s2 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: () = Any.any_l () | & ptr: Opaque.ptr = ptr | & own: t_PtrOwn_T = own | & _4: t_T = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_ghost__ptr_own__impl_PtrOwn_T_1__ptr_is_aligned_lemma (* ghost::ptr_own::PtrOwn<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.int.Int64
  
  type t_PtrOwn_T
  
  predicate is_null_ptr_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_T (self: t_PtrOwn_T) : Opaque.ptr
  
  predicate is_aligned_T (ptr: Opaque.ptr)
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  predicate ptr_is_aligned_opaque_T (self: t_PtrOwn_T) = is_aligned_ptr_T (ptr_T self)
  
  type t_T
  
  type t_Metadata
  
  predicate metadata_matches_T (_value: t_T) (_metadata: t_Metadata)
  
  function val_T (self: t_PtrOwn_T) : t_T
  
  function metadata_T (_1: Opaque.ptr) : t_Metadata
  
  function size_of_val_T (val': t_T) : int
  
  axiom size_of_val_T_spec: forall val': t_T. 0 <= size_of_val_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_PtrOwn_T (self: t_PtrOwn_T) =
    not is_null_ptr_T (ptr_T self)
    /\ ptr_is_aligned_opaque_T self
    /\ metadata_matches_T (val_T self) (metadata_T (ptr_T self))
    /\ size_of_val_T (val_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_T self)) + size_of_val_T (val_T self) <= UInt64.t'int const_MAX'0
    /\ inv_ref_T (val_T self)
  
  predicate inv_PtrOwn_T (_1: t_PtrOwn_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_T [inv_PtrOwn_T x]. inv_PtrOwn_T x = invariant_PtrOwn_T x
  
  predicate invariant_ref_PtrOwn_T [@inline:trivial] (self: t_PtrOwn_T) = inv_PtrOwn_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_T
  
  predicate inv_ref_PtrOwn_T [@inline:trivial] (_1: t_PtrOwn_T) = invariant_ref_PtrOwn_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ptr_is_aligned_lemma_T (self: t_PtrOwn_T) (return (x: ())) =
    {[@expl:ptr_is_aligned_lemma 'self' type invariant] inv_ref_PtrOwn_T self}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:ptr_is_aligned_lemma ensures] is_aligned_ptr_T (ptr_T self)} (! return {result}) ]
end
module M_ghost__resource__fmap_view__impl_Authority_K_V__new (* ghost::resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap_K_Ag_V
  
  type t_View_AuthViewRel_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None | Some t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_Option_Ag_V = None'0 | Some'0 t_Ag_V
  
  type t_Option_Option_Ag_V = None'1 | Some'1 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'0: t_Option_Ag_V; f1'0: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0 = other.f0 then Some'0 self else None'0
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'0 = self;
                                                                                                        f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'0 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  type t_K
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'1 then
      Some (total_op_K self other)
    else
      None
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'0)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'0 c -> op_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'0 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'0 = self; f1'0 = factor } with
      | {f0'0 = x; f1'0 = None'0} -> Some'1 x
      | {f0'0 = None'0} -> None'1
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> match factor_Ag_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'1 c -> op_Option_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'1 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'1
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'1 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'1: t_K; f1'1: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'1 = k; f1'1 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_Ag_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in Some res
    else
      None
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some c -> op_FMap_K_Ag_V factor c = Some self
        | None -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some comb
      -> incl_FMap_K_Ag_V self comb
  
  predicate rel_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some a'0 -> incl_FMap_K_Ag_V f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) : ()
  
  axiom rel_unit_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a unit_FMap_K_Ag_V
  
  function rel_none_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) : ()
  
  axiom rel_none_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (None) f
  
  function rel_mono_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f1: t_FMap_K_Ag_V) (f2: t_FMap_K_Ag_V) : ()
  
  axiom rel_mono_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f1: t_FMap_K_Ag_V, f2: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a f1
      -> incl_FMap_K_Ag_V f2 f1 -> rel_AuthViewRel_FMap_K_Ag_V a f2
  
  function auth_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
  
  function frag_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom frag_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V self)
  
  function new_AuthViewRel_FMap_K_Ag_V (auth: t_Option_FMap_K_Ag_V) (frag: t_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  axiom new_AuthViewRel_FMap_K_Ag_V_spec:
    forall auth: t_Option_FMap_K_Ag_V, frag: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V auth frag
      -> auth_AuthViewRel_FMap_K_Ag_V (new_AuthViewRel_FMap_K_Ag_V auth frag) = auth
  
  axiom new_AuthViewRel_FMap_K_Ag_V_spec'0:
    forall auth: t_Option_FMap_K_Ag_V, frag: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V auth frag
      -> frag_AuthViewRel_FMap_K_Ag_V (new_AuthViewRel_FMap_K_Ag_V auth frag) = frag
  
  function new_auth_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (auth: t_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V =
    new_AuthViewRel_FMap_K_Ag_V (Some auth) unit_FMap_K_Ag_V
  
  meta "rewrite_def" function new_auth_AuthViewRel_FMap_K_Ag_V
  
  type t_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  function val_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  function view_Resource_View_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
   = val_View_AuthViewRel_FMap_K_Ag_V self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  let rec alloc_View_AuthViewRel_FMap_K_Ag_V (r: t_View_AuthViewRel_FMap_K_Ag_V)
    (return (x: t_Resource_View_AuthViewRel_FMap_K_Ag_V)) = any
    [ return (result: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> {view_Resource_View_AuthViewRel_FMap_K_Ag_V result
      = r}
      (! return {result}) ]
  
  let rec into_inner_Resource_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V)
    (return (x: t_Resource_View_AuthViewRel_FMap_K_Ag_V)) = any
    [ return (result: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> {result = self} (! return {result}) ]
  
  type t_Authority_K_V = { f0'2: t_Resource_View_AuthViewRel_FMap_K_Ag_V }
  
  predicate invariant_Authority_K_V (self: t_Authority_K_V) =
    auth_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0'2) <> None
  
  predicate inv_Authority_K_V (_1: t_Authority_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_K_V [inv_Authority_K_V x]. inv_Authority_K_V x
      = invariant_Authority_K_V x
  
  predicate invariant_Ghost_Authority_K_V [@inline:trivial] (self: t_Authority_K_V) = inv_Authority_K_V self
  
  meta "rewrite_def" predicate invariant_Ghost_Authority_K_V
  
  predicate inv_Ghost_Authority_K_V [@inline:trivial] (_1: t_Authority_K_V) = invariant_Ghost_Authority_K_V _1
  
  meta "rewrite_def" predicate inv_Ghost_Authority_K_V
  
  let rec new_Authority_K_V (x: t_Authority_K_V) (return (x'0: t_Authority_K_V)) =
    {[@expl:new 'x' type invariant] inv_Authority_K_V x}
    any [ return (result: t_Authority_K_V) -> {inv_Ghost_Authority_K_V result} {result = x} (! return {result}) ]
  
  type t_FMap_K_V
  
  type t_Option_V = None'2 | Some'2 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K'0 self k = get_K'0 other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  function index_Mapping_tup2_K_Ag_V_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_V) (a: tup2_K_Ag_V) : t_V =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_V
  
  function len_K'0 (self: t_FMap_K_V) : int
  
  axiom len_K_spec'0: forall self: t_FMap_K_V. len_K'0 self >= 0
  
  function map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_V) : t_FMap_K_V
  
  axiom map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_V. forall k: t_K [get_K'0 (map_K self f) k]. get_K'0 (map_K self f) k
        = match get_K self k with
          | None'0 -> None'2
          | Some'0 v -> Some'2 (index_Mapping_tup2_K_Ag_V_V f { f0'1 = k; f1'1 = v })
          end
  
  axiom map_K_spec'0: forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_V. len_K'0 (map_K self f) = len_K self
  
  predicate index_Mapping_FMap_K_Ag_V_bool [@inline:trivial] (self: Map.map t_FMap_K_Ag_V bool) (a: t_FMap_K_Ag_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_Ag_V_bool
  
  function such_that_FMap_K_Ag_V (p: Map.map t_FMap_K_Ag_V bool) : t_FMap_K_Ag_V
  
  axiom such_that_FMap_K_Ag_V_spec:
    forall p: Map.map t_FMap_K_Ag_V bool. (exists x: t_FMap_K_Ag_V. index_Mapping_FMap_K_Ag_V_bool p x)
      -> index_Mapping_FMap_K_Ag_V_bool p (such_that_FMap_K_Ag_V p)
  
  function unwrap_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) : t_FMap_K_Ag_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_Ag_V (fun (__0: t_FMap_K_Ag_V) -> true)
      end
  
  function view_Authority_K_V (self: t_Authority_K_V) : t_FMap_K_V =
    map_K (unwrap_Option_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0'2))) (fun (__0: tup2_K_Ag_V) -> let {f1'1 = x} = __0 in x.f0)
  
  constant empty_K'0 : t_FMap_K_V
  
  axiom empty_K_spec'1: len_K'0 empty_K'0 = 0
  
  axiom empty_K_spec'2: view_FMap_K_V empty_K'0 = Const.const (None'2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_K (return (x: t_Authority_K_V)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_6 <- new_auth_AuthViewRel_FMap_K_Ag_V empty_K ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = alloc_View_AuthViewRel_FMap_K_Ag_V {_6}
          (fun (_ret: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> [ &_5 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0
      [ s0 = into_inner_Resource_View_AuthViewRel_FMap_K_Ag_V {_5}
          (fun (_ret: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> [ &_4 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_3 <- { f0'2 = _4 } ] s1
      | s1 = new_Authority_K_V {_3} (fun (_ret: t_Authority_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:assertion] ext_eq_K (view_Authority_K_V r) empty_K'0} s1
      | s1 = [ &_0 <- r ] s2
      | s2 = return {_0} ] ]
    [ & _0: t_Authority_K_V = Any.any_l ()
    | & r: t_Authority_K_V = Any.any_l ()
    | & _3: t_Authority_K_V = Any.any_l ()
    | & _4: t_Resource_View_AuthViewRel_FMap_K_Ag_V = Any.any_l ()
    | & _5: t_Resource_View_AuthViewRel_FMap_K_Ag_V = Any.any_l ()
    | & _6: t_View_AuthViewRel_FMap_K_Ag_V = Any.any_l () ])
    [ return (result: t_Authority_K_V) -> {[@expl:new result type invariant] inv_Ghost_Authority_K_V result}
      {[@expl:new ensures] view_Authority_K_V result = empty_K'0}
      (! return {result}) ]
end
module M_ghost__resource__fmap_view__impl_Authority_K_V__insert (* ghost::resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_V
  
  type t_Ag_V = { f0: t_V }
  
  type t_K
  
  type t_FMapInsertLocalUpdate_K_Ag_V = { f0'0: t_K; f1'0: t_Ag_V }
  
  type t_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V = { f0'1: t_FMapInsertLocalUpdate_K_Ag_V }
  
  type t_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  type t_Authority_K_V = { f0'2: t_Resource_View_AuthViewRel_FMap_K_Ag_V }
  
  type t_View_AuthViewRel_FMap_K_Ag_V
  
  type t_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None | Some t_FMap_K_Ag_V
  
  function auth_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
  
  type t_Option_Ag_V = None'0 | Some'0 t_Ag_V
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate premise_FMapInsertLocalUpdate_K_Ag_V (self: t_FMapInsertLocalUpdate_K_Ag_V) (from_auth: t_FMap_K_Ag_V) (_3: t_FMap_K_Ag_V) =
    get_K from_auth self.f0'0 = None'0
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_Option_Ag_V = None'1 | Some'1 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'3: t_Option_Ag_V; f1'3: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0 = other.f0 then Some'0 self else None'0
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'3 = self;
                                                                                                        f1'3 = other } with
      | {f0'3 = None'0} -> Some'1 other
      | {f1'3 = None'0} -> Some'1 self
      | {f0'3 = Some'0 x; f1'3 = Some'0 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'0 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'1 then
      Some (total_op_K self other)
    else
      None
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'0)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'0 c -> op_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'0 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'3 = self; f1'3 = factor } with
      | {f0'3 = x; f1'3 = None'0} -> Some'1 x
      | {f0'3 = None'0} -> None'1
      | {f0'3 = Some'0 x; f1'3 = Some'0 y} -> match factor_Ag_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'1 c -> op_Option_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'1 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'1
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'1 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'4: t_K; f1'4: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'4 = k; f1'4 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'4 = k; f1'4 = vo} = __0 in match factor_Option_Ag_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in Some res
    else
      None
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some c -> op_FMap_K_Ag_V factor c = Some self
        | None -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some comb
      -> incl_FMap_K_Ag_V self comb
  
  predicate rel_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some a'0 -> incl_FMap_K_Ag_V f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) : ()
  
  axiom rel_unit_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a unit_FMap_K_Ag_V
  
  function rel_none_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) : ()
  
  axiom rel_none_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (None) f
  
  function rel_mono_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f1: t_FMap_K_Ag_V) (f2: t_FMap_K_Ag_V) : ()
  
  axiom rel_mono_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f1: t_FMap_K_Ag_V, f2: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a f1
      -> incl_FMap_K_Ag_V f2 f1 -> rel_AuthViewRel_FMap_K_Ag_V a f2
  
  function frag_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom frag_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V self)
  
  predicate premise_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V (self: t_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V) (from: t_View_AuthViewRel_FMap_K_Ag_V) =
    match auth_AuthViewRel_FMap_K_Ag_V from with
      | Some auth -> premise_FMapInsertLocalUpdate_K_Ag_V self.f0'1 auth (frag_AuthViewRel_FMap_K_Ag_V from)
      | None -> false
      end
  
  function val_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  function view_Resource_View_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
   = val_View_AuthViewRel_FMap_K_Ag_V self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  type t_Id
  
  function id_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_Id
  
  type tup2_FMap_K_Ag_V_FMap_K_Ag_V = { f0'5: t_FMap_K_Ag_V; f1'5: t_FMap_K_Ag_V }
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_Ag_V) (k: t_K) (v: t_Ag_V) : t_FMap_K_Ag_V
  
  axiom insert_K_spec: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. view_FMap_K_Ag_V (insert_K self k v)
      = Map.set (view_FMap_K_Ag_V self) k (Some'0 v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_Ag_V, k: t_K, v: t_Ag_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  function update_FMapInsertLocalUpdate_K_Ag_V (self: t_FMapInsertLocalUpdate_K_Ag_V) (from_auth: t_FMap_K_Ag_V) (from_frag: t_FMap_K_Ag_V) : tup2_FMap_K_Ag_V_FMap_K_Ag_V
   = { f0'5 = insert_K from_auth self.f0'0 self.f1'0; f1'5 = insert_K from_frag self.f0'0 self.f1'0 }
  
  predicate index_Mapping_FMap_K_Ag_V_bool [@inline:trivial] (self: Map.map t_FMap_K_Ag_V bool) (a: t_FMap_K_Ag_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_Ag_V_bool
  
  function such_that_FMap_K_Ag_V (p: Map.map t_FMap_K_Ag_V bool) : t_FMap_K_Ag_V
  
  axiom such_that_FMap_K_Ag_V_spec:
    forall p: Map.map t_FMap_K_Ag_V bool. (exists x: t_FMap_K_Ag_V. index_Mapping_FMap_K_Ag_V_bool p x)
      -> index_Mapping_FMap_K_Ag_V_bool p (such_that_FMap_K_Ag_V p)
  
  function unwrap_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) : t_FMap_K_Ag_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_Ag_V (fun (__0: t_FMap_K_Ag_V) -> true)
      end
  
  type t_Option_Option_FMap_K_Ag_V = None'2 | Some'2 t_Option_FMap_K_Ag_V
  
  function and_then_Option_Option_FMap_K_Ag_V (self: t_Option_Option_FMap_K_Ag_V) (f: Map.map t_Option_FMap_K_Ag_V t_Option_Option_FMap_K_Ag_V) : t_Option_Option_FMap_K_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_FMap_K_Ag_V_Option_FMap_K_Ag_V = { f0'6: t_Option_FMap_K_Ag_V; f1'6: t_Option_FMap_K_Ag_V }
  
  function map_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_Option_FMap_K_Ag_V
   = match self with
      | None -> None'2
      | Some x -> Some'2 (Map.get f x)
      end
  
  function op_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (other: t_Option_FMap_K_Ag_V) : t_Option_Option_FMap_K_Ag_V
   = match { f0'6 = self; f1'6 = other } with
      | {f0'6 = None} -> Some'2 other
      | {f1'6 = None} -> Some'2 self
      | {f0'6 = Some x; f1'6 = Some y} -> map_Option_FMap_K_Ag_V (op_FMap_K_Ag_V x y) (fun (z: t_FMap_K_Ag_V) -> Some z)
      end
  
  function associative_Option_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (b: t_Option_FMap_K_Ag_V) (c: t_Option_FMap_K_Ag_V) : ()
  
  axiom associative_Option_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, b: t_Option_FMap_K_Ag_V, c: t_Option_FMap_K_Ag_V. and_then_Option_Option_FMap_K_Ag_V (op_Option_FMap_K_Ag_V a b) (fun (ab: t_Option_FMap_K_Ag_V) -> op_Option_FMap_K_Ag_V ab c)
      = and_then_Option_Option_FMap_K_Ag_V (op_Option_FMap_K_Ag_V b c) (fun (bc: t_Option_FMap_K_Ag_V) -> op_Option_FMap_K_Ag_V a bc)
  
  function commutative_Option_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (b: t_Option_FMap_K_Ag_V) : ()
  
  axiom commutative_Option_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, b: t_Option_FMap_K_Ag_V. op_Option_FMap_K_Ag_V a b = op_Option_FMap_K_Ag_V b a
  
  function frame_preserving_FMapInsertLocalUpdate_K_Ag_V (self: t_FMapInsertLocalUpdate_K_Ag_V) (from_auth: t_FMap_K_Ag_V) (from_frag: t_FMap_K_Ag_V) (frame: t_Option_FMap_K_Ag_V) : ()
  
  axiom frame_preserving_FMapInsertLocalUpdate_K_Ag_V_spec:
    forall self: t_FMapInsertLocalUpdate_K_Ag_V, from_auth: t_FMap_K_Ag_V, from_frag: t_FMap_K_Ag_V, frame: t_Option_FMap_K_Ag_V. premise_FMapInsertLocalUpdate_K_Ag_V self from_auth from_frag
      -> op_Option_FMap_K_Ag_V (Some from_frag) frame = Some'2 (Some from_auth)
      -> (let {f0'5 = to_auth; f1'5 = to_frag} = update_FMapInsertLocalUpdate_K_Ag_V self from_auth from_frag in op_Option_FMap_K_Ag_V (Some to_frag) frame
      = Some'2 (Some to_auth))
  
  function new_AuthViewRel_FMap_K_Ag_V (auth: t_Option_FMap_K_Ag_V) (frag: t_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  axiom new_AuthViewRel_FMap_K_Ag_V_spec:
    forall auth: t_Option_FMap_K_Ag_V, frag: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V auth frag
      -> auth_AuthViewRel_FMap_K_Ag_V (new_AuthViewRel_FMap_K_Ag_V auth frag) = auth
  
  axiom new_AuthViewRel_FMap_K_Ag_V_spec'0:
    forall auth: t_Option_FMap_K_Ag_V, frag: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V auth frag
      -> frag_AuthViewRel_FMap_K_Ag_V (new_AuthViewRel_FMap_K_Ag_V auth frag) = frag
  
  function update_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V (self: t_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V) (from: t_View_AuthViewRel_FMap_K_Ag_V) (_3: ()) : t_View_AuthViewRel_FMap_K_Ag_V
   =
    let from_auth = unwrap_Option_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V from) in let {f0'5 = auth; f1'5 = frag} = update_FMapInsertLocalUpdate_K_Ag_V self.f0'1 from_auth (frag_AuthViewRel_FMap_K_Ag_V from) in let _ = frame_preserving_FMapInsertLocalUpdate_K_Ag_V self.f0'1 from_auth (frag_AuthViewRel_FMap_K_Ag_V from) (factor_FMap_K_Ag_V from_auth (frag_AuthViewRel_FMap_K_Ag_V from)) in new_AuthViewRel_FMap_K_Ag_V (Some auth) frag
  
  axiom update_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V_spec:
    forall self: t_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V, from: t_View_AuthViewRel_FMap_K_Ag_V, _3: (). premise_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V self from
      -> (let {f0'5 = auth; f1'5 = frag} = update_FMapInsertLocalUpdate_K_Ag_V self.f0'1 (unwrap_Option_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V from)) (frag_AuthViewRel_FMap_K_Ag_V from) in rel_AuthViewRel_FMap_K_Ag_V (Some auth) frag)
  
  let rec update_View_AuthViewRel_FMap_K_Ag_V (self: MutBorrow.t t_Resource_View_AuthViewRel_FMap_K_Ag_V)
    (upd: t_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V) (return (x: ())) =
    {[@expl:update requires] premise_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V upd (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.current)}
    any
    [ return (result: ()) -> {id_View_AuthViewRel_FMap_K_Ag_V self.final = id_View_AuthViewRel_FMap_K_Ag_V self.current}
      {view_Resource_View_AuthViewRel_FMap_K_Ag_V self.final
      = update_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V upd (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.current) result}
      (! return {result}) ]
  
  type t_FMap_K_V
  
  type t_Option_V = None'3 | Some'3 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K'0 self k = get_K'0 other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  function index_Mapping_tup2_K_Ag_V_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_V) (a: tup2_K_Ag_V) : t_V =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_V
  
  function len_K'0 (self: t_FMap_K_V) : int
  
  axiom len_K_spec'0: forall self: t_FMap_K_V. len_K'0 self >= 0
  
  function map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_V) : t_FMap_K_V
  
  axiom map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_V. forall k: t_K [get_K'0 (map_K self f) k]. get_K'0 (map_K self f) k
        = match get_K self k with
          | None'0 -> None'3
          | Some'0 v -> Some'3 (index_Mapping_tup2_K_Ag_V_V f { f0'4 = k; f1'4 = v })
          end
  
  axiom map_K_spec'0: forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_V. len_K'0 (map_K self f) = len_K self
  
  function view_Authority_K_V (self: t_Authority_K_V) : t_FMap_K_V =
    map_K (unwrap_Option_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0'2))) (fun (__0: tup2_K_Ag_V) -> let {f1'4 = x} = __0 in x.f0)
  
  predicate contains_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K'0 self k <> None'3
  
  meta "rewrite_def" predicate contains_K'0
  
  function insert_K'0 (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec'1: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K'0 self k v)
      = Map.set (view_FMap_K_V self) k (Some'3 v)
  
  axiom insert_K_spec'2: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K'0 (insert_K'0 self k v)
      = (if contains_K'0 self k then len_K'0 self else len_K'0 self + 1)
  
  predicate invariant_Authority_K_V (self: t_Authority_K_V) =
    auth_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0'2) <> None
  
  predicate inv_Authority_K_V (_1: t_Authority_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_K_V [inv_Authority_K_V x]. inv_Authority_K_V x
      = invariant_Authority_K_V x
  
  predicate invariant_ref_Authority_K_V [@inline:trivial] (self: MutBorrow.t t_Authority_K_V) =
    inv_Authority_K_V self.current /\ inv_Authority_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Authority_K_V
  
  predicate inv_ref_Authority_K_V [@inline:trivial] (_1: MutBorrow.t t_Authority_K_V) = invariant_ref_Authority_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Authority_K_V
  
  predicate resolve_ref_Authority_K_V [@inline:trivial] (_1: MutBorrow.t t_Authority_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Authority_K_V
  
  type t_Option_View_AuthViewRel_FMap_K_Ag_V = None'4 | Some'4 t_View_AuthViewRel_FMap_K_Ag_V
  
  function and_then_Option_View_AuthViewRel_FMap_K_Ag_V (self: t_Option_View_AuthViewRel_FMap_K_Ag_V) (f: Map.map t_View_AuthViewRel_FMap_K_Ag_V t_Option_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = match self with
      | None'4 -> None'4
      | Some'4 x -> Map.get f x
      end
  
  function op_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) (other: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = match op_FMap_K_Ag_V (frag_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V other) with
      | Some f -> match { f0'6 = auth_AuthViewRel_FMap_K_Ag_V self; f1'6 = auth_AuthViewRel_FMap_K_Ag_V other } with
        | {f0'6 = None; f1'6 = a} -> if rel_AuthViewRel_FMap_K_Ag_V a f then
          Some'4 (new_AuthViewRel_FMap_K_Ag_V a f)
        else
          None'4
        
        | {f0'6 = a; f1'6 = None} -> if rel_AuthViewRel_FMap_K_Ag_V a f then
          Some'4 (new_AuthViewRel_FMap_K_Ag_V a f)
        else
          None'4
        
        | _ -> None'4
        end
      | None -> None'4
      end
  
  function associative_View_AuthViewRel_FMap_K_Ag_V (a: t_View_AuthViewRel_FMap_K_Ag_V) (b: t_View_AuthViewRel_FMap_K_Ag_V) (c: t_View_AuthViewRel_FMap_K_Ag_V) : ()
  
  axiom associative_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_View_AuthViewRel_FMap_K_Ag_V, b: t_View_AuthViewRel_FMap_K_Ag_V, c: t_View_AuthViewRel_FMap_K_Ag_V. and_then_Option_View_AuthViewRel_FMap_K_Ag_V (op_View_AuthViewRel_FMap_K_Ag_V a b) (fun (ab: t_View_AuthViewRel_FMap_K_Ag_V) -> op_View_AuthViewRel_FMap_K_Ag_V ab c)
      = and_then_Option_View_AuthViewRel_FMap_K_Ag_V (op_View_AuthViewRel_FMap_K_Ag_V b c) (fun (bc: t_View_AuthViewRel_FMap_K_Ag_V) -> op_View_AuthViewRel_FMap_K_Ag_V a bc)
  
  function commutative_View_AuthViewRel_FMap_K_Ag_V (a: t_View_AuthViewRel_FMap_K_Ag_V) (b: t_View_AuthViewRel_FMap_K_Ag_V) : ()
  
  axiom commutative_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_View_AuthViewRel_FMap_K_Ag_V, b: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V a b
      = op_View_AuthViewRel_FMap_K_Ag_V b a
  
  function new_frag_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (frag: t_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V =
    new_AuthViewRel_FMap_K_Ag_V (None) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_FMap_K_Ag_V
  
  function core_Ag_V (self: t_Ag_V) : t_Option_Ag_V = Some'0 self
  
  axiom core_Ag_V_spec: forall self: t_Ag_V. match core_Ag_V self with
        | Some'0 c -> op_Ag_V c c = Some'0 c /\ op_Ag_V c self = Some'0 self
        | None'0 -> true
        end
  
  function core_total_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : t_FMap_K_Ag_V =
    let r = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f1'4 = v} = __0 in core_Ag_V v) in r
  
  axiom core_total_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V. op_FMap_K_Ag_V (core_total_FMap_K_Ag_V self) (core_total_FMap_K_Ag_V self)
      = Some (core_total_FMap_K_Ag_V self)
  
  axiom core_total_FMap_K_Ag_V_spec'0: forall self: t_FMap_K_Ag_V. op_FMap_K_Ag_V (core_total_FMap_K_Ag_V self) self
      = Some self
  
  function core_total_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
   = new_frag_AuthViewRel_FMap_K_Ag_V (core_total_FMap_K_Ag_V (frag_AuthViewRel_FMap_K_Ag_V self))
  
  axiom core_total_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V (core_total_View_AuthViewRel_FMap_K_Ag_V self) (core_total_View_AuthViewRel_FMap_K_Ag_V self)
      = Some'4 (core_total_View_AuthViewRel_FMap_K_Ag_V self)
  
  axiom core_total_View_AuthViewRel_FMap_K_Ag_V_spec'0:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V (core_total_View_AuthViewRel_FMap_K_Ag_V self) self
      = Some'4 self
  
  function core_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = Some'4 (core_total_View_AuthViewRel_FMap_K_Ag_V self)
  
  axiom core_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. match core_View_AuthViewRel_FMap_K_Ag_V self with
        | Some'4 c -> op_View_AuthViewRel_FMap_K_Ag_V c c = Some'4 c
        /\ op_View_AuthViewRel_FMap_K_Ag_V c self = Some'4 self
        | None'4 -> true
        end
  
  let rec core_View_AuthViewRel_FMap_K_Ag_V'0 (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V)
    (return (x: t_Resource_View_AuthViewRel_FMap_K_Ag_V)) =
    {[@expl:core requires] core_View_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self)
    <> None'4}
    any
    [ return (result: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> {id_View_AuthViewRel_FMap_K_Ag_V result
      = id_View_AuthViewRel_FMap_K_Ag_V self}
      {Some'4 (view_Resource_View_AuthViewRel_FMap_K_Ag_V result)
      = core_View_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self)}
      (! return {result}) ]
  
  type t_Fragment_K_V = { f0'7: t_Resource_View_AuthViewRel_FMap_K_Ag_V; f1'7: t_K; f2'7: t_V }
  
  predicate invariant_Fragment_K_V (self: t_Fragment_K_V) =
    get_K (frag_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0'7)) self.f1'7
    = Some'0 { f0 = self.f2'7 }
  
  predicate inv_Fragment_K_V (_1: t_Fragment_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment_K_V [inv_Fragment_K_V x]. inv_Fragment_K_V x
      = invariant_Fragment_K_V x
  
  function id_K (self: t_Authority_K_V) : t_Id = id_View_AuthViewRel_FMap_K_Ag_V self.f0'2
  
  type tup2_K_V = { f0'8: t_K; f1'8: t_V }
  
  function view_Fragment_K_V (self: t_Fragment_K_V) : tup2_K_V = { f0'8 = self.f1'7; f1'8 = self.f2'7 }
  
  function id_K'0 (self: t_Fragment_K_V) : t_Id = id_View_AuthViewRel_FMap_K_Ag_V self.f0'7
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert_K'1 (self: MutBorrow.t t_Authority_K_V) (k: t_K) (v: t_V) (return (x: t_Fragment_K_V)) =
    {[@expl:insert 'self' type invariant] inv_ref_Authority_K_V self}
    {[@expl:insert requires] not contains_K'0 (view_Authority_K_V self.current) k}
    (! bb0
    [ bb0 = s0 [ s0 = [ &s <- self.current ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_16 <- { f0 = v } ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_14 <- { f0'0 = k; f1'0 = _16 } ] s1
      | s1 = [ &_13 <- { f0'1 = _14 } ] s2
      | s2 = MutBorrow.borrow_final <t_Resource_View_AuthViewRel_FMap_K_Ag_V> {self.current.f0'2}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Resource_View_AuthViewRel_FMap_K_Ag_V) ->
            [ &_12 <- _ret ] [ &self <- { self with current = { f0'2 = _ret.final } } ] s3)
      | s3 = update_View_AuthViewRel_FMap_K_Ag_V {_12} {_13} (fun (_ret: ()) -> [ &_11 <- _ret ] s4)
      | s4 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] ext_eq_K (view_Authority_K_V self.current) (insert_K'0 (view_Authority_K_V s) k v)} s1
      | s1 = {[@expl:type invariant] inv_ref_Authority_K_V self} s2
      | s2 = -{resolve_ref_Authority_K_V self}- s3
      | s3 = core_View_AuthViewRel_FMap_K_Ag_V'0 {self.current.f0'2}
          (fun (_ret: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> [ &_20 <- _ret ] s4)
      | s4 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- { f0'7 = _20; f1'7 = k; f2'7 = v } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Fragment_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Authority_K_V = self
    | & k: t_K = k
    | & v: t_V = v
    | & s: t_Authority_K_V = Any.any_l ()
    | & _11: () = Any.any_l ()
    | & _12: MutBorrow.t t_Resource_View_AuthViewRel_FMap_K_Ag_V = Any.any_l ()
    | & _13: t_AuthUpdate_FMapInsertLocalUpdate_K_Ag_V = Any.any_l ()
    | & _14: t_FMapInsertLocalUpdate_K_Ag_V = Any.any_l ()
    | & _16: t_Ag_V = Any.any_l ()
    | & _20: t_Resource_View_AuthViewRel_FMap_K_Ag_V = Any.any_l () ])
    [ return (result: t_Fragment_K_V) -> {[@expl:insert result type invariant] inv_Fragment_K_V result}
      {[@expl:insert ensures #0] view_Authority_K_V self.final = insert_K'0 (view_Authority_K_V self.current) k v}
      {[@expl:insert ensures #1] id_K self.final = id_K self.current}
      {[@expl:insert ensures #2] view_Fragment_K_V result = { f0'8 = k; f1'8 = v }}
      {[@expl:insert ensures #3] id_K'0 result = id_K self.current}
      (! return {result}) ]
end
module M_ghost__resource__fmap_view__impl_Authority_K_V__contains (* ghost::resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  type t_K
  
  type t_V
  
  type t_Fragment_K_V = { f0: t_Resource_View_AuthViewRel_FMap_K_Ag_V; f1: t_K; f2: t_V }
  
  type t_Authority_K_V = { f0'0: t_Resource_View_AuthViewRel_FMap_K_Ag_V }
  
  type t_Id
  
  function id_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_Id
  
  type t_View_AuthViewRel_FMap_K_Ag_V
  
  type t_Option_View_AuthViewRel_FMap_K_Ag_V = None | Some t_View_AuthViewRel_FMap_K_Ag_V
  
  function and_then_Option_View_AuthViewRel_FMap_K_Ag_V (self: t_Option_View_AuthViewRel_FMap_K_Ag_V) (f: Map.map t_View_AuthViewRel_FMap_K_Ag_V t_Option_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None'0 | Some'0 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type t_Ag_V = { f0'1: t_V }
  
  type t_Option_Ag_V = None'1 | Some'1 t_Ag_V
  
  type t_Option_Option_Ag_V = None'2 | Some'2 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'2: t_Option_Ag_V; f1'2: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'1 -> None'2
      | Some'1 x -> Some'2 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0'1 = other.f0'1 then
      Some'1 self
    else
      None'1
  
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'2 = self;
                                                                                                        f1'2 = other } with
      | {f0'2 = None'1} -> Some'2 other
      | {f1'2 = None'1} -> Some'2 self
      | {f0'2 = Some'1 x; f1'2 = Some'1 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'1 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'2 then
      Some'0 (total_op_K self other)
    else
      None'0
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'1)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'0 x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'1 c -> op_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'1 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'2 = self; f1'2 = factor } with
      | {f0'2 = x; f1'2 = None'1} -> Some'2 x
      | {f0'2 = None'1} -> None'2
      | {f0'2 = Some'1 x; f1'2 = Some'1 y} -> match factor_Ag_V x y with
        | Some'1 z -> Some'2 (Some'1 z)
        | None'1 -> if x = y then Some'2 (None'1) else None'2
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'2 c -> op_Option_Ag_V factor c = Some'2 self
        | None'2 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'2 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'2
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'2 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'3: t_K; f1'3: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'1 -> None'1
          | Some'1 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'3 = k; f1'3 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'3 = k; f1'3 = vo} = __0 in match factor_Option_Ag_V (Some'1 vo) (get_K factor k) with
        | Some'2 r -> r
        | None'2 -> None'1
        end) in Some'0 res
    else
      None'0
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'0 c -> op_FMap_K_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'0 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'0
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'0 comb
      -> incl_FMap_K_Ag_V self comb
  
  predicate rel_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some'0 a'0 -> incl_FMap_K_Ag_V f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) : ()
  
  axiom rel_unit_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a unit_FMap_K_Ag_V
  
  function rel_none_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) : ()
  
  axiom rel_none_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (None'0) f
  
  function rel_mono_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f1'0: t_FMap_K_Ag_V) (f2'0: t_FMap_K_Ag_V) : ()
  
  axiom rel_mono_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f1'0: t_FMap_K_Ag_V, f2'0: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a f1'0
      -> incl_FMap_K_Ag_V f2'0 f1'0 -> rel_AuthViewRel_FMap_K_Ag_V a f2'0
  
  function auth_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
  
  function frag_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom frag_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V self)
  
  type tup2_Option_FMap_K_Ag_V_Option_FMap_K_Ag_V = { f0'4: t_Option_FMap_K_Ag_V; f1'4: t_Option_FMap_K_Ag_V }
  
  function new_AuthViewRel_FMap_K_Ag_V (auth: t_Option_FMap_K_Ag_V) (frag: t_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  axiom new_AuthViewRel_FMap_K_Ag_V_spec:
    forall auth: t_Option_FMap_K_Ag_V, frag: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V auth frag
      -> auth_AuthViewRel_FMap_K_Ag_V (new_AuthViewRel_FMap_K_Ag_V auth frag) = auth
  
  axiom new_AuthViewRel_FMap_K_Ag_V_spec'0:
    forall auth: t_Option_FMap_K_Ag_V, frag: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V auth frag
      -> frag_AuthViewRel_FMap_K_Ag_V (new_AuthViewRel_FMap_K_Ag_V auth frag) = frag
  
  function op_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) (other: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = match op_FMap_K_Ag_V (frag_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V other) with
      | Some'0 f -> match { f0'4 = auth_AuthViewRel_FMap_K_Ag_V self; f1'4 = auth_AuthViewRel_FMap_K_Ag_V other } with
        | {f0'4 = None'0; f1'4 = a} -> if rel_AuthViewRel_FMap_K_Ag_V a f then
          Some (new_AuthViewRel_FMap_K_Ag_V a f)
        else
          None
        
        | {f0'4 = a; f1'4 = None'0} -> if rel_AuthViewRel_FMap_K_Ag_V a f then
          Some (new_AuthViewRel_FMap_K_Ag_V a f)
        else
          None
        
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_AuthViewRel_FMap_K_Ag_V (a: t_View_AuthViewRel_FMap_K_Ag_V) (b: t_View_AuthViewRel_FMap_K_Ag_V) (c: t_View_AuthViewRel_FMap_K_Ag_V) : ()
  
  axiom associative_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_View_AuthViewRel_FMap_K_Ag_V, b: t_View_AuthViewRel_FMap_K_Ag_V, c: t_View_AuthViewRel_FMap_K_Ag_V. and_then_Option_View_AuthViewRel_FMap_K_Ag_V (op_View_AuthViewRel_FMap_K_Ag_V a b) (fun (ab: t_View_AuthViewRel_FMap_K_Ag_V) -> op_View_AuthViewRel_FMap_K_Ag_V ab c)
      = and_then_Option_View_AuthViewRel_FMap_K_Ag_V (op_View_AuthViewRel_FMap_K_Ag_V b c) (fun (bc: t_View_AuthViewRel_FMap_K_Ag_V) -> op_View_AuthViewRel_FMap_K_Ag_V a bc)
  
  function commutative_View_AuthViewRel_FMap_K_Ag_V (a: t_View_AuthViewRel_FMap_K_Ag_V) (b: t_View_AuthViewRel_FMap_K_Ag_V) : ()
  
  axiom commutative_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_View_AuthViewRel_FMap_K_Ag_V, b: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V a b
      = op_View_AuthViewRel_FMap_K_Ag_V b a
  
  function new_frag_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (frag: t_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V =
    new_AuthViewRel_FMap_K_Ag_V (None'0) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_FMap_K_Ag_V
  
  function factor_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) (factor: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = match factor_FMap_K_Ag_V (frag_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V factor) with
      | Some'0 f -> match { f0'4 = auth_AuthViewRel_FMap_K_Ag_V self; f1'4 = auth_AuthViewRel_FMap_K_Ag_V factor } with
        | {f0'4 = Some'0 a; f1'4 = None'0} -> Some (new_AuthViewRel_FMap_K_Ag_V (Some'0 a) f)
        | {f0'4 = a1; f1'4 = a2} -> if a1 = a2 then Some (new_frag_AuthViewRel_FMap_K_Ag_V f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V, factor: t_View_AuthViewRel_FMap_K_Ag_V. match factor_View_AuthViewRel_FMap_K_Ag_V self factor with
        | Some c -> op_View_AuthViewRel_FMap_K_Ag_V factor c = Some self
        | None -> forall c: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V factor c <> Some self
        end
  
  predicate incl_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) (other: t_View_AuthViewRel_FMap_K_Ag_V) =
    factor_View_AuthViewRel_FMap_K_Ag_V other self <> None
  
  function incl_transitive_View_AuthViewRel_FMap_K_Ag_V (a: t_View_AuthViewRel_FMap_K_Ag_V) (b: t_View_AuthViewRel_FMap_K_Ag_V) (c: t_View_AuthViewRel_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_View_AuthViewRel_FMap_K_Ag_V, b: t_View_AuthViewRel_FMap_K_Ag_V, c: t_View_AuthViewRel_FMap_K_Ag_V. incl_View_AuthViewRel_FMap_K_Ag_V a b
      -> incl_View_AuthViewRel_FMap_K_Ag_V b c -> incl_View_AuthViewRel_FMap_K_Ag_V a c
  
  function incl_op_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) (other: t_View_AuthViewRel_FMap_K_Ag_V) (comb: t_View_AuthViewRel_FMap_K_Ag_V) : ()
  
  axiom incl_op_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V, other: t_View_AuthViewRel_FMap_K_Ag_V, comb: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V self other
        = Some comb -> incl_View_AuthViewRel_FMap_K_Ag_V self comb
  
  predicate incl_eq_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) (other: t_View_AuthViewRel_FMap_K_Ag_V) =
    self = other \/ incl_View_AuthViewRel_FMap_K_Ag_V self other
  
  function val_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  function view_Resource_View_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
   = val_View_AuthViewRel_FMap_K_Ag_V self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  let rec join_shared_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V)
    (other: t_Resource_View_AuthViewRel_FMap_K_Ag_V) (return (x: t_Resource_View_AuthViewRel_FMap_K_Ag_V)) =
    {[@expl:join_shared requires] id_View_AuthViewRel_FMap_K_Ag_V self = id_View_AuthViewRel_FMap_K_Ag_V other}
    any
    [ return (result: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> {id_View_AuthViewRel_FMap_K_Ag_V result
      = id_View_AuthViewRel_FMap_K_Ag_V self}
      {incl_eq_View_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self) (view_Resource_View_AuthViewRel_FMap_K_Ag_V result)
      /\ incl_eq_View_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V other) (view_Resource_View_AuthViewRel_FMap_K_Ag_V result)}
      (! return {result}) ]
  
  type tup2_K_V = { f0'5: t_K; f1'5: t_V }
  
  function view_Fragment_K_V (self: t_Fragment_K_V) : tup2_K_V = { f0'5 = self.f1; f1'5 = self.f2 }
  
  predicate invariant_Authority_K_V (self: t_Authority_K_V) =
    auth_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0'0) <> None'0
  
  predicate inv_Authority_K_V (_1: t_Authority_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_K_V [inv_Authority_K_V x]. inv_Authority_K_V x
      = invariant_Authority_K_V x
  
  predicate invariant_ref_Authority_K_V [@inline:trivial] (self: t_Authority_K_V) = inv_Authority_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Authority_K_V
  
  predicate inv_ref_Authority_K_V [@inline:trivial] (_1: t_Authority_K_V) = invariant_ref_Authority_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Authority_K_V
  
  predicate invariant_Fragment_K_V (self: t_Fragment_K_V) =
    get_K (frag_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0)) self.f1
    = Some'1 { f0'1 = self.f2 }
  
  predicate inv_Fragment_K_V (_1: t_Fragment_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment_K_V [inv_Fragment_K_V x]. inv_Fragment_K_V x
      = invariant_Fragment_K_V x
  
  predicate invariant_ref_Fragment_K_V [@inline:trivial] (self: t_Fragment_K_V) = inv_Fragment_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Fragment_K_V
  
  predicate inv_ref_Fragment_K_V [@inline:trivial] (_1: t_Fragment_K_V) = invariant_ref_Fragment_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Fragment_K_V
  
  function id_K (self: t_Authority_K_V) : t_Id = id_View_AuthViewRel_FMap_K_Ag_V self.f0'0
  
  function id_K'0 (self: t_Fragment_K_V) : t_Id = id_View_AuthViewRel_FMap_K_Ag_V self.f0
  
  type t_FMap_K_V
  
  type t_Option_V = None'3 | Some'3 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K'0 [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K'0
  
  function index_Mapping_tup2_K_Ag_V_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_V) (a: tup2_K_Ag_V) : t_V =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_V
  
  function len_K'0 (self: t_FMap_K_V) : int
  
  axiom len_K_spec'0: forall self: t_FMap_K_V. len_K'0 self >= 0
  
  function map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_V) : t_FMap_K_V
  
  axiom map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_V. forall k: t_K [get_K'0 (map_K self f) k]. get_K'0 (map_K self f) k
        = match get_K self k with
          | None'1 -> None'3
          | Some'1 v -> Some'3 (index_Mapping_tup2_K_Ag_V_V f { f0'3 = k; f1'3 = v })
          end
  
  axiom map_K_spec'0: forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_V. len_K'0 (map_K self f) = len_K self
  
  predicate index_Mapping_FMap_K_Ag_V_bool [@inline:trivial] (self: Map.map t_FMap_K_Ag_V bool) (a: t_FMap_K_Ag_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_Ag_V_bool
  
  function such_that_FMap_K_Ag_V (p: Map.map t_FMap_K_Ag_V bool) : t_FMap_K_Ag_V
  
  axiom such_that_FMap_K_Ag_V_spec:
    forall p: Map.map t_FMap_K_Ag_V bool. (exists x: t_FMap_K_Ag_V. index_Mapping_FMap_K_Ag_V_bool p x)
      -> index_Mapping_FMap_K_Ag_V_bool p (such_that_FMap_K_Ag_V p)
  
  function unwrap_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) : t_FMap_K_Ag_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_FMap_K_Ag_V (fun (__0: t_FMap_K_Ag_V) -> true)
      end
  
  function view_Authority_K_V (self: t_Authority_K_V) : t_FMap_K_V =
    map_K (unwrap_Option_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0'0))) (fun (__0: tup2_K_Ag_V) -> let {f1'3 = x} = __0 in x.f0'1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains_K (self: t_Authority_K_V) (frag: t_Fragment_K_V) (return (x: ())) =
    {[@expl:contains 'self' type invariant] inv_ref_Authority_K_V self}
    {[@expl:contains 'frag' type invariant] inv_ref_Fragment_K_V frag}
    {[@expl:contains requires] id_K self = id_K'0 frag}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- frag.f0 ] s1
      | s1 = join_shared_View_AuthViewRel_FMap_K_Ag_V {self.f0'0} {_8}
          (fun (_ret: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> [ &new_resource <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 =
        {[@expl:assertion] get_K (frag_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V new_resource)) (view_Fragment_K_V frag).f0'5
        = Some'1 { f0'1 = (view_Fragment_K_V frag).f1'5 }}
        s1
      | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: t_Authority_K_V = self
    | & frag: t_Fragment_K_V = frag
    | & new_resource: t_Resource_View_AuthViewRel_FMap_K_Ag_V = Any.any_l ()
    | & _8: t_Resource_View_AuthViewRel_FMap_K_Ag_V = Any.any_l () ])
    [ return (result: ()) -> {[@expl:contains ensures] get_K'0 (view_Authority_K_V self) (view_Fragment_K_V frag).f0'5
      = Some'3 ((view_Fragment_K_V frag).f1'5)}
      (! return {result}) ]
end
module M_ghost__resource__fmap_view__impl_Clone_for_Fragment_K_V__clone (* <ghost::resource::fmap_view::Fragment<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  type t_K
  
  type t_V
  
  type t_Fragment_K_V = { f0: t_Resource_View_AuthViewRel_FMap_K_Ag_V; f1: t_K; f2: t_V }
  
  type t_View_AuthViewRel_FMap_K_Ag_V
  
  type t_Option_View_AuthViewRel_FMap_K_Ag_V = None | Some t_View_AuthViewRel_FMap_K_Ag_V
  
  function and_then_Option_View_AuthViewRel_FMap_K_Ag_V (self: t_Option_View_AuthViewRel_FMap_K_Ag_V) (f: Map.map t_View_AuthViewRel_FMap_K_Ag_V t_Option_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None'0 | Some'0 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type t_Ag_V = { f0'0: t_V }
  
  type t_Option_Ag_V = None'1 | Some'1 t_Ag_V
  
  type t_Option_Option_Ag_V = None'2 | Some'2 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'1: t_Option_Ag_V; f1'1: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None'1 -> None'2
      | Some'1 x -> Some'2 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0'0 = other.f0'0 then
      Some'1 self
    else
      None'1
  
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'1 = self;
                                                                                                        f1'1 = other } with
      | {f0'1 = None'1} -> Some'2 other
      | {f1'1 = None'1} -> Some'2 self
      | {f0'1 = Some'1 x; f1'1 = Some'1 y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some'1 z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'2 then
      Some'0 (total_op_K self other)
    else
      None'0
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None'1)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'0 x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some'1 c -> op_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Ag_V. op_Ag_V factor c <> Some'1 self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'1 = self; f1'1 = factor } with
      | {f0'1 = x; f1'1 = None'1} -> Some'2 x
      | {f0'1 = None'1} -> None'2
      | {f0'1 = Some'1 x; f1'1 = Some'1 y} -> match factor_Ag_V x y with
        | Some'1 z -> Some'2 (Some'1 z)
        | None'1 -> if x = y then Some'2 (None'1) else None'2
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'2 c -> op_Option_Ag_V factor c = Some'2 self
        | None'2 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'2 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'2
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'2 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'2: t_K; f1'2: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'1 -> None'1
          | Some'1 v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'2 = k; f1'2 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'2 = k; f1'2 = vo} = __0 in match factor_Option_Ag_V (Some'1 vo) (get_K factor k) with
        | Some'2 r -> r
        | None'2 -> None'1
        end) in Some'0 res
    else
      None'0
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'0 c -> op_FMap_K_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'0 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'0
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'0 comb
      -> incl_FMap_K_Ag_V self comb
  
  predicate rel_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some'0 a'0 -> incl_FMap_K_Ag_V f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) : ()
  
  axiom rel_unit_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a unit_FMap_K_Ag_V
  
  function rel_none_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) : ()
  
  axiom rel_none_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (None'0) f
  
  function rel_mono_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f1'0: t_FMap_K_Ag_V) (f2'0: t_FMap_K_Ag_V) : ()
  
  axiom rel_mono_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f1'0: t_FMap_K_Ag_V, f2'0: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a f1'0
      -> incl_FMap_K_Ag_V f2'0 f1'0 -> rel_AuthViewRel_FMap_K_Ag_V a f2'0
  
  function auth_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
  
  function frag_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom frag_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V self)
  
  type tup2_Option_FMap_K_Ag_V_Option_FMap_K_Ag_V = { f0'3: t_Option_FMap_K_Ag_V; f1'3: t_Option_FMap_K_Ag_V }
  
  function new_AuthViewRel_FMap_K_Ag_V (auth: t_Option_FMap_K_Ag_V) (frag: t_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  axiom new_AuthViewRel_FMap_K_Ag_V_spec:
    forall auth: t_Option_FMap_K_Ag_V, frag: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V auth frag
      -> auth_AuthViewRel_FMap_K_Ag_V (new_AuthViewRel_FMap_K_Ag_V auth frag) = auth
  
  axiom new_AuthViewRel_FMap_K_Ag_V_spec'0:
    forall auth: t_Option_FMap_K_Ag_V, frag: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V auth frag
      -> frag_AuthViewRel_FMap_K_Ag_V (new_AuthViewRel_FMap_K_Ag_V auth frag) = frag
  
  function op_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) (other: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = match op_FMap_K_Ag_V (frag_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V other) with
      | Some'0 f -> match { f0'3 = auth_AuthViewRel_FMap_K_Ag_V self; f1'3 = auth_AuthViewRel_FMap_K_Ag_V other } with
        | {f0'3 = None'0; f1'3 = a} -> if rel_AuthViewRel_FMap_K_Ag_V a f then
          Some (new_AuthViewRel_FMap_K_Ag_V a f)
        else
          None
        
        | {f0'3 = a; f1'3 = None'0} -> if rel_AuthViewRel_FMap_K_Ag_V a f then
          Some (new_AuthViewRel_FMap_K_Ag_V a f)
        else
          None
        
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_AuthViewRel_FMap_K_Ag_V (a: t_View_AuthViewRel_FMap_K_Ag_V) (b: t_View_AuthViewRel_FMap_K_Ag_V) (c: t_View_AuthViewRel_FMap_K_Ag_V) : ()
  
  axiom associative_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_View_AuthViewRel_FMap_K_Ag_V, b: t_View_AuthViewRel_FMap_K_Ag_V, c: t_View_AuthViewRel_FMap_K_Ag_V. and_then_Option_View_AuthViewRel_FMap_K_Ag_V (op_View_AuthViewRel_FMap_K_Ag_V a b) (fun (ab: t_View_AuthViewRel_FMap_K_Ag_V) -> op_View_AuthViewRel_FMap_K_Ag_V ab c)
      = and_then_Option_View_AuthViewRel_FMap_K_Ag_V (op_View_AuthViewRel_FMap_K_Ag_V b c) (fun (bc: t_View_AuthViewRel_FMap_K_Ag_V) -> op_View_AuthViewRel_FMap_K_Ag_V a bc)
  
  function commutative_View_AuthViewRel_FMap_K_Ag_V (a: t_View_AuthViewRel_FMap_K_Ag_V) (b: t_View_AuthViewRel_FMap_K_Ag_V) : ()
  
  axiom commutative_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_View_AuthViewRel_FMap_K_Ag_V, b: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V a b
      = op_View_AuthViewRel_FMap_K_Ag_V b a
  
  function new_frag_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (frag: t_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V =
    new_AuthViewRel_FMap_K_Ag_V (None'0) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_FMap_K_Ag_V
  
  function core_Ag_V (self: t_Ag_V) : t_Option_Ag_V = Some'1 self
  
  axiom core_Ag_V_spec: forall self: t_Ag_V. match core_Ag_V self with
        | Some'1 c -> op_Ag_V c c = Some'1 c /\ op_Ag_V c self = Some'1 self
        | None'1 -> true
        end
  
  function core_total_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : t_FMap_K_Ag_V =
    let r = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f1'2 = v} = __0 in core_Ag_V v) in r
  
  axiom core_total_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V. op_FMap_K_Ag_V (core_total_FMap_K_Ag_V self) (core_total_FMap_K_Ag_V self)
      = Some'0 (core_total_FMap_K_Ag_V self)
  
  axiom core_total_FMap_K_Ag_V_spec'0: forall self: t_FMap_K_Ag_V. op_FMap_K_Ag_V (core_total_FMap_K_Ag_V self) self
      = Some'0 self
  
  function core_total_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
   = new_frag_AuthViewRel_FMap_K_Ag_V (core_total_FMap_K_Ag_V (frag_AuthViewRel_FMap_K_Ag_V self))
  
  axiom core_total_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V (core_total_View_AuthViewRel_FMap_K_Ag_V self) (core_total_View_AuthViewRel_FMap_K_Ag_V self)
      = Some (core_total_View_AuthViewRel_FMap_K_Ag_V self)
  
  axiom core_total_View_AuthViewRel_FMap_K_Ag_V_spec'0:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. op_View_AuthViewRel_FMap_K_Ag_V (core_total_View_AuthViewRel_FMap_K_Ag_V self) self
      = Some self
  
  function core_View_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_View_AuthViewRel_FMap_K_Ag_V
   = Some (core_total_View_AuthViewRel_FMap_K_Ag_V self)
  
  axiom core_View_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. match core_View_AuthViewRel_FMap_K_Ag_V self with
        | Some c -> op_View_AuthViewRel_FMap_K_Ag_V c c = Some c /\ op_View_AuthViewRel_FMap_K_Ag_V c self = Some self
        | None -> true
        end
  
  function val_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  function view_Resource_View_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
   = val_View_AuthViewRel_FMap_K_Ag_V self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  type t_Id
  
  function id_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_Id
  
  let rec core_View_AuthViewRel_FMap_K_Ag_V'0 (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V)
    (return (x: t_Resource_View_AuthViewRel_FMap_K_Ag_V)) =
    {[@expl:core requires] core_View_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self) <> None}
    any
    [ return (result: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> {id_View_AuthViewRel_FMap_K_Ag_V result
      = id_View_AuthViewRel_FMap_K_Ag_V self}
      {Some (view_Resource_View_AuthViewRel_FMap_K_Ag_V result)
      = core_View_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self)}
      (! return {result}) ]
  
  predicate invariant_Fragment_K_V (self: t_Fragment_K_V) =
    get_K (frag_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0)) self.f1
    = Some'1 { f0'0 = self.f2 }
  
  predicate inv_Fragment_K_V (_1: t_Fragment_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment_K_V [inv_Fragment_K_V x]. inv_Fragment_K_V x
      = invariant_Fragment_K_V x
  
  predicate invariant_ref_Fragment_K_V [@inline:trivial] (self: t_Fragment_K_V) = inv_Fragment_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Fragment_K_V
  
  predicate inv_ref_Fragment_K_V [@inline:trivial] (_1: t_Fragment_K_V) = invariant_ref_Fragment_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Fragment_K_V
  
  type tup2_K_V = { f0'4: t_K; f1'4: t_V }
  
  function view_Fragment_K_V (self: t_Fragment_K_V) : tup2_K_V = { f0'4 = self.f1; f1'4 = self.f2 }
  
  function id_K (self: t_Fragment_K_V) : t_Id = id_View_AuthViewRel_FMap_K_Ag_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Fragment_K_V (self: t_Fragment_K_V) (return (x: t_Fragment_K_V)) =
    {[@expl:clone 'self' type invariant] inv_ref_Fragment_K_V self}
    (! bb0
    [ bb0 = s0
      [ s0 = core_View_AuthViewRel_FMap_K_Ag_V'0 {self.f0}
          (fun (_ret: t_Resource_View_AuthViewRel_FMap_K_Ag_V) -> [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { f0 = _4; f1 = self.f1; f2 = self.f2 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Fragment_K_V = Any.any_l ()
    | & self: t_Fragment_K_V = self
    | & _4: t_Resource_View_AuthViewRel_FMap_K_Ag_V = Any.any_l () ])
    [ return (result: t_Fragment_K_V) -> {[@expl:clone result type invariant] inv_Fragment_K_V result}
      {[@expl:clone ensures #0] view_Fragment_K_V result = view_Fragment_K_V self}
      {[@expl:clone ensures #1] id_K result = id_K self}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R__split_off (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  
  type t_Resource_R
  
  let rec dummy_R (return (x: t_Resource_R)) = any [ return (result: t_Resource_R) -> (! return {result}) ]
  
  let rec replace_Resource_R (dest: MutBorrow.t t_Resource_R) (src: t_Resource_R) (return (x: t_Resource_R)) = any
    [ return (result: t_Resource_R) -> {dest.final = src} {result = dest.current} (! return {result}) ]
  
  type t_R
  
  type tup2_Resource_R_Resource_R = { f0: t_Resource_R; f1: t_Resource_R }
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate incl_eq_R (self: t_R) (other: t_R) = self = other \/ incl_R self other
  
  predicate incl_eq_op_R (a: t_R) (b: t_R) (x: t_R) =
    match op_R a b with
      | None -> false
      | Some ab -> incl_eq_R ab x
      end
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  let rec split_R (self: t_Resource_R) (a: t_R) (b: t_R) (return (x: tup2_Resource_R_Resource_R)) =
    {[@expl:split requires] incl_eq_op_R a b (view_Resource_R self)}
    any
    [ return (result: tup2_Resource_R_Resource_R) -> {id_R result.f0 = id_R self /\ id_R result.f1 = id_R self}
      {view_Resource_R result.f0 = a}
      {view_Resource_R result.f1 = b}
      (! return {result}) ]
  
  predicate resolve_ref_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Resource_R
  
  predicate resolve_Resource_R (_1: t_Resource_R)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec split_off_R (self: MutBorrow.t t_Resource_R) (r: t_R) (s: t_R) (return (x: t_Resource_R)) =
    {[@expl:split_off requires] incl_eq_op_R r s (view_Resource_R self.current)}
    (! bb0
    [ bb0 = s0 [ s0 = dummy_R (fun (_ret: t_Resource_R) -> [ &_10 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <t_Resource_R> {self.current}
          (fun (_ret: MutBorrow.t t_Resource_R) -> [ &_9 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = replace_Resource_R {_9} {_10} (fun (_ret: t_Resource_R) -> [ &this <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = split_R {this} {r} {s} (fun (_ret: tup2_Resource_R_Resource_R) -> [ &_13 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &r'0 <- _13.f0 ] s1
      | s1 = [ &this'0 <- _13.f1 ] s2
      | s2 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Resource_R) -> [ &_18 <- _ret ] [ &self <- { self with current = _ret.final } ] s3)
      | s3 = replace_Resource_R {_18} {this'0} (fun (_ret: t_Resource_R) -> [ &_17 <- _ret ] s4)
      | s4 = bb4 ]
    | bb4 = s0
      [ s0 = -{resolve_ref_Resource_R self}- s1
      | s1 = -{resolve_Resource_R _17}- s2
      | s2 = [ &_0 <- r'0 ] s3
      | s3 = return {_0} ] ]
    [ & _0: t_Resource_R = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & r: t_R = r
    | & s: t_R = s
    | & this: t_Resource_R = Any.any_l ()
    | & _9: MutBorrow.t t_Resource_R = Any.any_l ()
    | & _10: t_Resource_R = Any.any_l ()
    | & r'0: t_Resource_R = Any.any_l ()
    | & this'0: t_Resource_R = Any.any_l ()
    | & _13: tup2_Resource_R_Resource_R = Any.any_l ()
    | & _17: t_Resource_R = Any.any_l ()
    | & _18: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: t_Resource_R) -> {[@expl:split_off ensures #0] id_R self.final = id_R self.current
      /\ id_R result = id_R self.current}
      {[@expl:split_off ensures #1] view_Resource_R self.final = s}
      {[@expl:split_off ensures #2] view_Resource_R result = r}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R__join_in (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  
  type t_Resource_R
  
  let rec dummy_R (return (x: t_Resource_R)) = any [ return (result: t_Resource_R) -> (! return {result}) ]
  
  let rec replace_Resource_R (dest: MutBorrow.t t_Resource_R) (src: t_Resource_R) (return (x: t_Resource_R)) = any
    [ return (result: t_Resource_R) -> {dest.final = src} {result = dest.current} (! return {result}) ]
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  type t_R
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  let rec join_R (self: t_Resource_R) (other: t_Resource_R) (return (x: t_Resource_R)) =
    {[@expl:join requires] id_R self = id_R other}
    any
    [ return (result: t_Resource_R) -> {id_R result = id_R self}
      {Some (view_Resource_R result) = op_R (view_Resource_R self) (view_Resource_R other)}
      (! return {result}) ]
  
  predicate resolve_ref_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Resource_R
  
  predicate resolve_Resource_R (_1: t_Resource_R)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec join_in_R (self: MutBorrow.t t_Resource_R) (other: t_Resource_R) (return (x: ())) =
    {[@expl:join_in requires] id_R self.current = id_R other}
    (! bb0
    [ bb0 = s0 [ s0 = dummy_R (fun (_ret: t_Resource_R) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <t_Resource_R> {self.current}
          (fun (_ret: MutBorrow.t t_Resource_R) -> [ &_7 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = replace_Resource_R {_7} {_8} (fun (_ret: t_Resource_R) -> [ &this <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = join_R {this} {other} (fun (_ret: t_Resource_R) -> [ &this'0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Resource_R) -> [ &_13 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = replace_Resource_R {_13} {this'0} (fun (_ret: t_Resource_R) -> [ &_12 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = -{resolve_ref_Resource_R self}- s1 | s1 = -{resolve_Resource_R _12}- s2 | s2 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & other: t_Resource_R = other
    | & this: t_Resource_R = Any.any_l ()
    | & _7: MutBorrow.t t_Resource_R = Any.any_l ()
    | & _8: t_Resource_R = Any.any_l ()
    | & this'0: t_Resource_R = Any.any_l ()
    | & _12: t_Resource_R = Any.any_l ()
    | & _13: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: ()) -> {[@expl:join_in ensures #0] id_R self.final = id_R self.current}
      {[@expl:join_in ensures #1] Some (view_Resource_R self.final)
      = op_R (view_Resource_R self.current) (view_Resource_R other)}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R__weaken (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  type t_Resource_R
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  predicate incl_eq_R (self: t_R) (other: t_R) = self = other \/ incl_R self other
  
  predicate incl_eq_op_R (a: t_R) (b: t_R) (x: t_R) =
    match op_R a b with
      | None -> false
      | Some ab -> incl_eq_R ab x
      end
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  let rec split_off_R (self: MutBorrow.t t_Resource_R) (r: t_R) (s: t_R) (return (x: t_Resource_R)) =
    {[@expl:split_off requires] incl_eq_op_R r s (view_Resource_R self.current)}
    any
    [ return (result: t_Resource_R) -> {id_R self.final = id_R self.current /\ id_R result = id_R self.current}
      {view_Resource_R self.final = s}
      {view_Resource_R result = r}
      (! return {result}) ]
  
  predicate resolve_Resource_R (_1: t_Resource_R)
  
  predicate resolve_ref_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Resource_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec weaken_R (self: MutBorrow.t t_Resource_R) (target: t_R) (return (x: ())) =
    {[@expl:weaken requires] incl_R target (view_Resource_R self.current)}
    (! bb0
    [ bb0 = s0 [ s0 = [ &f <- unwrap_Option_R (factor_R (view_Resource_R self.current) target) ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Resource_R) -> [ &_9 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = split_off_R {_9} {f} {target} (fun (_ret: t_Resource_R) -> [ &_8 <- _ret ] s2)
      | s2 = -{resolve_Resource_R _8}- s3
      | s3 = bb2 ]
    | bb2 = s0 [ s0 = -{resolve_ref_Resource_R self}- s1 | s1 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & target: t_R = target
    | & f: t_R = Any.any_l ()
    | & _8: t_Resource_R = Any.any_l ()
    | & _9: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: ()) -> {[@expl:weaken ensures #0] id_R self.final = id_R self.current}
      {[@expl:weaken ensures #1] view_Resource_R self.final = target}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R__update (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use set.Set
  use map.Map
  use creusot.prelude.Any
  
  type t_U
  
  predicate inv_U (_1: t_U)
  
  predicate resolve_U (_1: t_U)
  
  type t_Resource_R
  
  type t_R
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  predicate contains_R [@inline:trivial] (self: Set.set t_R) (e: t_R) = Set.mem e self
  
  meta "rewrite_def" predicate contains_R
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function frame_preserving_U (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_U_spec: forall self: t_U, from: t_R, frame: t_R. premise_U self from
      -> op_R from frame <> None -> op_R (update_U self from (frame_preserving_U self from frame)) frame <> None
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  function and_then_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_R
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_R_Option_R = { f0: t_Option_R; f1: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function associative_Option_R (a: t_Option_R) (b: t_Option_R) (c: t_Option_R) : ()
  
  axiom associative_Option_R_spec:
    forall a: t_Option_R, b: t_Option_R, c: t_Option_R. and_then_Option_Option_R (op_Option_R a b) (fun (ab: t_Option_R) -> op_Option_R ab c)
      = and_then_Option_Option_R (op_Option_R b c) (fun (bc: t_Option_R) -> op_Option_R a bc)
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  let rec update_raw_R (self: MutBorrow.t t_Resource_R) (target_s: Set.set t_R) (return (x: t_R)) =
    {[@expl:update_raw requires] forall f: t_Option_R. op_Option_R (Some (view_Resource_R self.current)) f <> None'0
      -> (exists x: t_R. contains_R target_s x /\ op_Option_R (Some x) f <> None'0)}
    any
    [ return (result: t_R) -> {id_R self.final = id_R self.current}
      {contains_R target_s result}
      {view_Resource_R self.final = result}
      (! return {result}) ]
  
  predicate resolve_ref_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Resource_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec update_R (self: MutBorrow.t t_Resource_R) (upd: t_U) (return (x: t_Choice)) =
    {[@expl:update 'upd' type invariant] inv_U upd}
    {[@expl:update requires] premise_U upd (view_Resource_R self.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:type invariant] inv_U upd} s1
      | s1 = -{resolve_U upd}- s2
      | s2 = [ &v <- view_Resource_R self.current ] s3
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = [ &target_s <- fun (r'0: t_R) -> exists ch: t_Choice. update_U upd v ch = r'0 ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:assertion] contains_R target_s (update_U upd v (such_that_Choice (fun (__0: t_Choice) -> true)))}
        s1
      | s1 = {[@expl:assertion] forall f: t_R. op_R v f <> None
          -> (exists ch: t_Choice. op_R (update_U upd v ch) f <> None)}
        s2
      | s2 = [ &_14 <- () ] s3
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Resource_R) -> [ &_17 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
      | s1 = update_raw_R {_17} {target_s} (fun (_ret: t_R) -> [ &r <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = -{resolve_ref_Resource_R self}- s1
      | s1 = [ &_0 <- such_that_Choice (fun (ch: t_Choice) -> update_U upd v ch = r) ] s2
      | s2 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_Choice = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & upd: t_U = upd
    | & v: t_R = Any.any_l ()
    | & target_s: Set.set t_R = Any.any_l ()
    | & _14: () = Any.any_l ()
    | & r: t_R = Any.any_l ()
    | & _17: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: t_Choice) -> {[@expl:update ensures #0] id_R self.final = id_R self.current}
      {[@expl:update ensures #1] view_Resource_R self.final = update_U upd (view_Resource_R self.current) result}
      (! return {result}) ]
end
module M_ghost__impl_Clone_for_Ghost_T__clone (* <ghost::Ghost<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Ghost_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_Ghost_T
  
  predicate inv_Ghost_T [@inline:trivial] (_1: t_T) = invariant_Ghost_T _1
  
  meta "rewrite_def" predicate inv_Ghost_T
  
  predicate invariant_ref_Ghost_T [@inline:trivial] (self: t_T) = inv_Ghost_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_T
  
  predicate inv_ref_Ghost_T [@inline:trivial] (_1: t_T) = invariant_ref_Ghost_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  let rec deref_Ghost_T (self: t_T) (return (x: t_T)) = {[@expl:deref 'self' type invariant] inv_ref_Ghost_T self}
    any [ return (result: t_T) -> {inv_ref_T result} {result = self} (! return {result}) ]
  
  let rec new_T (x: t_T) (return (x'0: t_T)) = {[@expl:new 'x' type invariant] inv_T x}
    any [ return (result: t_T) -> {inv_Ghost_T result} {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Ghost_T (self: t_T) (return (x: t_T)) = {[@expl:clone 'self' type invariant] inv_ref_Ghost_T self}
    (! bb0
    [ bb0 = s0 [ s0 = deref_Ghost_T {self} (fun (_ret: t_T) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = new_T {_4} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: t_T = Any.any_l () | & self: t_T = self | & _4: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:clone result type invariant] inv_Ghost_T result}
      {[@expl:clone ensures] result = self}
      (! return {result}) ]
end
module M_invariant__impl_Clone_for_Subset_T__clone (* <invariant::Subset<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Subset_T
  
  type t_T
  
  predicate invariant_T (self: t_T)
  
  function view_Subset_T (self: t_Subset_T) : t_T
  
  axiom view_Subset_T_spec: forall self: t_Subset_T. invariant_T (view_Subset_T self)
  
  function view_inj_T (self: t_Subset_T) (other: t_Subset_T) : ()
  
  axiom view_inj_T_spec: forall self: t_Subset_T, other: t_Subset_T. view_Subset_T self = view_Subset_T other
      -> self = other
  
  predicate inv_T (_1: t_T)
  
  axiom inv_axiom: forall x: t_T [inv_T x]. inv_T x -> invariant_T x
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  let rec deref_Subset_T (self: t_Subset_T) (return (x: t_T)) = any
    [ return (result: t_T) -> {inv_ref_T result} {result = view_Subset_T self} (! return {result}) ]
  
  predicate precondition_clone (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_clone () args]. (let self_ = args in inv_ref_T self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  let rec clone_T (self_: t_T) (return (x: t_T)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_T) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  function new_T (x: t_T) : t_Subset_T
  
  axiom new_T_spec: forall x: t_T. invariant_T x -> view_Subset_T (new_T x) = x
  
  let rec new_T'0 (x: t_T) (return (x'0: t_Subset_T)) = {[@expl:new 'x' type invariant] inv_T x}
    any [ return (result: t_Subset_T) -> {result = new_T x} (! return {result}) ]
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Subset_T (self: t_Subset_T) (return (x: t_Subset_T)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = deref_Subset_T {self} (fun (_ret: t_T) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = clone_T {_7} (fun (_ret: t_T) -> [ &_5 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new_T'0 {_5} (fun (_ret: t_Subset_T) -> [ &_0 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_Subset_T = Any.any_l ()
    | & self: t_Subset_T = self
    | & _3: () = Any.any_l ()
    | & _5: t_T = Any.any_l ()
    | & _7: t_T = Any.any_l () ])
    [ return (result: t_Subset_T) ->
    {[@expl:clone ensures] postcondition_clone () (view_Subset_T self) (view_Subset_T result)}
      (! return {result}) ]
end
module M_logic__fmap__impl_FMap_K_V__ext_eq (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function view_inj_K (self: t_FMap_K_V) (other: t_FMap_K_V) : () = ()
  
  axiom view_inj_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. view_FMap_K_V self = view_FMap_K_V other
      -> self = other
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant other : t_FMap_K_V
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V)
  
  goal vc_ext_eq_K: [@expl:ext_eq ensures] (forall k: t_K. get_K self k = get_K other k) = (self = other)
end
module M_logic__fmap__impl_FMap_K_V__filter (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate index_Mapping_tup2_K_V_bool [@inline:trivial] (self: Map.map tup2_K_V bool) (a: tup2_K_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_K_V_bool
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None -> None
          | Some v -> index_Mapping_tup2_K_V_Option_V f { f0 = k; f1 = v }
          end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant p : Map.map tup2_K_V bool
  
  function filter_K (self: t_FMap_K_V) (p: Map.map tup2_K_V bool) : t_FMap_K_V
  
  goal vc_filter_K: (forall __0: tup2_K_V. let {f0 = k; f1 = v} = __0 in true)
    /\ ((forall k: t_K [get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f0 = k'0; f1 = v} = __0 in if index_Mapping_tup2_K_V_bool p { f0 = k'0;
                                                                                                                                            f1 = v } then
          Some v
        else
          None
        )) k]. get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f0 = k'0; f1 = v} = __0 in if index_Mapping_tup2_K_V_bool p { f0 = k'0;
                                                                                                                                   f1 = v } then
            Some v
          else
            None
          )) k
        = match get_K self k with
          | None -> None
          | Some v -> index_Mapping_tup2_K_V_Option_V (fun (__0: tup2_K_V) -> let {f0 = k'0; f1 = v'0} = __0 in if index_Mapping_tup2_K_V_bool p { f0 = k'0;
                                                                                                                                                   f1 = v'0 } then
            Some v'0
          else
            None
          ) { f0 = k; f1 = v }
          end)
    -> (let result = filter_map_K self (fun (__0: tup2_K_V) -> let {f0 = k; f1 = v} = __0 in if index_Mapping_tup2_K_V_bool p { f0 = k;
                                                                                                                                f1 = v } then
      Some v
    else
      None
    ) in [@expl:filter ensures] forall k: t_K [get_K result k]. get_K result k
      = match get_K self k with
        | None -> None
        | Some v -> if index_Mapping_tup2_K_V_bool p { f0 = k; f1 = v } then Some v else None
        end))
end
module M_logic__fmap__impl_FMap_K_V_0__contains_ghost (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_ref_V = None | Some t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate inv_Option_ref_V (_1: t_Option_ref_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_V [inv_Option_ref_V x]. inv_Option_ref_V x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_V f0
        end
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_V) : t_Option_ref_V = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  let rec get_ghost_K (self: t_FMap_K_V) (key: t_K) (return (x: t_Option_ref_V)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    {[@expl:get_ghost 'key' type invariant] inv_ref_K key}
    any
    [ return (result: t_Option_ref_V) -> {inv_Option_ref_V result}
      {result = map_Option_V (get_K self key) (fun (v: t_V) -> v)}
      (! return {result}) ]
  
  predicate invariant_ref_Option_ref_V [@inline:trivial] (self: t_Option_ref_V) = inv_Option_ref_V self
  
  meta "rewrite_def" predicate invariant_ref_Option_ref_V
  
  predicate inv_ref_Option_ref_V [@inline:trivial] (_1: t_Option_ref_V) = invariant_ref_Option_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_Option_ref_V
  
  let rec is_some_ref_V (self_: t_Option_ref_V) (return (x: bool)) =
    {[@expl:is_some 'self_' type invariant] inv_ref_Option_ref_V self_}
    any [ return (result: bool) -> {result = (self_ <> None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains_ghost_K (self: t_FMap_K_V) (key: t_K) (return (x: bool)) =
    {[@expl:contains_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    {[@expl:contains_ghost 'key' type invariant] inv_ref_K key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost_K {self} {key} (fun (_ret: t_Option_ref_V) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = is_some_ref_V {_5} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: bool = Any.any_l () | & self: t_FMap_K_V = self | & key: t_K = key | & _5: t_Option_ref_V = Any.any_l () ])
    [ return (result: bool) -> {[@expl:contains_ghost ensures] result = contains_K self key} (! return {result}) ]
end
module M_logic__fmap__impl_Index_for_FMap_K_V__index (* <logic::fmap::FMap<K, V> as std::ops::Index<&'a K>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_ref_V = None | Some t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate inv_Option_ref_V (_1: t_Option_ref_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_V [inv_Option_ref_V x]. inv_Option_ref_V x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_V f0
        end
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_V) : t_Option_ref_V = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  let rec get_ghost_K (self: t_FMap_K_V) (key: t_K) (return (x: t_Option_ref_V)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    {[@expl:get_ghost 'key' type invariant] inv_ref_K key}
    any
    [ return (result: t_Option_ref_V) -> {inv_Option_ref_V result}
      {result = map_Option_V (get_K self key) (fun (v: t_V) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_V (self_: t_Option_ref_V) (return (x: t_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_V self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_V) -> {inv_ref_V result} {Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_FMap_K_V'0 (self: t_FMap_K_V) (key: t_K) (return (x: t_V)) =
    {[@expl:index 'self' type invariant] inv_ref_FMap_K_V self}
    {[@expl:index 'key' type invariant] inv_ref_K key}
    {[@expl:index requires] contains_K self key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost_K {self} {key} (fun (_ret: t_Option_ref_V) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = unwrap_ref_V {_6} (fun (_ret: t_V) -> [ &_5 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- _5 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_V = Any.any_l ()
    | & self: t_FMap_K_V = self
    | & key: t_K = key
    | & _5: t_V = Any.any_l ()
    | & _6: t_Option_ref_V = Any.any_l () ])
    [ return (result: t_V) -> {[@expl:index result type invariant] inv_ref_V result}
      {[@expl:index ensures] Some'0 result = get_K self key}
      (! return {result}) ]
end
module M_logic__fmap__impl_IntoIterator_for_FMap_K_V__into_iter (* <logic::fmap::FMap<K, V> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use map.Map
  
  type t_FMap_K_V
  
  type t_FMapIter_K_V = { inner: t_FMap_K_V }
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate inv_FMapIter_K_V (_1: t_FMapIter_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMapIter_K_V [inv_FMapIter_K_V x]. inv_FMapIter_K_V x = inv_FMap_K_V x.inner
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V = self.inner
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMapIter_K_V)) =
    {[@expl:into_iter 'self' type invariant] inv_FMap_K_V self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { inner = self } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_FMapIter_K_V = Any.any_l () | & self: t_FMap_K_V = self ])
    [ return (result: t_FMapIter_K_V) -> {[@expl:into_iter result type invariant] inv_FMapIter_K_V result}
      {[@expl:into_iter ensures] view_FMapIter_K_V result = self}
      (! return {result}) ]
end
module M_logic__fmap__impl_Iterator_for_FMapIter_K_V__next (* <logic::fmap::FMapIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  use seq.Seq
  
  type t_FMap_K_V
  
  type t_FMapIter_K_V = { inner: t_FMap_K_V }
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None'0 | Some'0 tup2_K_V
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: MutBorrow.t t_FMap_K_V) =
    inv_FMap_K_V self.current /\ inv_FMap_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: MutBorrow.t t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_tup2_K_V f0'0
        end
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_V empty_K = Const.const (None)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  let rec remove_one_ghost_K (self: MutBorrow.t t_FMap_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:remove_one_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    any
    [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result}
      {match result with
        | None'0 -> self.current = self.final /\ is_empty_K self.current
        | Some'0 {f0 = k; f1 = v} -> self.current = insert_K self.final k v /\ not contains_K self.final k
        end}
      (! return {result}) ]
  
  predicate inv_FMapIter_K_V (_1: t_FMapIter_K_V)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapIter_K_V [inv_FMapIter_K_V x]. inv_FMapIter_K_V x = inv_FMap_K_V x.inner
  
  predicate invariant_ref_FMapIter_K_V [@inline:trivial] (self: MutBorrow.t t_FMapIter_K_V) =
    inv_FMapIter_K_V self.current /\ inv_FMapIter_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMapIter_K_V
  
  predicate inv_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = invariant_ref_FMapIter_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMapIter_K_V
  
  predicate resolve_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FMapIter_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V = self.inner
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some'0 { f0 = k; f1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  function produces_trans_FMapIter_K_V (a: t_FMapIter_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMapIter_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMapIter_K_V) : ()
   = let ac = Seq.(++) ab bc in ()
  
  axiom produces_trans_FMapIter_K_V_spec:
    forall a: t_FMapIter_K_V, ab: Seq.seq tup2_K_V, b: t_FMapIter_K_V, bc: Seq.seq tup2_K_V, c: t_FMapIter_K_V. produces_FMapIter_K_V a ab b
      -> produces_FMapIter_K_V b bc c -> produces_FMapIter_K_V a (Seq.(++) ab bc) c
  
  function produces_refl_FMapIter_K_V (self: t_FMapIter_K_V) : () = ()
  
  axiom produces_refl_FMapIter_K_V_spec:
    forall self: t_FMapIter_K_V. produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
  
  predicate completed_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) = is_empty_K (view_FMapIter_K_V self.current)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:next 'self' type invariant] inv_ref_FMapIter_K_V self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_FMap_K_V self.current.inner}
        MutBorrow.borrow_final <t_FMap_K_V> {self.current.inner} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_FMap_K_V) ->
            [ &_3 <- _ret ] -{inv_FMap_K_V _ret.final}-
            [ &self <- { self with current = { inner = _ret.final } } ] s1)
      | s1 = remove_one_ghost_K {_3} (fun (_ret: t_Option_tup2_K_V) -> [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_ref_FMapIter_K_V self} s1
      | s1 = -{resolve_ref_FMapIter_K_V self}- s2
      | s2 = return {_0} ] ]
    [ & _0: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_FMapIter_K_V = self
    | & _3: MutBorrow.t t_FMap_K_V = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:next result type invariant] inv_Option_tup2_K_V result}
      {[@expl:next ensures] match result with
        | None'0 -> completed_FMapIter_K_V self
        | Some'0 {f0 = k; f1 = v} -> produces_FMapIter_K_V self.current (Seq.singleton { f0 = k; f1 = v }) self.final
        /\ view_FMapIter_K_V self.current = insert_K (view_FMapIter_K_V self.final) k v
        end}
      (! return {result}) ]
end
module M_logic__fmap__impl_IteratorSpec_for_FMapIter_K_V__produces_refl (* <logic::fmap::FMapIter<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap_K_V
  
  type t_FMapIter_K_V = { inner: t_FMap_K_V }
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None | Some tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V = self.inner
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some'0 v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMapIter_K_V
  
  function produces_refl_FMapIter_K_V (self: t_FMapIter_K_V) : ()
  
  goal vc_produces_refl_FMapIter_K_V:
    [@expl:produces_refl ensures] produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
end
module M_logic__fmap__impl_IteratorSpec_for_FMapIter_K_V__produces_trans (* <logic::fmap::FMapIter<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap_K_V
  
  type t_FMapIter_K_V = { inner: t_FMap_K_V }
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None | Some tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V = self.inner
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some'0 v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMapIter_K_V
  
  constant ab : Seq.seq tup2_K_V
  
  constant b : t_FMapIter_K_V
  
  constant bc : Seq.seq tup2_K_V
  
  constant c : t_FMapIter_K_V
  
  function produces_trans_FMapIter_K_V (a: t_FMapIter_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMapIter_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMapIter_K_V) : ()
  
  goal vc_produces_trans_FMapIter_K_V: produces_FMapIter_K_V a ab b
    -> produces_FMapIter_K_V b bc c
    -> (let ac = Seq.(++) ab bc in (forall x: tup2_K_V. contains_tup2_K_V ab x -> contains_tup2_K_V ac x)
    && (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get ac (i + Seq.length ab) = Seq.get bc i)
    && (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length ac -> (Seq.get ac i).f0 <> k)
        -> (forall i: int. 0 <= i /\ i < Seq.length ab -> (Seq.get ab i).f0 <> k)
        /\ (forall i: int. 0 <= i /\ i < Seq.length bc -> (Seq.get bc i).f0 <> k)
        /\ get_K (view_FMapIter_K_V a) k = get_K (view_FMapIter_K_V b) k
        /\ get_K (view_FMapIter_K_V b) k = get_K (view_FMapIter_K_V c) k)
    && ([@expl:produces_trans ensures] produces_FMapIter_K_V a (Seq.(++) ab bc) c))
end
module M_logic__fmap__impl_IntoIterator_for_ref_FMap_K_V__into_iter (* <&'a logic::fmap::FMap<K, V> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_FMap_ref_K_ref_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  type t_Option_ref_V = None'0 | Some'0 t_V
  
  function view_FMap_ref_K_ref_V (self: t_FMap_ref_K_ref_V) : Map.map t_K t_Option_ref_V
  
  function get_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_Option_ref_V =
    Map.get (view_FMap_ref_K_ref_V self) k
  
  meta "rewrite_def" function get_ref_K
  
  predicate contains_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) = get_ref_K self k <> None'0
  
  meta "rewrite_def" predicate contains_ref_K
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate index_Mapping_ref_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_ref_V_bool
  
  function such_that_ref_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_ref_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_ref_V_bool p x)
      -> index_Mapping_ref_V_bool p (such_that_ref_V p)
  
  function unwrap_Option_ref_V (self: t_Option_ref_V) : t_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_ref_V (fun (__0: t_V) -> true)
      end
  
  function lookup_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_V =
    unwrap_Option_ref_V (get_ref_K self k)
  
  meta "rewrite_def" function lookup_ref_K
  
  function index_FMap_ref_K_ref_V [@inline:trivial] (self: t_FMap_ref_K_ref_V) (key: t_K) : t_V = lookup_ref_K self key
  
  meta "rewrite_def" function index_FMap_ref_K_ref_V
  
  predicate invariant_FMap_ref_K_ref_V [@inline:trivial] (self: t_FMap_ref_K_ref_V) =
    forall k: t_K. contains_ref_K self k -> inv_ref_K k /\ inv_ref_V (index_FMap_ref_K_ref_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_ref_K_ref_V
  
  predicate inv_FMap_ref_K_ref_V (_1: t_FMap_ref_K_ref_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap_ref_K_ref_V [inv_FMap_ref_K_ref_V x]. inv_FMap_ref_K_ref_V x
      = invariant_FMap_ref_K_ref_V x
  
  function len_ref_K (self: t_FMap_ref_K_ref_V) : int
  
  axiom len_ref_K_spec: forall self: t_FMap_ref_K_ref_V. len_ref_K self >= 0
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  let rec as_ref_ghost_K (self: t_FMap_K_V) (return (x: t_FMap_ref_K_ref_V)) =
    {[@expl:as_ref_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    any
    [ return (result: t_FMap_ref_K_ref_V) -> {inv_FMap_ref_K_ref_V result}
      {len_ref_K result = len_K self}
      {forall k: t_K, v: t_V. (get_K self k = Some v) = (get_ref_K result k = Some'0 v)}
      (! return {result}) ]
  
  type t_FMapIterRef_K_V = { inner: t_FMap_ref_K_ref_V }
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function view_FMapIterRef_K_V (self: t_FMapIterRef_K_V) : t_FMap_K_V =
    such_that_FMap_K_V (fun (m: t_FMap_K_V) -> forall k: t_K, v: t_V. (get_K m k = Some v)
      = (get_ref_K self.inner k = Some'0 v))
  
  predicate inv_FMapIterRef_K_V (_1: t_FMapIterRef_K_V)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapIterRef_K_V [inv_FMapIterRef_K_V x]. inv_FMapIterRef_K_V x
      = inv_FMap_ref_K_ref_V x.inner
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter_ref_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMapIterRef_K_V)) =
    {[@expl:into_iter 'self' type invariant] inv_ref_FMap_K_V self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = as_ref_ghost_K {self} (fun (_ret: t_FMap_ref_K_ref_V) -> [ &_6 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &result <- { inner = _6 } ] s1
      | s1 = {[@expl:assertion] ext_eq_K (view_FMapIterRef_K_V result) _self} s2
      | s2 = [ &_0 <- result ] s3
      | s3 = return {_0} ] ]
    [ & _0: t_FMapIterRef_K_V = Any.any_l ()
    | & self: t_FMap_K_V = self
    | & _self: t_FMap_K_V = Any.any_l ()
    | & result: t_FMapIterRef_K_V = Any.any_l ()
    | & _6: t_FMap_ref_K_ref_V = Any.any_l () ])
    [ return (result: t_FMapIterRef_K_V) -> {[@expl:into_iter result type invariant] inv_FMapIterRef_K_V result}
      {[@expl:into_iter ensures] view_FMapIterRef_K_V result = self}
      (! return {result}) ]
end
module M_logic__fmap__impl_IteratorSpec_for_FMapIterRef_K_V__produces_refl (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap_ref_K_ref_V
  
  type t_FMapIterRef_K_V = { inner: t_FMap_ref_K_ref_V }
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_ref_K_ref_V = None | Some tup2_ref_K_ref_V
  
  function get_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (ix: int) : t_Option_tup2_ref_K_ref_V = if 0 <= ix
    /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_FMap_K_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  type t_Option_ref_V = None'1 | Some'1 t_V
  
  function view_FMap_ref_K_ref_V (self: t_FMap_ref_K_ref_V) : Map.map t_K t_Option_ref_V
  
  function get_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_Option_ref_V =
    Map.get (view_FMap_ref_K_ref_V self) k
  
  meta "rewrite_def" function get_ref_K
  
  function view_FMapIterRef_K_V (self: t_FMapIterRef_K_V) : t_FMap_K_V =
    such_that_FMap_K_V (fun (m: t_FMap_K_V) -> forall k: t_K, v: t_V. (get_K m k = Some'0 v)
      = (get_ref_K self.inner k = Some'1 v))
  
  predicate produces_FMapIterRef_K_V (self: t_FMapIterRef_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_FMapIterRef_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_ref_K_ref_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K (view_FMapIterRef_K_V o) k /\ get_K (view_FMapIterRef_K_V self) k = Some'0 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIterRef_K_V o) k = get_K (view_FMapIterRef_K_V self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMapIterRef_K_V
  
  function produces_refl_FMapIterRef_K_V (self: t_FMapIterRef_K_V) : ()
  
  goal vc_produces_refl_FMapIterRef_K_V:
    [@expl:produces_refl ensures] produces_FMapIterRef_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
end
module M_logic__fmap__impl_IteratorSpec_for_FMapIterRef_K_V__produces_trans (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap_ref_K_ref_V
  
  type t_FMapIterRef_K_V = { inner: t_FMap_ref_K_ref_V }
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_ref_K_ref_V = None | Some tup2_ref_K_ref_V
  
  function get_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (ix: int) : t_Option_tup2_ref_K_ref_V = if 0 <= ix
    /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_FMap_K_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  type t_Option_ref_V = None'1 | Some'1 t_V
  
  function view_FMap_ref_K_ref_V (self: t_FMap_ref_K_ref_V) : Map.map t_K t_Option_ref_V
  
  function get_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_Option_ref_V =
    Map.get (view_FMap_ref_K_ref_V self) k
  
  meta "rewrite_def" function get_ref_K
  
  function view_FMapIterRef_K_V (self: t_FMapIterRef_K_V) : t_FMap_K_V =
    such_that_FMap_K_V (fun (m: t_FMap_K_V) -> forall k: t_K, v: t_V. (get_K m k = Some'0 v)
      = (get_ref_K self.inner k = Some'1 v))
  
  predicate produces_FMapIterRef_K_V (self: t_FMapIterRef_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_FMapIterRef_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_ref_K_ref_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K (view_FMapIterRef_K_V o) k /\ get_K (view_FMapIterRef_K_V self) k = Some'0 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIterRef_K_V o) k = get_K (view_FMapIterRef_K_V self) k)
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMapIterRef_K_V
  
  constant ab : Seq.seq tup2_ref_K_ref_V
  
  constant b : t_FMapIterRef_K_V
  
  constant bc : Seq.seq tup2_ref_K_ref_V
  
  constant c : t_FMapIterRef_K_V
  
  function produces_trans_FMapIterRef_K_V (a: t_FMapIterRef_K_V) (ab: Seq.seq tup2_ref_K_ref_V) (b: t_FMapIterRef_K_V) (bc: Seq.seq tup2_ref_K_ref_V) (c: t_FMapIterRef_K_V) : ()
  
  goal vc_produces_trans_FMapIterRef_K_V: produces_FMapIterRef_K_V a ab b
    -> produces_FMapIterRef_K_V b bc c
    -> (let ac = Seq.(++) ab bc in (forall x: tup2_ref_K_ref_V. contains_tup2_ref_K_ref_V ab x
        -> contains_tup2_ref_K_ref_V ac x)
    && (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get ac (i + Seq.length ab) = Seq.get bc i)
    && (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length ac -> (Seq.get ac i).f0 <> k)
        -> (forall i: int. 0 <= i /\ i < Seq.length ab -> (Seq.get ab i).f0 <> k)
        /\ (forall i: int. 0 <= i /\ i < Seq.length bc -> (Seq.get bc i).f0 <> k)
        /\ get_K (view_FMapIterRef_K_V a) k = get_K (view_FMapIterRef_K_V b) k
        /\ get_K (view_FMapIterRef_K_V b) k = get_K (view_FMapIterRef_K_V c) k)
    && ([@expl:produces_trans ensures] produces_FMapIterRef_K_V a (Seq.(++) ab bc) c))
end
module M_logic__fset__impl_FSet_T__ext_eq (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant other : Fset.fset t_T
  
  predicate ext_eq_T (self: Fset.fset t_T) (other: Fset.fset t_T)
  
  goal vc_ext_eq_T: [@expl:ext_eq ensures] (forall e: t_T. contains_T self e = contains_T other e) = (self = other)
end
module M_logic__fset__impl_FSet_T__singleton (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function insert_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.add e self
  
  meta "rewrite_def" function insert_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  function singleton_T (x: t_T) : Fset.fset t_T
  
  goal vc_singleton_T: [@expl:singleton ensures] forall y: t_T. contains_T (insert_T (Fset.empty: Fset.fset t_T) x) y
      = (x = y)
end
module M_logic__fset__impl_FSet_T__unions (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  predicate contains_U [@inline:trivial] (self: Fset.fset t_U) (e: t_U) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_U
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant f : Map.map t_T (Fset.fset t_U)
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  goal vc_unions_T: if Fset.cardinal self = 0 then
      [@expl:unions ensures] forall y: t_U. contains_U (Fset.empty: Fset.fset t_U) y
        = (exists x: t_T. contains_T self x /\ contains_U (Map.get f x) y)
    else
      let x = Fset.pick self in well_founded_relation_Int (Fset.cardinal self) (Fset.cardinal (remove_T self x))
      /\ ((forall y: t_U. contains_U (unions_T (remove_T self x) f) y
          = (exists x'0: t_T. contains_T (remove_T self x) x'0 /\ contains_U (Map.get f x'0) y))
      -> ([@expl:unions ensures] forall y: t_U. contains_U (Fset.union (Map.get f x) (unions_T (remove_T self x) f)) y
        = (exists x'0: t_T. contains_T self x'0 /\ contains_U (Map.get f x'0) y)))

end
module M_logic__fset__impl_FSet_T__cons (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T self x /\ contains_Seq_T (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset t_T
  
  constant ss : Fset.fset (Seq.seq t_T)
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  goal vc_cons_T: (forall x: t_T, xs: Seq.seq t_T. tail_T (push_front_T xs x) = xs)
    && (forall xs: Seq.seq t_T. 0 < Seq.length xs -> push_front_T (tail_T xs) (Seq.get xs 0) = xs)
    && ((forall y: Seq.seq t_T. contains_Seq_T (unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))) y
        = (exists x: t_T. contains_T s x
          /\ contains_Seq_T (Map.get (fun (x'0: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x'0)) x) y))
    -> ([@expl:cons ensures] forall xs: Seq.seq t_T. contains_Seq_T (unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs'0: Seq.seq t_T) -> push_front_T xs'0 x))) xs
      = (0 < Seq.length xs /\ contains_T s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))))
end
module M_logic__fset__impl_FSet_T__concat (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset (Seq.seq t_T)
  
  constant t : Fset.fset (Seq.seq t_T)
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  goal vc_concat_T:
    (forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))) y
        = (exists x: Seq.seq t_T. contains_Seq_T s x
          /\ contains_Seq_T (Map.get (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs)) x) y))
    -> ([@expl:concat ensures] forall xs: Seq.seq t_T. contains_Seq_T (unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))) xs
      = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs))
end
module M_logic__fset__impl_FSet_T__replicate (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains_T'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T'0
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T'0 self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T'0 s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant n : int
  
  function replicate_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  goal vc_replicate_T: n >= 0
    -> (if n = 0 then
      (forall xs: Seq.seq t_T. Seq.length xs = 0 -> xs = (Seq.empty: Seq.seq t_T))
      && ((forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) y
          = ((Seq.empty: Seq.seq t_T) = y))
      -> ([@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x))))
    else
      (forall xs: Seq.seq t_T, i: int. 0 < i /\ i < Seq.length xs -> Seq.get xs i = Seq.get (tail_T xs) (i - 1))
      && (([@expl:replicate requires] n - 1 >= 0) /\ well_founded_relation_Int n (n - 1))
      /\ ((forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self (n - 1)) xs
          = (Seq.length xs = n - 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> (forall xs: Seq.seq t_T. contains_Seq_T (cons_T self (replicate_T self (n - 1))) xs
          = (0 < Seq.length xs
          /\ contains_T'0 self (Seq.get xs 0) /\ contains_Seq_T (replicate_T self (n - 1)) (tail_T xs)))
      -> ([@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (cons_T self (replicate_T self (n - 1))) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x))))
    )
end
module M_logic__fset__impl_FSet_T__replicate_up_to (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains_T'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T'0
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T'0 self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T'0 s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  function replicate_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_T_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_T self n
      = (if n = 0 then singleton_Seq_T (Seq.empty: Seq.seq t_T) else cons_T self (replicate_T self (n - 1)))
  
  axiom replicate_T_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant n : int
  
  function replicate_up_to_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  goal vc_replicate_up_to_T: n >= 0
    -> (if n = 0 then
      (forall xs: Seq.seq t_T. Seq.length xs = 0 -> xs = (Seq.empty: Seq.seq t_T))
      && ((forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) y
          = ((Seq.empty: Seq.seq t_T) = y))
      -> ([@expl:replicate_up_to ensures] forall xs: Seq.seq t_T. contains_Seq_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x))))
    else
      (([@expl:replicate_up_to requires] n - 1 >= 0) /\ well_founded_relation_Int n (n - 1))
      /\ ((forall xs: Seq.seq t_T. contains_Seq_T (replicate_up_to_T self (n - 1)) xs
          = (Seq.length xs <= n - 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@expl:replicate requires] n >= 0)
      /\ ((forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
          = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@expl:replicate_up_to ensures] forall xs: Seq.seq t_T. contains_Seq_T (Fset.union (replicate_up_to_T self (n
          - 1)) (replicate_T self n)) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))))
    )
end
module M_logic__fset__unions_union
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  predicate contains_U [@inline:trivial] (self: Fset.fset t_U) (e: t_U) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_U
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset t_U
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). forall y: t_U. contains_U (unions_T self f) y
        = (exists x: t_T. contains_T self x /\ contains_U (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unions_union_T : ()
  
  goal vc_unions_union_T:
    ([@expl:unions_union ensures #0] forall s1: Fset.fset t_T, s2: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions_T (Fset.union s1 s2) f
        = Fset.union (unions_T s1 f) (unions_T s2 f))
    && ([@expl:unions_union ensures #1] forall s: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U), g: Map.map t_T (Fset.fset t_U). unions_T s (fun (x: t_T) -> Fset.union (Map.get f x) (Map.get g x))
      = Fset.union (unions_T s f) (unions_T s g))
end
module M_logic__fset__map_union
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  function map_T (self: Fset.fset t_T) (f: Map.map t_T t_U) : Fset.fset t_U = Fset.map f self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function map_union_T : ()
  
  goal vc_map_union_T:
    [@expl:map_union ensures] forall s: Fset.fset t_T, t: Fset.fset t_T, f: Map.map t_T t_U. map_T (Fset.union s t) f
      = Fset.union (map_T s f) (map_T t f)
end
module M_logic__fset__concat_union
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function concat_union_T : ()
  
  goal vc_concat_union_T:
    ([@expl:concat_union ensures #0] forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat_T (Fset.union s1 s2) t
        = Fset.union (concat_T s1 t) (concat_T s2 t))
    && ([@expl:concat_union ensures #1] forall s: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat_T s (Fset.union t1 t2)
      = Fset.union (concat_T s t1) (concat_T s t2))
end
module M_logic__fset__cons_concat
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function cons_concat_T : ()
  
  goal vc_cons_concat_T: (forall x: t_T, xs: Seq.seq t_T, ys: Seq.seq t_T. Seq.(++) (push_front_T xs x) ys
        = push_front_T (Seq.(++) xs ys) x)
    && (forall x: t_T, ys: Seq.seq t_T. tail_T (push_front_T ys x) = ys)
    && (forall ys: Seq.seq t_T. 0 < Seq.length ys -> ys = push_front_T (tail_T ys) (Seq.get ys 0))
    && ([@expl:cons_concat ensures] forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat_T (cons_T s t) u
      = cons_T s (concat_T t u))
end
module M_logic__fset__concat_replicate
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains_T'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T'0
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T'0 self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T'0 s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  function replicate_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_T_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_T self n
      = (if n = 0 then singleton_Seq_T (Seq.empty: Seq.seq t_T) else cons_T self (replicate_T self (n - 1)))
  
  axiom replicate_T_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty_T (s: Fset.fset (Seq.seq t_T)) : () = ()
  
  axiom concat_empty_T_spec: forall s: Fset.fset (Seq.seq t_T). concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) s
      = s
  
  axiom concat_empty_T_spec'0: forall s: Fset.fset (Seq.seq t_T). concat_T s (singleton_Seq_T (Seq.empty: Seq.seq t_T))
      = s
  
  constant cons_concat_T: () = ()
  
  axiom cons_concat_T_spec:
    forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat_T (cons_T s t) u
      = cons_T s (concat_T t u)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant n : int
  
  constant m : int
  
  constant s : Fset.fset t_T
  
  function concat_replicate_T (n: int) (m: int) (s: Fset.fset t_T) : ()
  
  goal vc_concat_replicate_T: 0 <= n /\ 0 <= m
    -> (if n = 0 then
      ([@expl:replicate requires] m >= 0)
      /\ ((forall xs: Seq.seq t_T. contains_Seq_T (replicate_T s m) xs
          = (Seq.length xs = m /\ (forall x: t_T. contains_T xs x -> contains_T'0 s x)))
      -> concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) (replicate_T s m) = replicate_T s m
        && concat_T (replicate_T s m) (singleton_Seq_T (Seq.empty: Seq.seq t_T)) = replicate_T s m
      -> (let _ = concat_empty_T (replicate_T s m) in [@expl:concat_replicate ensures] replicate_T s (n + m)
      = concat_T (replicate_T s n) (replicate_T s m)))
    else
      (forall s'0: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat_T (cons_T s'0 t) u
          = cons_T s'0 (concat_T t u))
      -> (let _ = cons_concat_T in (([@expl:concat_replicate requires] 0 <= n - 1 /\ 0 <= m)
        /\ well_founded_relation_Int n (n - 1))
      /\ (replicate_T s (n - 1 + m) = concat_T (replicate_T s (n - 1)) (replicate_T s m)
      -> (let _ = concat_replicate_T (n - 1) m s in [@expl:concat_replicate ensures] replicate_T s (n + m)
      = concat_T (replicate_T s n) (replicate_T s m))))
    )
end
module M_logic__fset__concat_empty
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset (Seq.seq t_T)
  
  function concat_empty_T (s: Fset.fset (Seq.seq t_T)) : ()
  
  goal vc_concat_empty_T: (forall xs: Seq.seq t_T. Seq.(++) xs (Seq.empty: Seq.seq t_T) = xs)
    && (forall xs: Seq.seq t_T. Seq.(++) (Seq.empty: Seq.seq t_T) xs = xs)
    && ([@expl:concat_empty ensures #0] concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) s = s)
    && ([@expl:concat_empty ensures #1] concat_T s (singleton_Seq_T (Seq.empty: Seq.seq t_T)) = s)
end
module M_logic__fset__concat_replicate_up_to
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains_T'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T'0
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T'0 self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T'0 s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  function replicate_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_T_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_T self n
      = (if n = 0 then singleton_Seq_T (Seq.empty: Seq.seq t_T) else cons_T self (replicate_T self (n - 1)))
  
  axiom replicate_T_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
  
  function replicate_up_to_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_up_to_T_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_up_to_T self n
      = (if n = 0 then
        singleton_Seq_T (Seq.empty: Seq.seq t_T)
      else
        Fset.union (replicate_up_to_T self (n - 1)) (replicate_T self n)
      )
  
  axiom replicate_up_to_T_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains_Seq_T (replicate_up_to_T self n) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty_T (s: Fset.fset (Seq.seq t_T)) : () = ()
  
  axiom concat_empty_T_spec: forall s: Fset.fset (Seq.seq t_T). concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) s
      = s
  
  axiom concat_empty_T_spec'0: forall s: Fset.fset (Seq.seq t_T). concat_T s (singleton_Seq_T (Seq.empty: Seq.seq t_T))
      = s
  
  constant concat_union_T: () = ()
  
  axiom concat_union_T_spec:
    forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat_T (Fset.union s1 s2) t
      = Fset.union (concat_T s1 t) (concat_T s2 t)
  
  axiom concat_union_T_spec'0:
    forall s: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat_T s (Fset.union t1 t2)
      = Fset.union (concat_T s t1) (concat_T s t2)
  
  constant cons_concat_T: () = ()
  
  axiom cons_concat_T_spec:
    forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat_T (cons_T s t) u
      = cons_T s (concat_T t u)
  
  function concat_replicate_T (n: int) (m: int) (s: Fset.fset t_T) : ()
  
  axiom concat_replicate_T_def: forall n: int, m: int, s: Fset.fset t_T. 0 <= n /\ 0 <= m
      -> concat_replicate_T n m s
      = (if n = 0 then
        let _ = concat_empty_T (replicate_T s m) in ()
      else
        let _ = cons_concat_T in let _ = concat_replicate_T (n - 1) m s in ()
      )
  
  axiom concat_replicate_T_spec: forall n: int, m: int, s: Fset.fset t_T. 0 <= n /\ 0 <= m
      -> replicate_T s (n + m) = concat_T (replicate_T s n) (replicate_T s m)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant n : int
  
  constant m : int
  
  constant s : Fset.fset t_T
  
  function concat_replicate_up_to_T (n: int) (m: int) (s: Fset.fset t_T) : ()
  
  goal vc_concat_replicate_up_to_T: 0 <= n /\ n < m
    -> (if n + 1 = m then
      ([@expl:replicate requires] n + 1 >= 0)
      /\ ((forall xs: Seq.seq t_T. contains_Seq_T (replicate_T s (n + 1)) xs
          = (Seq.length xs = n + 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 s x)))
      -> concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) (replicate_T s (n + 1)) = replicate_T s (n + 1)
        && concat_T (replicate_T s (n + 1)) (singleton_Seq_T (Seq.empty: Seq.seq t_T)) = replicate_T s (n + 1)
      -> (let _ = concat_empty_T (replicate_T s (n + 1)) in [@expl:concat_replicate_up_to ensures] replicate_up_to_T s m
      = Fset.union (replicate_up_to_T s n) (concat_T (replicate_T s (n + 1)) (replicate_up_to_T s (m - n - 1)))))
    else
      (forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat_T (Fset.union s1 s2) t
            = Fset.union (concat_T s1 t) (concat_T s2 t))
        && (forall s'0: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat_T s'0 (Fset.union t1 t2)
          = Fset.union (concat_T s'0 t1) (concat_T s'0 t2))
      -> (let _ = concat_union_T in ([@expl:concat_replicate requires] 0 <= n /\ 0 <= m - n - 1)
      /\ (replicate_T s (n + (m - n - 1)) = concat_T (replicate_T s n) (replicate_T s (m - n - 1))
      -> (let _ = concat_replicate_T n (m - n - 1) s in (([@expl:concat_replicate_up_to requires] 0 <= n /\ n < m - 1)
        /\ well_founded_relation_Int m (m - 1))
      /\ (replicate_up_to_T s (m - 1)
        = Fset.union (replicate_up_to_T s n) (concat_T (replicate_T s (n + 1)) (replicate_up_to_T s (m - 1 - n - 1)))
      -> (let _ = concat_replicate_up_to_T n (m - 1) s in [@expl:concat_replicate_up_to ensures] replicate_up_to_T s m
      = Fset.union (replicate_up_to_T s n) (concat_T (replicate_T s (n + 1)) (replicate_up_to_T s (m - n - 1))))))))
    )
end
module M_logic__id__impl_Clone_for_Id__clone (* <logic::id::Id as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Id (self: t_Id) (return (x: t_Id)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = return {_0} ] ] [ & _0: t_Id = Any.any_l () | & self: t_Id = self ])
    [ return (result: t_Id) -> {[@expl:clone ensures] result = self} (! return {result}) ]
end
module M_logic__id__impl_PartialEq_for_Id__ne (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Id
  
  let rec eq_Id (self: t_Id) (other: t_Id) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self = other)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ne_Id (self: t_Id) (other: t_Id) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = eq_Id {self} {other} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- not _4 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self: t_Id = self | & other: t_Id = other | & _4: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:ne ensures] result <> (self = other)} (! return {result}) ]
end
module M_logic__int__impl_Clone_for_Int__clone (* <logic::int::Int as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Int (self: int) (return (x: int)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = return {_0} ] ] [ & _0: int = Any.any_l () | & self: int = self ])
    [ return (result: int) -> {[@expl:clone ensures] result = self} (! return {result}) ]
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_le_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate le_log_ref_T (self: t_T) (other: t_T) = le_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_le_log_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_le_log_ref_T: [@expl:cmp_le_log ensures] le_log_ref_T x y = (cmp_log_ref_T x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_lt_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate lt_log_ref_T (self: t_T) (other: t_T) = lt_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_lt_log_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_lt_log_ref_T: [@expl:cmp_lt_log ensures] lt_log_ref_T x y = (cmp_log_ref_T x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_ge_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate ge_log_ref_T (self: t_T) (other: t_T) = ge_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_ge_log_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_ge_log_ref_T: [@expl:cmp_ge_log ensures] ge_log_ref_T x y = (cmp_log_ref_T x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_gt_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate gt_log_ref_T (self: t_T) (other: t_T) = gt_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_gt_log_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_gt_log_ref_T: [@expl:cmp_gt_log ensures] gt_log_ref_T x y = (cmp_log_ref_T x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__refl (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  function refl_ref_T (x: t_T) : ()
  
  goal vc_refl_ref_T: [@expl:refl ensures] cmp_log_ref_T x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_ref_T__trans (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  constant z : t_T
  
  constant o : t_Ordering
  
  function trans_ref_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  goal vc_trans_ref_T: cmp_log_ref_T x y = o -> cmp_log_ref_T y z = o -> ([@expl:trans ensures] cmp_log_ref_T x z = o)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__antisym1 (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function antisym1_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_antisym1_ref_T: cmp_log_ref_T x y = Less -> ([@expl:antisym1 ensures] cmp_log_ref_T y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__antisym2 (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function antisym2_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_antisym2_ref_T: cmp_log_ref_T x y = Greater -> ([@expl:antisym2 ensures] cmp_log_ref_T y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__eq_cmp (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function eq_cmp_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_eq_cmp_ref_T: [@expl:eq_cmp ensures] (x = y) = (cmp_log_ref_T x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_le_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  goal vc_cmp_le_log_Int: [@expl:cmp_le_log ensures] (x <= y) = (cmp_log_Int x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_lt_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  goal vc_cmp_lt_log_Int: [@expl:cmp_lt_log ensures] (x < y) = (cmp_log_Int x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_ge_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  goal vc_cmp_ge_log_Int: [@expl:cmp_ge_log ensures] (x >= y) = (cmp_log_Int x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_gt_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  goal vc_cmp_gt_log_Int: [@expl:cmp_gt_log ensures] (x > y) = (cmp_log_Int x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__refl (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  function refl_Int (x: int) : ()
  
  goal vc_refl_Int: [@expl:refl ensures] cmp_log_Int x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_Int__trans (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  constant z : int
  
  constant o : t_Ordering
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  goal vc_trans_Int: cmp_log_Int x y = o -> cmp_log_Int y z = o -> ([@expl:trans ensures] cmp_log_Int x z = o)
end
module M_logic__ord__impl_OrdLogic_for_Int__antisym1 (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function antisym1_Int (x: int) (y: int) : ()
  
  goal vc_antisym1_Int: cmp_log_Int x y = Less -> ([@expl:antisym1 ensures] cmp_log_Int y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__antisym2 (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function antisym2_Int (x: int) (y: int) : ()
  
  goal vc_antisym2_Int: cmp_log_Int x y = Greater -> ([@expl:antisym2 ensures] cmp_log_Int y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__eq_cmp (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  goal vc_eq_cmp_Int: [@expl:eq_cmp ensures] (x = y) = (cmp_log_Int x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_le_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_le_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_le_log_u8: [@expl:cmp_le_log ensures] UInt8.le x y = (cmp_log_u8 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_lt_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_lt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_lt_log_u8: [@expl:cmp_lt_log ensures] UInt8.lt x y = (cmp_log_u8 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_ge_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_ge_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_ge_log_u8: [@expl:cmp_ge_log ensures] UInt8.ge x y = (cmp_log_u8 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_gt_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_gt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_gt_log_u8: [@expl:cmp_gt_log ensures] UInt8.gt x y = (cmp_log_u8 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__refl (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  function refl_u8 (x: UInt8.t) : ()
  
  goal vc_refl_u8: [@expl:refl ensures] cmp_log_u8 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u8__trans (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  constant z : UInt8.t
  
  constant o : t_Ordering
  
  function trans_u8 (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  goal vc_trans_u8: cmp_log_u8 x y = o -> cmp_log_u8 y z = o -> ([@expl:trans ensures] cmp_log_u8 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u8__antisym1 (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function antisym1_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_antisym1_u8: cmp_log_u8 x y = Less -> ([@expl:antisym1 ensures] cmp_log_u8 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__antisym2 (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function antisym2_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_antisym2_u8: cmp_log_u8 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_u8 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__eq_cmp (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function eq_cmp_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_eq_cmp_u8: [@expl:eq_cmp ensures] (x = y) = (cmp_log_u8 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_le_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_le_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_le_log_u16: [@expl:cmp_le_log ensures] UInt16.le x y = (cmp_log_u16 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_lt_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_lt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_lt_log_u16: [@expl:cmp_lt_log ensures] UInt16.lt x y = (cmp_log_u16 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_ge_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_ge_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_ge_log_u16: [@expl:cmp_ge_log ensures] UInt16.ge x y = (cmp_log_u16 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_gt_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_gt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_gt_log_u16: [@expl:cmp_gt_log ensures] UInt16.gt x y = (cmp_log_u16 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__refl (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  function refl_u16 (x: UInt16.t) : ()
  
  goal vc_refl_u16: [@expl:refl ensures] cmp_log_u16 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u16__trans (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  constant z : UInt16.t
  
  constant o : t_Ordering
  
  function trans_u16 (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  goal vc_trans_u16: cmp_log_u16 x y = o -> cmp_log_u16 y z = o -> ([@expl:trans ensures] cmp_log_u16 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u16__antisym1 (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function antisym1_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_antisym1_u16: cmp_log_u16 x y = Less -> ([@expl:antisym1 ensures] cmp_log_u16 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__antisym2 (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function antisym2_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_antisym2_u16: cmp_log_u16 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_u16 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__eq_cmp (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function eq_cmp_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_eq_cmp_u16: [@expl:eq_cmp ensures] (x = y) = (cmp_log_u16 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_le_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_le_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_le_log_u32: [@expl:cmp_le_log ensures] UInt32.le x y = (cmp_log_u32 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_lt_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_lt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_lt_log_u32: [@expl:cmp_lt_log ensures] UInt32.lt x y = (cmp_log_u32 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_ge_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_ge_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_ge_log_u32: [@expl:cmp_ge_log ensures] UInt32.ge x y = (cmp_log_u32 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_gt_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_gt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_gt_log_u32: [@expl:cmp_gt_log ensures] UInt32.gt x y = (cmp_log_u32 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__refl (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  function refl_u32 (x: UInt32.t) : ()
  
  goal vc_refl_u32: [@expl:refl ensures] cmp_log_u32 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u32__trans (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  constant z : UInt32.t
  
  constant o : t_Ordering
  
  function trans_u32 (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  goal vc_trans_u32: cmp_log_u32 x y = o -> cmp_log_u32 y z = o -> ([@expl:trans ensures] cmp_log_u32 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u32__antisym1 (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function antisym1_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_antisym1_u32: cmp_log_u32 x y = Less -> ([@expl:antisym1 ensures] cmp_log_u32 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__antisym2 (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function antisym2_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_antisym2_u32: cmp_log_u32 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_u32 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__eq_cmp (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function eq_cmp_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_eq_cmp_u32: [@expl:eq_cmp ensures] (x = y) = (cmp_log_u32 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_le_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_le_log_u64: [@expl:cmp_le_log ensures] UInt64.le x y = (cmp_log_u64 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_lt_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_lt_log_u64: [@expl:cmp_lt_log ensures] UInt64.lt x y = (cmp_log_u64 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_ge_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_ge_log_u64: [@expl:cmp_ge_log ensures] UInt64.ge x y = (cmp_log_u64 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_gt_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_gt_log_u64: [@expl:cmp_gt_log ensures] UInt64.gt x y = (cmp_log_u64 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__refl (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  function refl_u64 (x: UInt64.t) : ()
  
  goal vc_refl_u64: [@expl:refl ensures] cmp_log_u64 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u64__trans (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  constant z : UInt64.t
  
  constant o : t_Ordering
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  goal vc_trans_u64: cmp_log_u64 x y = o -> cmp_log_u64 y z = o -> ([@expl:trans ensures] cmp_log_u64 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u64__antisym1 (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym1_u64: cmp_log_u64 x y = Less -> ([@expl:antisym1 ensures] cmp_log_u64 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__antisym2 (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym2_u64: cmp_log_u64 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_u64 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__eq_cmp (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_eq_cmp_u64: [@expl:eq_cmp ensures] (x = y) = (cmp_log_u64 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_le_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_le_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_le_log_u128: [@expl:cmp_le_log ensures] UInt128.le x y = (cmp_log_u128 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_lt_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_lt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_lt_log_u128: [@expl:cmp_lt_log ensures] UInt128.lt x y = (cmp_log_u128 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_ge_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_ge_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_ge_log_u128: [@expl:cmp_ge_log ensures] UInt128.ge x y = (cmp_log_u128 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_gt_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_gt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_gt_log_u128: [@expl:cmp_gt_log ensures] UInt128.gt x y = (cmp_log_u128 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__refl (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  function refl_u128 (x: UInt128.t) : ()
  
  goal vc_refl_u128: [@expl:refl ensures] cmp_log_u128 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u128__trans (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  constant z : UInt128.t
  
  constant o : t_Ordering
  
  function trans_u128 (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  goal vc_trans_u128: cmp_log_u128 x y = o -> cmp_log_u128 y z = o -> ([@expl:trans ensures] cmp_log_u128 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u128__antisym1 (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function antisym1_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_antisym1_u128: cmp_log_u128 x y = Less -> ([@expl:antisym1 ensures] cmp_log_u128 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__antisym2 (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function antisym2_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_antisym2_u128: cmp_log_u128 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_u128 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__eq_cmp (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function eq_cmp_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_eq_cmp_u128: [@expl:eq_cmp ensures] (x = y) = (cmp_log_u128 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_le_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_le_log_usize: [@expl:cmp_le_log ensures] UInt64.le x y = (cmp_log_usize x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_lt_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_lt_log_usize: [@expl:cmp_lt_log ensures] UInt64.lt x y = (cmp_log_usize x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_ge_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_ge_log_usize: [@expl:cmp_ge_log ensures] UInt64.ge x y = (cmp_log_usize x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_gt_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_gt_log_usize: [@expl:cmp_gt_log ensures] UInt64.gt x y = (cmp_log_usize x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__refl (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  function refl_usize (x: UInt64.t) : ()
  
  goal vc_refl_usize: [@expl:refl ensures] cmp_log_usize x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_usize__trans (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  constant z : UInt64.t
  
  constant o : t_Ordering
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  goal vc_trans_usize: cmp_log_usize x y = o -> cmp_log_usize y z = o -> ([@expl:trans ensures] cmp_log_usize x z = o)
end
module M_logic__ord__impl_OrdLogic_for_usize__antisym1 (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym1_usize: cmp_log_usize x y = Less -> ([@expl:antisym1 ensures] cmp_log_usize y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__antisym2 (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym2_usize: cmp_log_usize x y = Greater -> ([@expl:antisym2 ensures] cmp_log_usize y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__eq_cmp (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_eq_cmp_usize: [@expl:eq_cmp ensures] (x = y) = (cmp_log_usize x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_le_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_le_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_le_log_i8: [@expl:cmp_le_log ensures] Int8.le x y = (cmp_log_i8 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_lt_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_lt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_lt_log_i8: [@expl:cmp_lt_log ensures] Int8.lt x y = (cmp_log_i8 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_ge_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_ge_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_ge_log_i8: [@expl:cmp_ge_log ensures] Int8.ge x y = (cmp_log_i8 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_gt_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_gt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_gt_log_i8: [@expl:cmp_gt_log ensures] Int8.gt x y = (cmp_log_i8 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__refl (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  function refl_i8 (x: Int8.t) : ()
  
  goal vc_refl_i8: [@expl:refl ensures] cmp_log_i8 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i8__trans (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  constant z : Int8.t
  
  constant o : t_Ordering
  
  function trans_i8 (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  goal vc_trans_i8: cmp_log_i8 x y = o -> cmp_log_i8 y z = o -> ([@expl:trans ensures] cmp_log_i8 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i8__antisym1 (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function antisym1_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_antisym1_i8: cmp_log_i8 x y = Less -> ([@expl:antisym1 ensures] cmp_log_i8 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__antisym2 (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function antisym2_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_antisym2_i8: cmp_log_i8 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_i8 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__eq_cmp (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function eq_cmp_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_eq_cmp_i8: [@expl:eq_cmp ensures] (x = y) = (cmp_log_i8 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_le_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_le_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_le_log_i16: [@expl:cmp_le_log ensures] Int16.le x y = (cmp_log_i16 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_lt_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_lt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_lt_log_i16: [@expl:cmp_lt_log ensures] Int16.lt x y = (cmp_log_i16 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_ge_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_ge_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_ge_log_i16: [@expl:cmp_ge_log ensures] Int16.ge x y = (cmp_log_i16 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_gt_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_gt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_gt_log_i16: [@expl:cmp_gt_log ensures] Int16.gt x y = (cmp_log_i16 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__refl (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  function refl_i16 (x: Int16.t) : ()
  
  goal vc_refl_i16: [@expl:refl ensures] cmp_log_i16 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i16__trans (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  constant z : Int16.t
  
  constant o : t_Ordering
  
  function trans_i16 (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  goal vc_trans_i16: cmp_log_i16 x y = o -> cmp_log_i16 y z = o -> ([@expl:trans ensures] cmp_log_i16 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i16__antisym1 (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function antisym1_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_antisym1_i16: cmp_log_i16 x y = Less -> ([@expl:antisym1 ensures] cmp_log_i16 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__antisym2 (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function antisym2_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_antisym2_i16: cmp_log_i16 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_i16 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__eq_cmp (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function eq_cmp_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_eq_cmp_i16: [@expl:eq_cmp ensures] (x = y) = (cmp_log_i16 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_le_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_le_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_le_log_i32: [@expl:cmp_le_log ensures] Int32.le x y = (cmp_log_i32 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_lt_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_lt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_lt_log_i32: [@expl:cmp_lt_log ensures] Int32.lt x y = (cmp_log_i32 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_ge_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_ge_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_ge_log_i32: [@expl:cmp_ge_log ensures] Int32.ge x y = (cmp_log_i32 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_gt_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_gt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_gt_log_i32: [@expl:cmp_gt_log ensures] Int32.gt x y = (cmp_log_i32 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__refl (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  function refl_i32 (x: Int32.t) : ()
  
  goal vc_refl_i32: [@expl:refl ensures] cmp_log_i32 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i32__trans (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  constant z : Int32.t
  
  constant o : t_Ordering
  
  function trans_i32 (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  goal vc_trans_i32: cmp_log_i32 x y = o -> cmp_log_i32 y z = o -> ([@expl:trans ensures] cmp_log_i32 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i32__antisym1 (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function antisym1_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_antisym1_i32: cmp_log_i32 x y = Less -> ([@expl:antisym1 ensures] cmp_log_i32 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__antisym2 (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function antisym2_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_antisym2_i32: cmp_log_i32 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_i32 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__eq_cmp (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function eq_cmp_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_eq_cmp_i32: [@expl:eq_cmp ensures] (x = y) = (cmp_log_i32 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_le_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_le_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_le_log_i64: [@expl:cmp_le_log ensures] Int64.le x y = (cmp_log_i64 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_lt_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_lt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_lt_log_i64: [@expl:cmp_lt_log ensures] Int64.lt x y = (cmp_log_i64 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_ge_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_ge_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_ge_log_i64: [@expl:cmp_ge_log ensures] Int64.ge x y = (cmp_log_i64 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_gt_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_gt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_gt_log_i64: [@expl:cmp_gt_log ensures] Int64.gt x y = (cmp_log_i64 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__refl (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  function refl_i64 (x: Int64.t) : ()
  
  goal vc_refl_i64: [@expl:refl ensures] cmp_log_i64 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i64__trans (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  constant z : Int64.t
  
  constant o : t_Ordering
  
  function trans_i64 (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  goal vc_trans_i64: cmp_log_i64 x y = o -> cmp_log_i64 y z = o -> ([@expl:trans ensures] cmp_log_i64 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i64__antisym1 (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym1_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym1_i64: cmp_log_i64 x y = Less -> ([@expl:antisym1 ensures] cmp_log_i64 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__antisym2 (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym2_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym2_i64: cmp_log_i64 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_i64 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__eq_cmp (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function eq_cmp_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_eq_cmp_i64: [@expl:eq_cmp ensures] (x = y) = (cmp_log_i64 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_le_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_le_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_le_log_i128: [@expl:cmp_le_log ensures] Int128.le x y = (cmp_log_i128 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_lt_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_lt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_lt_log_i128: [@expl:cmp_lt_log ensures] Int128.lt x y = (cmp_log_i128 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_ge_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_ge_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_ge_log_i128: [@expl:cmp_ge_log ensures] Int128.ge x y = (cmp_log_i128 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_gt_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_gt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_gt_log_i128: [@expl:cmp_gt_log ensures] Int128.gt x y = (cmp_log_i128 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__refl (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  function refl_i128 (x: Int128.t) : ()
  
  goal vc_refl_i128: [@expl:refl ensures] cmp_log_i128 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i128__trans (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  constant z : Int128.t
  
  constant o : t_Ordering
  
  function trans_i128 (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  goal vc_trans_i128: cmp_log_i128 x y = o -> cmp_log_i128 y z = o -> ([@expl:trans ensures] cmp_log_i128 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i128__antisym1 (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function antisym1_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_antisym1_i128: cmp_log_i128 x y = Less -> ([@expl:antisym1 ensures] cmp_log_i128 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__antisym2 (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function antisym2_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_antisym2_i128: cmp_log_i128 x y = Greater -> ([@expl:antisym2 ensures] cmp_log_i128 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__eq_cmp (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function eq_cmp_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_eq_cmp_i128: [@expl:eq_cmp ensures] (x = y) = (cmp_log_i128 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_le_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_le_log_isize: [@expl:cmp_le_log ensures] Int64.le x y = (cmp_log_isize x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_lt_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_lt_log_isize: [@expl:cmp_lt_log ensures] Int64.lt x y = (cmp_log_isize x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_ge_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_ge_log_isize: [@expl:cmp_ge_log ensures] Int64.ge x y = (cmp_log_isize x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_gt_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_gt_log_isize: [@expl:cmp_gt_log ensures] Int64.gt x y = (cmp_log_isize x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__refl (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  function refl_isize (x: Int64.t) : ()
  
  goal vc_refl_isize: [@expl:refl ensures] cmp_log_isize x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_isize__trans (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  constant z : Int64.t
  
  constant o : t_Ordering
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  goal vc_trans_isize: cmp_log_isize x y = o -> cmp_log_isize y z = o -> ([@expl:trans ensures] cmp_log_isize x z = o)
end
module M_logic__ord__impl_OrdLogic_for_isize__antisym1 (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym1_isize: cmp_log_isize x y = Less -> ([@expl:antisym1 ensures] cmp_log_isize y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__antisym2 (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym2_isize: cmp_log_isize x y = Greater -> ([@expl:antisym2 ensures] cmp_log_isize y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__eq_cmp (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_eq_cmp_isize: [@expl:eq_cmp ensures] (x = y) = (cmp_log_isize x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_le_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_le_log_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_le_log_char: [@expl:cmp_le_log ensures] Char.le x y = (cmp_log_char x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_lt_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_lt_log_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_lt_log_char: [@expl:cmp_lt_log ensures] Char.lt x y = (cmp_log_char x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_ge_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_ge_log_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_ge_log_char: [@expl:cmp_ge_log ensures] Char.ge x y = (cmp_log_char x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_gt_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_gt_log_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_gt_log_char: [@expl:cmp_gt_log ensures] Char.gt x y = (cmp_log_char x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__refl (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  function refl_char (x: Char.t) : ()
  
  goal vc_refl_char: [@expl:refl ensures] cmp_log_char x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_char__trans (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  constant z : Char.t
  
  constant o : t_Ordering
  
  function trans_char (x: Char.t) (y: Char.t) (z: Char.t) (o: t_Ordering) : ()
  
  goal vc_trans_char: cmp_log_char x y = o -> cmp_log_char y z = o -> ([@expl:trans ensures] cmp_log_char x z = o)
end
module M_logic__ord__impl_OrdLogic_for_char__antisym1 (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function antisym1_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_antisym1_char: cmp_log_char x y = Less -> ([@expl:antisym1 ensures] cmp_log_char y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__antisym2 (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function antisym2_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_antisym2_char: cmp_log_char x y = Greater -> ([@expl:antisym2 ensures] cmp_log_char y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_char__eq_cmp (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function eq_cmp_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_eq_cmp_char: [@expl:eq_cmp ensures] (x = y) = (cmp_log_char x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_le_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_le_log_bool (x: bool) (y: bool) : ()
  
  goal vc_cmp_le_log_bool: [@expl:cmp_le_log ensures] Bool.le x y = (cmp_log_bool x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_lt_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_lt_log_bool (x: bool) (y: bool) : ()
  
  goal vc_cmp_lt_log_bool: [@expl:cmp_lt_log ensures] Bool.lt x y = (cmp_log_bool x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_ge_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_ge_log_bool (x: bool) (y: bool) : ()
  
  goal vc_cmp_ge_log_bool: [@expl:cmp_ge_log ensures] Bool.ge x y = (cmp_log_bool x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_gt_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_gt_log_bool (x: bool) (y: bool) : ()
  
  goal vc_cmp_gt_log_bool: [@expl:cmp_gt_log ensures] Bool.gt x y = (cmp_log_bool x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__refl (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  function refl_bool (x: bool) : ()
  
  goal vc_refl_bool: [@expl:refl ensures] cmp_log_bool x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_bool__trans (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  constant z : bool
  
  constant o : t_Ordering
  
  function trans_bool (x: bool) (y: bool) (z: bool) (o: t_Ordering) : ()
  
  goal vc_trans_bool: cmp_log_bool x y = o -> cmp_log_bool y z = o -> ([@expl:trans ensures] cmp_log_bool x z = o)
end
module M_logic__ord__impl_OrdLogic_for_bool__antisym1 (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function antisym1_bool (x: bool) (y: bool) : ()
  
  goal vc_antisym1_bool: cmp_log_bool x y = Less -> ([@expl:antisym1 ensures] cmp_log_bool y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__antisym2 (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function antisym2_bool (x: bool) (y: bool) : ()
  
  goal vc_antisym2_bool: cmp_log_bool x y = Greater -> ([@expl:antisym2 ensures] cmp_log_bool y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__eq_cmp (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function eq_cmp_bool (x: bool) (y: bool) : ()
  
  goal vc_eq_cmp_bool: [@expl:eq_cmp ensures] (x = y) = (cmp_log_bool x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_le_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate le_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ le_log_B self.f1 o.f1 \/ lt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function cmp_le_log_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_cmp_le_log_tup2_A_B: [@expl:cmp_le_log ensures] le_log_tup2_A_B x y = (cmp_log_tup2_A_B x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_lt_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate lt_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ lt_log_B self.f1 o.f1 \/ lt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function cmp_lt_log_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_cmp_lt_log_tup2_A_B: [@expl:cmp_lt_log ensures] lt_log_tup2_A_B x y = (cmp_log_tup2_A_B x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_ge_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate ge_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ ge_log_B self.f1 o.f1 \/ gt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function cmp_ge_log_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_cmp_ge_log_tup2_A_B: [@expl:cmp_ge_log ensures] ge_log_tup2_A_B x y = (cmp_log_tup2_A_B x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_gt_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate gt_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ gt_log_B self.f1 o.f1 \/ gt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function cmp_gt_log_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_cmp_gt_log_tup2_A_B: [@expl:cmp_gt_log ensures] gt_log_tup2_A_B x y = (cmp_log_tup2_A_B x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__refl (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  function refl_tup2_A_B (x: tup2_A_B) : ()
  
  goal vc_refl_tup2_A_B: [@expl:refl ensures] cmp_log_tup2_A_B x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__trans (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  constant z : tup2_A_B
  
  constant o : t_Ordering
  
  function trans_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) (z: tup2_A_B) (o: t_Ordering) : ()
  
  goal vc_trans_tup2_A_B: cmp_log_tup2_A_B x y = o
    -> cmp_log_tup2_A_B y z = o -> ([@expl:trans ensures] cmp_log_tup2_A_B x z = o)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__antisym1 (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function antisym1_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_antisym1_tup2_A_B: cmp_log_tup2_A_B x y = Less -> ([@expl:antisym1 ensures] cmp_log_tup2_A_B y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__antisym2 (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function antisym2_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_antisym2_tup2_A_B: cmp_log_tup2_A_B x y = Greater -> ([@expl:antisym2 ensures] cmp_log_tup2_A_B y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__eq_cmp (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function eq_cmp_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_eq_cmp_tup2_A_B: [@expl:eq_cmp ensures] (x = y) = (cmp_log_tup2_A_B x y = Equal)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__factor (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag_T
  
  constant factor : t_Ag_T
  
  function factor_Ag_T (self: t_Ag_T) (factor: t_Ag_T) : t_Option_Ag_T
  
  goal vc_factor_Ag_T: [@expl:factor ensures] match op_Ag_T self factor with
      | Some c -> op_Ag_T factor c = Some self
      | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
      end
end
module M_logic__ra__agree__impl_RA_for_Ag_T__commutative (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Ag_T
  
  constant b : t_Ag_T
  
  function commutative_Ag_T (a: t_Ag_T) (b: t_Ag_T) : ()
  
  goal vc_commutative_Ag_T: [@expl:commutative ensures] op_Ag_T a b = op_Ag_T b a
end
module M_logic__ra__agree__impl_RA_for_Ag_T__associative (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function and_then_Option_Ag_T (self: t_Option_Ag_T) (f: Map.map t_Ag_T t_Option_Ag_T) : t_Option_Ag_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Ag_T
  
  constant b : t_Ag_T
  
  constant c : t_Ag_T
  
  function associative_Ag_T (a: t_Ag_T) (b: t_Ag_T) (c: t_Ag_T) : ()
  
  goal vc_associative_Ag_T:
    [@expl:associative ensures] and_then_Option_Ag_T (op_Ag_T a b) (fun (ab: t_Ag_T) -> op_Ag_T ab c)
    = and_then_Option_Ag_T (op_Ag_T b c) (fun (bc: t_Ag_T) -> op_Ag_T a bc)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__core (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag_T
  
  function core_Ag_T (self: t_Ag_T) : t_Option_Ag_T
  
  goal vc_core_Ag_T: [@expl:core ensures] match Some self with
      | Some c -> op_Ag_T c c = Some c /\ op_Ag_T c self = Some self
      | None -> true
      end
end
module M_logic__ra__agree__impl_RA_for_Ag_T__core_is_maximal_idemp (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  function core_Ag_T (self: t_Ag_T) : t_Option_Ag_T = Some self
  
  axiom core_Ag_T_spec: forall self: t_Ag_T. match core_Ag_T self with
        | Some c -> op_Ag_T c c = Some c /\ op_Ag_T c self = Some self
        | None -> true
        end
  
  function factor_Ag_T (self: t_Ag_T) (factor: t_Ag_T) : t_Option_Ag_T = op_Ag_T self factor
  
  axiom factor_Ag_T_spec: forall self: t_Ag_T, factor: t_Ag_T. match factor_Ag_T self factor with
        | Some c -> op_Ag_T factor c = Some self
        | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
        end
  
  predicate incl_Ag_T (self: t_Ag_T) (other: t_Ag_T) = factor_Ag_T other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag_T
  
  constant i : t_Ag_T
  
  function core_is_maximal_idemp_Ag_T (self: t_Ag_T) (i: t_Ag_T) : ()
  
  goal vc_core_is_maximal_idemp_Ag_T: op_Ag_T i i = Some i
    -> op_Ag_T i self = Some self
    -> ([@expl:core_is_maximal_idemp ensures] match core_Ag_T self with
      | Some c -> incl_Ag_T i c
      | None -> false
      end)
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_mono (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  constant f1 : t_T
  
  constant f2 : t_T
  
  function rel_mono_AuthViewRel_T (a: t_Option_T) (f1: t_T) (f2: t_T) : ()
  
  goal vc_rel_mono_AuthViewRel_T: rel_AuthViewRel_T a f1
    -> incl_T f2 f1 -> ([@expl:rel_mono ensures] rel_AuthViewRel_T a f2)
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_none (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  constant f : t_T
  
  function rel_none_AuthViewRel_T (a: t_Option_T) (f: t_T) : ()
  
  goal vc_rel_none_AuthViewRel_T: [@expl:rel_none ensures] rel_AuthViewRel_T (None) f
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_unit (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. op_T (core_total_T self) (core_total_T self) = Some (core_total_T self)
  
  axiom core_total_T_spec'0: forall self: t_T. op_T (core_total_T self) self = Some self
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some x
  
  constant unit_core_T: () = ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T: () = let _ = unit_T in ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  function rel_unit_AuthViewRel_T (a: t_Option_T) : ()
  
  goal vc_rel_unit_AuthViewRel_T: [@expl:rel_unit ensures] rel_AuthViewRel_T a unit_T
end
module M_logic__ra__auth__impl_Update_for_AuthUpdate_U__update (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate_U = { f0: t_U }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. op_R (core_total_R self) (core_total_R self) = Some (core_total_R self)
  
  axiom core_total_R_spec'0: forall self: t_R. op_R (core_total_R self) self = Some self
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R: () = ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R: () = let _ = unit_R in ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : () = ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : () = ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  predicate premise_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some auth -> premise_U self.f0 auth (frag_AuthViewRel_R from)
      | None -> false
      end
  
  type tup2_R_R = { f0'0: t_R; f1'0: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  function and_then_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_R
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_R_Option_R = { f0'1: t_Option_R; f1'1: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'1 = self;
                                                                                            f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function associative_Option_R (a: t_Option_R) (b: t_Option_R) (c: t_Option_R) : ()
  
  axiom associative_Option_R_spec:
    forall a: t_Option_R, b: t_Option_R, c: t_Option_R. and_then_Option_Option_R (op_Option_R a b) (fun (ab: t_Option_R) -> op_Option_R ab c)
      = and_then_Option_Option_R (op_Option_R b c) (fun (bc: t_Option_R) -> op_Option_R a bc)
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option_R. premise_U self from_auth from_frag
      -> op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
      -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_U self from_auth from_frag in op_Option_R (Some to_frag) frame
      = Some'0 (Some to_auth))
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_AuthUpdate_U
  
  constant from : t_View_AuthViewRel_R
  
  constant _3 : ()
  
  function update_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (_3: ()) : t_View_AuthViewRel_R
  
  goal vc_update_AuthUpdate_U: premise_AuthUpdate_U self from
    -> ([@expl:unwrap_logic requires] auth_AuthViewRel_R from <> None)
    /\ (let from_auth = unwrap_Option_R (auth_AuthViewRel_R from) in rel_AuthViewRel_R (auth_AuthViewRel_R from) (frag_AuthViewRel_R from)
    -> (let {f0'0 = auth; f1'0 = frag} = update_U self.f0 from_auth (frag_AuthViewRel_R from) in rel_AuthViewRel_R (auth_AuthViewRel_R from) (frag_AuthViewRel_R from)
    -> rel_AuthViewRel_R (auth_AuthViewRel_R from) (frag_AuthViewRel_R from)
    -> match factor_R from_auth (frag_AuthViewRel_R from) with
        | Some c -> op_R (frag_AuthViewRel_R from) c = Some from_auth
        | None -> forall c: t_R. op_R (frag_AuthViewRel_R from) c <> Some from_auth
        end
    -> (([@expl:frame_preserving requires #0] premise_U self.f0 from_auth (frag_AuthViewRel_R from))
      && ([@expl:frame_preserving requires #1] op_Option_R (Some (frag_AuthViewRel_R from)) (factor_R from_auth (frag_AuthViewRel_R from))
      = Some'0 (Some from_auth)))
    /\ ((let {f0'0 = to_auth; f1'0 = to_frag} = update_U self.f0 from_auth (frag_AuthViewRel_R from) in op_Option_R (Some to_frag) (factor_R from_auth (frag_AuthViewRel_R from))
      = Some'0 (Some to_auth))
    -> (let _ = frame_preserving_U self.f0 from_auth (frag_AuthViewRel_R from) (factor_R from_auth (frag_AuthViewRel_R from)) in ([@expl:new requires] rel_AuthViewRel_R (Some auth) frag)
    /\ (auth_AuthViewRel_R (new_AuthViewRel_R (Some auth) frag) = Some auth
      && frag_AuthViewRel_R (new_AuthViewRel_R (Some auth) frag) = frag
    -> ([@expl:update ensures] let {f0'0 = auth'0; f1'0 = frag'0} = update_U self.f0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from) in rel_AuthViewRel_R (Some auth'0) frag'0))))))
end
module M_logic__ra__auth__impl_Update_for_AuthUpdate_U__frame_preserving (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate_U = { f0: t_U }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. op_R (core_total_R self) (core_total_R self) = Some (core_total_R self)
  
  axiom core_total_R_spec'0: forall self: t_R. op_R (core_total_R self) self = Some self
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R: () = ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R: () = let _ = unit_R in ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : () = ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : () = ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  predicate premise_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some auth -> premise_U self.f0 auth (frag_AuthViewRel_R from)
      | None -> false
      end
  
  type t_Option_View_AuthViewRel_R = None'0 | Some'0 t_View_AuthViewRel_R
  
  function and_then_Option_View_AuthViewRel_R (self: t_Option_View_AuthViewRel_R) (f: Map.map t_View_AuthViewRel_R t_Option_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None; f1'0 = a} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | {f0'0 = a; f1'0 = None} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | _ -> None'0
        end
      | None -> None'0
      end
  
  function associative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) : ()
  
  axiom associative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R. and_then_Option_View_AuthViewRel_R (op_View_AuthViewRel_R a b) (fun (ab: t_View_AuthViewRel_R) -> op_View_AuthViewRel_R ab c)
      = and_then_Option_View_AuthViewRel_R (op_View_AuthViewRel_R b c) (fun (bc: t_View_AuthViewRel_R) -> op_View_AuthViewRel_R a bc)
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  type tup2_R_R = { f0'1: t_R; f1'1: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  type t_Option_Option_R = None'1 | Some'1 t_Option_R
  
  function and_then_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_R
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'1 other
      | {f1'0 = None} -> Some'1 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function associative_Option_R (a: t_Option_R) (b: t_Option_R) (c: t_Option_R) : ()
  
  axiom associative_Option_R_spec:
    forall a: t_Option_R, b: t_Option_R, c: t_Option_R. and_then_Option_Option_R (op_Option_R a b) (fun (ab: t_Option_R) -> op_Option_R ab c)
      = and_then_Option_Option_R (op_Option_R b c) (fun (bc: t_Option_R) -> op_Option_R a bc)
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option_R. premise_U self from_auth from_frag
      -> op_Option_R (Some from_frag) frame = Some'1 (Some from_auth)
      -> (let {f0'1 = to_auth; f1'1 = to_frag} = update_U self from_auth from_frag in op_Option_R (Some to_frag) frame
      = Some'1 (Some to_auth))
  
  function update_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (_3: ()) : t_View_AuthViewRel_R =
    let from_auth = unwrap_Option_R (auth_AuthViewRel_R from) in let {f0'1 = auth; f1'1 = frag} = update_U self.f0 from_auth (frag_AuthViewRel_R from) in let _ = frame_preserving_U self.f0 from_auth (frag_AuthViewRel_R from) (factor_R from_auth (frag_AuthViewRel_R from)) in new_AuthViewRel_R (Some auth) frag
  
  axiom update_AuthUpdate_U_spec:
    forall self: t_AuthUpdate_U, from: t_View_AuthViewRel_R, _3: (). premise_AuthUpdate_U self from
      -> (let {f0'1 = auth; f1'1 = frag} = update_U self.f0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from) in rel_AuthViewRel_R (Some auth) frag)
  
  predicate index_Mapping_View_AuthViewRel_R_bool [@inline:trivial] (self: Map.map t_View_AuthViewRel_R bool) (a: t_View_AuthViewRel_R) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_View_AuthViewRel_R_bool
  
  function such_that_View_AuthViewRel_R (p: Map.map t_View_AuthViewRel_R bool) : t_View_AuthViewRel_R
  
  axiom such_that_View_AuthViewRel_R_spec:
    forall p: Map.map t_View_AuthViewRel_R bool. (exists x: t_View_AuthViewRel_R. index_Mapping_View_AuthViewRel_R_bool p x)
      -> index_Mapping_View_AuthViewRel_R_bool p (such_that_View_AuthViewRel_R p)
  
  function unwrap_Option_View_AuthViewRel_R (self: t_Option_View_AuthViewRel_R) : t_View_AuthViewRel_R = match self with
      | Some'0 x -> x
      | None'0 -> such_that_View_AuthViewRel_R (fun (__0: t_View_AuthViewRel_R) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_AuthUpdate_U
  
  constant from : t_View_AuthViewRel_R
  
  constant frame : t_View_AuthViewRel_R
  
  function frame_preserving_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (frame: t_View_AuthViewRel_R) : ()
  
  goal vc_frame_preserving_AuthUpdate_U: premise_AuthUpdate_U self from
    -> op_View_AuthViewRel_R from frame <> None'0
    -> ([@expl:unwrap_logic requires] auth_AuthViewRel_R from <> None)
    /\ (let auth = unwrap_Option_R (auth_AuthViewRel_R from) in ([@expl:unwrap_logic requires] op_View_AuthViewRel_R from frame
      <> None'0)
    /\ (rel_AuthViewRel_R (auth_AuthViewRel_R (unwrap_Option_View_AuthViewRel_R (op_View_AuthViewRel_R from frame))) (frag_AuthViewRel_R (unwrap_Option_View_AuthViewRel_R (op_View_AuthViewRel_R from frame)))
    -> (let x = frag_AuthViewRel_R (unwrap_Option_View_AuthViewRel_R (op_View_AuthViewRel_R from frame)) in match factor_R auth x with
        | Some c -> op_R x c = Some auth
        | None -> forall c: t_R. op_R x c <> Some auth
        end
    -> ([@expl:unwrap_logic requires] factor_R auth x <> None)
    /\ (let y = unwrap_Option_R (factor_R auth x) in rel_AuthViewRel_R (auth_AuthViewRel_R frame) (frag_AuthViewRel_R frame)
    -> ([@expl:unwrap_logic requires] op_R (frag_AuthViewRel_R frame) y <> None)
    /\ (let f = unwrap_Option_R (op_R (frag_AuthViewRel_R frame) y) in rel_AuthViewRel_R (auth_AuthViewRel_R from) (frag_AuthViewRel_R from)
    -> (([@expl:frame_preserving requires #0] premise_U self.f0 auth (frag_AuthViewRel_R from))
      && ([@expl:frame_preserving requires #1] op_Option_R (Some (frag_AuthViewRel_R from)) (Some f)
      = Some'1 (Some auth)))
    /\ ((let {f0'1 = to_auth; f1'1 = to_frag} = update_U self.f0 auth (frag_AuthViewRel_R from) in op_Option_R (Some to_frag) (Some f)
      = Some'1 (Some to_auth))
    -> (let _ = frame_preserving_U self.f0 auth (frag_AuthViewRel_R from) (Some f) in [@expl:frame_preserving ensures] op_View_AuthViewRel_R (update_AuthUpdate_U self from ()) frame
    <> None'0)))))))
end
module M_logic__ra__excl__impl_RA_for_Excl_T__factor (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl_T
  
  constant factor : t_Excl_T
  
  function factor_Excl_T (self: t_Excl_T) (factor: t_Excl_T) : t_Option_Excl_T
  
  goal vc_factor_Excl_T: [@expl:factor ensures] match None with
      | Some c -> op_Excl_T factor c = Some self
      | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
      end
end
module M_logic__ra__excl__impl_RA_for_Excl_T__commutative (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Excl_T
  
  constant b : t_Excl_T
  
  function commutative_Excl_T (a: t_Excl_T) (b: t_Excl_T) : ()
  
  goal vc_commutative_Excl_T: [@expl:commutative ensures] op_Excl_T a b = op_Excl_T b a
end
module M_logic__ra__excl__impl_RA_for_Excl_T__associative (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function and_then_Option_Excl_T (self: t_Option_Excl_T) (f: Map.map t_Excl_T t_Option_Excl_T) : t_Option_Excl_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Excl_T
  
  constant b : t_Excl_T
  
  constant c : t_Excl_T
  
  function associative_Excl_T (a: t_Excl_T) (b: t_Excl_T) (c: t_Excl_T) : ()
  
  goal vc_associative_Excl_T:
    [@expl:associative ensures] and_then_Option_Excl_T (op_Excl_T a b) (fun (ab: t_Excl_T) -> op_Excl_T ab c)
    = and_then_Option_Excl_T (op_Excl_T b c) (fun (bc: t_Excl_T) -> op_Excl_T a bc)
end
module M_logic__ra__excl__impl_RA_for_Excl_T__core (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl_T
  
  function core_Excl_T (self: t_Excl_T) : t_Option_Excl_T
  
  goal vc_core_Excl_T: [@expl:core ensures] match None with
      | Some c -> op_Excl_T c c = Some c /\ op_Excl_T c self = Some self
      | None -> true
      end
end
module M_logic__ra__excl__impl_RA_for_Excl_T__core_is_maximal_idemp (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  function core_Excl_T (self: t_Excl_T) : t_Option_Excl_T = None
  
  axiom core_Excl_T_spec: forall self: t_Excl_T. match core_Excl_T self with
        | Some c -> op_Excl_T c c = Some c /\ op_Excl_T c self = Some self
        | None -> true
        end
  
  function factor_Excl_T (self: t_Excl_T) (factor: t_Excl_T) : t_Option_Excl_T = None
  
  axiom factor_Excl_T_spec: forall self: t_Excl_T, factor: t_Excl_T. match factor_Excl_T self factor with
        | Some c -> op_Excl_T factor c = Some self
        | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
        end
  
  predicate incl_Excl_T (self: t_Excl_T) (other: t_Excl_T) = factor_Excl_T other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl_T
  
  constant i : t_Excl_T
  
  function core_is_maximal_idemp_Excl_T (self: t_Excl_T) (i: t_Excl_T) : ()
  
  goal vc_core_is_maximal_idemp_Excl_T: op_Excl_T i i = Some i
    -> op_Excl_T i self = Some self
    -> ([@expl:core_is_maximal_idemp ensures] match core_Excl_T self with
      | Some c -> incl_Excl_T i c
      | None -> false
      end)
end
module M_logic__ra__excl__impl_Update_for_ExclUpdate_T__update (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_ExclUpdate_T = { f0: t_T }
  
  type t_Excl_T = { f0'0: t_T }
  
  predicate premise_ExclUpdate_T (self: t_ExclUpdate_T) (_2: t_Excl_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ExclUpdate_T
  
  constant from : t_Excl_T
  
  constant _3 : ()
  
  function update_ExclUpdate_T (self: t_ExclUpdate_T) (from: t_Excl_T) (_3: ()) : t_Excl_T
  
  goal vc_update_ExclUpdate_T: true
end
module M_logic__ra__excl__impl_Update_for_ExclUpdate_T__frame_preserving (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_ExclUpdate_T = { f0: t_T }
  
  type t_Excl_T = { f0'0: t_T }
  
  predicate premise_ExclUpdate_T (self: t_ExclUpdate_T) (_2: t_Excl_T) = true
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function and_then_Option_Excl_T (self: t_Option_Excl_T) (f: Map.map t_Excl_T t_Option_Excl_T) : t_Option_Excl_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  function associative_Excl_T (a: t_Excl_T) (b: t_Excl_T) (c: t_Excl_T) : () = ()
  
  axiom associative_Excl_T_spec:
    forall a: t_Excl_T, b: t_Excl_T, c: t_Excl_T. and_then_Option_Excl_T (op_Excl_T a b) (fun (ab: t_Excl_T) -> op_Excl_T ab c)
      = and_then_Option_Excl_T (op_Excl_T b c) (fun (bc: t_Excl_T) -> op_Excl_T a bc)
  
  function commutative_Excl_T (a: t_Excl_T) (b: t_Excl_T) : () = ()
  
  axiom commutative_Excl_T_spec: forall a: t_Excl_T, b: t_Excl_T. op_Excl_T a b = op_Excl_T b a
  
  function update_ExclUpdate_T (self: t_ExclUpdate_T) (from: t_Excl_T) (_3: ()) : t_Excl_T = { f0'0 = self.f0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ExclUpdate_T
  
  constant from : t_Excl_T
  
  constant frame : t_Excl_T
  
  function frame_preserving_ExclUpdate_T (self: t_ExclUpdate_T) (from: t_Excl_T) (frame: t_Excl_T) : ()
  
  goal vc_frame_preserving_ExclUpdate_T: premise_ExclUpdate_T self from
    -> op_Excl_T from frame <> None
    -> ([@expl:frame_preserving ensures] op_Excl_T (update_ExclUpdate_T self from ()) frame <> None)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__factor (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function factor_Option_V (self: t_Option_V) (factor: t_Option_V) : t_Option_Option_V = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None'0} -> Some'1 x
      | {f0 = None'0} -> None'1
      | {f0 = Some'0 x; f1 = Some'0 y} -> match factor_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_V_spec: forall self: t_Option_V, factor: t_Option_V. match factor_Option_V self factor with
        | Some'1 c -> op_Option_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_V. op_Option_V factor c <> Some'1 self
        end
  
  predicate incl_Option_V (self: t_Option_V) (other: t_Option_V) = factor_Option_V other self <> None'1
  
  function incl_transitive_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : () = ()
  
  axiom incl_transitive_Option_V_spec: forall a: t_Option_V, b: t_Option_V, c: t_Option_V. incl_Option_V a b
      -> incl_Option_V b c -> incl_Option_V a c
  
  function incl_op_Option_V (self: t_Option_V) (other: t_Option_V) (comb: t_Option_V) : () = ()
  
  axiom incl_op_Option_V_spec: forall self: t_Option_V, other: t_Option_V, comb: t_Option_V. op_Option_V self other
        = Some'1 comb -> incl_Option_V self comb
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant factor : t_FMap_K_V
  
  function factor_FMap_K_V (self: t_FMap_K_V) (factor: t_FMap_K_V) : t_Option_FMap_K_V
  
  goal vc_factor_FMap_K_V: if forall k: t_K. incl_Option_V (get_K factor k) (get_K self k) then
      (forall __0: tup2_K_V. let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k) with
              | Some'1 c -> op_Option_V (get_K factor k) c = Some'1 (Some'0 vo)
              | None'1 -> forall c: t_Option_V. op_Option_V (get_K factor k) c <> Some'1 (Some'0 vo)
              end
          -> match factor_Option_V (Some'0 vo) (get_K factor k) with
            | Some'1 r -> true
            | None'1 -> true
            end)
      /\ ((forall k: t_K [get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k'0) with
            | Some'1 r -> r
            | None'1 -> None'0
            end)) k]. get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k'0) with
              | Some'1 r -> r
              | None'1 -> None'0
              end)) k
          = match get_K self k with
            | None'0 -> None'0
            | Some'0 v -> index_Mapping_tup2_K_V_Option_V (fun (__0: tup2_K_V) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k'0) with
              | Some'1 r -> r
              | None'1 -> None'0
              end) { f0'1 = k; f1'1 = v }
            end)
      -> (let res = filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in match op_FMap_K_V factor res with
        | None -> false
        && ([@expl:factor ensures] match Some res with
          | Some c -> op_FMap_K_V factor c = Some self
          | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
          end)
        | Some o -> ext_eq_K o self = (o = self)
        -> ext_eq_K o self
        && ([@expl:factor ensures] match Some res with
          | Some c -> op_FMap_K_V factor c = Some self
          | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
          end)
        end))
    else
      [@expl:factor ensures] match None with
        | Some c -> op_FMap_K_V factor c = Some self
        | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
        end

end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__commutative (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'1: t_Option_FMap_K_V; f1'1: t_Option_FMap_K_V }
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMap_K_V
  
  constant b : t_FMap_K_V
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : ()
  
  goal vc_commutative_FMap_K_V: match { f0'1 = op_FMap_K_V a b; f1'1 = op_FMap_K_V b a } with
      | {f0'1 = Some ab; f1'1 = Some ba} -> ext_eq_K ab ba = (ab = ba)
      -> ext_eq_K ab ba && ([@expl:commutative ensures] op_FMap_K_V a b = op_FMap_K_V b a)
      | {f0'1 = None; f1'1 = None} -> [@expl:commutative ensures] op_FMap_K_V a b = op_FMap_K_V b a
      | _ -> false && ([@expl:commutative ensures] op_FMap_K_V a b = op_FMap_K_V b a)
      end
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__associative (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'1: t_Option_FMap_K_V; f1'1: t_Option_FMap_K_V }
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMap_K_V
  
  constant b : t_FMap_K_V
  
  constant c : t_FMap_K_V
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : ()
  
  goal vc_associative_FMap_K_V: match { f0'1 = op_FMap_K_V a b; f1'1 = op_FMap_K_V b c } with
      | {f0'1 = Some ab; f1'1 = Some bc} -> match { f0'1 = op_FMap_K_V ab c; f1'1 = op_FMap_K_V a bc } with
        | {f0'1 = Some x; f1'1 = Some y} -> ext_eq_K x y = (x = y)
        -> ext_eq_K x y
        && ([@expl:associative ensures] and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab'0: t_FMap_K_V) -> op_FMap_K_V ab'0 c)
        = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc'0: t_FMap_K_V) -> op_FMap_K_V a bc'0))
        | _ -> [@expl:associative ensures] and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab'0: t_FMap_K_V) -> op_FMap_K_V ab'0 c)
        = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc'0: t_FMap_K_V) -> op_FMap_K_V a bc'0)
        end
      | _ -> [@expl:associative ensures] and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
      end
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__core (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  axiom core_V_spec: forall self: t_V. match core_V self with
        | Some'0 c -> op_V c c = Some'0 c /\ op_V c self = Some'0 self
        | None'0 -> true
        end
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V =
    let r = filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v) in r
  
  axiom core_total_FMap_K_V_spec:
    forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
      = Some (core_total_FMap_K_V self)
  
  axiom core_total_FMap_K_V_spec'0: forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) self = Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V
  
  goal vc_core_FMap_K_V: op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
        = Some (core_total_FMap_K_V self)
      && op_FMap_K_V (core_total_FMap_K_V self) self = Some self
    -> ([@expl:core ensures] match Some (core_total_FMap_K_V self) with
      | Some c -> op_FMap_K_V c c = Some c /\ op_FMap_K_V c self = Some self
      | None -> true
      end)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__core_is_maximal_idemp (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  axiom core_V_spec: forall self: t_V. match core_V self with
        | Some'0 c -> op_V c c = Some'0 c /\ op_V c self = Some'0 self
        | None'0 -> true
        end
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V =
    let r = filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v) in r
  
  axiom core_total_FMap_K_V_spec:
    forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
      = Some (core_total_FMap_K_V self)
  
  axiom core_total_FMap_K_V_spec'0: forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) self = Some self
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V = Some (core_total_FMap_K_V self)
  
  axiom core_FMap_K_V_spec: forall self: t_FMap_K_V. match core_FMap_K_V self with
        | Some c -> op_FMap_K_V c c = Some c /\ op_FMap_K_V c self = Some self
        | None -> true
        end
  
  function factor_Option_V (self: t_Option_V) (factor: t_Option_V) : t_Option_Option_V = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None'0} -> Some'1 x
      | {f0 = None'0} -> None'1
      | {f0 = Some'0 x; f1 = Some'0 y} -> match factor_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_V_spec: forall self: t_Option_V, factor: t_Option_V. match factor_Option_V self factor with
        | Some'1 c -> op_Option_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_V. op_Option_V factor c <> Some'1 self
        end
  
  predicate incl_Option_V (self: t_Option_V) (other: t_Option_V) = factor_Option_V other self <> None'1
  
  function incl_transitive_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : () = ()
  
  axiom incl_transitive_Option_V_spec: forall a: t_Option_V, b: t_Option_V, c: t_Option_V. incl_Option_V a b
      -> incl_Option_V b c -> incl_Option_V a c
  
  function incl_op_Option_V (self: t_Option_V) (other: t_Option_V) (comb: t_Option_V) : () = ()
  
  axiom incl_op_Option_V_spec: forall self: t_Option_V, other: t_Option_V, comb: t_Option_V. op_Option_V self other
        = Some'1 comb -> incl_Option_V self comb
  
  function factor_FMap_K_V (self: t_FMap_K_V) (factor: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. incl_Option_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in Some res
    else
      None
  
  
  axiom factor_FMap_K_V_spec: forall self: t_FMap_K_V, factor: t_FMap_K_V. match factor_FMap_K_V self factor with
        | Some c -> op_FMap_K_V factor c = Some self
        | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
        end
  
  predicate incl_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) = factor_FMap_K_V other self <> None
  
  function core_is_maximal_idemp_V (self: t_V) (i: t_V) : ()
  
  axiom core_is_maximal_idemp_V_spec: forall self: t_V, i: t_V. op_V i i = Some'0 i
      -> op_V i self = Some'0 self
      -> match core_V self with
        | Some'0 c -> incl_V i c
        | None'0 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant i : t_FMap_K_V
  
  function core_is_maximal_idemp_FMap_K_V (self: t_FMap_K_V) (i: t_FMap_K_V) : ()
  
  goal vc_core_is_maximal_idemp_FMap_K_V: op_FMap_K_V i i = Some i
    -> op_FMap_K_V i self = Some self
    -> ([@expl:core_is_maximal_idemp ensures] match core_FMap_K_V self with
      | Some c -> incl_FMap_K_V i c
      | None -> false
      end)
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__unit (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0: t_Option_FMap_K_V; f1: t_Option_FMap_K_V }
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'1: t_V; f1'1: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None'0; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None'0} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'1 = x; f1'1 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : () = match { f0 = op_FMap_K_V a b;
                                                                                               f1 = op_FMap_K_V b c } with
      | {f0 = Some ab; f1 = Some bc} -> match { f0 = op_FMap_K_V ab c; f1 = op_FMap_K_V a bc } with
        | {f0 = Some x; f1 = Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_FMap_K_V_spec:
    forall a: t_FMap_K_V, b: t_FMap_K_V, c: t_FMap_K_V. and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_V empty_K = Const.const (None'0)
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_FMap_K_V : t_FMap_K_V
  
  goal vc_unit_FMap_K_V: (forall x: t_FMap_K_V. len_K empty_K = 0 && view_FMap_K_V empty_K = Const.const (None'0)
        -> ([@expl:unwrap_logic requires] op_FMap_K_V x empty_K <> None))
    /\ (forall x: t_FMap_K_V. ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V x empty_K)) x)
    && (len_K empty_K = 0 && view_FMap_K_V empty_K = Const.const (None'0)
    -> (let result = empty_K in [@expl:unit ensures] forall x: t_FMap_K_V [op_FMap_K_V x result]. op_FMap_K_V x result
      = Some x))
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__core_total (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0: t_Option_FMap_K_V; f1: t_Option_FMap_K_V }
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'1: t_V; f1'1: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None'0; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None'0} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'1 = x; f1'1 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : () = match { f0 = op_FMap_K_V a b;
                                                                                               f1 = op_FMap_K_V b c } with
      | {f0 = Some ab; f1 = Some bc} -> match { f0 = op_FMap_K_V ab c; f1 = op_FMap_K_V a bc } with
        | {f0 = Some x; f1 = Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_FMap_K_V_spec:
    forall a: t_FMap_K_V, b: t_FMap_K_V, c: t_FMap_K_V. and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  type tup2_K_V = { f0'2: t_K; f1'2: t_V }
  
  function core_V (self: t_V) : t_Option_V
  
  axiom core_V_spec: forall self: t_V. match core_V self with
        | Some'0 c -> op_V c c = Some'0 c /\ op_V c self = Some'0 self
        | None'0 -> true
        end
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'2 = k; f1'2 = v }
          end
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V
  
  goal vc_core_total_FMap_K_V: (forall __0: tup2_K_V. let {f1'2 = v} = __0 in true)
    /\ ((forall k: t_K [get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'2 = v} = __0 in core_V v)) k]. get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'2 = v} = __0 in core_V v)) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V (fun (__0: tup2_K_V) -> let {f1'2 = v'0} = __0 in core_V v'0) { f0'2 = k;
                                                                                                                        f1'2 = v }
          end)
    -> (let r = filter_map_K self (fun (__0: tup2_K_V) -> let {f1'2 = v} = __0 in core_V v) in ([@expl:unwrap_logic requires] op_FMap_K_V r r
      <> None)
    /\ (ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V r r)) r = (unwrap_Option_FMap_K_V (op_FMap_K_V r r) = r)
    -> ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V r r)) r
    && ([@expl:unwrap_logic requires] op_FMap_K_V r self <> None)
    /\ (ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V r self)) self
      = (unwrap_Option_FMap_K_V (op_FMap_K_V r self) = self)
    -> ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V r self)) self
    && (let result = r in ([@expl:core_total ensures #0] op_FMap_K_V result result = Some result)
    && ([@expl:core_total ensures #1] op_FMap_K_V result self = Some self))))))
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__core_is_total (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'1: t_Option_FMap_K_V; f1'1: t_Option_FMap_K_V }
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : () = match { f0'1 = op_FMap_K_V a b;
                                                                                               f1'1 = op_FMap_K_V b c } with
      | {f0'1 = Some ab; f1'1 = Some bc} -> match { f0'1 = op_FMap_K_V ab c; f1'1 = op_FMap_K_V a bc } with
        | {f0'1 = Some x; f1'1 = Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_FMap_K_V_spec:
    forall a: t_FMap_K_V, b: t_FMap_K_V, c: t_FMap_K_V. and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  type tup2_K_V = { f0'2: t_K; f1'2: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'2 = k; f1'2 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  axiom core_V_spec: forall self: t_V. match core_V self with
        | Some'0 c -> op_V c c = Some'0 c /\ op_V c self = Some'0 self
        | None'0 -> true
        end
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V =
    let r = filter_map_K self (fun (__0: tup2_K_V) -> let {f1'2 = v} = __0 in core_V v) in r
  
  axiom core_total_FMap_K_V_spec:
    forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
      = Some (core_total_FMap_K_V self)
  
  axiom core_total_FMap_K_V_spec'0: forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) self = Some self
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V = Some (core_total_FMap_K_V self)
  
  axiom core_FMap_K_V_spec: forall self: t_FMap_K_V. match core_FMap_K_V self with
        | Some c -> op_FMap_K_V c c = Some c /\ op_FMap_K_V c self = Some self
        | None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  function core_is_total_FMap_K_V (self: t_FMap_K_V) : ()
  
  goal vc_core_is_total_FMap_K_V: [@expl:core_is_total ensures] core_FMap_K_V self = Some (core_total_FMap_K_V self)
end
module M_logic__ra__fmap__impl_FMap_K_V__total_op (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  type t_Option_Option_V = None'0 | Some'0 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some c -> op_V factor c = Some self
        | None -> forall c: t_V. op_V factor c <> Some self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None} -> get_K (merge_K self m f) k = x
          | {f0 = Some x; f1 = Some y} -> get_K (merge_K self m f) k
          = Some (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant other : t_FMap_K_V
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V
  
  goal vc_total_op_K: (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'0)
    -> (forall __0: tup2_V_V. let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
          | Some r -> true
          | _ -> [@expl:such_that requires] exists x'0: t_V. index_Mapping_V_bool (fun (__0'0: t_V) -> true) x'0
          end)
    /\ ((forall k: t_K [get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
          | Some r -> r
          | _ -> such_that_V (fun (__0'0: t_V) -> true)
          end)) k]. match { f0 = get_K self k; f1 = get_K other k } with
          | {f0 = None; f1 = y} -> get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y'0} = __0 in match op_V x y'0 with
              | Some r -> r
              | _ -> such_that_V (fun (__0'0: t_V) -> true)
              end)) k
          = y
          | {f0 = x; f1 = None} -> get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x'0; f1'0 = y} = __0 in match op_V x'0 y with
              | Some r -> r
              | _ -> such_that_V (fun (__0'0: t_V) -> true)
              end)) k
          = x
          | {f0 = Some x; f1 = Some y} -> get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x'0; f1'0 = y'0} = __0 in match op_V x'0 y'0 with
              | Some r -> r
              | _ -> such_that_V (fun (__0'0: t_V) -> true)
              end)) k
          = Some (index_Mapping_tup2_V_V_V (fun (__0: tup2_V_V) -> let {f0'0 = x'0; f1'0 = y'0} = __0 in match op_V x'0 y'0 with
            | Some r -> r
            | _ -> such_that_V (fun (__0'0: t_V) -> true)
            end) { f0'0 = x; f1'0 = y })
          end)
    -> ([@expl:total_op ensures] forall k: t_K. Some'0 (get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
          | Some r -> r
          | _ -> such_that_V (fun (__0'0: t_V) -> true)
          end)) k)
      = op_Option_V (get_K self k) (get_K other k)))
end
module M_logic__ra__fmap__impl_LocalUpdate_for_FMapInsertLocalUpdate_K_V__frame_preserving (* <logic::ra::fmap::FMapInsertLocalUpdate<K, V> as logic::ra::update::LocalUpdate<logic::fmap::FMap<K, V>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_K
  
  type t_V
  
  type t_FMapInsertLocalUpdate_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate premise_FMapInsertLocalUpdate_K_V (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (_3: t_FMap_K_V) =
    get_K from_auth self.f0 = None'0
  
  type t_Option_Option_FMap_K_V = None'1 | Some'1 t_Option_FMap_K_V
  
  function and_then_Option_Option_FMap_K_V (self: t_Option_Option_FMap_K_V) (f: Map.map t_Option_FMap_K_V t_Option_Option_FMap_K_V) : t_Option_Option_FMap_K_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'0: t_Option_FMap_K_V; f1'0: t_Option_FMap_K_V }
  
  function map_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_Option_FMap_K_V
   = match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_Option_V = None'2 | Some'2 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0'1: t_Option_V; f1'1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'2
      | Some'0 x -> Some'2 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'1 = self;
                                                                                            f1'1 = other } with
      | {f0'1 = None'0} -> Some'2 other
      | {f1'1 = None'0} -> Some'2 self
      | {f0'1 = Some'0 x; f1'1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type tup2_V_V = { f0'2: t_V; f1'2: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'1 = get_K self k;
                                                                                                                         f1'1 = get_K m k } with
          | {f0'1 = None'0; f1'1 = y} -> get_K (merge_K self m f) k = y
          | {f0'1 = x; f1'1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0'1 = Some'0 x; f1'1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'2 = x; f1'2 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'2 = x; f1'2 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'2 then Some (total_op_K self other) else None
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : () = match { f0'0 = op_FMap_K_V a b;
                                                                                               f1'0 = op_FMap_K_V b c } with
      | {f0'0 = Some ab; f1'0 = Some bc} -> match { f0'0 = op_FMap_K_V ab c; f1'0 = op_FMap_K_V a bc } with
        | {f0'0 = Some x; f1'0 = Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_FMap_K_V_spec:
    forall a: t_FMap_K_V, b: t_FMap_K_V, c: t_FMap_K_V. and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  function op_Option_FMap_K_V (self: t_Option_FMap_K_V) (other: t_Option_FMap_K_V) : t_Option_Option_FMap_K_V =
    match { f0'0 = self; f1'0 = other } with
      | {f0'0 = None} -> Some'1 other
      | {f1'0 = None} -> Some'1 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_FMap_K_V (op_FMap_K_V x y) (fun (z: t_FMap_K_V) -> Some z)
      end
  
  function associative_Option_FMap_K_V (a: t_Option_FMap_K_V) (b: t_Option_FMap_K_V) (c: t_Option_FMap_K_V) : ()
  
  axiom associative_Option_FMap_K_V_spec:
    forall a: t_Option_FMap_K_V, b: t_Option_FMap_K_V, c: t_Option_FMap_K_V. and_then_Option_Option_FMap_K_V (op_Option_FMap_K_V a b) (fun (ab: t_Option_FMap_K_V) -> op_Option_FMap_K_V ab c)
      = and_then_Option_Option_FMap_K_V (op_Option_FMap_K_V b c) (fun (bc: t_Option_FMap_K_V) -> op_Option_FMap_K_V a bc)
  
  function commutative_Option_FMap_K_V (a: t_Option_FMap_K_V) (b: t_Option_FMap_K_V) : ()
  
  axiom commutative_Option_FMap_K_V_spec: forall a: t_Option_FMap_K_V, b: t_Option_FMap_K_V. op_Option_FMap_K_V a b
      = op_Option_FMap_K_V b a
  
  type tup2_FMap_K_V_FMap_K_V = { f0'3: t_FMap_K_V; f1'3: t_FMap_K_V }
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some'0 v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  function update_FMapInsertLocalUpdate_K_V (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (from_frag: t_FMap_K_V) : tup2_FMap_K_V_FMap_K_V
   = { f0'3 = insert_K from_auth self.f0 self.f1; f1'3 = insert_K from_frag self.f0 self.f1 }
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMapInsertLocalUpdate_K_V
  
  constant from_auth : t_FMap_K_V
  
  constant from_frag : t_FMap_K_V
  
  constant frame : t_Option_FMap_K_V
  
  function frame_preserving_FMapInsertLocalUpdate_K_V (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (from_frag: t_FMap_K_V) (frame: t_Option_FMap_K_V) : ()
  
  goal vc_frame_preserving_FMapInsertLocalUpdate_K_V: premise_FMapInsertLocalUpdate_K_V self from_auth from_frag
    -> op_Option_FMap_K_V (Some from_frag) frame = Some'1 (Some from_auth)
    -> (let {f0'3 = to_auth; f1'3 = to_frag} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in match op_Option_FMap_K_V (Some to_frag) frame with
      | Some'1 (Some x) -> ext_eq_K to_auth x = (to_auth = x)
      -> ext_eq_K to_auth x
      && ([@expl:frame_preserving ensures] let {f0'3 = to_auth'0; f1'3 = to_frag'0} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in op_Option_FMap_K_V (Some to_frag'0) frame
      = Some'1 (Some to_auth'0))
      | _ -> false
      && ([@expl:frame_preserving ensures] let {f0'3 = to_auth'0; f1'3 = to_frag'0} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in op_Option_FMap_K_V (Some to_frag'0) frame
      = Some'1 (Some to_auth'0))
      end)
end
module M_logic__ra__option__impl_RA_for_Option_T__factor (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  constant factor : t_Option_T
  
  function factor_Option_T (self: t_Option_T) (factor: t_Option_T) : t_Option_Option_T
  
  goal vc_factor_Option_T: match { f0 = self; f1 = factor } with
      | {f0 = x; f1 = None} -> [@expl:factor ensures] match Some'0 x with
        | Some'0 c -> op_Option_T factor c = Some'0 self
        | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
        end
      | {f0 = None} -> [@expl:factor ensures] match None'0 with
        | Some'0 c -> op_Option_T factor c = Some'0 self
        | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
        end
      | {f0 = Some x; f1 = Some y} -> match factor_T x y with
          | Some c -> op_T y c = Some x
          | None -> forall c: t_T. op_T y c <> Some x
          end
      -> match factor_T x y with
        | Some z -> [@expl:factor ensures] match Some'0 (Some z) with
          | Some'0 c -> op_Option_T factor c = Some'0 self
          | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
          end
        | None -> if x = y then
          [@expl:factor ensures] match Some'0 (None) with
            | Some'0 c -> op_Option_T factor c = Some'0 self
            | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
            end
        else
          [@expl:factor ensures] match None'0 with
            | Some'0 c -> op_Option_T factor c = Some'0 self
            | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
            end
        
        end
      end
end
module M_logic__ra__option__impl_RA_for_Option_T__commutative (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  constant b : t_Option_T
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : ()
  
  goal vc_commutative_Option_T: [@expl:commutative ensures] op_Option_T a b = op_Option_T b a
end
module M_logic__ra__option__impl_RA_for_Option_T__associative (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  type tup3_Option_T_Option_T_Option_T = { f0'0: t_Option_T; f1'0: t_Option_T; f2'0: t_Option_T }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  constant b : t_Option_T
  
  constant c : t_Option_T
  
  function associative_Option_T (a: t_Option_T) (b: t_Option_T) (c: t_Option_T) : ()
  
  goal vc_associative_Option_T: match { f0'0 = a; f1'0 = b; f2'0 = c } with
      | {f0'0 = None} -> [@expl:associative ensures] and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
      | {f1'0 = None} -> [@expl:associative ensures] and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
      | {f2'0 = None} -> [@expl:associative ensures] and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
      | {f0'0 = Some aa; f1'0 = Some bb; f2'0 = Some cc} -> and_then_Option_T (op_T aa bb) (fun (ab: t_T) -> op_T ab cc)
        = and_then_Option_T (op_T bb cc) (fun (bc: t_T) -> op_T aa bc)
      -> ([@expl:associative ensures] and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc))
      end
end
module M_logic__ra__option__impl_RA_for_Option_T__core (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some c -> op_T c c = Some c /\ op_T c self = Some self
        | None -> true
        end
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> core_T x
      end
  
  axiom core_total_Option_T_spec:
    forall self: t_Option_T. op_Option_T (core_total_Option_T self) (core_total_Option_T self)
      = Some'0 (core_total_Option_T self)
  
  axiom core_total_Option_T_spec'0: forall self: t_Option_T. op_Option_T (core_total_Option_T self) self = Some'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T
  
  goal vc_core_Option_T: op_Option_T (core_total_Option_T self) (core_total_Option_T self)
        = Some'0 (core_total_Option_T self)
      && op_Option_T (core_total_Option_T self) self = Some'0 self
    -> ([@expl:core ensures] match Some'0 (core_total_Option_T self) with
      | Some'0 c -> op_Option_T c c = Some'0 c /\ op_Option_T c self = Some'0 self
      | None'0 -> true
      end)
end
module M_logic__ra__option__impl_RA_for_Option_T__core_is_maximal_idemp (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some c -> op_T c c = Some c /\ op_T c self = Some self
        | None -> true
        end
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> core_T x
      end
  
  axiom core_total_Option_T_spec:
    forall self: t_Option_T. op_Option_T (core_total_Option_T self) (core_total_Option_T self)
      = Some'0 (core_total_Option_T self)
  
  axiom core_total_Option_T_spec'0: forall self: t_Option_T. op_Option_T (core_total_Option_T self) self = Some'0 self
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = Some'0 (core_total_Option_T self)
  
  axiom core_Option_T_spec: forall self: t_Option_T. match core_Option_T self with
        | Some'0 c -> op_Option_T c c = Some'0 c /\ op_Option_T c self = Some'0 self
        | None'0 -> true
        end
  
  function factor_Option_T (self: t_Option_T) (factor: t_Option_T) : t_Option_Option_T = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None} -> Some'0 x
      | {f0 = None} -> None'0
      | {f0 = Some x; f1 = Some y} -> match factor_T x y with
        | Some z -> Some'0 (Some z)
        | None -> if x = y then Some'0 (None) else None'0
        end
      end
  
  axiom factor_Option_T_spec: forall self: t_Option_T, factor: t_Option_T. match factor_Option_T self factor with
        | Some'0 c -> op_Option_T factor c = Some'0 self
        | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
        end
  
  predicate incl_Option_T (self: t_Option_T) (other: t_Option_T) = factor_Option_T other self <> None'0
  
  function core_is_maximal_idemp_T (self: t_T) (i: t_T) : ()
  
  axiom core_is_maximal_idemp_T_spec: forall self: t_T, i: t_T. op_T i i = Some i
      -> op_T i self = Some self
      -> match core_T self with
        | Some c -> incl_T i c
        | None -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  constant i : t_Option_T
  
  function core_is_maximal_idemp_Option_T (self: t_Option_T) (i: t_Option_T) : ()
  
  goal vc_core_is_maximal_idemp_Option_T: op_Option_T i i = Some'0 i
    -> op_Option_T i self = Some'0 self
    -> match { f0 = self; f1 = i } with
      | {f0 = Some x; f1 = Some i'0} -> (([@expl:core_is_maximal_idemp requires #0] op_T i'0 i'0 = Some i'0)
        && ([@expl:core_is_maximal_idemp requires #1] op_T i'0 x = Some x))
      /\ (match core_T x with
          | Some c -> incl_T i'0 c
          | None -> false
          end
      -> ([@expl:core_is_maximal_idemp ensures] match core_Option_T self with
        | Some'0 c -> incl_Option_T i c
        | None'0 -> false
        end))
      | _ -> [@expl:core_is_maximal_idemp ensures] match core_Option_T self with
        | Some'0 c -> incl_Option_T i c
        | None'0 -> false
        end
      end
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__unit (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup3_Option_T_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T; f2: t_Option_T }
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  type tup2_Option_T_Option_T = { f0'0: t_Option_T; f1'0: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function associative_Option_T (a: t_Option_T) (b: t_Option_T) (c: t_Option_T) : () = match { f0 = a;
                                                                                               f1 = b;
                                                                                               f2 = c } with
      | {f0 = None} -> ()
      | {f1 = None} -> ()
      | {f2 = None} -> ()
      | {f0 = Some aa; f1 = Some bb; f2 = Some cc} -> associative_T aa bb cc
      end
  
  axiom associative_Option_T_spec:
    forall a: t_Option_T, b: t_Option_T, c: t_Option_T. and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_Option_T : t_Option_T
  
  goal vc_unit_Option_T:
    let result = None in [@expl:unit ensures] forall x: t_Option_T [op_Option_T x result]. op_Option_T x result
      = Some'0 x
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__core_total (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup3_Option_T_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T; f2: t_Option_T }
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  type tup2_Option_T_Option_T = { f0'0: t_Option_T; f1'0: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function associative_Option_T (a: t_Option_T) (b: t_Option_T) (c: t_Option_T) : () = match { f0 = a;
                                                                                               f1 = b;
                                                                                               f2 = c } with
      | {f0 = None} -> ()
      | {f1 = None} -> ()
      | {f2 = None} -> ()
      | {f0 = Some aa; f1 = Some bb; f2 = Some cc} -> associative_T aa bb cc
      end
  
  axiom associative_Option_T_spec:
    forall a: t_Option_T, b: t_Option_T, c: t_Option_T. and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some c -> op_T c c = Some c /\ op_T c self = Some self
        | None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T
  
  goal vc_core_total_Option_T: match self with
      | None -> let result = None in ([@expl:core_total ensures #0] op_Option_T result result = Some'0 result)
      && ([@expl:core_total ensures #1] op_Option_T result self = Some'0 self)
      | Some x -> match core_T x with
          | Some c -> op_T c c = Some c /\ op_T c x = Some x
          | None -> true
          end
      -> (let result = core_T x in ([@expl:core_total ensures #0] op_Option_T result result = Some'0 result)
      && ([@expl:core_total ensures #1] op_Option_T result self = Some'0 self))
      end
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__core_is_total (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  type tup3_Option_T_Option_T_Option_T = { f0'0: t_Option_T; f1'0: t_Option_T; f2'0: t_Option_T }
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function associative_Option_T (a: t_Option_T) (b: t_Option_T) (c: t_Option_T) : () = match { f0'0 = a;
                                                                                               f1'0 = b;
                                                                                               f2'0 = c } with
      | {f0'0 = None} -> ()
      | {f1'0 = None} -> ()
      | {f2'0 = None} -> ()
      | {f0'0 = Some aa; f1'0 = Some bb; f2'0 = Some cc} -> associative_T aa bb cc
      end
  
  axiom associative_Option_T_spec:
    forall a: t_Option_T, b: t_Option_T, c: t_Option_T. and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some c -> op_T c c = Some c /\ op_T c self = Some self
        | None -> true
        end
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> core_T x
      end
  
  axiom core_total_Option_T_spec:
    forall self: t_Option_T. op_Option_T (core_total_Option_T self) (core_total_Option_T self)
      = Some'0 (core_total_Option_T self)
  
  axiom core_total_Option_T_spec'0: forall self: t_Option_T. op_Option_T (core_total_Option_T self) self = Some'0 self
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = Some'0 (core_total_Option_T self)
  
  axiom core_Option_T_spec: forall self: t_Option_T. match core_Option_T self with
        | Some'0 c -> op_Option_T c c = Some'0 c /\ op_Option_T c self = Some'0 self
        | None'0 -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  function core_is_total_Option_T (self: t_Option_T) : ()
  
  goal vc_core_is_total_Option_T: [@expl:core_is_total ensures] core_Option_T self = Some'0 (core_total_Option_T self)
end
module M_logic__ra__option__impl_Update_for_OptionUpdate_U__update (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_OptionUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) =
    match from with
      | Some from'0 -> premise_U self.f0 from'0
      | None -> false
      end
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_OptionUpdate_U
  
  constant from : t_Option_R
  
  constant ch : t_Choice
  
  function update_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) (ch: t_Choice) : t_Option_R
  
  goal vc_update_OptionUpdate_U: premise_OptionUpdate_U self from
    -> match from with
      | Some from'0 -> [@expl:update requires] premise_U self.f0 from'0
      | None -> true
      end
end
module M_logic__ra__option__impl_Update_for_OptionUpdate_U__frame_preserving (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_OptionUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) =
    match from with
      | Some from'0 -> premise_U self.f0 from'0
      | None -> false
      end
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  function and_then_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_R
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup3_Option_R_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R; f2'0: t_Option_R }
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  type tup2_Option_R_Option_R = { f0'1: t_Option_R; f1'1: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'1 = self;
                                                                                            f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function associative_Option_R (a: t_Option_R) (b: t_Option_R) (c: t_Option_R) : () = match { f0'0 = a;
                                                                                               f1'0 = b;
                                                                                               f2'0 = c } with
      | {f0'0 = None} -> ()
      | {f1'0 = None} -> ()
      | {f2'0 = None} -> ()
      | {f0'0 = Some aa; f1'0 = Some bb; f2'0 = Some cc} -> associative_R aa bb cc
      end
  
  axiom associative_Option_R_spec:
    forall a: t_Option_R, b: t_Option_R, c: t_Option_R. and_then_Option_Option_R (op_Option_R a b) (fun (ab: t_Option_R) -> op_Option_R ab c)
      = and_then_Option_Option_R (op_Option_R b c) (fun (bc: t_Option_R) -> op_Option_R a bc)
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : () = ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) (ch: t_Choice) : t_Option_R =
    match from with
      | Some from'0 -> Some (update_U self.f0 from'0 ch)
      | None -> None
      end
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function frame_preserving_U (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_U_spec: forall self: t_U, from: t_R, frame: t_R. premise_U self from
      -> op_R from frame <> None -> op_R (update_U self from (frame_preserving_U self from frame)) frame <> None
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_OptionUpdate_U
  
  constant from : t_Option_R
  
  constant frame : t_Option_R
  
  function frame_preserving_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) (frame: t_Option_R) : t_Choice
  
  goal vc_frame_preserving_OptionUpdate_U: premise_OptionUpdate_U self from
    -> op_Option_R from frame <> None'0
    -> match frame with
      | Some frame'0 -> ([@expl:unwrap_logic requires] from <> None)
      /\ (([@expl:frame_preserving requires #0] premise_U self.f0 (unwrap_Option_R from))
        && ([@expl:frame_preserving requires #1] op_R (unwrap_Option_R from) frame'0 <> None))
      /\ (op_R (update_U self.f0 (unwrap_Option_R from) (frame_preserving_U self.f0 (unwrap_Option_R from) frame'0)) frame'0
        <> None
      -> ([@expl:frame_preserving ensures] op_Option_R (update_OptionUpdate_U self from (frame_preserving_U self.f0 (unwrap_Option_R from) frame'0)) frame
      <> None'0))
      | None -> ([@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) x)
      /\ (index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) (such_that_Choice (fun (__0: t_Choice) -> true))
      -> ([@expl:frame_preserving ensures] op_Option_R (update_OptionUpdate_U self from (such_that_Choice (fun (__0: t_Choice) -> true))) frame
      <> None'0))
      end
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__factor (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  constant factor : tup2_T_U
  
  function factor_tup2_T_U (self: tup2_T_U) (factor: tup2_T_U) : t_Option_tup2_T_U
  
  goal vc_factor_tup2_T_U: match factor_T self.f0 factor.f0 with
        | Some'0 c -> op_T factor.f0 c = Some'0 (self.f0)
        | None'0 -> forall c: t_T. op_T factor.f0 c <> Some'0 (self.f0)
        end
    -> match factor_U self.f1 factor.f1 with
        | Some'1 c -> op_U factor.f1 c = Some'1 (self.f1)
        | None'1 -> forall c: t_U. op_U factor.f1 c <> Some'1 (self.f1)
        end
    -> match { f0'0 = factor_T self.f0 factor.f0; f1'0 = factor_U self.f1 factor.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> [@expl:factor ensures] match Some { f0 = x; f1 = y } with
        | Some c -> op_tup2_T_U factor c = Some self
        | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
        end
      | _ -> [@expl:factor ensures] match None with
        | Some c -> op_tup2_T_U factor c = Some self
        | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
        end
      end
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__commutative (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : tup2_T_U
  
  constant b : tup2_T_U
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : ()
  
  goal vc_commutative_tup2_T_U: [@expl:commutative ensures] op_tup2_T_U a b = op_tup2_T_U b a
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__associative (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : tup2_T_U
  
  constant b : tup2_T_U
  
  constant c : tup2_T_U
  
  function associative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) (c: tup2_T_U) : ()
  
  goal vc_associative_tup2_T_U:
    [@expl:associative ensures] and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
    = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__core (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some'0 c -> op_T c c = Some'0 c /\ op_T c self = Some'0 self
        | None'0 -> true
        end
  
  function core_U (self: t_U) : t_Option_U
  
  axiom core_U_spec: forall self: t_U. match core_U self with
        | Some'1 c -> op_U c c = Some'1 c /\ op_U c self = Some'1 self
        | None'1 -> true
        end
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U
  
  goal vc_core_tup2_T_U: match core_T self.f0 with
        | Some'0 c -> op_T c c = Some'0 c /\ op_T c self.f0 = Some'0 (self.f0)
        | None'0 -> true
        end
    -> match core_U self.f1 with
        | Some'1 c -> op_U c c = Some'1 c /\ op_U c self.f1 = Some'1 (self.f1)
        | None'1 -> true
        end
    -> match { f0'0 = core_T self.f0; f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> [@expl:core ensures] match Some { f0 = x; f1 = y } with
        | Some c -> op_tup2_T_U c c = Some c /\ op_tup2_T_U c self = Some self
        | None -> true
        end
      | _ -> [@expl:core ensures] match None with
        | Some c -> op_tup2_T_U c c = Some c /\ op_tup2_T_U c self = Some self
        | None -> true
        end
      end
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__core_is_maximal_idemp (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some'0 c -> op_T c c = Some'0 c /\ op_T c self = Some'0 self
        | None'0 -> true
        end
  
  function core_U (self: t_U) : t_Option_U
  
  axiom core_U_spec: forall self: t_U. match core_U self with
        | Some'1 c -> op_U c c = Some'1 c /\ op_U c self = Some'1 self
        | None'1 -> true
        end
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  axiom core_tup2_T_U_spec: forall self: tup2_T_U. match core_tup2_T_U self with
        | Some c -> op_tup2_T_U c c = Some c /\ op_tup2_T_U c self = Some self
        | None -> true
        end
  
  function factor_tup2_T_U (self: tup2_T_U) (factor: tup2_T_U) : t_Option_tup2_T_U =
    match { f0'0 = factor_T self.f0 factor.f0; f1'0 = factor_U self.f1 factor.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  axiom factor_tup2_T_U_spec: forall self: tup2_T_U, factor: tup2_T_U. match factor_tup2_T_U self factor with
        | Some c -> op_tup2_T_U factor c = Some self
        | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
        end
  
  predicate incl_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) = factor_tup2_T_U other self <> None
  
  function core_is_maximal_idemp_T (self: t_T) (i: t_T) : ()
  
  axiom core_is_maximal_idemp_T_spec: forall self: t_T, i: t_T. op_T i i = Some'0 i
      -> op_T i self = Some'0 self
      -> match core_T self with
        | Some'0 c -> incl_T i c
        | None'0 -> false
        end
  
  function core_is_maximal_idemp_U (self: t_U) (i: t_U) : ()
  
  axiom core_is_maximal_idemp_U_spec: forall self: t_U, i: t_U. op_U i i = Some'1 i
      -> op_U i self = Some'1 self
      -> match core_U self with
        | Some'1 c -> incl_U i c
        | None'1 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  constant i : tup2_T_U
  
  function core_is_maximal_idemp_tup2_T_U (self: tup2_T_U) (i: tup2_T_U) : ()
  
  goal vc_core_is_maximal_idemp_tup2_T_U: op_tup2_T_U i i = Some i
    -> op_tup2_T_U i self = Some self
    -> (([@expl:core_is_maximal_idemp requires #0] op_T i.f0 i.f0 = Some'0 (i.f0))
      && ([@expl:core_is_maximal_idemp requires #1] op_T i.f0 self.f0 = Some'0 (self.f0)))
    /\ (match core_T self.f0 with
        | Some'0 c -> incl_T i.f0 c
        | None'0 -> false
        end
    -> (let _ = core_is_maximal_idemp_T self.f0 i.f0 in (([@expl:core_is_maximal_idemp requires #0] op_U i.f1 i.f1
        = Some'1 (i.f1))
      && ([@expl:core_is_maximal_idemp requires #1] op_U i.f1 self.f1 = Some'1 (self.f1)))
    /\ (match core_U self.f1 with
        | Some'1 c -> incl_U i.f1 c
        | None'1 -> false
        end
    -> (let _ = core_is_maximal_idemp_U self.f1 i.f1 in [@expl:core_is_maximal_idemp ensures] match core_tup2_T_U self with
      | Some c -> incl_tup2_T_U i c
      | None -> false
      end))))
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__unit (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  function associative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) (c: tup2_T_U) : () = ()
  
  axiom associative_tup2_T_U_spec:
    forall a: tup2_T_U, b: tup2_T_U, c: tup2_T_U. and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
      = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. op_T (core_total_T self) (core_total_T self) = Some'0 (core_total_T self)
  
  axiom core_total_T_spec'0: forall self: t_T. op_T (core_total_T self) self = Some'0 self
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x
  
  constant unit_core_T: () = ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T: () = let _ = unit_T in ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  function core_total_U (self: t_U) : t_U
  
  axiom core_total_U_spec: forall self: t_U. op_U (core_total_U self) (core_total_U self) = Some'1 (core_total_U self)
  
  axiom core_total_U_spec'0: forall self: t_U. op_U (core_total_U self) self = Some'1 self
  
  constant unit_U : t_U
  
  axiom unit_U_spec: forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x
  
  constant unit_core_U: () = ()
  
  axiom unit_core_U_spec: core_total_U unit_U = unit_U
  
  constant incl_refl_U: () = let _ = unit_U in ()
  
  axiom incl_refl_U_spec: forall x: t_U. incl_U x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_tup2_T_U : tup2_T_U
  
  goal vc_unit_tup2_T_U: (forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x)
    -> (forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x)
    -> (let result = { f0 = unit_T;
                       f1 = unit_U } in [@expl:unit ensures] forall x: tup2_T_U [op_tup2_T_U x result]. op_tup2_T_U x result
      = Some x)
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__core_total (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  function associative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) (c: tup2_T_U) : () = ()
  
  axiom associative_tup2_T_U_spec:
    forall a: tup2_T_U, b: tup2_T_U, c: tup2_T_U. and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
      = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. op_T (core_total_T self) (core_total_T self) = Some'0 (core_total_T self)
  
  axiom core_total_T_spec'0: forall self: t_T. op_T (core_total_T self) self = Some'0 self
  
  constant unit_core_T: () = ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T: () = let _ = unit_T in ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  constant unit_U : t_U
  
  axiom unit_U_spec: forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x
  
  function core_total_U (self: t_U) : t_U
  
  axiom core_total_U_spec: forall self: t_U. op_U (core_total_U self) (core_total_U self) = Some'1 (core_total_U self)
  
  axiom core_total_U_spec'0: forall self: t_U. op_U (core_total_U self) self = Some'1 self
  
  constant unit_core_U: () = ()
  
  axiom unit_core_U_spec: core_total_U unit_U = unit_U
  
  constant incl_refl_U: () = let _ = unit_U in ()
  
  axiom incl_refl_U_spec: forall x: t_U. incl_U x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  function core_total_tup2_T_U (self: tup2_T_U) : tup2_T_U
  
  goal vc_core_total_tup2_T_U: op_T (core_total_T self.f0) (core_total_T self.f0) = Some'0 (core_total_T self.f0)
      && op_T (core_total_T self.f0) self.f0 = Some'0 (self.f0)
    -> op_U (core_total_U self.f1) (core_total_U self.f1) = Some'1 (core_total_U self.f1)
      && op_U (core_total_U self.f1) self.f1 = Some'1 (self.f1)
    -> (let result = { f0 = core_total_T self.f0;
                       f1 = core_total_U self.f1 } in ([@expl:core_total ensures #0] op_tup2_T_U result result
      = Some result)
    && ([@expl:core_total ensures #1] op_tup2_T_U result self = Some self))
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__core_is_total (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  function associative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) (c: tup2_T_U) : () = ()
  
  axiom associative_tup2_T_U_spec:
    forall a: tup2_T_U, b: tup2_T_U, c: tup2_T_U. and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
      = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some'0 c -> op_T c c = Some'0 c /\ op_T c self = Some'0 self
        | None'0 -> true
        end
  
  function core_U (self: t_U) : t_Option_U
  
  axiom core_U_spec: forall self: t_U. match core_U self with
        | Some'1 c -> op_U c c = Some'1 c /\ op_U c self = Some'1 self
        | None'1 -> true
        end
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  axiom core_tup2_T_U_spec: forall self: tup2_T_U. match core_tup2_T_U self with
        | Some c -> op_tup2_T_U c c = Some c /\ op_tup2_T_U c self = Some self
        | None -> true
        end
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. op_T (core_total_T self) (core_total_T self) = Some'0 (core_total_T self)
  
  axiom core_total_T_spec'0: forall self: t_T. op_T (core_total_T self) self = Some'0 self
  
  constant unit_core_T: () = ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T: () = let _ = unit_T in ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  constant unit_U : t_U
  
  axiom unit_U_spec: forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x
  
  function core_total_U (self: t_U) : t_U
  
  axiom core_total_U_spec: forall self: t_U. op_U (core_total_U self) (core_total_U self) = Some'1 (core_total_U self)
  
  axiom core_total_U_spec'0: forall self: t_U. op_U (core_total_U self) self = Some'1 self
  
  constant unit_core_U: () = ()
  
  axiom unit_core_U_spec: core_total_U unit_U = unit_U
  
  constant incl_refl_U: () = let _ = unit_U in ()
  
  axiom incl_refl_U_spec: forall x: t_U. incl_U x x
  
  function core_total_tup2_T_U (self: tup2_T_U) : tup2_T_U = { f0 = core_total_T self.f0; f1 = core_total_U self.f1 }
  
  axiom core_total_tup2_T_U_spec:
    forall self: tup2_T_U. op_tup2_T_U (core_total_tup2_T_U self) (core_total_tup2_T_U self)
      = Some (core_total_tup2_T_U self)
  
  axiom core_total_tup2_T_U_spec'0: forall self: tup2_T_U. op_tup2_T_U (core_total_tup2_T_U self) self = Some self
  
  function core_is_total_T (self: t_T) : ()
  
  axiom core_is_total_T_spec: forall self: t_T. core_T self = Some'0 (core_total_T self)
  
  function core_is_total_U (self: t_U) : ()
  
  axiom core_is_total_U_spec: forall self: t_U. core_U self = Some'1 (core_total_U self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  function core_is_total_tup2_T_U (self: tup2_T_U) : ()
  
  goal vc_core_is_total_tup2_T_U: core_T self.f0 = Some'0 (core_total_T self.f0)
    -> (let _ = core_is_total_T self.f0 in core_U self.f1 = Some'1 (core_total_U self.f1)
    -> (let _ = core_is_total_U self.f1 in [@expl:core_is_total ensures] core_tup2_T_U self
    = Some (core_total_tup2_T_U self)))
end
module M_logic__ra__prod__impl_Update_for_ProdUpdate_U1_U2__update (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  type t_Choice
  
  type t_Choice'0
  
  type tup2_Choice_Choice = { f0'1: t_Choice; f1'1: t_Choice'0 }
  
  predicate premise_U1 (self: t_U1) (from: t_R1)
  
  predicate premise_U2 (self: t_U2) (from: t_R2)
  
  predicate premise_ProdUpdate_U1_U2 (self: t_ProdUpdate_U1_U2) (from: tup2_R1_R2) =
    premise_U1 self.f0 from.f0'0 /\ premise_U2 self.f1 from.f1'0
  
  function update_U1 (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_U2 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ProdUpdate_U1_U2
  
  constant from : tup2_R1_R2
  
  constant ch : tup2_Choice_Choice
  
  function update_ProdUpdate_U1_U2 (self: t_ProdUpdate_U1_U2) (from: tup2_R1_R2) (ch: tup2_Choice_Choice) : tup2_R1_R2
  
  goal vc_update_ProdUpdate_U1_U2: premise_ProdUpdate_U1_U2 self from
    -> ([@expl:update requires] premise_U1 self.f0 from.f0'0) /\ ([@expl:update requires] premise_U2 self.f1 from.f1'0)
end
module M_logic__ra__prod__impl_Update_for_ProdUpdate_U1_U2__frame_preserving (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  type t_Choice
  
  type t_Choice'0
  
  type tup2_Choice_Choice = { f0'1: t_Choice; f1'1: t_Choice'0 }
  
  predicate premise_U1 (self: t_U1) (from: t_R1)
  
  predicate premise_U2 (self: t_U2) (from: t_R2)
  
  predicate premise_ProdUpdate_U1_U2 (self: t_ProdUpdate_U1_U2) (from: tup2_R1_R2) =
    premise_U1 self.f0 from.f0'0 /\ premise_U2 self.f1 from.f1'0
  
  type t_Option_tup2_R1_R2 = None | Some tup2_R1_R2
  
  function and_then_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_Option_tup2_R1_R2) : t_Option_tup2_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_tup2_R1_R2) : t_Option_tup2_R1_R2 =
    match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_R1'0 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1'0 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1'0 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 tup2_R1_R2) : t_Option_tup2_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_tup2_R1_R2 (self: tup2_R1_R2) (other: tup2_R1_R2) : t_Option_tup2_R1_R2 =
    and_then_Option_R1 (op_R1 self.f0'0 other.f0'0) (fun (x: t_R1) -> map_Option_R2 (op_R2 self.f1'0 other.f1'0) (fun (y: t_R2) -> { f0'0 = x;
                                                                                                                                     f1'0 = y }))
  
  function associative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) (c: tup2_R1_R2) : () = ()
  
  axiom associative_tup2_R1_R2_spec:
    forall a: tup2_R1_R2, b: tup2_R1_R2, c: tup2_R1_R2. and_then_Option_tup2_R1_R2 (op_tup2_R1_R2 a b) (fun (ab: tup2_R1_R2) -> op_tup2_R1_R2 ab c)
      = and_then_Option_tup2_R1_R2 (op_tup2_R1_R2 b c) (fun (bc: tup2_R1_R2) -> op_tup2_R1_R2 a bc)
  
  function commutative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) : () = ()
  
  axiom commutative_tup2_R1_R2_spec: forall a: tup2_R1_R2, b: tup2_R1_R2. op_tup2_R1_R2 a b = op_tup2_R1_R2 b a
  
  function update_U1 (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_U2 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  function update_ProdUpdate_U1_U2 (self: t_ProdUpdate_U1_U2) (from: tup2_R1_R2) (ch: tup2_Choice_Choice) : tup2_R1_R2 =
    { f0'0 = update_U1 self.f0 from.f0'0 ch.f0'1; f1'0 = update_U2 self.f1 from.f1'0 ch.f1'1 }
  
  function frame_preserving_U1 (self: t_U1) (from: t_R1) (frame: t_R1) : t_Choice
  
  axiom frame_preserving_U1_spec: forall self: t_U1, from: t_R1, frame: t_R1. premise_U1 self from
      -> op_R1 from frame <> None'0 -> op_R1 (update_U1 self from (frame_preserving_U1 self from frame)) frame <> None'0
  
  function frame_preserving_U2 (self: t_U2) (from: t_R2) (frame: t_R2) : t_Choice'0
  
  axiom frame_preserving_U2_spec: forall self: t_U2, from: t_R2, frame: t_R2. premise_U2 self from
      -> op_R2 from frame <> None'1 -> op_R2 (update_U2 self from (frame_preserving_U2 self from frame)) frame <> None'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ProdUpdate_U1_U2
  
  constant from : tup2_R1_R2
  
  constant frame : tup2_R1_R2
  
  function frame_preserving_ProdUpdate_U1_U2 (self: t_ProdUpdate_U1_U2) (from: tup2_R1_R2) (frame: tup2_R1_R2) : tup2_Choice_Choice
  
  goal vc_frame_preserving_ProdUpdate_U1_U2: premise_ProdUpdate_U1_U2 self from
    -> op_tup2_R1_R2 from frame <> None
    -> (([@expl:frame_preserving requires #0] premise_U1 self.f0 from.f0'0)
      && ([@expl:frame_preserving requires #1] op_R1 from.f0'0 frame.f0'0 <> None'0))
    /\ (op_R1 (update_U1 self.f0 from.f0'0 (frame_preserving_U1 self.f0 from.f0'0 frame.f0'0)) frame.f0'0 <> None'0
    -> (([@expl:frame_preserving requires #0] premise_U2 self.f1 from.f1'0)
      && ([@expl:frame_preserving requires #1] op_R2 from.f1'0 frame.f1'0 <> None'1))
    /\ (op_R2 (update_U2 self.f1 from.f1'0 (frame_preserving_U2 self.f1 from.f1'0 frame.f1'0)) frame.f1'0 <> None'1
    -> ([@expl:frame_preserving ensures] op_tup2_R1_R2 (update_ProdUpdate_U1_U2 self from { f0'1 = frame_preserving_U1 self.f0 from.f0'0 frame.f0'0;
                                                                                            f1'1 = frame_preserving_U2 self.f1 from.f1'0 frame.f1'0 }) frame
    <> None)))
end
module M_logic__ra__prod__impl_LocalUpdate_for_ProdLocalUpdate_U1_U2__frame_preserving (* <logic::ra::prod::ProdLocalUpdate<U1, U2> as logic::ra::update::LocalUpdate<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U1
  
  type t_U2
  
  type t_ProdLocalUpdate_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  type t_Option_tup2_R1_R2 = None | Some tup2_R1_R2
  
  predicate premise_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise_ProdLocalUpdate_U1_U2 (self: t_ProdLocalUpdate_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) =
    premise_U1 self.f0 from_auth.f0'0 from_frag.f0'0 /\ premise_U2 self.f1 from_auth.f1'0 from_frag.f1'0
  
  type t_Option_Option_tup2_R1_R2 = None'0 | Some'0 t_Option_tup2_R1_R2
  
  function and_then_Option_Option_tup2_R1_R2 (self: t_Option_Option_tup2_R1_R2) (f: Map.map t_Option_tup2_R1_R2 t_Option_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_tup2_R1_R2_Option_tup2_R1_R2 = { f0'1: t_Option_tup2_R1_R2; f1'1: t_Option_tup2_R1_R2 }
  
  function map_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_Option_tup2_R1_R2) : t_Option_tup2_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_tup2_R1_R2) : t_Option_tup2_R1_R2 =
    match self with
      | None'1 -> None
      | Some'1 x -> Map.get f x
      end
  
  function and_then_Option_R1'0 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1'0 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1'0 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 tup2_R1_R2) : t_Option_tup2_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_tup2_R1_R2 (self: tup2_R1_R2) (other: tup2_R1_R2) : t_Option_tup2_R1_R2 =
    and_then_Option_R1 (op_R1 self.f0'0 other.f0'0) (fun (x: t_R1) -> map_Option_R2 (op_R2 self.f1'0 other.f1'0) (fun (y: t_R2) -> { f0'0 = x;
                                                                                                                                     f1'0 = y }))
  
  function associative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) (c: tup2_R1_R2) : () = ()
  
  axiom associative_tup2_R1_R2_spec:
    forall a: tup2_R1_R2, b: tup2_R1_R2, c: tup2_R1_R2. and_then_Option_tup2_R1_R2 (op_tup2_R1_R2 a b) (fun (ab: tup2_R1_R2) -> op_tup2_R1_R2 ab c)
      = and_then_Option_tup2_R1_R2 (op_tup2_R1_R2 b c) (fun (bc: tup2_R1_R2) -> op_tup2_R1_R2 a bc)
  
  function commutative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) : () = ()
  
  axiom commutative_tup2_R1_R2_spec: forall a: tup2_R1_R2, b: tup2_R1_R2. op_tup2_R1_R2 a b = op_tup2_R1_R2 b a
  
  function op_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (other: t_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_tup2_R1_R2 (op_tup2_R1_R2 x y) (fun (z: tup2_R1_R2) -> Some z)
      end
  
  function associative_Option_tup2_R1_R2 (a: t_Option_tup2_R1_R2) (b: t_Option_tup2_R1_R2) (c: t_Option_tup2_R1_R2) : ()
  
  axiom associative_Option_tup2_R1_R2_spec:
    forall a: t_Option_tup2_R1_R2, b: t_Option_tup2_R1_R2, c: t_Option_tup2_R1_R2. and_then_Option_Option_tup2_R1_R2 (op_Option_tup2_R1_R2 a b) (fun (ab: t_Option_tup2_R1_R2) -> op_Option_tup2_R1_R2 ab c)
      = and_then_Option_Option_tup2_R1_R2 (op_Option_tup2_R1_R2 b c) (fun (bc: t_Option_tup2_R1_R2) -> op_Option_tup2_R1_R2 a bc)
  
  function commutative_Option_tup2_R1_R2 (a: t_Option_tup2_R1_R2) (b: t_Option_tup2_R1_R2) : ()
  
  axiom commutative_Option_tup2_R1_R2_spec:
    forall a: t_Option_tup2_R1_R2, b: t_Option_tup2_R1_R2. op_Option_tup2_R1_R2 a b = op_Option_tup2_R1_R2 b a
  
  type tup2_tup2_R1_R2_tup2_R1_R2 = { f0'2: tup2_R1_R2; f1'2: tup2_R1_R2 }
  
  type tup2_R1_R1 = { f0'3: t_R1; f1'3: t_R1 }
  
  function update_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) : tup2_R1_R1
  
  type tup2_R2_R2 = { f0'4: t_R2; f1'4: t_R2 }
  
  function update_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) : tup2_R2_R2
  
  function update_ProdLocalUpdate_U1_U2 (self: t_ProdLocalUpdate_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) : tup2_tup2_R1_R2_tup2_R1_R2
   =
    let {f0'3 = to_auth0; f1'3 = to_frag0} = update_U1 self.f0 from_auth.f0'0 from_frag.f0'0 in let {f0'4 = to_auth1; f1'4 = to_frag1} = update_U2 self.f1 from_auth.f1'0 from_frag.f1'0 in { f0'2 = { f0'0 = to_auth0;
                                                                                                                                                                                                       f1'0 = to_auth1 };
                                                                                                                                                                                              f1'2 = { f0'0 = to_frag0;
                                                                                                                                                                                                       f1'0 = to_frag1 } }
  
  function map_Option_tup2_R1_R2'0 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_R1) : t_Option_R1 =
    match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  type t_Option_Option_R1 = None'3 | Some'3 t_Option_R1
  
  function and_then_Option_Option_R1 (self: t_Option_Option_R1) (f: Map.map t_Option_R1 t_Option_Option_R1) : t_Option_Option_R1
   = match self with
      | None'3 -> None'3
      | Some'3 x -> Map.get f x
      end
  
  type tup2_Option_R1_Option_R1 = { f0'5: t_Option_R1; f1'5: t_Option_R1 }
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_Option_R1 = match self with
      | None'1 -> None'3
      | Some'1 x -> Some'3 (Map.get f x)
      end
  
  function op_Option_R1 (self: t_Option_R1) (other: t_Option_R1) : t_Option_Option_R1 = match { f0'5 = self;
                                                                                                f1'5 = other } with
      | {f0'5 = None'1} -> Some'3 other
      | {f1'5 = None'1} -> Some'3 self
      | {f0'5 = Some'1 x; f1'5 = Some'1 y} -> map_Option_R1 (op_R1 x y) (fun (z: t_R1) -> Some'1 z)
      end
  
  function associative_Option_R1 (a: t_Option_R1) (b: t_Option_R1) (c: t_Option_R1) : ()
  
  axiom associative_Option_R1_spec:
    forall a: t_Option_R1, b: t_Option_R1, c: t_Option_R1. and_then_Option_Option_R1 (op_Option_R1 a b) (fun (ab: t_Option_R1) -> op_Option_R1 ab c)
      = and_then_Option_Option_R1 (op_Option_R1 b c) (fun (bc: t_Option_R1) -> op_Option_R1 a bc)
  
  function commutative_Option_R1 (a: t_Option_R1) (b: t_Option_R1) : ()
  
  axiom commutative_Option_R1_spec: forall a: t_Option_R1, b: t_Option_R1. op_Option_R1 a b = op_Option_R1 b a
  
  function frame_preserving_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) (frame: t_Option_R1) : ()
  
  axiom frame_preserving_U1_spec:
    forall self: t_U1, from_auth: t_R1, from_frag: t_R1, frame: t_Option_R1. premise_U1 self from_auth from_frag
      -> op_Option_R1 (Some'1 from_frag) frame = Some'3 (Some'1 from_auth)
      -> (let {f0'3 = to_auth; f1'3 = to_frag} = update_U1 self from_auth from_frag in op_Option_R1 (Some'1 to_frag) frame
      = Some'3 (Some'1 to_auth))
  
  function map_Option_tup2_R1_R2'1 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_R2) : t_Option_R2 =
    match self with
      | None -> None'2
      | Some x -> Some'2 (Map.get f x)
      end
  
  type t_Option_Option_R2 = None'4 | Some'4 t_Option_R2
  
  function and_then_Option_Option_R2 (self: t_Option_Option_R2) (f: Map.map t_Option_R2 t_Option_Option_R2) : t_Option_Option_R2
   = match self with
      | None'4 -> None'4
      | Some'4 x -> Map.get f x
      end
  
  type tup2_Option_R2_Option_R2 = { f0'6: t_Option_R2; f1'6: t_Option_R2 }
  
  function map_Option_R2'0 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_Option_R2 = match self with
      | None'2 -> None'4
      | Some'2 x -> Some'4 (Map.get f x)
      end
  
  function op_Option_R2 (self: t_Option_R2) (other: t_Option_R2) : t_Option_Option_R2 = match { f0'6 = self;
                                                                                                f1'6 = other } with
      | {f0'6 = None'2} -> Some'4 other
      | {f1'6 = None'2} -> Some'4 self
      | {f0'6 = Some'2 x; f1'6 = Some'2 y} -> map_Option_R2'0 (op_R2 x y) (fun (z: t_R2) -> Some'2 z)
      end
  
  function associative_Option_R2 (a: t_Option_R2) (b: t_Option_R2) (c: t_Option_R2) : ()
  
  axiom associative_Option_R2_spec:
    forall a: t_Option_R2, b: t_Option_R2, c: t_Option_R2. and_then_Option_Option_R2 (op_Option_R2 a b) (fun (ab: t_Option_R2) -> op_Option_R2 ab c)
      = and_then_Option_Option_R2 (op_Option_R2 b c) (fun (bc: t_Option_R2) -> op_Option_R2 a bc)
  
  function commutative_Option_R2 (a: t_Option_R2) (b: t_Option_R2) : ()
  
  axiom commutative_Option_R2_spec: forall a: t_Option_R2, b: t_Option_R2. op_Option_R2 a b = op_Option_R2 b a
  
  function frame_preserving_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) (frame: t_Option_R2) : ()
  
  axiom frame_preserving_U2_spec:
    forall self: t_U2, from_auth: t_R2, from_frag: t_R2, frame: t_Option_R2. premise_U2 self from_auth from_frag
      -> op_Option_R2 (Some'2 from_frag) frame = Some'4 (Some'2 from_auth)
      -> (let {f0'4 = to_auth; f1'4 = to_frag} = update_U2 self from_auth from_frag in op_Option_R2 (Some'2 to_frag) frame
      = Some'4 (Some'2 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ProdLocalUpdate_U1_U2
  
  constant from_auth : tup2_R1_R2
  
  constant from_frag : tup2_R1_R2
  
  constant frame : t_Option_tup2_R1_R2
  
  function frame_preserving_ProdLocalUpdate_U1_U2 (self: t_ProdLocalUpdate_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) (frame: t_Option_tup2_R1_R2) : ()
  
  goal vc_frame_preserving_ProdLocalUpdate_U1_U2: premise_ProdLocalUpdate_U1_U2 self from_auth from_frag
    -> op_Option_tup2_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
    -> (([@expl:frame_preserving requires #0] premise_U1 self.f0 from_auth.f0'0 from_frag.f0'0)
      && ([@expl:frame_preserving requires #1] op_Option_R1 (Some'1 (from_frag.f0'0)) (map_Option_tup2_R1_R2'0 frame (fun (f: tup2_R1_R2) -> f.f0'0))
      = Some'3 (Some'1 (from_auth.f0'0))))
    /\ ((let {f0'3 = to_auth; f1'3 = to_frag} = update_U1 self.f0 from_auth.f0'0 from_frag.f0'0 in op_Option_R1 (Some'1 to_frag) (map_Option_tup2_R1_R2'0 frame (fun (f: tup2_R1_R2) -> f.f0'0))
      = Some'3 (Some'1 to_auth))
    -> (let _ = frame_preserving_U1 self.f0 from_auth.f0'0 from_frag.f0'0 (map_Option_tup2_R1_R2'0 frame (fun (f: tup2_R1_R2) -> f.f0'0)) in (([@expl:frame_preserving requires #0] premise_U2 self.f1 from_auth.f1'0 from_frag.f1'0)
      && ([@expl:frame_preserving requires #1] op_Option_R2 (Some'2 (from_frag.f1'0)) (map_Option_tup2_R1_R2'1 frame (fun (f: tup2_R1_R2) -> f.f1'0))
      = Some'4 (Some'2 (from_auth.f1'0))))
    /\ ((let {f0'4 = to_auth; f1'4 = to_frag} = update_U2 self.f1 from_auth.f1'0 from_frag.f1'0 in op_Option_R2 (Some'2 to_frag) (map_Option_tup2_R1_R2'1 frame (fun (f: tup2_R1_R2) -> f.f1'0))
      = Some'4 (Some'2 to_auth))
    -> (let _ = frame_preserving_U2 self.f1 from_auth.f1'0 from_frag.f1'0 (map_Option_tup2_R1_R2'1 frame (fun (f: tup2_R1_R2) -> f.f1'0)) in [@expl:frame_preserving ensures] let {f0'2 = to_auth; f1'2 = to_frag} = update_ProdLocalUpdate_U1_U2 self from_auth from_frag in op_Option_tup2_R1_R2 (Some to_frag) frame
    = Some'0 (Some to_auth)))))
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__factor (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum_R1_R2
  
  constant factor : t_Sum_R1_R2
  
  function factor_Sum_R1_R2 (self: t_Sum_R1_R2) (factor: t_Sum_R1_R2) : t_Option_Sum_R1_R2
  
  goal vc_factor_Sum_R1_R2: match { f0 = self; f1 = factor } with
      | {f0 = Left x; f1 = Left y} -> match factor_R1 x y with
          | Some'0 c -> op_R1 y c = Some'0 x
          | None'0 -> forall c: t_R1. op_R1 y c <> Some'0 x
          end
      -> ([@expl:factor ensures] match map_Option_R1 (factor_R1 x y) (fun (l: t_R1) -> Left l) with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end)
      | {f0 = Right x; f1 = Right y} -> match factor_R2 x y with
          | Some'1 c -> op_R2 y c = Some'1 x
          | None'1 -> forall c: t_R2. op_R2 y c <> Some'1 x
          end
      -> ([@expl:factor ensures] match map_Option_R2 (factor_R2 x y) (fun (r: t_R2) -> Right r) with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end)
      | _ -> [@expl:factor ensures] match None with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end
      end
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__commutative (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Sum_R1_R2
  
  constant b : t_Sum_R1_R2
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : ()
  
  goal vc_commutative_Sum_R1_R2: [@expl:commutative ensures] op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__associative (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Sum_R1_R2
  
  constant b : t_Sum_R1_R2
  
  constant c : t_Sum_R1_R2
  
  function associative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) (c: t_Sum_R1_R2) : ()
  
  goal vc_associative_Sum_R1_R2:
    [@expl:associative ensures] and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
    = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__core (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function core_R1 (self: t_R1) : t_Option_R1
  
  axiom core_R1_spec: forall self: t_R1. match core_R1 self with
        | Some'0 c -> op_R1 c c = Some'0 c /\ op_R1 c self = Some'0 self
        | None'0 -> true
        end
  
  function core_R2 (self: t_R2) : t_Option_R2
  
  axiom core_R2_spec: forall self: t_R2. match core_R2 self with
        | Some'1 c -> op_R2 c c = Some'1 c /\ op_R2 c self = Some'1 self
        | None'1 -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum_R1_R2
  
  function core_Sum_R1_R2 (self: t_Sum_R1_R2) : t_Option_Sum_R1_R2
  
  goal vc_core_Sum_R1_R2: match self with
      | Left x -> match core_R1 x with
          | Some'0 c -> op_R1 c c = Some'0 c /\ op_R1 c x = Some'0 x
          | None'0 -> true
          end
      -> ([@expl:core ensures] match map_Option_R1 (core_R1 x) (fun (l: t_R1) -> Left l) with
        | Some c -> op_Sum_R1_R2 c c = Some c /\ op_Sum_R1_R2 c self = Some self
        | None -> true
        end)
      | Right x -> match core_R2 x with
          | Some'1 c -> op_R2 c c = Some'1 c /\ op_R2 c x = Some'1 x
          | None'1 -> true
          end
      -> ([@expl:core ensures] match map_Option_R2 (core_R2 x) (fun (r: t_R2) -> Right r) with
        | Some c -> op_Sum_R1_R2 c c = Some c /\ op_Sum_R1_R2 c self = Some self
        | None -> true
        end)
      end
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__core_is_maximal_idemp (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function core_R1 (self: t_R1) : t_Option_R1
  
  axiom core_R1_spec: forall self: t_R1. match core_R1 self with
        | Some'0 c -> op_R1 c c = Some'0 c /\ op_R1 c self = Some'0 self
        | None'0 -> true
        end
  
  function core_R2 (self: t_R2) : t_Option_R2
  
  axiom core_R2_spec: forall self: t_R2. match core_R2 self with
        | Some'1 c -> op_R2 c c = Some'1 c /\ op_R2 c self = Some'1 self
        | None'1 -> true
        end
  
  function core_Sum_R1_R2 (self: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | Left x -> map_Option_R1 (core_R1 x) (fun (l: t_R1) -> Left l)
      | Right x -> map_Option_R2 (core_R2 x) (fun (r: t_R2) -> Right r)
      end
  
  axiom core_Sum_R1_R2_spec: forall self: t_Sum_R1_R2. match core_Sum_R1_R2 self with
        | Some c -> op_Sum_R1_R2 c c = Some c /\ op_Sum_R1_R2 c self = Some self
        | None -> true
        end
  
  function factor_Sum_R1_R2 (self: t_Sum_R1_R2) (factor: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                     f1 = factor } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (factor_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (factor_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  axiom factor_Sum_R1_R2_spec: forall self: t_Sum_R1_R2, factor: t_Sum_R1_R2. match factor_Sum_R1_R2 self factor with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end
  
  predicate incl_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) = factor_Sum_R1_R2 other self <> None
  
  function core_is_maximal_idemp_R1 (self: t_R1) (i: t_R1) : ()
  
  axiom core_is_maximal_idemp_R1_spec: forall self: t_R1, i: t_R1. op_R1 i i = Some'0 i
      -> op_R1 i self = Some'0 self
      -> match core_R1 self with
        | Some'0 c -> incl_R1 i c
        | None'0 -> false
        end
  
  function core_is_maximal_idemp_R2 (self: t_R2) (i: t_R2) : ()
  
  axiom core_is_maximal_idemp_R2_spec: forall self: t_R2, i: t_R2. op_R2 i i = Some'1 i
      -> op_R2 i self = Some'1 self
      -> match core_R2 self with
        | Some'1 c -> incl_R2 i c
        | None'1 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum_R1_R2
  
  constant i : t_Sum_R1_R2
  
  function core_is_maximal_idemp_Sum_R1_R2 (self: t_Sum_R1_R2) (i: t_Sum_R1_R2) : ()
  
  goal vc_core_is_maximal_idemp_Sum_R1_R2: op_Sum_R1_R2 i i = Some i
    -> op_Sum_R1_R2 i self = Some self
    -> match { f0 = self; f1 = i } with
      | {f0 = Left s; f1 = Left i'0} -> (([@expl:core_is_maximal_idemp requires #0] op_R1 i'0 i'0 = Some'0 i'0)
        && ([@expl:core_is_maximal_idemp requires #1] op_R1 i'0 s = Some'0 s))
      /\ (match core_R1 s with
          | Some'0 c -> incl_R1 i'0 c
          | None'0 -> false
          end
      -> ([@expl:core_is_maximal_idemp ensures] match core_Sum_R1_R2 self with
        | Some c -> incl_Sum_R1_R2 i c
        | None -> false
        end))
      | {f0 = Right s; f1 = Right i'0} -> (([@expl:core_is_maximal_idemp requires #0] op_R2 i'0 i'0 = Some'1 i'0)
        && ([@expl:core_is_maximal_idemp requires #1] op_R2 i'0 s = Some'1 s))
      /\ (match core_R2 s with
          | Some'1 c -> incl_R2 i'0 c
          | None'1 -> false
          end
      -> ([@expl:core_is_maximal_idemp ensures] match core_Sum_R1_R2 self with
        | Some c -> incl_Sum_R1_R2 i c
        | None -> false
        end))
      | _ -> [@expl:core_is_maximal_idemp ensures] match core_Sum_R1_R2 self with
        | Some c -> incl_Sum_R1_R2 i c
        | None -> false
        end
      end
end
module M_logic__ra__sum__impl_Update_for_SumUpdateL_U__update (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R1)
  
  predicate premise_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) =
    match from with
      | Left from'0 -> premise_U self.f0 from'0
      | Right _ -> false
      end
  
  function update_U (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateL_U
  
  constant from : t_Sum_R1_R2
  
  constant ch : t_Choice
  
  function update_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) (ch: t_Choice) : t_Sum_R1_R2
  
  goal vc_update_SumUpdateL_U: premise_SumUpdateL_U self from
    -> match from with
      | Left from'0 -> [@expl:update requires] premise_U self.f0 from'0
      | x -> true
      end
end
module M_logic__ra__sum__impl_Update_for_SumUpdateL_U__frame_preserving (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R1)
  
  predicate premise_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) =
    match from with
      | Left from'0 -> premise_U self.f0 from'0
      | Right _ -> false
      end
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function associative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) (c: t_Sum_R1_R2) : () = ()
  
  axiom associative_Sum_R1_R2_spec:
    forall a: t_Sum_R1_R2, b: t_Sum_R1_R2, c: t_Sum_R1_R2. and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
      = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function update_U (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) (ch: t_Choice) : t_Sum_R1_R2 = match from with
      | Left from'0 -> Left (update_U self.f0 from'0 ch)
      | x -> x
      end
  
  function frame_preserving_U (self: t_U) (from: t_R1) (frame: t_R1) : t_Choice
  
  axiom frame_preserving_U_spec: forall self: t_U, from: t_R1, frame: t_R1. premise_U self from
      -> op_R1 from frame <> None'0 -> op_R1 (update_U self from (frame_preserving_U self from frame)) frame <> None'0
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateL_U
  
  constant from : t_Sum_R1_R2
  
  constant frame : t_Sum_R1_R2
  
  function frame_preserving_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) (frame: t_Sum_R1_R2) : t_Choice
  
  goal vc_frame_preserving_SumUpdateL_U: premise_SumUpdateL_U self from
    -> op_Sum_R1_R2 from frame <> None
    -> match { f0'0 = from; f1'0 = frame } with
      | {f0'0 = Left from'0; f1'0 = Left frame'0} -> (([@expl:frame_preserving requires #0] premise_U self.f0 from'0)
        && ([@expl:frame_preserving requires #1] op_R1 from'0 frame'0 <> None'0))
      /\ (op_R1 (update_U self.f0 from'0 (frame_preserving_U self.f0 from'0 frame'0)) frame'0 <> None'0
      -> ([@expl:frame_preserving ensures] op_Sum_R1_R2 (update_SumUpdateL_U self from (frame_preserving_U self.f0 from'0 frame'0)) frame
      <> None))
      | _ -> ([@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) x)
      /\ (index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) (such_that_Choice (fun (__0: t_Choice) -> true))
      -> ([@expl:frame_preserving ensures] op_Sum_R1_R2 (update_SumUpdateL_U self from (such_that_Choice (fun (__0: t_Choice) -> true))) frame
      <> None))
      end
end
module M_logic__ra__sum__impl_Update_for_SumUpdateR_U__update (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateR_U = { f0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum_V_R = Left t_V | Right t_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) =
    match from with
      | Right from'0 -> premise_U self.f0 from'0
      | Left _ -> false
      end
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateR_U
  
  constant from : t_Sum_V_R
  
  constant ch : t_Choice
  
  function update_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) (ch: t_Choice) : t_Sum_V_R
  
  goal vc_update_SumUpdateR_U: premise_SumUpdateR_U self from
    -> match from with
      | Right from'0 -> [@expl:update requires] premise_U self.f0 from'0
      | x -> true
      end
end
module M_logic__ra__sum__impl_Update_for_SumUpdateR_U__frame_preserving (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateR_U = { f0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum_V_R = Left t_V | Right t_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) =
    match from with
      | Right from'0 -> premise_U self.f0 from'0
      | Left _ -> false
      end
  
  type t_Option_Sum_V_R = None | Some t_Sum_V_R
  
  function and_then_Option_Sum_V_R (self: t_Option_Sum_V_R) (f: Map.map t_Sum_V_R t_Option_Sum_V_R) : t_Option_Sum_V_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_V_R_Sum_V_R = { f0'0: t_Sum_V_R; f1'0: t_Sum_V_R }
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Sum_V_R) : t_Option_Sum_V_R = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  type t_Option_R = None'1 | Some'1 t_R
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Sum_V_R) : t_Option_Sum_V_R = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'1 c -> op_R factor c = Some'1 self
        | None'1 -> forall c: t_R. op_R factor c <> Some'1 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'1
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'1 comb -> incl_R self comb
  
  function op_Sum_V_R (self: t_Sum_V_R) (other: t_Sum_V_R) : t_Option_Sum_V_R = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_V (op_V x y) (fun (l: t_V) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R (op_R x y) (fun (r: t_R) -> Right r)
      | _ -> None
      end
  
  function associative_Sum_V_R (a: t_Sum_V_R) (b: t_Sum_V_R) (c: t_Sum_V_R) : () = ()
  
  axiom associative_Sum_V_R_spec:
    forall a: t_Sum_V_R, b: t_Sum_V_R, c: t_Sum_V_R. and_then_Option_Sum_V_R (op_Sum_V_R a b) (fun (ab: t_Sum_V_R) -> op_Sum_V_R ab c)
      = and_then_Option_Sum_V_R (op_Sum_V_R b c) (fun (bc: t_Sum_V_R) -> op_Sum_V_R a bc)
  
  function commutative_Sum_V_R (a: t_Sum_V_R) (b: t_Sum_V_R) : () = ()
  
  axiom commutative_Sum_V_R_spec: forall a: t_Sum_V_R, b: t_Sum_V_R. op_Sum_V_R a b = op_Sum_V_R b a
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) (ch: t_Choice) : t_Sum_V_R = match from with
      | Right from'0 -> Right (update_U self.f0 from'0 ch)
      | x -> x
      end
  
  function frame_preserving_U (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_U_spec: forall self: t_U, from: t_R, frame: t_R. premise_U self from
      -> op_R from frame <> None'1 -> op_R (update_U self from (frame_preserving_U self from frame)) frame <> None'1
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateR_U
  
  constant from : t_Sum_V_R
  
  constant frame : t_Sum_V_R
  
  function frame_preserving_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) (frame: t_Sum_V_R) : t_Choice
  
  goal vc_frame_preserving_SumUpdateR_U: premise_SumUpdateR_U self from
    -> op_Sum_V_R from frame <> None
    -> match { f0'0 = from; f1'0 = frame } with
      | {f0'0 = Right from'0; f1'0 = Right frame'0} -> (([@expl:frame_preserving requires #0] premise_U self.f0 from'0)
        && ([@expl:frame_preserving requires #1] op_R from'0 frame'0 <> None'1))
      /\ (op_R (update_U self.f0 from'0 (frame_preserving_U self.f0 from'0 frame'0)) frame'0 <> None'1
      -> ([@expl:frame_preserving ensures] op_Sum_V_R (update_SumUpdateR_U self from (frame_preserving_U self.f0 from'0 frame'0)) frame
      <> None))
      | _ -> ([@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) x)
      /\ (index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) (such_that_Choice (fun (__0: t_Choice) -> true))
      -> ([@expl:frame_preserving ensures] op_Sum_V_R (update_SumUpdateR_U self from (such_that_Choice (fun (__0: t_Choice) -> true))) frame
      <> None))
      end
end
module M_logic__ra__sum__impl_LocalUpdate_for_SumLocalUpdateL_U__frame_preserving (* <logic::ra::sum::SumLocalUpdateL<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  predicate premise_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise_SumLocalUpdateL_U (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Left from_auth'0; f1'0 = Left from_frag'0} -> premise_U self.f0 from_auth'0 from_frag'0
      | {f0'0 = Right _; f1'0 = Right _} -> false
      | _ -> true
      end
  
  type t_Option_Option_Sum_R1_R2 = None'0 | Some'0 t_Option_Sum_R1_R2
  
  function and_then_Option_Option_Sum_R1_R2 (self: t_Option_Option_Sum_R1_R2) (f: Map.map t_Option_Sum_R1_R2 t_Option_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_Sum_R1_R2_Option_Sum_R1_R2 = { f0'1: t_Option_Sum_R1_R2; f1'1: t_Option_Sum_R1_R2 }
  
  function map_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function associative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) (c: t_Sum_R1_R2) : () = ()
  
  axiom associative_Sum_R1_R2_spec:
    forall a: t_Sum_R1_R2, b: t_Sum_R1_R2, c: t_Sum_R1_R2. and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
      = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function op_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (other: t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_Sum_R1_R2 (op_Sum_R1_R2 x y) (fun (z: t_Sum_R1_R2) -> Some z)
      end
  
  function associative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) (c: t_Option_Sum_R1_R2) : ()
  
  axiom associative_Option_Sum_R1_R2_spec:
    forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2, c: t_Option_Sum_R1_R2. and_then_Option_Option_Sum_R1_R2 (op_Option_Sum_R1_R2 a b) (fun (ab: t_Option_Sum_R1_R2) -> op_Option_Sum_R1_R2 ab c)
      = and_then_Option_Option_Sum_R1_R2 (op_Option_Sum_R1_R2 b c) (fun (bc: t_Option_Sum_R1_R2) -> op_Option_Sum_R1_R2 a bc)
  
  function commutative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) : ()
  
  axiom commutative_Option_Sum_R1_R2_spec: forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 a b
      = op_Option_Sum_R1_R2 b a
  
  type tup2_R1_R1 = { f0'2: t_R1; f1'2: t_R1 }
  
  function update_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1) : tup2_R1_R1
  
  predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool [@inline:trivial] (self: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) (a: tup2_Sum_R1_R2_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool
  
  function such_that_tup2_Sum_R1_R2_Sum_R1_R2 (p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) : tup2_Sum_R1_R2_Sum_R1_R2
  
  axiom such_that_tup2_Sum_R1_R2_Sum_R1_R2_spec:
    forall p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool. (exists x: tup2_Sum_R1_R2_Sum_R1_R2. index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p x)
      -> index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p (such_that_tup2_Sum_R1_R2_Sum_R1_R2 p)
  
  function update_SumLocalUpdateL_U (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) : tup2_Sum_R1_R2_Sum_R1_R2
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Left from_auth'0; f1'0 = Left from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in { f0'0 = Left to_auth;
                                                                                                                                                   f1'0 = Left to_frag }
      | _ -> such_that_tup2_Sum_R1_R2_Sum_R1_R2 (fun (__0: tup2_Sum_R1_R2_Sum_R1_R2) -> true)
      end
  
  type tup3_Sum_R1_R2_Sum_R1_R2_Option_Sum_R1_R2 = { f0'3: t_Sum_R1_R2; f1'3: t_Sum_R1_R2; f2'3: t_Option_Sum_R1_R2 }
  
  type t_Option_Option_R1 = None'3 | Some'3 t_Option_R1
  
  function and_then_Option_Option_R1 (self: t_Option_Option_R1) (f: Map.map t_Option_R1 t_Option_Option_R1) : t_Option_Option_R1
   = match self with
      | None'3 -> None'3
      | Some'3 x -> Map.get f x
      end
  
  type tup2_Option_R1_Option_R1 = { f0'4: t_Option_R1; f1'4: t_Option_R1 }
  
  function map_Option_R1'0 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_Option_R1 = match self with
      | None'1 -> None'3
      | Some'1 x -> Some'3 (Map.get f x)
      end
  
  function op_Option_R1 (self: t_Option_R1) (other: t_Option_R1) : t_Option_Option_R1 = match { f0'4 = self;
                                                                                                f1'4 = other } with
      | {f0'4 = None'1} -> Some'3 other
      | {f1'4 = None'1} -> Some'3 self
      | {f0'4 = Some'1 x; f1'4 = Some'1 y} -> map_Option_R1'0 (op_R1 x y) (fun (z: t_R1) -> Some'1 z)
      end
  
  function associative_Option_R1 (a: t_Option_R1) (b: t_Option_R1) (c: t_Option_R1) : ()
  
  axiom associative_Option_R1_spec:
    forall a: t_Option_R1, b: t_Option_R1, c: t_Option_R1. and_then_Option_Option_R1 (op_Option_R1 a b) (fun (ab: t_Option_R1) -> op_Option_R1 ab c)
      = and_then_Option_Option_R1 (op_Option_R1 b c) (fun (bc: t_Option_R1) -> op_Option_R1 a bc)
  
  function commutative_Option_R1 (a: t_Option_R1) (b: t_Option_R1) : ()
  
  axiom commutative_Option_R1_spec: forall a: t_Option_R1, b: t_Option_R1. op_Option_R1 a b = op_Option_R1 b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1) (frame: t_Option_R1) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R1, from_frag: t_R1, frame: t_Option_R1. premise_U self from_auth from_frag
      -> op_Option_R1 (Some'1 from_frag) frame = Some'3 (Some'1 from_auth)
      -> (let {f0'2 = to_auth; f1'2 = to_frag} = update_U self from_auth from_frag in op_Option_R1 (Some'1 to_frag) frame
      = Some'3 (Some'1 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumLocalUpdateL_U
  
  constant from_auth : t_Sum_R1_R2
  
  constant from_frag : t_Sum_R1_R2
  
  constant frame : t_Option_Sum_R1_R2
  
  function frame_preserving_SumLocalUpdateL_U (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) (frame: t_Option_Sum_R1_R2) : ()
  
  goal vc_frame_preserving_SumLocalUpdateL_U: premise_SumLocalUpdateL_U self from_auth from_frag
    -> op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
    -> match { f0'3 = from_auth; f1'3 = from_frag; f2'3 = frame } with
      | {f0'3 = Left from_auth'0; f1'3 = Left from_frag'0; f2'3 = Some (Left frame'0)} -> (([@expl:frame_preserving requires #0] premise_U self.f0 from_auth'0 from_frag'0)
        && ([@expl:frame_preserving requires #1] op_Option_R1 (Some'1 from_frag'0) (Some'1 frame'0)
        = Some'3 (Some'1 from_auth'0)))
      /\ ((let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in op_Option_R1 (Some'1 to_frag) (Some'1 frame'0)
        = Some'3 (Some'1 to_auth))
      -> ([@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)))
      | {f0'3 = Left from_auth'0; f1'3 = Left from_frag'0; f2'3 = None} -> (([@expl:frame_preserving requires #0] premise_U self.f0 from_auth'0 from_frag'0)
        && ([@expl:frame_preserving requires #1] op_Option_R1 (Some'1 from_frag'0) (None'1)
        = Some'3 (Some'1 from_auth'0)))
      /\ ((let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in op_Option_R1 (Some'1 to_frag) (None'1)
        = Some'3 (Some'1 to_auth))
      -> ([@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)))
      | _ -> [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)
      end
end
module M_logic__ra__sum__impl_LocalUpdate_for_SumLocalUpdateR_U__frame_preserving (* <logic::ra::sum::SumLocalUpdateR<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateR_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  predicate premise_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise_SumLocalUpdateR_U (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Right from_auth'0; f1'0 = Right from_frag'0} -> premise_U self.f0 from_auth'0 from_frag'0
      | {f0'0 = Left _; f1'0 = Left _} -> false
      | _ -> true
      end
  
  type t_Option_Option_Sum_R1_R2 = None'0 | Some'0 t_Option_Sum_R1_R2
  
  function and_then_Option_Option_Sum_R1_R2 (self: t_Option_Option_Sum_R1_R2) (f: Map.map t_Option_Sum_R1_R2 t_Option_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_Sum_R1_R2_Option_Sum_R1_R2 = { f0'1: t_Option_Sum_R1_R2; f1'1: t_Option_Sum_R1_R2 }
  
  function map_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function associative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) (c: t_Sum_R1_R2) : () = ()
  
  axiom associative_Sum_R1_R2_spec:
    forall a: t_Sum_R1_R2, b: t_Sum_R1_R2, c: t_Sum_R1_R2. and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
      = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function op_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (other: t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_Sum_R1_R2 (op_Sum_R1_R2 x y) (fun (z: t_Sum_R1_R2) -> Some z)
      end
  
  function associative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) (c: t_Option_Sum_R1_R2) : ()
  
  axiom associative_Option_Sum_R1_R2_spec:
    forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2, c: t_Option_Sum_R1_R2. and_then_Option_Option_Sum_R1_R2 (op_Option_Sum_R1_R2 a b) (fun (ab: t_Option_Sum_R1_R2) -> op_Option_Sum_R1_R2 ab c)
      = and_then_Option_Option_Sum_R1_R2 (op_Option_Sum_R1_R2 b c) (fun (bc: t_Option_Sum_R1_R2) -> op_Option_Sum_R1_R2 a bc)
  
  function commutative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) : ()
  
  axiom commutative_Option_Sum_R1_R2_spec: forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 a b
      = op_Option_Sum_R1_R2 b a
  
  type tup2_R2_R2 = { f0'2: t_R2; f1'2: t_R2 }
  
  function update_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2) : tup2_R2_R2
  
  predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool [@inline:trivial] (self: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) (a: tup2_Sum_R1_R2_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool
  
  function such_that_tup2_Sum_R1_R2_Sum_R1_R2 (p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) : tup2_Sum_R1_R2_Sum_R1_R2
  
  axiom such_that_tup2_Sum_R1_R2_Sum_R1_R2_spec:
    forall p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool. (exists x: tup2_Sum_R1_R2_Sum_R1_R2. index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p x)
      -> index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p (such_that_tup2_Sum_R1_R2_Sum_R1_R2 p)
  
  function update_SumLocalUpdateR_U (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) : tup2_Sum_R1_R2_Sum_R1_R2
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Right from_auth'0; f1'0 = Right from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in { f0'0 = Right to_auth;
                                                                                                                                                     f1'0 = Right to_frag }
      | _ -> such_that_tup2_Sum_R1_R2_Sum_R1_R2 (fun (__0: tup2_Sum_R1_R2_Sum_R1_R2) -> true)
      end
  
  type tup3_Sum_R1_R2_Sum_R1_R2_Option_Sum_R1_R2 = { f0'3: t_Sum_R1_R2; f1'3: t_Sum_R1_R2; f2'3: t_Option_Sum_R1_R2 }
  
  type t_Option_Option_R2 = None'3 | Some'3 t_Option_R2
  
  function and_then_Option_Option_R2 (self: t_Option_Option_R2) (f: Map.map t_Option_R2 t_Option_Option_R2) : t_Option_Option_R2
   = match self with
      | None'3 -> None'3
      | Some'3 x -> Map.get f x
      end
  
  type tup2_Option_R2_Option_R2 = { f0'4: t_Option_R2; f1'4: t_Option_R2 }
  
  function map_Option_R2'0 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_Option_R2 = match self with
      | None'2 -> None'3
      | Some'2 x -> Some'3 (Map.get f x)
      end
  
  function op_Option_R2 (self: t_Option_R2) (other: t_Option_R2) : t_Option_Option_R2 = match { f0'4 = self;
                                                                                                f1'4 = other } with
      | {f0'4 = None'2} -> Some'3 other
      | {f1'4 = None'2} -> Some'3 self
      | {f0'4 = Some'2 x; f1'4 = Some'2 y} -> map_Option_R2'0 (op_R2 x y) (fun (z: t_R2) -> Some'2 z)
      end
  
  function associative_Option_R2 (a: t_Option_R2) (b: t_Option_R2) (c: t_Option_R2) : ()
  
  axiom associative_Option_R2_spec:
    forall a: t_Option_R2, b: t_Option_R2, c: t_Option_R2. and_then_Option_Option_R2 (op_Option_R2 a b) (fun (ab: t_Option_R2) -> op_Option_R2 ab c)
      = and_then_Option_Option_R2 (op_Option_R2 b c) (fun (bc: t_Option_R2) -> op_Option_R2 a bc)
  
  function commutative_Option_R2 (a: t_Option_R2) (b: t_Option_R2) : ()
  
  axiom commutative_Option_R2_spec: forall a: t_Option_R2, b: t_Option_R2. op_Option_R2 a b = op_Option_R2 b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2) (frame: t_Option_R2) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R2, from_frag: t_R2, frame: t_Option_R2. premise_U self from_auth from_frag
      -> op_Option_R2 (Some'2 from_frag) frame = Some'3 (Some'2 from_auth)
      -> (let {f0'2 = to_auth; f1'2 = to_frag} = update_U self from_auth from_frag in op_Option_R2 (Some'2 to_frag) frame
      = Some'3 (Some'2 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumLocalUpdateR_U
  
  constant from_auth : t_Sum_R1_R2
  
  constant from_frag : t_Sum_R1_R2
  
  constant frame : t_Option_Sum_R1_R2
  
  function frame_preserving_SumLocalUpdateR_U (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) (frame: t_Option_Sum_R1_R2) : ()
  
  goal vc_frame_preserving_SumLocalUpdateR_U: premise_SumLocalUpdateR_U self from_auth from_frag
    -> op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
    -> match { f0'3 = from_auth; f1'3 = from_frag; f2'3 = frame } with
      | {f0'3 = Right from_auth'0; f1'3 = Right from_frag'0; f2'3 = Some (Right frame'0)} -> (([@expl:frame_preserving requires #0] premise_U self.f0 from_auth'0 from_frag'0)
        && ([@expl:frame_preserving requires #1] op_Option_R2 (Some'2 from_frag'0) (Some'2 frame'0)
        = Some'3 (Some'2 from_auth'0)))
      /\ ((let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in op_Option_R2 (Some'2 to_frag) (Some'2 frame'0)
        = Some'3 (Some'2 to_auth))
      -> ([@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)))
      | {f0'3 = Right from_auth'0; f1'3 = Right from_frag'0; f2'3 = None} -> (([@expl:frame_preserving requires #0] premise_U self.f0 from_auth'0 from_frag'0)
        && ([@expl:frame_preserving requires #1] op_Option_R2 (Some'2 from_frag'0) (None'2)
        = Some'3 (Some'2 from_auth'0)))
      /\ ((let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in op_Option_R2 (Some'2 to_frag) (None'2)
        = Some'3 (Some'2 to_auth))
      -> ([@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)))
      | _ -> [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)
      end
end
module M_logic__ra__update__impl_Update_for_Snapshot_R__update (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate premise_Snapshot_R (self: t_R) (from: t_R) = forall y: t_R. op_R from y <> None -> op_R self y <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_R
  
  constant from : t_R
  
  constant _3 : ()
  
  function update_Snapshot_R (self: t_R) (from: t_R) (_3: ()) : t_R
  
  goal vc_update_Snapshot_R: true
end
module M_logic__ra__update__impl_Update_for_Snapshot_R__frame_preserving (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate premise_Snapshot_R (self: t_R) (from: t_R) = forall y: t_R. op_R from y <> None -> op_R self y <> None
  
  function update_Snapshot_R (self: t_R) (from: t_R) (_3: ()) : t_R = self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_R
  
  constant from : t_R
  
  constant frame : t_R
  
  function frame_preserving_Snapshot_R (self: t_R) (from: t_R) (frame: t_R) : ()
  
  goal vc_frame_preserving_Snapshot_R: premise_Snapshot_R self from
    -> op_R from frame <> None -> ([@expl:frame_preserving ensures] op_R (update_Snapshot_R self from ()) frame <> None)
end
module M_logic__ra__update__impl_Update_for_Snapshot_Mapping_Choice_R__update (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function index_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_R
  
  predicate premise_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> (exists ch: t_Choice. op_R (index_Mapping_Choice_R self ch) y <> None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Map.map t_Choice t_R
  
  constant from : t_R
  
  constant ch : t_Choice
  
  function update_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R
  
  goal vc_update_Snapshot_Mapping_Choice_R: true
end
module M_logic__ra__update__impl_Update_for_Snapshot_Mapping_Choice_R__frame_preserving (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function index_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_R
  
  predicate premise_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> (exists ch: t_Choice. op_R (index_Mapping_Choice_R self ch) y <> None)
  
  function update_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R =
    index_Mapping_Choice_R self ch
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Map.map t_Choice t_R
  
  constant from : t_R
  
  constant frame : t_R
  
  function frame_preserving_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) (frame: t_R) : t_Choice
  
  goal vc_frame_preserving_Snapshot_Mapping_Choice_R: premise_Snapshot_Mapping_Choice_R self from
    -> op_R from frame <> None
    -> (forall ch: t_Choice. [@expl:update requires] premise_Snapshot_Mapping_Choice_R self from)
    /\ ([@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (ch: t_Choice) -> op_R (update_Snapshot_Mapping_Choice_R self from ch) frame
        <> None) x)
    /\ (index_Mapping_Choice_bool (fun (ch: t_Choice) -> op_R (update_Snapshot_Mapping_Choice_R self from ch) frame
      <> None) (such_that_Choice (fun (ch: t_Choice) -> op_R (update_Snapshot_Mapping_Choice_R self from ch) frame
      <> None))
    -> ([@expl:frame_preserving ensures] op_R (update_Snapshot_Mapping_Choice_R self from (such_that_Choice (fun (ch: t_Choice) -> op_R (update_Snapshot_Mapping_Choice_R self from ch) frame
      <> None))) frame
    <> None))
end
module M_logic__ra__update__impl_LocalUpdate_for_Snapshot_tup2_R_R__frame_preserving (* <snapshot::Snapshot<(R, R)> as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type tup2_R_R = { f0: t_R; f1: t_R }
  
  type t_Option_R = None | Some t_R
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  function and_then_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_R
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function associative_Option_R (a: t_Option_R) (b: t_Option_R) (c: t_Option_R) : ()
  
  axiom associative_Option_R_spec:
    forall a: t_Option_R, b: t_Option_R, c: t_Option_R. and_then_Option_Option_R (op_Option_R a b) (fun (ab: t_Option_R) -> op_Option_R ab c)
      = and_then_Option_Option_R (op_Option_R b c) (fun (bc: t_Option_R) -> op_Option_R a bc)
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  predicate premise_Snapshot_tup2_R_R (self: tup2_R_R) (from_auth: t_R) (from_frag: t_R) =
    forall f: t_Option_R. op_Option_R (Some from_frag) f = Some'0 (Some from_auth)
      -> op_Option_R (Some (self.f1)) f = Some'0 (Some (self.f0))
  
  function update_Snapshot_tup2_R_R (self: tup2_R_R) (_2: t_R) (_3: t_R) : tup2_R_R = self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_R_R
  
  constant from_auth : t_R
  
  constant from_frag : t_R
  
  constant frame : t_Option_R
  
  function frame_preserving_Snapshot_tup2_R_R (self: tup2_R_R) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  goal vc_frame_preserving_Snapshot_tup2_R_R: premise_Snapshot_tup2_R_R self from_auth from_frag
    -> op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
    -> ([@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update_Snapshot_tup2_R_R self from_auth from_frag in op_Option_R (Some to_frag) frame
    = Some'0 (Some to_auth))
end
module M_logic__ra__view__impl_InhabitedInvariant_for_InnerView_R__inhabits (* <logic::ra::view::InnerView<R> as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function inhabits_InnerView_R : t_InnerView_R
  
  goal vc_inhabits_InnerView_R: (forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x)
    -> ([@expl:inhabits ensures] invariant_InnerView_R { auth = None; frag = unit_Frag })
end
module M_logic__ra__view__impl_View_R__frag (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  function frag_R (self: t_View_R) : t_Frag
  
  goal vc_frag_R: invariant_InnerView_R (view_Subset_InnerView_R self.f0)
    -> ([@expl:frag ensures] rel_R (auth_R self) (view_Subset_InnerView_R self.f0).frag)
end
module M_logic__ra__view__impl_View_R__ext_eq (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function view_inj_InnerView_R (self: t_Subset_InnerView_R) (other: t_Subset_InnerView_R) : ()
  
  axiom view_inj_InnerView_R_spec:
    forall self: t_Subset_InnerView_R, other: t_Subset_InnerView_R. view_Subset_InnerView_R self
        = view_Subset_InnerView_R other -> self = other
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  constant other : t_View_R
  
  predicate ext_eq_R (self: t_View_R) (other: t_View_R)
  
  goal vc_ext_eq_R: if auth_R self = auth_R other then
      rel_R (auth_R self) (frag_R self)
      -> rel_R (auth_R other) (frag_R other) -> ([@expl:ext_eq ensures] (frag_R self = frag_R other) = (self = other))
    else
      [@expl:ext_eq ensures] false = (self = other)

end
module M_logic__ra__view__impl_View_R__new (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant auth'0 : t_Option_Auth
  
  constant frag'0 : t_Frag
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R
  
  goal vc_new_R: rel_R auth'0 frag'0
    -> ([@expl:new_logic requires] invariant_InnerView_R { auth = auth'0; frag = frag'0 })
    /\ (view_Subset_InnerView_R (new_InnerView_R { auth = auth'0; frag = frag'0 }) = { auth = auth'0; frag = frag'0 }
    -> (let result = { f0 = new_InnerView_R { auth = auth'0; frag = frag'0 } } in ([@expl:new ensures #0] auth_R result
      = auth'0)
    && ([@expl:new ensures #1] frag_R result = frag'0)))
end
module M_logic__ra__view__impl_View_R__new_frag (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant frag'0 : t_Frag
  
  function new_frag_R (frag'0: t_Frag) : t_View_R
  
  goal vc_new_frag_R: rel_R (None) frag'0 -> ([@expl:new requires] rel_R (None) frag'0)
end
module M_logic__ra__view__impl_RA_for_View_R__factor (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function view_inj_InnerView_R (self: t_Subset_InnerView_R) (other: t_Subset_InnerView_R) : ()
  
  axiom view_inj_InnerView_R_spec:
    forall self: t_Subset_InnerView_R, other: t_Subset_InnerView_R. view_Subset_InnerView_R self
        = view_Subset_InnerView_R other -> self = other
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  constant factor : t_View_R
  
  function factor_View_R (self: t_View_R) (factor: t_View_R) : t_Option_View_R
  
  goal vc_factor_View_R: rel_R (auth_R self) (frag_R self)
    -> rel_R (auth_R factor) (frag_R factor)
    -> match factor_Frag (frag_R self) (frag_R factor) with
        | Some'0 c -> op_Frag (frag_R factor) c = Some'0 (frag_R self)
        | None'0 -> forall c: t_Frag. op_Frag (frag_R factor) c <> Some'0 (frag_R self)
        end
    -> match factor_Frag (frag_R self) (frag_R factor) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R factor } with
        | {f0'0 = Some'1 a; f1'0 = None'1} -> ([@expl:new requires] rel_R (Some'1 a) f)
        /\ (auth_R (new_R (Some'1 a) f) = Some'1 a && frag_R (new_R (Some'1 a) f) = f
        -> ([@expl:factor ensures] match Some (new_R (Some'1 a) f) with
          | Some c -> op_View_R factor c = Some self
          | None -> forall c: t_View_R. op_View_R factor c <> Some self
          end))
        | {f0'0 = a1; f1'0 = a2} -> if a1 = a2 then
          ([@expl:new_frag requires] rel_R (None'1) f)
          /\ ([@expl:factor ensures] match Some (new_frag_R f) with
            | Some c -> op_View_R factor c = Some self
            | None -> forall c: t_View_R. op_View_R factor c <> Some self
            end)
        else
          [@expl:factor ensures] match None with
            | Some c -> op_View_R factor c = Some self
            | None -> forall c: t_View_R. op_View_R factor c <> Some self
            end
        
        end
      | None'0 -> [@expl:factor ensures] match None with
        | Some c -> op_View_R factor c = Some self
        | None -> forall c: t_View_R. op_View_R factor c <> Some self
        end
      end
end
module M_logic__ra__view__impl_RA_for_View_R__commutative (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_View_R
  
  constant b : t_View_R
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : ()
  
  goal vc_commutative_View_R: [@expl:commutative ensures] op_View_R a b = op_View_R b a
end
module M_logic__ra__view__impl_RA_for_View_R__associative (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  type tup2_Option_Frag_Option_Frag = { f0'1: t_Option_Frag; f1'1: t_Option_Frag }
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth; f2'2: t_Option_Auth }
  
  function view_inj_InnerView_R (self: t_Subset_InnerView_R) (other: t_Subset_InnerView_R) : ()
  
  axiom view_inj_InnerView_R_spec:
    forall self: t_Subset_InnerView_R, other: t_Subset_InnerView_R. view_Subset_InnerView_R self
        = view_Subset_InnerView_R other -> self = other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_View_R
  
  constant b : t_View_R
  
  constant c : t_View_R
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : ()
  
  goal vc_associative_View_R: rel_R (auth_R a) (frag_R a)
    -> rel_R (auth_R b) (frag_R b)
    -> rel_R (auth_R b) (frag_R b)
    -> rel_R (auth_R c) (frag_R c)
    -> match { f0'1 = op_Frag (frag_R a) (frag_R b); f1'1 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'1 = Some'0 fab; f1'1 = Some'0 fbc} -> rel_R (auth_R c) (frag_R c)
      -> rel_R (auth_R a) (frag_R a)
      -> match { f0'1 = op_Frag fab (frag_R c); f1'1 = op_Frag (frag_R a) fbc } with
        | {f0'1 = Some'0 fabc1; f1'1 = Some'0 fabc2} -> fabc1 = fabc2
        && match { f0'2 = auth_R a; f1'2 = auth_R b; f2'2 = auth_R c } with
          | {f0'2 = Some'1 _; f1'2 = None'1; f2'2 = None'1} | {f0'2 = None'1; f1'2 = Some'1 _; f2'2 = None'1} | {f0'2 = None'1; f1'2 = None'1; f2'2 = Some'1 _} -> [@expl:associative ensures] and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
          = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
          | _ -> [@expl:associative ensures] and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
          = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
          end
        | _ -> [@expl:associative ensures] and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
        = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
        end
      | _ -> [@expl:associative ensures] and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
      end
end
module M_logic__ra__view__impl_RA_for_View_R__core (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_total_View_R (self: t_View_R) : t_View_R = new_frag_R (core_total_Frag (frag_R self))
  
  axiom core_total_View_R_spec: forall self: t_View_R. op_View_R (core_total_View_R self) (core_total_View_R self)
      = Some (core_total_View_R self)
  
  axiom core_total_View_R_spec'0: forall self: t_View_R. op_View_R (core_total_View_R self) self = Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R
  
  goal vc_core_View_R: op_View_R (core_total_View_R self) (core_total_View_R self) = Some (core_total_View_R self)
      && op_View_R (core_total_View_R self) self = Some self
    -> ([@expl:core ensures] match Some (core_total_View_R self) with
      | Some c -> op_View_R c c = Some c /\ op_View_R c self = Some self
      | None -> true
      end)
end
module M_logic__ra__view__impl_RA_for_View_R__core_is_maximal_idemp (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_total_View_R (self: t_View_R) : t_View_R = new_frag_R (core_total_Frag (frag_R self))
  
  axiom core_total_View_R_spec: forall self: t_View_R. op_View_R (core_total_View_R self) (core_total_View_R self)
      = Some (core_total_View_R self)
  
  axiom core_total_View_R_spec'0: forall self: t_View_R. op_View_R (core_total_View_R self) self = Some self
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (core_total_View_R self)
  
  axiom core_View_R_spec: forall self: t_View_R. match core_View_R self with
        | Some c -> op_View_R c c = Some c /\ op_View_R c self = Some self
        | None -> true
        end
  
  function factor_View_R (self: t_View_R) (factor: t_View_R) : t_Option_View_R =
    match factor_Frag (frag_R self) (frag_R factor) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R factor } with
        | {f0'0 = Some'1 a; f1'0 = None'1} -> Some (new_R (Some'1 a) f)
        | {f0'0 = a1; f1'0 = a2} -> if a1 = a2 then Some (new_frag_R f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_R_spec: forall self: t_View_R, factor: t_View_R. match factor_View_R self factor with
        | Some c -> op_View_R factor c = Some self
        | None -> forall c: t_View_R. op_View_R factor c <> Some self
        end
  
  predicate incl_View_R (self: t_View_R) (other: t_View_R) = factor_View_R other self <> None
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  axiom core_Frag_spec: forall self: t_Frag. match core_Frag self with
        | Some'0 c -> op_Frag c c = Some'0 c /\ op_Frag c self = Some'0 self
        | None'0 -> true
        end
  
  function core_is_total_Frag (self: t_Frag) : ()
  
  axiom core_is_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  function core_is_maximal_idemp_Frag (self: t_Frag) (i: t_Frag) : ()
  
  axiom core_is_maximal_idemp_Frag_spec: forall self: t_Frag, i: t_Frag. op_Frag i i = Some'0 i
      -> op_Frag i self = Some'0 self
      -> match core_Frag self with
        | Some'0 c -> incl_Frag i c
        | None'0 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  constant i : t_View_R
  
  function core_is_maximal_idemp_View_R (self: t_View_R) (i: t_View_R) : ()
  
  goal vc_core_is_maximal_idemp_View_R: op_View_R i i = Some i
    -> op_View_R i self = Some self
    -> rel_R (auth_R self) (frag_R self)
    -> rel_R (auth_R i) (frag_R i)
    -> (([@expl:core_is_maximal_idemp requires #0] op_Frag (frag_R i) (frag_R i) = Some'0 (frag_R i))
      && ([@expl:core_is_maximal_idemp requires #1] op_Frag (frag_R i) (frag_R self) = Some'0 (frag_R self)))
    /\ (match core_Frag (frag_R self) with
        | Some'0 c -> incl_Frag (frag_R i) c
        | None'0 -> false
        end
    -> ([@expl:core_is_maximal_idemp ensures] match core_View_R self with
      | Some c -> incl_View_R i c
      | None -> false
      end))
end
module M_logic__ra__view__impl_UnitRA_for_View_R__unit (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Option_Frag_Option_Frag = { f0'0: t_Option_Frag; f1'0: t_Option_Frag }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth; f2'1: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None'1; f1'2 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'2 = a; f1'2 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'0 = op_Frag (frag_R a) (frag_R b); f1'0 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'0 = Some'0 fab; f1'0 = Some'0 fbc} -> match { f0'0 = op_Frag fab (frag_R c);
                                                          f1'0 = op_Frag (frag_R a) fbc } with
        | {f0'0 = Some'0 fabc1; f1'0 = Some'0 fabc2} -> match { f0'1 = auth_R a; f1'1 = auth_R b; f2'1 = auth_R c } with
          | {f0'1 = Some'1 _; f1'1 = None'1; f2'1 = None'1} | {f0'1 = None'1; f1'1 = Some'1 _; f2'1 = None'1} | {f0'1 = None'1; f1'1 = None'1; f2'1 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  predicate ext_eq_R (self: t_View_R) (other: t_View_R) = auth_R self = auth_R other /\ frag_R self = frag_R other
  
  axiom ext_eq_R_spec: forall self: t_View_R, other: t_View_R. ext_eq_R self other = (self = other)
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_View_R : t_View_R
  
  goal vc_unit_View_R: (forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x)
    -> ([@expl:new_frag requires] rel_R (None'1) unit_Frag)
    /\ (let result = new_frag_R unit_Frag in [@expl:unit ensures] forall x: t_View_R [op_View_R x result]. op_View_R x result
      = Some x)
end
module M_logic__ra__view__impl_UnitRA_for_View_R__core_total (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Option_Frag_Option_Frag = { f0'0: t_Option_Frag; f1'0: t_Option_Frag }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth; f2'1: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None'1; f1'2 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'2 = a; f1'2 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'0 = op_Frag (frag_R a) (frag_R b); f1'0 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'0 = Some'0 fab; f1'0 = Some'0 fbc} -> match { f0'0 = op_Frag fab (frag_R c);
                                                          f1'0 = op_Frag (frag_R a) fbc } with
        | {f0'0 = Some'0 fabc1; f1'0 = Some'0 fabc2} -> match { f0'1 = auth_R a; f1'1 = auth_R b; f2'1 = auth_R c } with
          | {f0'1 = Some'1 _; f1'1 = None'1; f2'1 = None'1} | {f0'1 = None'1; f1'1 = Some'1 _; f2'1 = None'1} | {f0'1 = None'1; f1'1 = None'1; f2'1 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  axiom core_Frag_spec: forall self: t_Frag. match core_Frag self with
        | Some'0 c -> op_Frag c c = Some'0 c /\ op_Frag c self = Some'0 self
        | None'0 -> true
        end
  
  function core_is_total_Frag (self: t_Frag) : ()
  
  axiom core_is_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  predicate ext_eq_R (self: t_View_R) (other: t_View_R) = auth_R self = auth_R other /\ frag_R self = frag_R other
  
  axiom ext_eq_R_spec: forall self: t_View_R, other: t_View_R. ext_eq_R self other = (self = other)
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  function core_total_View_R (self: t_View_R) : t_View_R
  
  goal vc_core_total_View_R: rel_R (auth_R self) (frag_R self)
    -> op_Frag (core_total_Frag (frag_R self)) (core_total_Frag (frag_R self)) = Some'0 (core_total_Frag (frag_R self))
      && op_Frag (core_total_Frag (frag_R self)) (frag_R self) = Some'0 (frag_R self)
    -> ([@expl:new_frag requires] rel_R (None'1) (core_total_Frag (frag_R self)))
    /\ (let result = new_frag_R (core_total_Frag (frag_R self)) in ([@expl:core_total ensures #0] op_View_R result result
      = Some result)
    && ([@expl:core_total ensures #1] op_View_R result self = Some self))
end
module M_logic__ra__view__impl_UnitRA_for_View_R__core_is_total (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  type tup2_Option_Frag_Option_Frag = { f0'1: t_Option_Frag; f1'1: t_Option_Frag }
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth; f2'2: t_Option_Auth }
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'1 = op_Frag (frag_R a) (frag_R b); f1'1 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'1 = Some'0 fab; f1'1 = Some'0 fbc} -> match { f0'1 = op_Frag fab (frag_R c);
                                                          f1'1 = op_Frag (frag_R a) fbc } with
        | {f0'1 = Some'0 fabc1; f1'1 = Some'0 fabc2} -> match { f0'2 = auth_R a; f1'2 = auth_R b; f2'2 = auth_R c } with
          | {f0'2 = Some'1 _; f1'2 = None'1; f2'2 = None'1} | {f0'2 = None'1; f1'2 = Some'1 _; f2'2 = None'1} | {f0'2 = None'1; f1'2 = None'1; f2'2 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_total_View_R (self: t_View_R) : t_View_R = new_frag_R (core_total_Frag (frag_R self))
  
  axiom core_total_View_R_spec: forall self: t_View_R. op_View_R (core_total_View_R self) (core_total_View_R self)
      = Some (core_total_View_R self)
  
  axiom core_total_View_R_spec'0: forall self: t_View_R. op_View_R (core_total_View_R self) self = Some self
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (core_total_View_R self)
  
  axiom core_View_R_spec: forall self: t_View_R. match core_View_R self with
        | Some c -> op_View_R c c = Some c /\ op_View_R c self = Some self
        | None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  function core_is_total_View_R (self: t_View_R) : ()
  
  goal vc_core_is_total_View_R: [@expl:core_is_total ensures] core_View_R self = Some (core_total_View_R self)
end
module M_logic__ra__view__impl_Update_for_ViewUpdate_R_Choice__update (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Auth_Frag = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate_R_Choice = { f0'0: Map.map t_Choice tup2_Auth_Frag }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'1: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'1).auth
  
  function index_Mapping_Choice_tup2_Auth_Frag [@inline:trivial] (self: Map.map t_Choice tup2_Auth_Frag) (a: t_Choice) : tup2_Auth_Frag
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_tup2_Auth_Frag
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0'1).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) =
    auth_R from <> None
    /\ (forall ch: t_Choice. rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
    /\ (forall frame: t_Frag. match op_Frag (frag_R from) frame with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end
      -> (exists ch: t_Choice. match op_Frag (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1 frame with
          | Some'0 ff -> rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) ff
          | None'0 -> false
          end))
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'1 = new_InnerView_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdate_R_Choice
  
  constant from : t_View_R
  
  constant ch : t_Choice
  
  function update_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) (ch: t_Choice) : t_View_R
  
  goal vc_update_ViewUpdate_R_Choice: premise_ViewUpdate_R_Choice self from
    -> ([@expl:new requires] rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
end
module M_logic__ra__view__impl_Update_for_ViewUpdate_R_Choice__frame_preserving (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Auth_Frag = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate_R_Choice = { f0'0: Map.map t_Choice tup2_Auth_Frag }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'1: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'1).auth
  
  function index_Mapping_Choice_tup2_Auth_Frag [@inline:trivial] (self: Map.map t_Choice tup2_Auth_Frag) (a: t_Choice) : tup2_Auth_Frag
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_tup2_Auth_Frag
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0'1).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) =
    auth_R from <> None
    /\ (forall ch: t_Choice. rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
    /\ (forall frame: t_Frag. match op_Frag (frag_R from) frame with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end
      -> (exists ch: t_Choice. match op_Frag (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1 frame with
          | Some'0 ff -> rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) ff
          | None'0 -> false
          end))
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_Frag_Option_Frag = { f0'2: t_Option_Frag; f1'2: t_Option_Frag }
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'3: t_Option_Auth; f1'3: t_Option_Auth; f2'3: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'4: t_Option_Auth; f1'4: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'1 = new_InnerView_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'4 = auth_R self; f1'4 = auth_R other } with
        | {f0'4 = None; f1'4 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'4 = a; f1'4 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'2 = op_Frag (frag_R a) (frag_R b); f1'2 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'2 = Some'0 fab; f1'2 = Some'0 fbc} -> match { f0'2 = op_Frag fab (frag_R c);
                                                          f1'2 = op_Frag (frag_R a) fbc } with
        | {f0'2 = Some'0 fabc1; f1'2 = Some'0 fabc2} -> match { f0'3 = auth_R a; f1'3 = auth_R b; f2'3 = auth_R c } with
          | {f0'3 = Some _; f1'3 = None; f2'3 = None} | {f0'3 = None; f1'3 = Some _; f2'3 = None} | {f0'3 = None; f1'3 = None; f2'3 = Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function update_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) (ch: t_Choice) : t_View_R =
    new_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdate_R_Choice
  
  constant from : t_View_R
  
  constant frame : t_View_R
  
  function frame_preserving_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) (frame: t_View_R) : t_Choice
  
  goal vc_frame_preserving_ViewUpdate_R_Choice: premise_ViewUpdate_R_Choice self from
    -> op_View_R from frame <> None'1
    -> (forall ch: t_Choice. [@expl:update requires] premise_ViewUpdate_R_Choice self from)
    /\ ([@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (ch: t_Choice) -> op_View_R (update_ViewUpdate_R_Choice self from ch) frame
        <> None'1) x)
    /\ (index_Mapping_Choice_bool (fun (ch: t_Choice) -> op_View_R (update_ViewUpdate_R_Choice self from ch) frame
      <> None'1) (such_that_Choice (fun (ch: t_Choice) -> op_View_R (update_ViewUpdate_R_Choice self from ch) frame
      <> None'1))
    -> ([@expl:frame_preserving ensures] op_View_R (update_ViewUpdate_R_Choice self from (such_that_Choice (fun (ch: t_Choice) -> op_View_R (update_ViewUpdate_R_Choice self from ch) frame
      <> None'1))) frame
    <> None'1))
end
module M_logic__ra__view__impl_Update_for_ViewUpdateInsert_R__update (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateInsert_R = { f0: t_Auth; f1: t_Frag }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'0: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'0).auth
  
  predicate premise_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. rel_R (auth_R from) f
      -> match op_Frag self.f1 f with
        | Some'0 ff -> rel_R (Some (self.f0)) ff
        | None'0 -> false
        end)
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_InnerView_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateInsert_R
  
  constant from : t_View_R
  
  constant _3 : ()
  
  function update_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) (_3: ()) : t_View_R
  
  goal vc_update_ViewUpdateInsert_R: premise_ViewUpdateInsert_R self from
    -> ([@expl:new requires] rel_R (Some (self.f0)) self.f1)
    /\ (auth_R (new_R (Some (self.f0)) self.f1) = Some (self.f0) && frag_R (new_R (Some (self.f0)) self.f1) = self.f1
    -> ([@expl:update ensures] rel_R (Some (self.f0)) self.f1))
end
module M_logic__ra__view__impl_Update_for_ViewUpdateInsert_R__frame_preserving (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateInsert_R = { f0: t_Auth; f1: t_Frag }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'0: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'0).auth
  
  predicate premise_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. rel_R (auth_R from) f
      -> match op_Frag self.f1 f with
        | Some'0 ff -> rel_R (Some (self.f0)) ff
        | None'0 -> false
        end)
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_Frag_Option_Frag = { f0'1: t_Option_Frag; f1'1: t_Option_Frag }
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth; f2'2: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'3: t_Option_Auth; f1'3: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_InnerView_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'3 = auth_R self; f1'3 = auth_R other } with
        | {f0'3 = None; f1'3 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'3 = a; f1'3 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'1 = op_Frag (frag_R a) (frag_R b); f1'1 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'1 = Some'0 fab; f1'1 = Some'0 fbc} -> match { f0'1 = op_Frag fab (frag_R c);
                                                          f1'1 = op_Frag (frag_R a) fbc } with
        | {f0'1 = Some'0 fabc1; f1'1 = Some'0 fabc2} -> match { f0'2 = auth_R a; f1'2 = auth_R b; f2'2 = auth_R c } with
          | {f0'2 = Some _; f1'2 = None; f2'2 = None} | {f0'2 = None; f1'2 = Some _; f2'2 = None} | {f0'2 = None; f1'2 = None; f2'2 = Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function update_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) (_3: ()) : t_View_R =
    new_R (Some (self.f0)) self.f1
  
  axiom update_ViewUpdateInsert_R_spec:
    forall self: t_ViewUpdateInsert_R, from: t_View_R, _3: (). premise_ViewUpdateInsert_R self from
      -> rel_R (Some (self.f0)) self.f1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateInsert_R
  
  constant from : t_View_R
  
  constant frame : t_View_R
  
  function frame_preserving_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) (frame: t_View_R) : ()
  
  goal vc_frame_preserving_ViewUpdateInsert_R: premise_ViewUpdateInsert_R self from
    -> op_View_R from frame <> None'1
    -> rel_R (Some (self.f0)) self.f1
    && ([@expl:frame_preserving ensures] op_View_R (update_ViewUpdateInsert_R self from ()) frame <> None'1)
end
module M_logic__ra__view__impl_Update_for_ViewUpdateRemove_R__update (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateRemove_R = { f0: t_Auth }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'0: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. match op_Frag (frag_R from) f with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end -> rel_R (Some (self.f0)) f)
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_InnerView_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function new_auth_R [@inline:trivial] (auth'0: t_Auth) : t_View_R = new_R (Some auth'0) unit_Frag
  
  meta "rewrite_def" function new_auth_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateRemove_R
  
  constant from : t_View_R
  
  constant _3 : ()
  
  function update_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) (_3: ()) : t_View_R
  
  goal vc_update_ViewUpdateRemove_R: premise_ViewUpdateRemove_R self from
    -> ([@expl:update ensures] rel_R (Some (self.f0)) unit_Frag)
end
module M_logic__ra__view__impl_Update_for_ViewUpdateRemove_R__frame_preserving (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateRemove_R = { f0: t_Auth }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'0: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. match op_Frag (frag_R from) f with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end -> rel_R (Some (self.f0)) f)
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_Frag_Option_Frag = { f0'1: t_Option_Frag; f1'1: t_Option_Frag }
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth; f2'2: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'3: t_Option_Auth; f1'3: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_InnerView_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'3 = auth_R self; f1'3 = auth_R other } with
        | {f0'3 = None; f1'3 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'3 = a; f1'3 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'1 = op_Frag (frag_R a) (frag_R b); f1'1 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'1 = Some'0 fab; f1'1 = Some'0 fbc} -> match { f0'1 = op_Frag fab (frag_R c);
                                                          f1'1 = op_Frag (frag_R a) fbc } with
        | {f0'1 = Some'0 fabc1; f1'1 = Some'0 fabc2} -> match { f0'2 = auth_R a; f1'2 = auth_R b; f2'2 = auth_R c } with
          | {f0'2 = Some _; f1'2 = None; f2'2 = None} | {f0'2 = None; f1'2 = Some _; f2'2 = None} | {f0'2 = None; f1'2 = None; f2'2 = Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_auth_R [@inline:trivial] (auth'0: t_Auth) : t_View_R = new_R (Some auth'0) unit_Frag
  
  meta "rewrite_def" function new_auth_R
  
  function update_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) (_3: ()) : t_View_R =
    new_auth_R self.f0
  
  axiom update_ViewUpdateRemove_R_spec:
    forall self: t_ViewUpdateRemove_R, from: t_View_R, _3: (). premise_ViewUpdateRemove_R self from
      -> rel_R (Some (self.f0)) unit_Frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateRemove_R
  
  constant from : t_View_R
  
  constant frame : t_View_R
  
  function frame_preserving_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) (frame: t_View_R) : ()
  
  goal vc_frame_preserving_ViewUpdateRemove_R: premise_ViewUpdateRemove_R self from
    -> op_View_R from frame <> None'1
    -> ([@expl:frame_preserving ensures] op_View_R (update_ViewUpdateRemove_R self from ()) frame <> None'1)
end
module M_logic__ra__trait_RA__incl_op
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Self
  
  constant other : t_Self
  
  constant comb : t_Self
  
  function incl_op_Self (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
  goal vc_incl_op_Self: op_Self self other = Some comb -> ([@expl:incl_op ensures] incl_Self self comb)
end
module M_logic__ra__trait_RA__incl_transitive
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  function and_then_Option_Self (self: t_Option_Self) (f: Map.map t_Self t_Option_Self) : t_Option_Self =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function associative_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_Self_spec:
    forall a: t_Self, b: t_Self, c: t_Self. and_then_Option_Self (op_Self a b) (fun (ab: t_Self) -> op_Self ab c)
      = and_then_Option_Self (op_Self b c) (fun (bc: t_Self) -> op_Self a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Self
  
  constant b : t_Self
  
  constant c : t_Self
  
  function incl_transitive_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  goal vc_incl_transitive_Self: incl_Self a b -> incl_Self b c -> ([@expl:incl_transitive ensures] incl_Self a c)
end
module M_logic__ra__trait_UnitRA__incl_refl
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function and_then_Option_Self (self: t_Option_Self) (f: Map.map t_Self t_Option_Self) : t_Option_Self =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  function incl_transitive_Self (a: t_Self) (b: t_Self) (c: t_Self) : () = ()
  
  axiom incl_transitive_Self_spec: forall a: t_Self, b: t_Self, c: t_Self. incl_Self a b
      -> incl_Self b c -> incl_Self a c
  
  function associative_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_Self_spec:
    forall a: t_Self, b: t_Self, c: t_Self. and_then_Option_Self (op_Self a b) (fun (ab: t_Self) -> op_Self ab c)
      = and_then_Option_Self (op_Self b c) (fun (bc: t_Self) -> op_Self a bc)
  
  function commutative_Self (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_Self_spec: forall a: t_Self, b: t_Self. op_Self a b = op_Self b a
  
  function incl_op_Self (self: t_Self) (other: t_Self) (comb: t_Self) : () = ()
  
  axiom incl_op_Self_spec: forall self: t_Self, other: t_Self, comb: t_Self. op_Self self other = Some comb
      -> incl_Self self comb
  
  constant unit_Self : t_Self
  
  axiom unit_Self_spec: forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function incl_refl_Self : ()
  
  goal vc_incl_refl_Self: (forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x)
    -> (let _ = unit_Self in [@expl:incl_refl ensures] forall x: t_Self. incl_Self x x)
end
module M_logic__ra__trait_UnitRA__unit_core
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function and_then_Option_Self (self: t_Option_Self) (f: Map.map t_Self t_Option_Self) : t_Option_Self =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  function incl_transitive_Self (a: t_Self) (b: t_Self) (c: t_Self) : () = ()
  
  axiom incl_transitive_Self_spec: forall a: t_Self, b: t_Self, c: t_Self. incl_Self a b
      -> incl_Self b c -> incl_Self a c
  
  function associative_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_Self_spec:
    forall a: t_Self, b: t_Self, c: t_Self. and_then_Option_Self (op_Self a b) (fun (ab: t_Self) -> op_Self ab c)
      = and_then_Option_Self (op_Self b c) (fun (bc: t_Self) -> op_Self a bc)
  
  function commutative_Self (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_Self_spec: forall a: t_Self, b: t_Self. op_Self a b = op_Self b a
  
  function incl_op_Self (self: t_Self) (other: t_Self) (comb: t_Self) : () = ()
  
  axiom incl_op_Self_spec: forall self: t_Self, other: t_Self, comb: t_Self. op_Self self other = Some comb
      -> incl_Self self comb
  
  function core_total_Self (self: t_Self) : t_Self
  
  axiom core_total_Self_spec: forall self: t_Self. op_Self (core_total_Self self) (core_total_Self self)
      = Some (core_total_Self self)
  
  axiom core_total_Self_spec'0: forall self: t_Self. op_Self (core_total_Self self) self = Some self
  
  constant unit_Self : t_Self
  
  axiom unit_Self_spec: forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_core_Self : ()
  
  goal vc_unit_core_Self: [@expl:unit_core ensures] core_total_Self unit_Self = unit_Self
end
module M_logic__ra__trait_UnitRA__core_total
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function and_then_Option_Self (self: t_Option_Self) (f: Map.map t_Self t_Option_Self) : t_Option_Self =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  function incl_transitive_Self (a: t_Self) (b: t_Self) (c: t_Self) : () = ()
  
  axiom incl_transitive_Self_spec: forall a: t_Self, b: t_Self, c: t_Self. incl_Self a b
      -> incl_Self b c -> incl_Self a c
  
  function associative_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_Self_spec:
    forall a: t_Self, b: t_Self, c: t_Self. and_then_Option_Self (op_Self a b) (fun (ab: t_Self) -> op_Self ab c)
      = and_then_Option_Self (op_Self b c) (fun (bc: t_Self) -> op_Self a bc)
  
  function commutative_Self (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_Self_spec: forall a: t_Self, b: t_Self. op_Self a b = op_Self b a
  
  function incl_op_Self (self: t_Self) (other: t_Self) (comb: t_Self) : () = ()
  
  axiom incl_op_Self_spec: forall self: t_Self, other: t_Self, comb: t_Self. op_Self self other = Some comb
      -> incl_Self self comb
  
  constant unit_Self : t_Self
  
  axiom unit_Self_spec: forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x
  
  function core_Self (self: t_Self) : t_Option_Self
  
  axiom core_Self_spec: forall self: t_Self. match core_Self self with
        | Some c -> op_Self c c = Some c /\ op_Self c self = Some self
        | None -> true
        end
  
  function core_is_maximal_idemp_Self (self: t_Self) (i: t_Self) : ()
  
  axiom core_is_maximal_idemp_Self_spec: forall self: t_Self, i: t_Self. op_Self i i = Some i
      -> op_Self i self = Some self
      -> match core_Self self with
        | Some c -> incl_Self i c
        | None -> false
        end
  
  predicate index_Mapping_Self_bool [@inline:trivial] (self: Map.map t_Self bool) (a: t_Self) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Self_bool
  
  function such_that_Self (p: Map.map t_Self bool) : t_Self
  
  axiom such_that_Self_spec: forall p: Map.map t_Self bool. (exists x: t_Self. index_Mapping_Self_bool p x)
      -> index_Mapping_Self_bool p (such_that_Self p)
  
  function unwrap_Option_Self (self: t_Option_Self) : t_Self = match self with
      | Some x -> x
      | None -> such_that_Self (fun (__0: t_Self) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Self
  
  function core_total_Self (self: t_Self) : t_Self
  
  goal vc_core_total_Self: (forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x)
    -> (([@expl:core_is_maximal_idemp requires #0] op_Self unit_Self unit_Self = Some unit_Self)
      && ([@expl:core_is_maximal_idemp requires #1] op_Self unit_Self self = Some self))
    /\ (match core_Self self with
        | Some c -> incl_Self unit_Self c
        | None -> false
        end
    -> (let _ = core_is_maximal_idemp_Self self unit_Self in match core_Self self with
        | Some c -> op_Self c c = Some c /\ op_Self c self = Some self
        | None -> true
        end
    -> ([@expl:unwrap_logic requires] core_Self self <> None)
    /\ (let result = unwrap_Option_Self (core_Self self) in ([@expl:core_total ensures #0] op_Self result result
      = Some result)
    && ([@expl:core_total ensures #1] op_Self result self = Some self))))
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_le_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_le_log_Real: [@expl:cmp_le_log ensures] Real.(<=) x y = (cmp_log_Real x y <> Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_lt_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_lt_log_Real: [@expl:cmp_lt_log ensures] Real.(<) x y = (cmp_log_Real x y = Less)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_ge_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_ge_log_Real: [@expl:cmp_ge_log ensures] Real.(>=) x y = (cmp_log_Real x y <> Less)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_gt_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_gt_log_Real: [@expl:cmp_gt_log ensures] Real.(>) x y = (cmp_log_Real x y = Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__refl (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  function refl_Real (x: Real.real) : ()
  
  goal vc_refl_Real: [@expl:refl ensures] cmp_log_Real x x = Equal
end
module M_logic__real__impl_OrdLogic_for_Real__trans (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  constant z : Real.real
  
  constant o : t_Ordering
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  goal vc_trans_Real: cmp_log_Real x y = o -> cmp_log_Real y z = o -> ([@expl:trans ensures] cmp_log_Real x z = o)
end
module M_logic__real__impl_OrdLogic_for_Real__antisym1 (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_antisym1_Real: cmp_log_Real x y = Less -> ([@expl:antisym1 ensures] cmp_log_Real y x = Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__antisym2 (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_antisym2_Real: cmp_log_Real x y = Greater -> ([@expl:antisym2 ensures] cmp_log_Real y x = Less)
end
module M_logic__real__impl_OrdLogic_for_Real__eq_cmp (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_eq_cmp_Real: [@expl:eq_cmp ensures] (x = y) = (cmp_log_Real x y = Equal)
end
module M_logic__seq__impl_Seq_T__map (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  function index_Mapping_T_U [@inline:trivial] (self: Map.map t_T t_U) (a: t_T) : t_U = Map.get self a
  
  meta "rewrite_def" function index_Mapping_T_U
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function push_front_U [@inline:trivial] (self: Seq.seq t_U) (x: t_U) : Seq.seq t_U = Seq.cons x self
  
  meta "rewrite_def" function push_front_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq t_T
  
  constant m : Map.map t_T t_U
  
  function map_T (self: Seq.seq t_T) (m: Map.map t_T t_U) : Seq.seq t_U
  
  goal vc_map_T: if Seq.length self = 0 then
      let result = Seq.empty: Seq.seq t_U in ([@expl:map ensures #0] Seq.length result = Seq.length self)
      && ([@expl:map ensures #1] forall i: int. 0 <= i /\ i < Seq.length self
        -> Seq.get result i = index_Mapping_T_U m (Seq.get self i))
    else
      well_founded_relation_Int (Seq.length self) (Seq.length (tail_T self))
      /\ (Seq.length (map_T (tail_T self) m) = Seq.length (tail_T self)
        && (forall i: int. 0 <= i /\ i < Seq.length (tail_T self)
          -> Seq.get (map_T (tail_T self) m) i = index_Mapping_T_U m (Seq.get (tail_T self) i))
      -> (let result = push_front_U (map_T (tail_T self) m) (Map.get m (Seq.get self 0)) in ([@expl:map ensures #0] Seq.length result
        = Seq.length self)
      && ([@expl:map ensures #1] forall i: int. 0 <= i /\ i < Seq.length self
        -> Seq.get result i = index_Mapping_T_U m (Seq.get self i))))

end
module M_logic__seq__impl_Seq_T__flat_map (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq t_T
  
  constant other : Map.map t_T (Seq.seq t_U)
  
  function flat_map_T (self: Seq.seq t_T) (other: Map.map t_T (Seq.seq t_U)) : Seq.seq t_U
  
  goal vc_flat_map_T: if Seq.length self = 0 then
      true
    else
      well_founded_relation_Int (Seq.length self) (Seq.length (tail_T self))

end
module M_logic__seq__impl_Seq_T__concat_contains (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function concat_contains_T : ()
  
  goal vc_concat_contains_T:
    [@expl:concat_contains ensures] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_T (Seq.(++) a b) x
        = contains_T a x
      \/ contains_T b x
end
module M_logic__seq__impl_Seq_Seq_T__flatten (* logic::seq::Seq<logic::seq::Seq<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  function tail_Seq_T (self: Seq.seq (Seq.seq t_T)) : Seq.seq (Seq.seq t_T) = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq (Seq.seq t_T)
  
  function flatten_T (self: Seq.seq (Seq.seq t_T)) : Seq.seq t_T
  
  goal vc_flatten_T: if Seq.length self = 0 then
      true
    else
      well_founded_relation_Int (Seq.length self) (Seq.length (tail_Seq_T self))

end
module M_logic__seq__impl_Index_for_Seq_T__index (* <logic::seq::Seq<T> as std::ops::Index<logic::int::Int>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  let rec get_ghost_T (self: Seq.seq t_T) (index: int) (return (x: t_Option_ref_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_Seq_T self}
    any
    [ return (result: t_Option_ref_T) -> {inv_Option_ref_T result}
      {match get_T self index with
        | None'0 -> result = None
        | Some'0 v -> result = Some v
        end}
      (! return {result}) ]
  
  let rec unwrap_ref_T (self_: t_Option_ref_T) (return (x: t_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_T self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_T) -> {inv_ref_T result} {Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_Seq_T (self: Seq.seq t_T) (index: int) (return (x: t_T)) =
    {[@expl:index 'self' type invariant] inv_ref_Seq_T self}
    {[@expl:index requires] 0 <= index /\ index < Seq.length self}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost_T {self} {index} (fun (_ret: t_Option_ref_T) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = unwrap_ref_T {_6} (fun (_ret: t_T) -> [ &_5 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- _5 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & self: Seq.seq t_T = self
    | & index: int = index
    | & _5: t_T = Any.any_l ()
    | & _6: t_Option_ref_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:index result type invariant] inv_ref_T result}
      {[@expl:index ensures] result = Seq.get self index}
      (! return {result}) ]
end
module M_logic__seq__impl_IndexMut_for_Seq_T__index_mut (* <logic::seq::Seq<T> as std::ops::IndexMut<logic::int::Int>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  type t_Option_ref_T = None | Some (MutBorrow.t t_T)
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) =
    inv_Seq_T self.current /\ inv_Seq_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  let rec get_mut_ghost_T (self: MutBorrow.t (Seq.seq t_T)) (index: int) (return (x: t_Option_ref_T)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv_ref_Seq_T self}
    any
    [ return (result: t_Option_ref_T) -> {inv_Option_ref_T result}
      {match result with
        | None -> get_T self.current index = None'0 /\ self.current = self.final
        | Some r -> get_T self.current index = Some'0 (r.current) /\ r.final = Seq.get self.final index
        end}
      {forall i: int. i <> index -> get_T self.current i = get_T self.final i}
      {Seq.length self.current = Seq.length self.final}
      (! return {result}) ]
  
  let rec unwrap_ref_T (self_: t_Option_ref_T) (return (x: MutBorrow.t t_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_T self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: MutBorrow.t t_T) -> {inv_ref_T result} {Some result = self_} (! return {result}) ]
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate resolve_ref_Seq_T [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Seq_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_mut_Seq_T (self: MutBorrow.t (Seq.seq t_T)) (index: int) (return (x: MutBorrow.t t_T)) =
    {[@expl:index_mut 'self' type invariant] inv_ref_Seq_T self}
    {[@expl:index_mut requires] 0 <= index /\ index < Seq.length self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Seq_T self.current}
        MutBorrow.borrow_final <Seq.seq t_T> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t (Seq.seq t_T)) ->
            [ &_10 <- _ret ] -{inv_Seq_T _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = get_mut_ghost_T {_10} {index} (fun (_ret: t_Option_ref_T) -> [ &_9 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap_ref_T {_9} (fun (_ret: MutBorrow.t t_T) -> [ &_8 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_T _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_3 <- _ret ] -{inv_T _ret.final}-
            [ &_8 <- { _8 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_T _8} s2
      | s2 = -{resolve_ref_T _8}- s3
      | s3 = {inv_T _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_0 <- _ret ] -{inv_T _ret.final}-
            [ &_3 <- { _3 with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv_ref_T _3} s5
      | s5 = -{resolve_ref_T _3}- s6
      | s6 = {[@expl:type invariant] inv_ref_Seq_T self} s7
      | s7 = -{resolve_ref_Seq_T self}- s8
      | s8 = return {_0} ] ]
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self: MutBorrow.t (Seq.seq t_T) = self
    | & index: int = index
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: t_Option_ref_T = Any.any_l ()
    | & _10: MutBorrow.t (Seq.seq t_T) = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) -> {[@expl:index_mut result type invariant] inv_ref_T result}
      {[@expl:index_mut ensures #0] Seq.length self.current = Seq.length self.final}
      {[@expl:index_mut ensures #1] result.current = Seq.get self.current index
      /\ result.final = Seq.get self.final index}
      {[@expl:index_mut ensures #2] forall i: int. i <> index -> get_T self.current i = get_T self.final i}
      (! return {result}) ]
end
module M_logic__seq__impl_IntoIterator_for_Seq_T__into_iter (* <logic::seq::Seq<T> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate inv_SeqIter_T (_1: t_SeqIter_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter_T [inv_SeqIter_T x]. inv_SeqIter_T x = inv_Seq_T x.inner
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter_Seq_T (self: Seq.seq t_T) (return (x: t_SeqIter_T)) =
    {[@expl:into_iter 'self' type invariant] inv_Seq_T self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { inner = self } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_SeqIter_T = Any.any_l () | & self: Seq.seq t_T = self ])
    [ return (result: t_SeqIter_T) -> {[@expl:into_iter result type invariant] inv_SeqIter_T result}
      {[@expl:into_iter ensures] view_SeqIter_T result = self}
      (! return {result}) ]
end
module M_logic__seq__impl_Iterator_for_SeqIter_T__next (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  type t_Option_T = None | Some t_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) =
    inv_Seq_T self.current /\ inv_Seq_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  let rec pop_front_ghost_T (self: MutBorrow.t (Seq.seq t_T)) (return (x: t_Option_T)) =
    {[@expl:pop_front_ghost 'self' type invariant] inv_ref_Seq_T self}
    any
    [ return (result: t_Option_T) -> {inv_Option_T result}
      {match result with
        | None -> self.current = (Seq.empty: Seq.seq t_T) /\ self.current = self.final
        | Some r -> self.current = push_front_T self.final r
        end}
      (! return {result}) ]
  
  predicate inv_SeqIter_T (_1: t_SeqIter_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_SeqIter_T [inv_SeqIter_T x]. inv_SeqIter_T x = inv_Seq_T x.inner
  
  predicate invariant_ref_SeqIter_T [@inline:trivial] (self: MutBorrow.t t_SeqIter_T) =
    inv_SeqIter_T self.current /\ inv_SeqIter_T self.final
  
  meta "rewrite_def" predicate invariant_ref_SeqIter_T
  
  predicate inv_ref_SeqIter_T [@inline:trivial] (_1: MutBorrow.t t_SeqIter_T) = invariant_ref_SeqIter_T _1
  
  meta "rewrite_def" predicate inv_ref_SeqIter_T
  
  predicate resolve_ref_SeqIter_T [@inline:trivial] (_1: MutBorrow.t t_SeqIter_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_SeqIter_T
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  function produces_trans_SeqIter_T (a: t_SeqIter_T) (ab: Seq.seq t_T) (b: t_SeqIter_T) (bc: Seq.seq t_T) (c: t_SeqIter_T) : ()
   = ()
  
  axiom produces_trans_SeqIter_T_spec:
    forall a: t_SeqIter_T, ab: Seq.seq t_T, b: t_SeqIter_T, bc: Seq.seq t_T, c: t_SeqIter_T. produces_SeqIter_T a ab b
      -> produces_SeqIter_T b bc c -> produces_SeqIter_T a (Seq.(++) ab bc) c
  
  function produces_refl_SeqIter_T (self: t_SeqIter_T) : () = ()
  
  axiom produces_refl_SeqIter_T_spec: forall self: t_SeqIter_T. produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
  
  predicate completed_SeqIter_T (self: MutBorrow.t t_SeqIter_T) = view_SeqIter_T self.current = (Seq.empty: Seq.seq t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_SeqIter_T (self: MutBorrow.t t_SeqIter_T) (return (x: t_Option_T)) =
    {[@expl:next 'self' type invariant] inv_ref_SeqIter_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Seq_T self.current.inner}
        MutBorrow.borrow_final <Seq.seq t_T> {self.current.inner} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t (Seq.seq t_T)) ->
            [ &_3 <- _ret ] -{inv_Seq_T _ret.final}-
            [ &self <- { self with current = { inner = _ret.final } } ] s1)
      | s1 = pop_front_ghost_T {_3} (fun (_ret: t_Option_T) -> [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_ref_SeqIter_T self} s1
      | s1 = -{resolve_ref_SeqIter_T self}- s2
      | s2 = return {_0} ] ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self: MutBorrow.t t_SeqIter_T = self
    | & _3: MutBorrow.t (Seq.seq t_T) = Any.any_l () ])
    [ return (result: t_Option_T) -> {[@expl:next result type invariant] inv_Option_T result}
      {[@expl:next ensures] match result with
        | None -> completed_SeqIter_T self
        | Some v -> produces_SeqIter_T self.current (Seq.singleton v) self.final
        end}
      (! return {result}) ]
end
module M_logic__seq__impl_IteratorSpec_for_SeqIter_T__produces_refl (* <logic::seq::SeqIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIter_T
  
  function produces_refl_SeqIter_T (self: t_SeqIter_T) : ()
  
  goal vc_produces_refl_SeqIter_T: [@expl:produces_refl ensures] produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_logic__seq__impl_IteratorSpec_for_SeqIter_T__produces_trans (* <logic::seq::SeqIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_SeqIter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_SeqIter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_SeqIter_T
  
  function produces_trans_SeqIter_T (a: t_SeqIter_T) (ab: Seq.seq t_T) (b: t_SeqIter_T) (bc: Seq.seq t_T) (c: t_SeqIter_T) : ()
  
  goal vc_produces_trans_SeqIter_T: produces_SeqIter_T a ab b
    -> produces_SeqIter_T b bc c -> ([@expl:produces_trans ensures] produces_SeqIter_T a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_IntoIterator_for_ref_Seq_T__into_iter (* <&'a logic::seq::Seq<T> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  let rec len_ghost_T (self: Seq.seq t_T) (return (x: int)) =
    {[@expl:len_ghost 'self' type invariant] inv_ref_Seq_T self}
    any [ return (result: int) -> {result = Seq.length self} (! return {result}) ]
  
  let rec sub_Int (self: int) (other: int) (return (x: int)) = any
    [ return (result: int) -> {result = self - other} (! return {result}) ]
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  predicate invariant_SeqIterRef_T (self: t_SeqIterRef_T) = 0 <= self.index /\ self.index <= Seq.length self.inner
  
  predicate inv_SeqIterRef_T (_1: t_SeqIterRef_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIterRef_T [inv_SeqIterRef_T x]. inv_SeqIterRef_T x
      = (invariant_SeqIterRef_T x /\ inv_ref_Seq_T x.inner)
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter_ref_Seq_T (self: Seq.seq t_T) (return (x: t_SeqIterRef_T)) =
    {[@expl:into_iter 'self' type invariant] inv_ref_Seq_T self}
    (! bb0
    [ bb0 = s0 [ s0 = len_ghost_T {self} (fun (_ret: int) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = len_ghost_T {self} (fun (_ret: int) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = sub_Int {_5} {_7} (fun (_ret: int) -> [ &_4 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0 <- { inner = self; index = _4 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_SeqIterRef_T = Any.any_l ()
    | & self: Seq.seq t_T = self
    | & _4: int = Any.any_l ()
    | & _5: int = Any.any_l ()
    | & _7: int = Any.any_l () ])
    [ return (result: t_SeqIterRef_T) -> {[@expl:into_iter result type invariant] inv_SeqIterRef_T result}
      {[@expl:into_iter ensures] view_SeqIterRef_T result = self}
      (! return {result}) ]
end
module M_logic__seq__impl_Iterator_for_SeqIterRef_T__next (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  type t_Option_ref_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  let rec get_ghost_T (self: Seq.seq t_T) (index'0: int) (return (x: t_Option_ref_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_Seq_T self}
    any
    [ return (result: t_Option_ref_T) -> {inv_Option_ref_T result}
      {match get_T self index'0 with
        | None'0 -> result = None
        | Some'0 v -> result = Some v
        end}
      (! return {result}) ]
  
  predicate invariant_SeqIterRef_T (self: t_SeqIterRef_T) = 0 <= self.index /\ self.index <= Seq.length self.inner
  
  predicate inv_SeqIterRef_T (_1: t_SeqIterRef_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_SeqIterRef_T [inv_SeqIterRef_T x]. inv_SeqIterRef_T x
      = (invariant_SeqIterRef_T x /\ inv_ref_Seq_T x.inner)
  
  predicate invariant_ref_SeqIterRef_T [@inline:trivial] (self: MutBorrow.t t_SeqIterRef_T) =
    inv_SeqIterRef_T self.current /\ inv_SeqIterRef_T self.final
  
  meta "rewrite_def" predicate invariant_ref_SeqIterRef_T
  
  predicate inv_ref_SeqIterRef_T [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef_T) = invariant_ref_SeqIterRef_T _1
  
  meta "rewrite_def" predicate inv_ref_SeqIterRef_T
  
  predicate resolve_ref_SeqIterRef_T [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_SeqIterRef_T
  
  let rec elim_Some (input: t_Option_ref_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_ref_T]. Some f0 <> input} (! {false} any) ]
  
  let rec incr_ghost (self: MutBorrow.t int) (return (x: ())) = any
    [ return (result: ()) -> {self.final = self.current + 1} (! return {result}) ]
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  function produces_trans_SeqIterRef_T (a: t_SeqIterRef_T) (ab: Seq.seq t_T) (b: t_SeqIterRef_T) (bc: Seq.seq t_T) (c: t_SeqIterRef_T) : ()
   = ()
  
  axiom produces_trans_SeqIterRef_T_spec:
    forall a: t_SeqIterRef_T, ab: Seq.seq t_T, b: t_SeqIterRef_T, bc: Seq.seq t_T, c: t_SeqIterRef_T. produces_SeqIterRef_T a ab b
      -> produces_SeqIterRef_T b bc c -> produces_SeqIterRef_T a (Seq.(++) ab bc) c
  
  function produces_refl_SeqIterRef_T (self: t_SeqIterRef_T) : () = ()
  
  axiom produces_refl_SeqIterRef_T_spec:
    forall self: t_SeqIterRef_T. produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
  
  predicate completed_SeqIterRef_T (self: MutBorrow.t t_SeqIterRef_T) =
    view_SeqIterRef_T self.current = (Seq.empty: Seq.seq t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_SeqIterRef_T (self: MutBorrow.t t_SeqIterRef_T) (return (x: t_Option_ref_T)) =
    {[@expl:next 'self' type invariant] inv_ref_SeqIterRef_T self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_before <- view_SeqIterRef_T self.current ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = get_ghost_T {self.current.inner} {self.current.index} (fun (_ret: t_Option_ref_T) -> [ &_5 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = any [ br0 -> {_5 = None} (! bb6) | br1 (x0: t_T) -> {_5 = Some x0} (! bb4) ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv_ref_SeqIterRef_T self} s1
      | s1 = -{resolve_ref_SeqIterRef_T self}- s2
      | s2 = {[@expl:assertion] self.current.index = Seq.length self.current.inner} s3
      | s3 = {[@expl:assertion] view_SeqIterRef_T self.current = (Seq.empty: Seq.seq t_T)} s4
      | s4 = [ &_0 <- None ] s5
      | s5 = bb7 ]
    | bb4 = s0
      [ s0 = elim_Some {_5} (fun (r0: t_T) -> [ &res <- r0 ] s1)
      | s1 = MutBorrow.borrow_final <int> {self.current.index} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t int) ->
            [ &_11 <- _ret ] [ &self <- { self with current = { self.current with index = _ret.final } } ] s2)
      | s2 = incr_ghost {_11} (fun (_ret: ()) -> [ &_10 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_SeqIterRef_T self} s1
      | s1 = -{resolve_ref_SeqIterRef_T self}- s2
      | s2 = {[@expl:assertion] view_SeqIterRef_T self.current = tail_T _before} s3
      | s3 = [ &_0 <- Some res ] s4
      | s4 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option_ref_T = Any.any_l ()
    | & self: MutBorrow.t t_SeqIterRef_T = self
    | & _before: Seq.seq t_T = Any.any_l ()
    | & _5: t_Option_ref_T = Any.any_l ()
    | & res: t_T = Any.any_l ()
    | & _10: () = Any.any_l ()
    | & _11: MutBorrow.t int = Any.any_l () ])
    [ return (result: t_Option_ref_T) -> {[@expl:next result type invariant] inv_Option_ref_T result}
      {[@expl:next ensures] match result with
        | None -> completed_SeqIterRef_T self
        | Some v -> produces_SeqIterRef_T self.current (Seq.singleton v) self.final
        end}
      (! return {result}) ]
end
module M_logic__seq__impl_IteratorSpec_for_SeqIterRef_T__produces_refl (* <logic::seq::SeqIterRef<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIterRef_T
  
  function produces_refl_SeqIterRef_T (self: t_SeqIterRef_T) : ()
  
  goal vc_produces_refl_SeqIterRef_T:
    [@expl:produces_refl ensures] produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
end
module M_logic__seq__impl_IteratorSpec_for_SeqIterRef_T__produces_trans (* <logic::seq::SeqIterRef<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_SeqIterRef_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_SeqIterRef_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_SeqIterRef_T
  
  function produces_trans_SeqIterRef_T (a: t_SeqIterRef_T) (ab: Seq.seq t_T) (b: t_SeqIterRef_T) (bc: Seq.seq t_T) (c: t_SeqIterRef_T) : ()
  
  goal vc_produces_trans_SeqIterRef_T: produces_SeqIterRef_T a ab b
    -> produces_SeqIterRef_T b bc c -> ([@expl:produces_trans ensures] produces_SeqIterRef_T a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_Resolve_for_SeqIter_T__resolve_coherence (* <logic::seq::SeqIter<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  type t_Option_T = None | Some t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  predicate resolve_Seq_T (self: Seq.seq t_T) = forall i: int. resolve_Option_T (get_T self i)
  
  predicate resolve_Seq_T'0 (_1: Seq.seq t_T)
  
  axiom resolve_axiom'0: forall x: Seq.seq t_T [resolve_Seq_T'0 x]. resolve_Seq_T'0 x -> resolve_Seq_T x
  
  predicate structural_resolve_SeqIter_T (_1: t_SeqIter_T) = resolve_Seq_T'0 _1.inner
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate resolve_SeqIter_T [@inline:trivial] (self: t_SeqIter_T) = resolve_Seq_T'0 (view_SeqIter_T self)
  
  meta "rewrite_def" predicate resolve_SeqIter_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIter_T
  
  function resolve_coherence_SeqIter_T (self: t_SeqIter_T) : ()
  
  goal vc_resolve_coherence_SeqIter_T: structural_resolve_SeqIter_T self
    -> ([@expl:resolve_coherence ensures] resolve_SeqIter_T self)
end
module M_logic__seq__flat_map_singleton
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  
  type t_A
  
  type t_B
  
  function tail_A (self: Seq.seq t_A) : Seq.seq t_A = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map_A (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  axiom flat_map_A_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map_A self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq t_B
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map_A (tail_A self) other)
      )
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function flat_map_singleton_A : ()
  
  goal vc_flat_map_singleton_A:
    [@expl:flat_map_singleton ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map_A (Seq.singleton x) f
      = Map.get f x
end
module M_logic__seq__flat_map_push_back
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  function tail_A (self: Seq.seq t_A) : Seq.seq t_A = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map_A (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  axiom flat_map_A_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map_A self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq t_B
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map_A (tail_A self) other)
      )
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant xs : Seq.seq t_A
  
  function flat_map_push_back_A (xs: Seq.seq t_A) : ()
  
  goal vc_flat_map_push_back_A: if Seq.length xs > 0 then
      well_founded_relation_Int (Seq.length xs) (Seq.length (tail_A xs))
      /\ ((forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map_A (Seq.snoc (tail_A xs) x) f
          = Seq.(++) (flat_map_A (tail_A xs) f) (Map.get f x))
      -> (let _ = flat_map_push_back_A (tail_A xs) in (forall x: t_A. Seq.snoc (tail_A xs) x = tail_A (Seq.snoc xs x))
      && ([@expl:flat_map_push_back ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map_A (Seq.snoc xs x) f
        = Seq.(++) (flat_map_A xs f) (Map.get f x))))
    else
      [@expl:flat_map_push_back ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map_A (Seq.snoc xs x) f
        = Seq.(++) (flat_map_A xs f) (Map.get f x)

end
module M_logic__well_founded__impl_WellFounded_for_u8__no_infinite_decreasing_sequence (* <u8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom eq_cmp_u8_spec: forall x: UInt8.t, y: UInt8.t. (x = y) = (cmp_log_u8 x y = Equal)
  
  function antisym2_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym2_u8_spec: forall x: UInt8.t, y: UInt8.t. cmp_log_u8 x y = Greater -> cmp_log_u8 y x = Less
  
  function antisym1_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym1_u8_spec: forall x: UInt8.t, y: UInt8.t. cmp_log_u8 x y = Less -> cmp_log_u8 y x = Greater
  
  function trans_u8 (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  axiom trans_u8_spec: forall x: UInt8.t, y: UInt8.t, z: UInt8.t, o: t_Ordering. cmp_log_u8 x y = o
      -> cmp_log_u8 y z = o -> cmp_log_u8 x z = o
  
  function refl_u8 (x: UInt8.t) : ()
  
  axiom refl_u8_spec: forall x: UInt8.t. cmp_log_u8 x x = Equal
  
  function cmp_gt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_gt_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.gt x y = (cmp_log_u8 x y = Greater)
  
  function cmp_ge_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_ge_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.ge x y = (cmp_log_u8 x y <> Less)
  
  function cmp_lt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_lt_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.lt x y = (cmp_log_u8 x y = Less)
  
  function cmp_le_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_le_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.le x y = (cmp_log_u8 x y <> Greater)
  
  predicate well_founded_relation_u8 [@inline:trivial] (self: UInt8.t) (other: UInt8.t) = UInt8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u8
  
  function index_Mapping_Int_u8 [@inline:trivial] (self: Map.map int UInt8.t) (a: int) : UInt8.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u8
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt8.t
  
  function no_infinite_decreasing_sequence_u8 (s: Map.map int UInt8.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u8:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i) - UInt8.t'int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
      - UInt8.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
      - UInt8.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
      - UInt8.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
        - UInt8.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
    - UInt8.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u8 (index_Mapping_Int_u8 s result) (index_Mapping_Int_u8 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_u16__no_infinite_decreasing_sequence (* <u16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom eq_cmp_u16_spec: forall x: UInt16.t, y: UInt16.t. (x = y) = (cmp_log_u16 x y = Equal)
  
  function antisym2_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym2_u16_spec: forall x: UInt16.t, y: UInt16.t. cmp_log_u16 x y = Greater -> cmp_log_u16 y x = Less
  
  function antisym1_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym1_u16_spec: forall x: UInt16.t, y: UInt16.t. cmp_log_u16 x y = Less -> cmp_log_u16 y x = Greater
  
  function trans_u16 (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  axiom trans_u16_spec: forall x: UInt16.t, y: UInt16.t, z: UInt16.t, o: t_Ordering. cmp_log_u16 x y = o
      -> cmp_log_u16 y z = o -> cmp_log_u16 x z = o
  
  function refl_u16 (x: UInt16.t) : ()
  
  axiom refl_u16_spec: forall x: UInt16.t. cmp_log_u16 x x = Equal
  
  function cmp_gt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_gt_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.gt x y = (cmp_log_u16 x y = Greater)
  
  function cmp_ge_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_ge_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.ge x y = (cmp_log_u16 x y <> Less)
  
  function cmp_lt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_lt_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.lt x y = (cmp_log_u16 x y = Less)
  
  function cmp_le_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_le_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.le x y = (cmp_log_u16 x y <> Greater)
  
  predicate well_founded_relation_u16 [@inline:trivial] (self: UInt16.t) (other: UInt16.t) = UInt16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u16
  
  function index_Mapping_Int_u16 [@inline:trivial] (self: Map.map int UInt16.t) (a: int) : UInt16.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u16
  
  constant const_MIN: UInt16.t = (0: UInt16.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt16.t
  
  function no_infinite_decreasing_sequence_u16 (s: Map.map int UInt16.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u16:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
          - UInt16.t'int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
      - UInt16.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
      - UInt16.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
      - UInt16.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
        - UInt16.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
    - UInt16.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u16 (index_Mapping_Int_u16 s result) (index_Mapping_Int_u16 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_u32__no_infinite_decreasing_sequence (* <u32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom eq_cmp_u32_spec: forall x: UInt32.t, y: UInt32.t. (x = y) = (cmp_log_u32 x y = Equal)
  
  function antisym2_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym2_u32_spec: forall x: UInt32.t, y: UInt32.t. cmp_log_u32 x y = Greater -> cmp_log_u32 y x = Less
  
  function antisym1_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym1_u32_spec: forall x: UInt32.t, y: UInt32.t. cmp_log_u32 x y = Less -> cmp_log_u32 y x = Greater
  
  function trans_u32 (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  axiom trans_u32_spec: forall x: UInt32.t, y: UInt32.t, z: UInt32.t, o: t_Ordering. cmp_log_u32 x y = o
      -> cmp_log_u32 y z = o -> cmp_log_u32 x z = o
  
  function refl_u32 (x: UInt32.t) : ()
  
  axiom refl_u32_spec: forall x: UInt32.t. cmp_log_u32 x x = Equal
  
  function cmp_gt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_gt_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.gt x y = (cmp_log_u32 x y = Greater)
  
  function cmp_ge_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_ge_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.ge x y = (cmp_log_u32 x y <> Less)
  
  function cmp_lt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_lt_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.lt x y = (cmp_log_u32 x y = Less)
  
  function cmp_le_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_le_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.le x y = (cmp_log_u32 x y <> Greater)
  
  predicate well_founded_relation_u32 [@inline:trivial] (self: UInt32.t) (other: UInt32.t) = UInt32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u32
  
  function index_Mapping_Int_u32 [@inline:trivial] (self: Map.map int UInt32.t) (a: int) : UInt32.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u32
  
  constant const_MIN: UInt32.t = (0: UInt32.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt32.t
  
  function no_infinite_decreasing_sequence_u32 (s: Map.map int UInt32.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u32:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
          - UInt32.t'int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
      - UInt32.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
      - UInt32.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
      - UInt32.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
        - UInt32.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
    - UInt32.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u32 (index_Mapping_Int_u32 s result) (index_Mapping_Int_u32 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_u64__no_infinite_decreasing_sequence (* <u64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate well_founded_relation_u64 [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u64
  
  function index_Mapping_Int_u64 [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u64
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt64.t
  
  function no_infinite_decreasing_sequence_u64 (s: Map.map int UInt64.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u64:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
          - UInt64.t'int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
      - UInt64.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
        - UInt64.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
    - UInt64.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u64 (index_Mapping_Int_u64 s result) (index_Mapping_Int_u64 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_u128__no_infinite_decreasing_sequence (* <u128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom eq_cmp_u128_spec: forall x: UInt128.t, y: UInt128.t. (x = y) = (cmp_log_u128 x y = Equal)
  
  function antisym2_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym2_u128_spec: forall x: UInt128.t, y: UInt128.t. cmp_log_u128 x y = Greater -> cmp_log_u128 y x = Less
  
  function antisym1_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym1_u128_spec: forall x: UInt128.t, y: UInt128.t. cmp_log_u128 x y = Less -> cmp_log_u128 y x = Greater
  
  function trans_u128 (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  axiom trans_u128_spec: forall x: UInt128.t, y: UInt128.t, z: UInt128.t, o: t_Ordering. cmp_log_u128 x y = o
      -> cmp_log_u128 y z = o -> cmp_log_u128 x z = o
  
  function refl_u128 (x: UInt128.t) : ()
  
  axiom refl_u128_spec: forall x: UInt128.t. cmp_log_u128 x x = Equal
  
  function cmp_gt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_gt_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.gt x y = (cmp_log_u128 x y = Greater)
  
  function cmp_ge_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_ge_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.ge x y = (cmp_log_u128 x y <> Less)
  
  function cmp_lt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_lt_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.lt x y = (cmp_log_u128 x y = Less)
  
  function cmp_le_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_le_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.le x y = (cmp_log_u128 x y <> Greater)
  
  predicate well_founded_relation_u128 [@inline:trivial] (self: UInt128.t) (other: UInt128.t) = UInt128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u128
  
  function index_Mapping_Int_u128 [@inline:trivial] (self: Map.map int UInt128.t) (a: int) : UInt128.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u128
  
  constant const_MIN: UInt128.t = (0: UInt128.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt128.t
  
  function no_infinite_decreasing_sequence_u128 (s: Map.map int UInt128.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u128:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
          - UInt128.t'int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
      - UInt128.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
      - UInt128.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
      - UInt128.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
        - UInt128.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
    - UInt128.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u128 (index_Mapping_Int_u128 s result) (index_Mapping_Int_u128 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_usize__no_infinite_decreasing_sequence (* <usize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  predicate well_founded_relation_usize [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_usize
  
  function index_Mapping_Int_usize [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_usize
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt64.t
  
  function no_infinite_decreasing_sequence_usize (s: Map.map int UInt64.t) : int
  
  goal vc_no_infinite_decreasing_sequence_usize:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
          - UInt64.t'int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
      - UInt64.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
        - UInt64.t'int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
    - UInt64.t'int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_usize (index_Mapping_Int_usize s result) (index_Mapping_Int_usize s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i8__no_infinite_decreasing_sequence (* <i8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom eq_cmp_i8_spec: forall x: Int8.t, y: Int8.t. (x = y) = (cmp_log_i8 x y = Equal)
  
  function antisym2_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym2_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Greater -> cmp_log_i8 y x = Less
  
  function antisym1_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym1_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Less -> cmp_log_i8 y x = Greater
  
  function trans_i8 (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  axiom trans_i8_spec: forall x: Int8.t, y: Int8.t, z: Int8.t, o: t_Ordering. cmp_log_i8 x y = o
      -> cmp_log_i8 y z = o -> cmp_log_i8 x z = o
  
  function refl_i8 (x: Int8.t) : ()
  
  axiom refl_i8_spec: forall x: Int8.t. cmp_log_i8 x x = Equal
  
  function cmp_gt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_gt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.gt x y = (cmp_log_i8 x y = Greater)
  
  function cmp_ge_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_ge_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.ge x y = (cmp_log_i8 x y <> Less)
  
  function cmp_lt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_lt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.lt x y = (cmp_log_i8 x y = Less)
  
  function cmp_le_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_le_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.le x y = (cmp_log_i8 x y <> Greater)
  
  predicate well_founded_relation_i8 [@inline:trivial] (self: Int8.t) (other: Int8.t) = Int8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i8
  
  function index_Mapping_Int_i8 [@inline:trivial] (self: Map.map int Int8.t) (a: int) : Int8.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i8
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int8.t
  
  function no_infinite_decreasing_sequence_i8 (s: Map.map int Int8.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i8:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i) - Int8.to_int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
      - Int8.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
      - Int8.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
      - Int8.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
        - Int8.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
    - Int8.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i8 (index_Mapping_Int_i8 s result) (index_Mapping_Int_i8 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i16__no_infinite_decreasing_sequence (* <i16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom eq_cmp_i16_spec: forall x: Int16.t, y: Int16.t. (x = y) = (cmp_log_i16 x y = Equal)
  
  function antisym2_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym2_i16_spec: forall x: Int16.t, y: Int16.t. cmp_log_i16 x y = Greater -> cmp_log_i16 y x = Less
  
  function antisym1_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym1_i16_spec: forall x: Int16.t, y: Int16.t. cmp_log_i16 x y = Less -> cmp_log_i16 y x = Greater
  
  function trans_i16 (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  axiom trans_i16_spec: forall x: Int16.t, y: Int16.t, z: Int16.t, o: t_Ordering. cmp_log_i16 x y = o
      -> cmp_log_i16 y z = o -> cmp_log_i16 x z = o
  
  function refl_i16 (x: Int16.t) : ()
  
  axiom refl_i16_spec: forall x: Int16.t. cmp_log_i16 x x = Equal
  
  function cmp_gt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_gt_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.gt x y = (cmp_log_i16 x y = Greater)
  
  function cmp_ge_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_ge_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.ge x y = (cmp_log_i16 x y <> Less)
  
  function cmp_lt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_lt_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.lt x y = (cmp_log_i16 x y = Less)
  
  function cmp_le_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_le_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.le x y = (cmp_log_i16 x y <> Greater)
  
  predicate well_founded_relation_i16 [@inline:trivial] (self: Int16.t) (other: Int16.t) = Int16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i16
  
  function index_Mapping_Int_i16 [@inline:trivial] (self: Map.map int Int16.t) (a: int) : Int16.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i16
  
  constant const_MIN: Int16.t = (-32768: Int16.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int16.t
  
  function no_infinite_decreasing_sequence_i16 (s: Map.map int Int16.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i16:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
          - Int16.to_int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
      - Int16.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
      - Int16.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
      - Int16.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
        - Int16.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
    - Int16.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i16 (index_Mapping_Int_i16 s result) (index_Mapping_Int_i16 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i32__no_infinite_decreasing_sequence (* <i32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_i32_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log_i32 x y = Equal)
  
  function antisym2_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Greater -> cmp_log_i32 y x = Less
  
  function antisym1_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Less -> cmp_log_i32 y x = Greater
  
  function trans_i32 (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_i32_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log_i32 x y = o
      -> cmp_log_i32 y z = o -> cmp_log_i32 x z = o
  
  function refl_i32 (x: Int32.t) : ()
  
  axiom refl_i32_spec: forall x: Int32.t. cmp_log_i32 x x = Equal
  
  function cmp_gt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log_i32 x y = Greater)
  
  function cmp_ge_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log_i32 x y <> Less)
  
  function cmp_lt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log_i32 x y = Less)
  
  function cmp_le_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log_i32 x y <> Greater)
  
  predicate well_founded_relation_i32 [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i32
  
  function index_Mapping_Int_i32 [@inline:trivial] (self: Map.map int Int32.t) (a: int) : Int32.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i32
  
  constant const_MIN: Int32.t = (-2147483648: Int32.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int32.t
  
  function no_infinite_decreasing_sequence_i32 (s: Map.map int Int32.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i32:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
          - Int32.to_int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
      - Int32.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
      - Int32.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
      - Int32.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
        - Int32.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
    - Int32.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i32 (index_Mapping_Int_i32 s result) (index_Mapping_Int_i32 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i64__no_infinite_decreasing_sequence (* <i64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_i64_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_i64 x y = Equal)
  
  function antisym2_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_i64_spec: forall x: Int64.t, y: Int64.t. cmp_log_i64 x y = Greater -> cmp_log_i64 y x = Less
  
  function antisym1_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_i64_spec: forall x: Int64.t, y: Int64.t. cmp_log_i64 x y = Less -> cmp_log_i64 y x = Greater
  
  function trans_i64 (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_i64_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_i64 x y = o
      -> cmp_log_i64 y z = o -> cmp_log_i64 x z = o
  
  function refl_i64 (x: Int64.t) : ()
  
  axiom refl_i64_spec: forall x: Int64.t. cmp_log_i64 x x = Equal
  
  function cmp_gt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_i64 x y = Greater)
  
  function cmp_ge_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_i64 x y <> Less)
  
  function cmp_lt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_i64 x y = Less)
  
  function cmp_le_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_i64 x y <> Greater)
  
  predicate well_founded_relation_i64 [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i64
  
  function index_Mapping_Int_i64 [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i64
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int64.t
  
  function no_infinite_decreasing_sequence_i64 (s: Map.map int Int64.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i64:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
          - Int64.to_int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
      - Int64.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
        - Int64.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
    - Int64.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i64 (index_Mapping_Int_i64 s result) (index_Mapping_Int_i64 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i128__no_infinite_decreasing_sequence (* <i128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom eq_cmp_i128_spec: forall x: Int128.t, y: Int128.t. (x = y) = (cmp_log_i128 x y = Equal)
  
  function antisym2_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym2_i128_spec: forall x: Int128.t, y: Int128.t. cmp_log_i128 x y = Greater -> cmp_log_i128 y x = Less
  
  function antisym1_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym1_i128_spec: forall x: Int128.t, y: Int128.t. cmp_log_i128 x y = Less -> cmp_log_i128 y x = Greater
  
  function trans_i128 (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  axiom trans_i128_spec: forall x: Int128.t, y: Int128.t, z: Int128.t, o: t_Ordering. cmp_log_i128 x y = o
      -> cmp_log_i128 y z = o -> cmp_log_i128 x z = o
  
  function refl_i128 (x: Int128.t) : ()
  
  axiom refl_i128_spec: forall x: Int128.t. cmp_log_i128 x x = Equal
  
  function cmp_gt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_gt_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.gt x y = (cmp_log_i128 x y = Greater)
  
  function cmp_ge_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_ge_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.ge x y = (cmp_log_i128 x y <> Less)
  
  function cmp_lt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_lt_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.lt x y = (cmp_log_i128 x y = Less)
  
  function cmp_le_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_le_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.le x y = (cmp_log_i128 x y <> Greater)
  
  predicate well_founded_relation_i128 [@inline:trivial] (self: Int128.t) (other: Int128.t) = Int128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i128
  
  function index_Mapping_Int_i128 [@inline:trivial] (self: Map.map int Int128.t) (a: int) : Int128.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i128
  
  constant const_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int128.t
  
  function no_infinite_decreasing_sequence_i128 (s: Map.map int Int128.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i128:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
          - Int128.to_int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
      - Int128.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
      - Int128.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
      - Int128.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
        - Int128.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
    - Int128.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i128 (index_Mapping_Int_i128 s result) (index_Mapping_Int_i128 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_isize__no_infinite_decreasing_sequence (* <isize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate well_founded_relation_isize [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_isize
  
  function index_Mapping_Int_isize [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_isize
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int64.t
  
  function no_infinite_decreasing_sequence_isize (s: Map.map int Int64.t) : int
  
  goal vc_no_infinite_decreasing_sequence_isize:
    no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
          - Int64.to_int const_MIN)
        >= 0
      && not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
      - Int64.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
        - Int64.to_int const_MIN)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
    - Int64.to_int const_MIN) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_isize (index_Mapping_Int_isize s result) (index_Mapping_Int_isize s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_ref_T__no_infinite_decreasing_sequence (* <&T as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation_T (self: t_T) (other: t_T)
  
  predicate well_founded_relation_ref_T [@inline:trivial] (self: t_T) (other: t_T) = well_founded_relation_T self other
  
  meta "rewrite_def" predicate well_founded_relation_ref_T
  
  function index_Mapping_Int_ref_T [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_ref_T
  
  function index_Mapping_Int_T [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T
  
  function no_infinite_decreasing_sequence_T (s: Map.map int t_T) : int
  
  axiom no_infinite_decreasing_sequence_T_spec: forall s: Map.map int t_T. no_infinite_decreasing_sequence_T s >= 0
  
  axiom no_infinite_decreasing_sequence_T_spec'0:
    forall s: Map.map int t_T. not well_founded_relation_T (index_Mapping_Int_T s (no_infinite_decreasing_sequence_T s)) (index_Mapping_Int_T s (no_infinite_decreasing_sequence_T s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T
  
  function no_infinite_decreasing_sequence_ref_T (s: Map.map int t_T) : int
  
  goal vc_no_infinite_decreasing_sequence_ref_T:
    no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_ref_T s i) >= 0
      && not well_founded_relation_T (index_Mapping_Int_T (fun (i: int) -> index_Mapping_Int_ref_T s i) (no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_ref_T s i))) (index_Mapping_Int_T (fun (i: int) -> index_Mapping_Int_ref_T s i) (no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_ref_T s i)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_ref_T s i) in ([@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_ref_T (index_Mapping_Int_ref_T s result) (index_Mapping_Int_ref_T s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_Box_T_Global__no_infinite_decreasing_sequence (* <std::boxed::Box<T> as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation_T (self: t_T) (other: t_T)
  
  predicate well_founded_relation_Box_T_Global [@inline:trivial] (self: t_T) (other: t_T) =
    well_founded_relation_T self other
  
  meta "rewrite_def" predicate well_founded_relation_Box_T_Global
  
  function index_Mapping_Int_Box_T_Global [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Box_T_Global
  
  function index_Mapping_Int_T [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T
  
  function no_infinite_decreasing_sequence_T (s: Map.map int t_T) : int
  
  axiom no_infinite_decreasing_sequence_T_spec: forall s: Map.map int t_T. no_infinite_decreasing_sequence_T s >= 0
  
  axiom no_infinite_decreasing_sequence_T_spec'0:
    forall s: Map.map int t_T. not well_founded_relation_T (index_Mapping_Int_T s (no_infinite_decreasing_sequence_T s)) (index_Mapping_Int_T s (no_infinite_decreasing_sequence_T s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T
  
  function no_infinite_decreasing_sequence_Box_T_Global (s: Map.map int t_T) : int
  
  goal vc_no_infinite_decreasing_sequence_Box_T_Global:
    no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i) >= 0
      && not well_founded_relation_T (index_Mapping_Int_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i) (no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i))) (index_Mapping_Int_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i) (no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i)
      + 1))
    -> (let result = no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i) in ([@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Box_T_Global (index_Mapping_Int_Box_T_Global s result) (index_Mapping_Int_Box_T_Global s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_unit__no_infinite_decreasing_sequence (* <() as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  predicate well_founded_relation_unit [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation_unit
  
  function index_Mapping_Int_unit [@inline:trivial] (self: Map.map int ()) (a: int) : () = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_unit
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int ()
  
  function no_infinite_decreasing_sequence_unit (s: Map.map int ()) : int
  
  goal vc_no_infinite_decreasing_sequence_unit:
    let result = 0 in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
    && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_unit (index_Mapping_Int_unit s result) (index_Mapping_Int_unit s (result
    + 1)))
end
module M_logic__well_founded__impl_WellFounded_for_tup8_T0_T1_T2_T3_T4_T5_T6_T7__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5, T6, T7) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type t_T7
  
  type tup8_T0_T1_T2_T3_T4_T5_T6_T7 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6; f7: t_T7 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_T6 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation_T7 (self: t_T7) (other: t_T7)
  
  predicate well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: tup8_T0_T1_T2_T3_T4_T5_T6_T7) (other: tup8_T0_T1_T2_T3_T4_T5_T6_T7) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2
      /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation_T6 self.f6 other.f6
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3
    /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ self.f6 = other.f6 /\ well_founded_relation_T7 self.f7 other.f7
  
  meta "rewrite_def" predicate well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  function index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7) (a: int) : tup8_T0_T1_T2_T3_T4_T5_T6_T7
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup7_T1_T2_T3_T4_T5_T6_T7 = {
    f0'0: t_T1;
    f1'0: t_T2;
    f2'0: t_T3;
    f3'0: t_T4;
    f4'0: t_T5;
    f5'0: t_T6;
    f6'0: t_T7 }
  
  type tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 = { f0'1: t_T0; f1'1: tup7_T1_T2_T3_T4_T5_T6_T7 }
  
  function tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (self: tup8_T0_T1_T2_T3_T4_T5_T6_T7) : tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7
   = { f0'1 = self.f0;
       f1'1 = { f0'0 = self.f1;
                f1'0 = self.f2;
                f2'0 = self.f3;
                f3'0 = self.f4;
                f4'0 = self.f5;
                f5'0 = self.f6;
                f6'0 = self.f7 } }
  
  predicate well_founded_relation_tup7_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: tup7_T1_T2_T3_T4_T5_T6_T7) (other: tup7_T1_T2_T3_T4_T5_T6_T7) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation_T4 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation_T5 self.f4'0 other.f4'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0
      /\ self.f3'0 = other.f3'0 /\ self.f4'0 = other.f4'0 /\ well_founded_relation_T6 self.f5'0 other.f5'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0
    /\ self.f3'0 = other.f3'0
    /\ self.f4'0 = other.f4'0 /\ self.f5'0 = other.f5'0 /\ well_founded_relation_T7 self.f6'0 other.f6'0
  
  meta "rewrite_def" predicate well_founded_relation_tup7_T1_T2_T3_T4_T5_T6_T7
  
  predicate well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) (other: tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup7_T1_T2_T3_T4_T5_T6_T7 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7
  
  function index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) (a: int) : tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i).f0'1 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0:
    forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i).f0'1 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) : Map.map int t_T0 =
    fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  function no_infinite_decreasing_sequence_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (s: Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7) : int
  
  goal vc_no_infinite_decreasing_sequence_tup8_T0_T1_T2_T3_T4_T5_T6_T7: if exists r: int. r >= 0
      /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
      + 1)) then
      ([@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
          + 1))) x)
      /\ (index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
        + 1))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s result) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (fun (i'0: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i'0)) i) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (fun (i'0: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i)))
          >= 0
        && not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable_Int in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s result) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup7_T0_T1_T2_T3_T4_T5_T6__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5, T6) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type tup7_T0_T1_T2_T3_T4_T5_T6 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_T6 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: tup7_T0_T1_T2_T3_T4_T5_T6) (other: tup7_T0_T1_T2_T3_T4_T5_T6) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation_T6 self.f6 other.f6
  
  meta "rewrite_def" predicate well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6
  
  function index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: Map.map int tup7_T0_T1_T2_T3_T4_T5_T6) (a: int) : tup7_T0_T1_T2_T3_T4_T5_T6
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup6_T1_T2_T3_T4_T5_T6 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4; f4'0: t_T5; f5'0: t_T6 }
  
  type tup2_T0_tup6_T1_T2_T3_T4_T5_T6 = { f0'1: t_T0; f1'1: tup6_T1_T2_T3_T4_T5_T6 }
  
  function tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (self: tup7_T0_T1_T2_T3_T4_T5_T6) : tup2_T0_tup6_T1_T2_T3_T4_T5_T6 =
    { f0'1 = self.f0;
      f1'1 = { f0'0 = self.f1; f1'0 = self.f2; f2'0 = self.f3; f3'0 = self.f4; f4'0 = self.f5; f5'0 = self.f6 } }
  
  predicate well_founded_relation_tup6_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: tup6_T1_T2_T3_T4_T5_T6) (other: tup6_T1_T2_T3_T4_T5_T6) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation_T4 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation_T5 self.f4'0 other.f4'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0
    /\ self.f3'0 = other.f3'0 /\ self.f4'0 = other.f4'0 /\ well_founded_relation_T6 self.f5'0 other.f5'0
  
  meta "rewrite_def" predicate well_founded_relation_tup6_T1_T2_T3_T4_T5_T6
  
  predicate well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: tup2_T0_tup6_T1_T2_T3_T4_T5_T6) (other: tup2_T0_tup6_T1_T2_T3_T4_T5_T6) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup6_T1_T2_T3_T4_T5_T6 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6
  
  function index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6) (a: int) : tup2_T0_tup6_T1_T2_T3_T4_T5_T6
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i).f0'1 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i).f0'1 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6) : Map.map int t_T0 =
    fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup7_T0_T1_T2_T3_T4_T5_T6
  
  function no_infinite_decreasing_sequence_tup7_T0_T1_T2_T3_T4_T5_T6 (s: Map.map int tup7_T0_T1_T2_T3_T4_T5_T6) : int
  
  goal vc_no_infinite_decreasing_sequence_tup7_T0_T1_T2_T3_T4_T5_T6: if exists r: int. r >= 0
      /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
      + 1)) then
      ([@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
          + 1))) x)
      /\ (index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
        + 1))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s result) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (fun (i'0: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i'0)) i) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (fun (i'0: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i)))
          >= 0
        && not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable_Int in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s result) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup6_T0_T1_T2_T3_T4_T5__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type tup6_T0_T1_T2_T3_T4_T5 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 [@inline:trivial] (self: tup6_T0_T1_T2_T3_T4_T5) (other: tup6_T0_T1_T2_T3_T4_T5) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
  
  meta "rewrite_def" predicate well_founded_relation_tup6_T0_T1_T2_T3_T4_T5
  
  function index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 [@inline:trivial] (self: Map.map int tup6_T0_T1_T2_T3_T4_T5) (a: int) : tup6_T0_T1_T2_T3_T4_T5
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup5_T1_T2_T3_T4_T5 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4; f4'0: t_T5 }
  
  type tup2_T0_tup5_T1_T2_T3_T4_T5 = { f0'1: t_T0; f1'1: tup5_T1_T2_T3_T4_T5 }
  
  function tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (self: tup6_T0_T1_T2_T3_T4_T5) : tup2_T0_tup5_T1_T2_T3_T4_T5 =
    { f0'1 = self.f0; f1'1 = { f0'0 = self.f1; f1'0 = self.f2; f2'0 = self.f3; f3'0 = self.f4; f4'0 = self.f5 } }
  
  predicate well_founded_relation_tup5_T1_T2_T3_T4_T5 [@inline:trivial] (self: tup5_T1_T2_T3_T4_T5) (other: tup5_T1_T2_T3_T4_T5) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation_T4 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation_T5 self.f4'0 other.f4'0
  
  meta "rewrite_def" predicate well_founded_relation_tup5_T1_T2_T3_T4_T5
  
  predicate well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 [@inline:trivial] (self: tup2_T0_tup5_T1_T2_T3_T4_T5) (other: tup2_T0_tup5_T1_T2_T3_T4_T5) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup5_T1_T2_T3_T4_T5 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5
  
  function index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 [@inline:trivial] (self: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5) (a: int) : tup2_T0_tup5_T1_T2_T3_T4_T5
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i).f0'1 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i).f0'1 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5) : Map.map int t_T0 =
    fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup6_T0_T1_T2_T3_T4_T5
  
  function no_infinite_decreasing_sequence_tup6_T0_T1_T2_T3_T4_T5 (s: Map.map int tup6_T0_T1_T2_T3_T4_T5) : int
  
  goal vc_no_infinite_decreasing_sequence_tup6_T0_T1_T2_T3_T4_T5: if exists r: int. r >= 0
      /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
      + 1)) then
      ([@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
          + 1))) x)
      /\ (index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
        + 1))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s result) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 (fun (i'0: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i'0)) i) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 (fun (i'0: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i)))
          >= 0
        && not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable_Int in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s result) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup5_T0_T1_T2_T3_T4__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type tup5_T0_T1_T2_T3_T4 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_tup5_T0_T1_T2_T3_T4 [@inline:trivial] (self: tup5_T0_T1_T2_T3_T4) (other: tup5_T0_T1_T2_T3_T4) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
  
  meta "rewrite_def" predicate well_founded_relation_tup5_T0_T1_T2_T3_T4
  
  function index_Mapping_Int_tup5_T0_T1_T2_T3_T4 [@inline:trivial] (self: Map.map int tup5_T0_T1_T2_T3_T4) (a: int) : tup5_T0_T1_T2_T3_T4
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup5_T0_T1_T2_T3_T4
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup4_T1_T2_T3_T4 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4 }
  
  type tup2_T0_tup4_T1_T2_T3_T4 = { f0'1: t_T0; f1'1: tup4_T1_T2_T3_T4 }
  
  function tuple_to_pair_tup5_T0_T1_T2_T3_T4 (self: tup5_T0_T1_T2_T3_T4) : tup2_T0_tup4_T1_T2_T3_T4 = { f0'1 = self.f0;
                                                                                                        f1'1 = { f0'0 = self.f1;
                                                                                                                 f1'0 = self.f2;
                                                                                                                 f2'0 = self.f3;
                                                                                                                 f3'0 = self.f4 } }
  
  predicate well_founded_relation_tup4_T1_T2_T3_T4 [@inline:trivial] (self: tup4_T1_T2_T3_T4) (other: tup4_T1_T2_T3_T4) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation_T4 self.f3'0 other.f3'0
  
  meta "rewrite_def" predicate well_founded_relation_tup4_T1_T2_T3_T4
  
  predicate well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 [@inline:trivial] (self: tup2_T0_tup4_T1_T2_T3_T4) (other: tup2_T0_tup4_T1_T2_T3_T4) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup4_T1_T2_T3_T4 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4
  
  function index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 [@inline:trivial] (self: Map.map int tup2_T0_tup4_T1_T2_T3_T4) (a: int) : tup2_T0_tup4_T1_T2_T3_T4
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup4_T1_T2_T3_T4) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i).f0'1 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i).f0'1 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup4_T1_T2_T3_T4) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup4_T1_T2_T3_T4) : Map.map int t_T0 = fun (i: int) -> if 0
    <= i then
      (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup5_T0_T1_T2_T3_T4
  
  function no_infinite_decreasing_sequence_tup5_T0_T1_T2_T3_T4 (s: Map.map int tup5_T0_T1_T2_T3_T4) : int
  
  goal vc_no_infinite_decreasing_sequence_tup5_T0_T1_T2_T3_T4: if exists r: int. r >= 0
      /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
      + 1)) then
      ([@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
          + 1))) x)
      /\ (index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
        + 1))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s result) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 (fun (i'0: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i'0)) i) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 (fun (i'0: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i)))
          >= 0
        && not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable_Int in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s result) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup4_T0_T1_T2_T3__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type tup4_T0_T1_T2_T3 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_tup4_T0_T1_T2_T3 [@inline:trivial] (self: tup4_T0_T1_T2_T3) (other: tup4_T0_T1_T2_T3) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
  
  meta "rewrite_def" predicate well_founded_relation_tup4_T0_T1_T2_T3
  
  function index_Mapping_Int_tup4_T0_T1_T2_T3 [@inline:trivial] (self: Map.map int tup4_T0_T1_T2_T3) (a: int) : tup4_T0_T1_T2_T3
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup4_T0_T1_T2_T3
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup3_T1_T2_T3 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3 }
  
  type tup2_T0_tup3_T1_T2_T3 = { f0'1: t_T0; f1'1: tup3_T1_T2_T3 }
  
  function tuple_to_pair_tup4_T0_T1_T2_T3 (self: tup4_T0_T1_T2_T3) : tup2_T0_tup3_T1_T2_T3 = { f0'1 = self.f0;
                                                                                               f1'1 = { f0'0 = self.f1;
                                                                                                        f1'0 = self.f2;
                                                                                                        f2'0 = self.f3 } }
  
  predicate well_founded_relation_tup3_T1_T2_T3 [@inline:trivial] (self: tup3_T1_T2_T3) (other: tup3_T1_T2_T3) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
  
  meta "rewrite_def" predicate well_founded_relation_tup3_T1_T2_T3
  
  predicate well_founded_relation_tup2_T0_tup3_T1_T2_T3 [@inline:trivial] (self: tup2_T0_tup3_T1_T2_T3) (other: tup2_T0_tup3_T1_T2_T3) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup3_T1_T2_T3 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup3_T1_T2_T3
  
  function index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 [@inline:trivial] (self: Map.map int tup2_T0_tup3_T1_T2_T3) (a: int) : tup2_T0_tup3_T1_T2_T3
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup3_T1_T2_T3
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup3_T1_T2_T3) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i).f0'1 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i).f0'1 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup3_T1_T2_T3) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup3_T1_T2_T3) : Map.map int t_T0 = fun (i: int) -> if 0
    <= i then
      (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup3_T1_T2_T3. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup4_T0_T1_T2_T3
  
  function no_infinite_decreasing_sequence_tup4_T0_T1_T2_T3 (s: Map.map int tup4_T0_T1_T2_T3) : int
  
  goal vc_no_infinite_decreasing_sequence_tup4_T0_T1_T2_T3: if exists r: int. r >= 0
      /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
      + 1)) then
      ([@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
          + 1))) x)
      /\ (index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
        + 1))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s result) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 (fun (i'0: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i'0)) i) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 (fun (i'0: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i)))
          >= 0
        && not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable_Int in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s result) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup3_T0_T1_T2__no_infinite_decreasing_sequence (* <(T0, T1, T2) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type tup3_T0_T1_T2 = { f0: t_T0; f1: t_T1; f2: t_T2 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup3_T0_T1_T2 [@inline:trivial] (self: tup3_T0_T1_T2) (other: tup3_T0_T1_T2) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
  
  meta "rewrite_def" predicate well_founded_relation_tup3_T0_T1_T2
  
  function index_Mapping_Int_tup3_T0_T1_T2 [@inline:trivial] (self: Map.map int tup3_T0_T1_T2) (a: int) : tup3_T0_T1_T2
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup3_T0_T1_T2
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup2_T1_T2 = { f0'0: t_T1; f1'0: t_T2 }
  
  type tup2_T0_tup2_T1_T2 = { f0'1: t_T0; f1'1: tup2_T1_T2 }
  
  function tuple_to_pair_tup3_T0_T1_T2 (self: tup3_T0_T1_T2) : tup2_T0_tup2_T1_T2 = { f0'1 = self.f0;
                                                                                      f1'1 = { f0'0 = self.f1;
                                                                                               f1'0 = self.f2 } }
  
  predicate well_founded_relation_tup2_T1_T2 [@inline:trivial] (self: tup2_T1_T2) (other: tup2_T1_T2) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T1_T2
  
  predicate well_founded_relation_tup2_T0_tup2_T1_T2 [@inline:trivial] (self: tup2_T0_tup2_T1_T2) (other: tup2_T0_tup2_T1_T2) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup2_T1_T2 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup2_T1_T2
  
  function index_Mapping_Int_tup2_T0_tup2_T1_T2 [@inline:trivial] (self: Map.map int tup2_T0_tup2_T1_T2) (a: int) : tup2_T0_tup2_T1_T2
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup2_T1_T2
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup2_T1_T2) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i).f0'1 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i).f0'1 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup2_T1_T2) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup2_T1_T2) : Map.map int t_T0 = fun (i: int) -> if 0
    <= i then
      (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup2_T1_T2. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup3_T0_T1_T2
  
  function no_infinite_decreasing_sequence_tup3_T0_T1_T2 (s: Map.map int tup3_T0_T1_T2) : int
  
  goal vc_no_infinite_decreasing_sequence_tup3_T0_T1_T2: if exists r: int. r >= 0
      /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
      + 1)) then
      ([@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
          + 1))) x)
      /\ (index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
        + 1))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s result) (index_Mapping_Int_tup3_T0_T1_T2 s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 (fun (i'0: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i'0)) i) (index_Mapping_Int_tup2_T0_tup2_T1_T2 (fun (i'0: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i)))
          >= 0
        && not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable_Int in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s result) (index_Mapping_Int_tup3_T0_T1_T2 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup2_T0_T1__no_infinite_decreasing_sequence (* <(T0, T1) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type tup2_T0_T1 = { f0: t_T0; f1: t_T1 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_tup2_T0_T1 [@inline:trivial] (self: tup2_T0_T1) (other: tup2_T0_T1) =
    well_founded_relation_T0 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_T1
  
  function index_Mapping_Int_tup2_T0_T1 [@inline:trivial] (self: Map.map int tup2_T0_T1) (a: int) : tup2_T0_T1 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_T1
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup2_T0_tup1_T1 = { f0'0: t_T0; f1'0: t_T1 }
  
  function tuple_to_pair_tup2_T0_T1 (self: tup2_T0_T1) : tup2_T0_tup1_T1 = { f0'0 = self.f0; f1'0 = self.f1 }
  
  predicate well_founded_relation_tup1_T1 [@inline:trivial] (self: t_T1) (other: t_T1) =
    well_founded_relation_T1 self other
  
  meta "rewrite_def" predicate well_founded_relation_tup1_T1
  
  predicate well_founded_relation_tup2_T0_tup1_T1 [@inline:trivial] (self: tup2_T0_tup1_T1) (other: tup2_T0_tup1_T1) =
    well_founded_relation_T0 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_tup1_T1 self.f1'0 other.f1'0
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup1_T1
  
  function index_Mapping_Int_tup2_T0_tup1_T1 [@inline:trivial] (self: Map.map int tup2_T0_tup1_T1) (a: int) : tup2_T0_tup1_T1
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup1_T1
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup1_T1) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup1_T1 s i).f0'0 (index_Mapping_Int_tup2_T0_tup1_T1 s (i
      + 1)).f0'0 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup1_T1 s i).f0'0 (index_Mapping_Int_tup2_T0_tup1_T1 s (extract_next_decr_T0 s i)).f0'0
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup1_T1) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup1_T1 s prev).f0'0 (index_Mapping_Int_tup2_T0_tup1_T1 s (extract_nth_T0 s i)).f0'0)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup1_T1) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_tup1_T1 s (extract_nth_T0 s i)).f0'0
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup1_T1. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i) (index_Mapping_Int_tup2_T0_tup1_T1 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup2_T0_T1
  
  function no_infinite_decreasing_sequence_tup2_T0_T1 (s: Map.map int tup2_T0_T1) : int
  
  goal vc_no_infinite_decreasing_sequence_tup2_T0_T1: if exists r: int. r >= 0
      /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
      + 1)) then
      ([@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
          + 1))) x)
      /\ (index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
        + 1))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s result) (index_Mapping_Int_tup2_T0_T1 s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 (fun (i'0: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i'0)) i) (index_Mapping_Int_tup2_T0_tup1_T1 (fun (i'0: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i)))
          >= 0
        && not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable_Int in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s result) (index_Mapping_Int_tup2_T0_T1 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup1_T0__no_infinite_decreasing_sequence (* <(T0,) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_tup1_T0 [@inline:trivial] (self: t_T0) (other: t_T0) =
    well_founded_relation_T0 self other
  
  meta "rewrite_def" predicate well_founded_relation_tup1_T0
  
  function index_Mapping_Int_tup1_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup1_T0
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup2_T0_unit = { f0: t_T0; f1: () }
  
  function tuple_to_pair_tup1_T0 (self: t_T0) : tup2_T0_unit = { f0 = self; f1 = () }
  
  predicate well_founded_relation_unit [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation_unit
  
  predicate well_founded_relation_tup2_T0_unit [@inline:trivial] (self: tup2_T0_unit) (other: tup2_T0_unit) =
    well_founded_relation_T0 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_unit self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_unit
  
  function index_Mapping_Int_tup2_T0_unit [@inline:trivial] (self: Map.map int tup2_T0_unit) (a: int) : tup2_T0_unit =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_unit
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_unit) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_unit s i).f0 (index_Mapping_Int_tup2_T0_unit s (i
      + 1)).f0 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_unit s i).f0 (index_Mapping_Int_tup2_T0_unit s (extract_next_decr_T0 s i)).f0
  
  function extract_nth_T0 (s: Map.map int tup2_T0_unit) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_unit s prev).f0 (index_Mapping_Int_tup2_T0_unit s (extract_nth_T0 s i)).f0)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_unit) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_unit s (extract_nth_T0 s i)).f0
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_unit. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i) (index_Mapping_Int_tup2_T0_unit s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T0
  
  function no_infinite_decreasing_sequence_tup1_T0 (s: Map.map int t_T0) : int
  
  goal vc_no_infinite_decreasing_sequence_tup1_T0: if exists r: int. r >= 0
      /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r + 1)) then
      ([@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r + 1))) x)
      /\ (index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r + 1))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r
      + 1))) in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s result) (index_Mapping_Int_tup1_T0 s (result
      + 1)))))
    else
      ([@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit (fun (i'0: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i'0)) i) (index_Mapping_Int_tup2_T0_unit (fun (i'0: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i'0)) (i
          + 1)))
      /\ ((forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i'0))) (i
          + 1)))
      -> no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i)))
          >= 0
        && not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i)))
        + 1))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i))) in ([@expl:unreachable requires] false)
      /\ (false
      -> (let result = unreachable_Int in ([@expl:no_infinite_decreasing_sequence ensures #0] result >= 0)
      && ([@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s result) (index_Mapping_Int_tup1_T0 s (result
      + 1)))))))

end
module M_logic__well_founded__extract_next_decr
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T1
  
  type t_T2
  
  type tup2_T1_T2 = { f0: t_T1; f1: t_T2 }
  
  function index_Mapping_Int_tup2_T1_T2 [@inline:trivial] (self: Map.map int tup2_T1_T2) (a: int) : tup2_T1_T2 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T1_T2
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup2_T1_T2 [@inline:trivial] (self: tup2_T1_T2) (other: tup2_T1_T2) =
    well_founded_relation_T1 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T2 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T1_T2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup2_T1_T2
  
  constant i : int
  
  function extract_next_decr_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  goal vc_extract_next_decr_T1: (forall i'0: int. 0 <= i'0
        -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
        + 1)))
    -> 0 <= i
    -> (if well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (i
    + 1)).f0 then
      let result = i + 1 in ([@expl:extract_next_decr ensures #0] i < result)
      && ([@expl:extract_next_decr ensures #1] well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s result).f0)
    else
      ((([@expl:extract_next_decr requires #0] forall i'0: int. 0 <= i'0
              -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
              + 1)))
          && ([@expl:extract_next_decr requires #1] 0 <= i + 1))
        /\ well_founded_relation_T2 (index_Mapping_Int_tup2_T1_T2 s i).f1 (index_Mapping_Int_tup2_T1_T2 s (i + 1)).f1)
      /\ (i + 1 < extract_next_decr_T1 s (i + 1)
        && well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s (i
        + 1)).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_next_decr_T1 s (i + 1))).f0
      -> (let result = extract_next_decr_T1 s (i + 1) in ([@expl:extract_next_decr ensures #0] i < result)
      && ([@expl:extract_next_decr ensures #1] well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s result).f0)))
    )
end
module M_logic__well_founded__extract_nth
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T1
  
  type t_T2
  
  type tup2_T1_T2 = { f0: t_T1; f1: t_T2 }
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup2_T1_T2 [@inline:trivial] (self: tup2_T1_T2) (other: tup2_T1_T2) =
    well_founded_relation_T1 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T2 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T1_T2
  
  function index_Mapping_Int_tup2_T1_T2 [@inline:trivial] (self: Map.map int tup2_T1_T2) (a: int) : tup2_T1_T2 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T1_T2
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function extract_next_decr_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  axiom extract_next_decr_T1_def: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T1 s i
      = (if well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (i
      + 1)).f0 then
        i + 1
      else
        extract_next_decr_T1 s (i + 1)
      )
  
  axiom extract_next_decr_T1_spec: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T1 s i
  
  axiom extract_next_decr_T1_spec'0: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_next_decr_T1 s i)).f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup2_T1_T2
  
  constant i : int
  
  function extract_nth_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  goal vc_extract_nth_T1: (forall i'0: int. 0 <= i'0
        -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
        + 1)))
    -> 0 <= i
    -> (if i = 0 then
      let result = 0 in ([@expl:extract_nth ensures #0] 0 <= result)
      && ([@expl:extract_nth ensures #1] 0 < i
      -> (let prev = extract_nth_T1 s (i - 1) in prev < result
      /\ well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev).f0 (index_Mapping_Int_tup2_T1_T2 s result).f0))
    else
      ((([@expl:extract_nth requires #0] forall i'0: int. 0 <= i'0
              -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
              + 1)))
          && ([@expl:extract_nth requires #1] 0 <= i - 1))
        /\ well_founded_relation_Int i (i - 1))
      /\ (0 <= extract_nth_T1 s (i - 1)
        && (0 < i - 1
        -> (let prev = extract_nth_T1 s (i - 1 - 1) in prev < extract_nth_T1 s (i - 1)
        /\ well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_nth_T1 s (i
        - 1))).f0))
      -> (let prev = extract_nth_T1 s (i - 1) in (([@expl:extract_next_decr requires #0] forall i'0: int. 0 <= i'0
            -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
            + 1)))
        && ([@expl:extract_next_decr requires #1] 0 <= prev))
      /\ (prev < extract_next_decr_T1 s prev
        && well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_next_decr_T1 s prev)).f0
      -> (let result = extract_next_decr_T1 s prev in ([@expl:extract_nth ensures #0] 0 <= result)
      && ([@expl:extract_nth ensures #1] 0 < i
      -> (let prev'0 = extract_nth_T1 s (i - 1) in prev'0 < result
      /\ well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev'0).f0 (index_Mapping_Int_tup2_T1_T2 s result).f0))))))
    )
end
module M_logic__well_founded__first_component_decr
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T1
  
  type t_T2
  
  type tup2_T1_T2 = { f0: t_T1; f1: t_T2 }
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup2_T1_T2 [@inline:trivial] (self: tup2_T1_T2) (other: tup2_T1_T2) =
    well_founded_relation_T1 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T2 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T1_T2
  
  function index_Mapping_Int_tup2_T1_T2 [@inline:trivial] (self: Map.map int tup2_T1_T2) (a: int) : tup2_T1_T2 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T1_T2
  
  function index_Mapping_Int_T1 [@inline:trivial] (self: Map.map int t_T1) (a: int) : t_T1 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T1
  
  function extract_next_decr_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  axiom extract_next_decr_T1_def: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T1 s i
      = (if well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (i
      + 1)).f0 then
        i + 1
      else
        extract_next_decr_T1 s (i + 1)
      )
  
  axiom extract_next_decr_T1_spec: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T1 s i
  
  axiom extract_next_decr_T1_spec'0: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_next_decr_T1 s i)).f0
  
  function extract_nth_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  axiom extract_nth_T1_def: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T1 s i = (if i = 0 then 0 else let prev = extract_nth_T1 s (i - 1) in extract_next_decr_T1 s prev)
  
  axiom extract_nth_T1_spec: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T1 s i
  
  axiom extract_nth_T1_spec'0: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T1 s (i - 1) in prev < extract_nth_T1 s i
      /\ well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_nth_T1 s i)).f0)
  
  predicate index_Mapping_T1_bool [@inline:trivial] (self: Map.map t_T1 bool) (a: t_T1) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T1_bool
  
  function such_that_T1 (p: Map.map t_T1 bool) : t_T1
  
  axiom such_that_T1_spec: forall p: Map.map t_T1 bool. (exists x: t_T1. index_Mapping_T1_bool p x)
      -> index_Mapping_T1_bool p (such_that_T1 p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup2_T1_T2
  
  function first_component_decr_T1 (s: Map.map int tup2_T1_T2) : Map.map int t_T1
  
  goal vc_first_component_decr_T1: (forall i: int. 0 <= i
        -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i) (index_Mapping_Int_tup2_T1_T2 s (i + 1)))
    -> (forall i: int. if 0 <= i then
          ([@expl:extract_nth requires #0] forall i'0: int. 0 <= i'0
              -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
              + 1)))
          && ([@expl:extract_nth requires #1] 0 <= i)
        else
          [@expl:such_that requires] exists x: t_T1. index_Mapping_T1_bool (fun (__0: t_T1) -> true) x
      )
    /\ (let result = fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T1_T2 s (extract_nth_T1 s i)).f0
    else
      such_that_T1 (fun (__0: t_T1) -> true)
     in [@expl:first_component_decr ensures] forall i: int. 0 <= i
      -> well_founded_relation_T1 (index_Mapping_Int_T1 result i) (index_Mapping_Int_T1 result (i + 1)))
end
module M_peano__impl_Clone_for_PeanoInt__clone (* <peano::PeanoInt as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec clone_u64 (self_: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = self_} (! return {result}) ]
  
  predicate postcondition_once_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once_clone
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result_state: ()) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut_clone
  
  function fn_mut_once_clone (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_clone
  
  function fn_once_clone (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_PeanoInt (self: t_PeanoInt) (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_5 <- self.f0 ] s1 | s1 = clone_u64 {_5} (fun (_ret: UInt64.t) -> [ &_3 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { f0 = _3 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_PeanoInt = Any.any_l ()
    | & self: t_PeanoInt = self
    | & _3: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@expl:clone ensures] postcondition_clone () self.f0 result.f0}
      (! return {result}) ]
end
module M_peano__impl_Default_for_PeanoInt__default (* <peano::PeanoInt as std::default::Default> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec default_u64 (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = (0: UInt64.t)} (! return {result}) ]
  
  type t_PeanoInt = { f0: UInt64.t }
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: UInt64.t. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: UInt64.t. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: UInt64.t) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: UInt64.t. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: UInt64.t. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default_PeanoInt (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0 [ s0 = default_u64 (fun (_ret: UInt64.t) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { f0 = _2 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_PeanoInt = Any.any_l () | & _2: UInt64.t = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@expl:default ensures] true /\ postcondition_default () () result.f0}
      (! return {result}) ]
end
module M_peano__impl_Eq_for_PeanoInt__assert_receiver_is_total_eq (* <peano::PeanoInt as std::cmp::Eq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq_PeanoInt (self: t_PeanoInt) (return (x: ())) = (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_le_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_le_log_PeanoInt: [@expl:cmp_le_log ensures] le_log_PeanoInt x y = (cmp_log_PeanoInt x y <> Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_lt_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_lt_log_PeanoInt: [@expl:cmp_lt_log ensures] lt_log_PeanoInt x y = (cmp_log_PeanoInt x y = Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_ge_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_ge_log_PeanoInt: [@expl:cmp_ge_log ensures] ge_log_PeanoInt x y = (cmp_log_PeanoInt x y <> Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_gt_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_gt_log_PeanoInt: [@expl:cmp_gt_log ensures] gt_log_PeanoInt x y = (cmp_log_PeanoInt x y = Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__refl (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  function refl_PeanoInt (x: t_PeanoInt) : ()
  
  goal vc_refl_PeanoInt: [@expl:refl ensures] cmp_log_PeanoInt x x = Equal
end
module M_peano__impl_OrdLogic_for_PeanoInt__trans (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  constant z : t_PeanoInt
  
  constant o : t_Ordering
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : ()
  
  goal vc_trans_PeanoInt: cmp_log_PeanoInt x y = o
    -> cmp_log_PeanoInt y z = o -> ([@expl:trans ensures] cmp_log_PeanoInt x z = o)
end
module M_peano__impl_OrdLogic_for_PeanoInt__antisym1 (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_antisym1_PeanoInt: cmp_log_PeanoInt x y = Less -> ([@expl:antisym1 ensures] cmp_log_PeanoInt y x = Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__antisym2 (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_antisym2_PeanoInt: cmp_log_PeanoInt x y = Greater -> ([@expl:antisym2 ensures] cmp_log_PeanoInt y x = Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__eq_cmp (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_eq_cmp_PeanoInt: [@expl:eq_cmp ensures] (x = y) = (cmp_log_PeanoInt x y = Equal)
end
module M_peano__impl_PartialOrd_for_PeanoInt__partial_cmp (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Ordering)) = any
    [ return (result: t_Ordering) -> {result = cmp_log_PeanoInt self other} (! return {result}) ]
  
  type t_Option_Ordering = None | Some t_Ordering
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = (! bb0
    [ bb0 = s0 [ s0 = cmp_PeanoInt {self} {other} (fun (_ret: t_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- Some _4 ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Option_Ordering = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Ordering = Any.any_l () ])
    [ return (result: t_Option_Ordering) -> {[@expl:partial_cmp ensures] result = Some (cmp_log_PeanoInt self other)}
      (! return {result}) ]
end
module M_peano__impl_PartialOrd_for_PeanoInt__lt (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_PeanoInt self other)} (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0'0: t_Ordering)) = any
    [ good (f0'0: t_Ordering) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Ordering [Some f0'0: t_Option_Ordering]. Some f0'0 <> input} (! {false} any) ]
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec lt_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_PeanoInt {self} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:lt ensures] result = UInt64.lt (view_PeanoInt self) (view_PeanoInt other)}
      (! return {result}) ]
end
module M_peano__impl_PartialOrd_for_PeanoInt__le (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_PeanoInt self other)} (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0'0: t_Ordering)) = any
    [ good (f0'0: t_Ordering) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Ordering [Some f0'0: t_Option_Ordering]. Some f0'0 <> input} (! {false} any) ]
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec le_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_PeanoInt {self} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:le ensures] result = UInt64.le (view_PeanoInt self) (view_PeanoInt other)}
      (! return {result}) ]
end
module M_peano__impl_PartialOrd_for_PeanoInt__gt (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_PeanoInt self other)} (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0'0: t_Ordering)) = any
    [ good (f0'0: t_Ordering) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Ordering [Some f0'0: t_Option_Ordering]. Some f0'0 <> input} (! {false} any) ]
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec gt_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_PeanoInt {self} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:gt ensures] result = UInt64.gt (view_PeanoInt self) (view_PeanoInt other)}
      (! return {result}) ]
end
module M_peano__impl_PartialOrd_for_PeanoInt__ge (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_PeanoInt self other)} (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0'0: t_Ordering)) = any
    [ good (f0'0: t_Ordering) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Ordering [Some f0'0: t_Option_Ordering]. Some f0'0 <> input} (! {false} any) ]
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ge_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_PeanoInt {self} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:ge ensures] result = UInt64.ge (view_PeanoInt self) (view_PeanoInt other)}
      (! return {result}) ]
end
module M_peano__impl_Ord_for_PeanoInt__cmp (* <peano::PeanoInt as std::cmp::Ord> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Ordering)) = any
    [ return (result: t_Ordering) -> {result = cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs)}
      (! return {result}) ]
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Ordering)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- other.f0 ] s1
      | s1 = cmp_u64 {self.f0} {_6} (fun (_ret: t_Ordering) -> [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = return {_0} ]
    [ & _0: t_Ordering = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _6: UInt64.t = Any.any_l () ])
    [ return (result: t_Ordering) -> {[@expl:cmp ensures] result = cmp_log_PeanoInt self other} (! return {result}) ]
end
module M_peano__impl_PartialEq_for_PeanoInt__eq (* <peano::PeanoInt as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self.f0 = other.f0 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self: t_PeanoInt = self | & other: t_PeanoInt = other ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (self = other)} (! return {result}) ]
end
module M_peano__impl_PeanoInt__new (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { f0 = (0: UInt64.t) } ] s1 | s1 = return {_0} ] ] [ & _0: t_PeanoInt = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@expl:new ensures] result.f0 = (0: UInt64.t)} (! return {result}) ]
end
module M_peano__impl_PeanoInt__to_u64 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_u64 (self: t_PeanoInt) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self.f0 ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: UInt64.t) -> {[@expl:to_u64 ensures] result = self.f0} (! return {result}) ]
end
module M_peano__impl_PeanoInt__to_u128 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_u128 (self: t_PeanoInt) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt128.of_int {UInt64.t'int self.f0} (fun (_ret_from: UInt128.t) -> [ &_0 <- _ret_from ] s1)
      | s1 = return {_0} ] ] [ & _0: UInt128.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: UInt128.t) -> {[@expl:to_u128 ensures] UInt128.t'int result = UInt64.t'int self.f0}
      (! return {result}) ]
end
module M_peano__impl_PeanoInt__to_i128 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_i128 (self: t_PeanoInt) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int128.of_int {UInt64.t'int self.f0} (fun (_ret_from: Int128.t) -> [ &_0 <- _ret_from ] s1)
      | s1 = return {_0} ] ] [ & _0: Int128.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: Int128.t) -> {[@expl:to_i128 ensures] Int128.to_int result = UInt64.t'int self.f0}
      (! return {result}) ]
end
module M_peano__impl_From_for_u64__from (* <u64 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec to_u64 (self: t_PeanoInt) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = self.f0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_u64 (val': t_PeanoInt) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_u64 {val'} (fun (_ret: UInt64.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: UInt64.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: UInt64.t) -> {[@expl:from ensures] result = val'.f0} (! return {result}) ]
end
module M_peano__impl_From_for_i64__from (* <i64 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec to_i64 (self: t_PeanoInt) (return (x: Int64.t)) = any
    [ return (result: Int64.t) -> {Int64.to_int result = UInt64.t'int self.f0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_i64 (val': t_PeanoInt) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_i64 {val'} (fun (_ret: Int64.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: Int64.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: Int64.t) -> {[@expl:from ensures] Int64.to_int result = UInt64.t'int val'.f0}
      (! return {result}) ]
end
module M_peano__impl_From_for_u128__from (* <u128 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec to_u128 (self: t_PeanoInt) (return (x: UInt128.t)) = any
    [ return (result: UInt128.t) -> {UInt128.t'int result = UInt64.t'int self.f0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_u128 (val': t_PeanoInt) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_u128 {val'} (fun (_ret: UInt128.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: UInt128.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: UInt128.t) -> {[@expl:from ensures] UInt128.t'int result = UInt64.t'int val'.f0}
      (! return {result}) ]
end
module M_peano__impl_From_for_i128__from (* <i128 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec to_i128 (self: t_PeanoInt) (return (x: Int128.t)) = any
    [ return (result: Int128.t) -> {Int128.to_int result = UInt64.t'int self.f0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_i128 (val': t_PeanoInt) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_i128 {val'} (fun (_ret: Int128.t) -> [ &_0 <- _ret ] s1) | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: Int128.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: Int128.t) -> {[@expl:from ensures] Int128.to_int result = UInt64.t'int val'.f0}
      (! return {result}) ]
end
module M_resolve__impl_Resolve_for_ref_T__resolve_coherence (* <&'a T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate resolve_ref_T (self: t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_T
  
  function resolve_coherence_ref_T (self: t_T) : ()
  
  goal vc_resolve_coherence_ref_T: [@expl:resolve_coherence ensures] resolve_ref_T self
end
module M_resolve__impl_Resolve_for_ref_T_0__resolve_coherence (* <&'a mut T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate resolve_ref_T (self: MutBorrow.t t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_T
  
  function resolve_coherence_ref_T (self: MutBorrow.t t_T) : ()
  
  goal vc_resolve_coherence_ref_T: [@expl:resolve_coherence ensures] resolve_ref_T self
end
module M_snapshot__impl_Clone_for_Snapshot_T__clone (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Snapshot_T (self: t_T) (return (x: t_T)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = return {_0} ] ] [ & _0: t_T = Any.any_l () | & self: t_T = self ])
    [ return (result: t_T) -> {[@expl:clone ensures] result = self} (! return {result}) ]
end
module M_std__array__impl_IteratorSpec_for_IntoIter_T__produces_refl (* <std::array::IntoIter<T, N> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : Seq.seq t_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    view_IntoIter_T self = Seq.(++) visited (view_IntoIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_T
  
  function produces_refl_IntoIter_T (self: t_IntoIter_T) : ()
  
  goal vc_produces_refl_IntoIter_T: [@expl:produces_refl ensures] produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__array__impl_IteratorSpec_for_IntoIter_T__produces_trans (* <std::array::IntoIter<T, N> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : Seq.seq t_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    view_IntoIter_T self = Seq.(++) visited (view_IntoIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter_T
  
  function produces_trans_IntoIter_T (a: t_IntoIter_T) (ab: Seq.seq t_T) (b: t_IntoIter_T) (bc: Seq.seq t_T) (c: t_IntoIter_T) : ()
  
  goal vc_produces_trans_IntoIter_T: produces_IntoIter_T a ab b
    -> produces_IntoIter_T b bc c -> ([@expl:produces_trans ensures] produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__clone__extern_spec_Clone_bool_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_bool_clone_body (self_: bool) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ] [ & _0: bool = Any.any_l () | & self_: bool = self_ ])
    [ return (result: bool) -> {[@expl:extern_spec_Clone_bool_clone_body ensures] result = self_} (! return {result}) ]
end
module M_std__clone__extern_spec_Clone_f32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.float.Float32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_f32_clone_body (self_: Float32.t) (return (x: Float32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Float32.t = Any.any_l () | & self_: Float32.t = self_ ])
    [ return (result: Float32.t) -> {[@expl:extern_spec_Clone_f32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__clone__extern_spec_Clone_f64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.float.Float64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_f64_clone_body (self_: Float64.t) (return (x: Float64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Float64.t = Any.any_l () | & self_: Float64.t = self_ ])
    [ return (result: Float64.t) -> {[@expl:extern_spec_Clone_f64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__clone__extern_spec_T_Clone_ref_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_ref_ref_T [@inline:trivial] (self: t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_T
  
  predicate inv_ref_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone__ref_T_clone_body_T (self_: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_T_Clone__ref_T_clone_body 'self_' type invariant] inv_ref_ref_T self_}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ] [ & _0: t_T = Any.any_l () | & self_: t_T = self_ ])
    [ return (result: t_T) -> {[@expl:extern_spec_T_Clone__ref_T_clone_body result type invariant] inv_ref_T result}
      {[@expl:extern_spec_T_Clone__ref_T_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IntoIter_K_V__produces_refl (* <std::collections::hash_map::IntoIter<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IntoIter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_IntoIter_K_V (self: t_IntoIter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_DeepModelTy_V (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (view_FMap_DeepModelTy_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate produces_IntoIter_K_V [@inline:trivial] (self: t_IntoIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_IntoIter_K_V) =
    len_DeepModelTy (view_IntoIter_K_V self) = Seq.length visited + len_DeepModelTy (view_IntoIter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_K_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IntoIter_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IntoIter_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V o) k = Some v
        -> get_DeepModelTy (view_IntoIter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_K k2 = k /\ contains_tup2_K_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_K k1 = k /\ contains_tup2_K_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IntoIter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model_K (Seq.get visited i1).f0 = deep_model_K (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IntoIter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_K_V
  
  function produces_refl_IntoIter_K_V (self: t_IntoIter_K_V) : ()
  
  goal vc_produces_refl_IntoIter_K_V:
    [@expl:produces_refl ensures] produces_IntoIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IntoIter_K_V__produces_trans (* <std::collections::hash_map::IntoIter<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IntoIter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_IntoIter_K_V (self: t_IntoIter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_DeepModelTy_V (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (view_FMap_DeepModelTy_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate produces_IntoIter_K_V [@inline:trivial] (self: t_IntoIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_IntoIter_K_V) =
    len_DeepModelTy (view_IntoIter_K_V self) = Seq.length visited + len_DeepModelTy (view_IntoIter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_K_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IntoIter_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IntoIter_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V o) k = Some v
        -> get_DeepModelTy (view_IntoIter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_K k2 = k /\ contains_tup2_K_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_K k1 = k /\ contains_tup2_K_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IntoIter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model_K (Seq.get visited i1).f0 = deep_model_K (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IntoIter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_K_V
  
  constant ab : Seq.seq tup2_K_V
  
  constant b : t_IntoIter_K_V
  
  constant bc : Seq.seq tup2_K_V
  
  constant c : t_IntoIter_K_V
  
  function produces_trans_IntoIter_K_V (a: t_IntoIter_K_V) (ab: Seq.seq tup2_K_V) (b: t_IntoIter_K_V) (bc: Seq.seq tup2_K_V) (c: t_IntoIter_K_V) : ()
  
  goal vc_produces_trans_IntoIter_K_V: produces_IntoIter_K_V a ab b
    -> produces_IntoIter_K_V b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@expl:produces_trans ensures] produces_IntoIter_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_Iter_K_V__produces_refl (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_Iter_K_V (self: t_Iter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_DeepModelTy_V (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (view_FMap_DeepModelTy_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_Iter_K_V [@inline:trivial] (self: t_Iter_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_Iter_K_V) =
    len_DeepModelTy (view_Iter_K_V self) = Seq.length visited + len_DeepModelTy (view_Iter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_Iter_K_V self) (deep_model_ref_K k) = Some v
        /\ get_DeepModelTy (view_Iter_K_V o) (deep_model_ref_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V o) k = Some v
        -> get_DeepModelTy (view_Iter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V self) k = Some v
        -> (exists k2: t_K. deep_model_ref_K k2 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v })
        \/ get_DeepModelTy (view_Iter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_Iter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_K_V
  
  function produces_refl_Iter_K_V (self: t_Iter_K_V) : ()
  
  goal vc_produces_refl_Iter_K_V:
    [@expl:produces_refl ensures] produces_Iter_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_Iter_K_V__produces_trans (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_Iter_K_V (self: t_Iter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_DeepModelTy_V (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (view_FMap_DeepModelTy_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_Iter_K_V [@inline:trivial] (self: t_Iter_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_Iter_K_V) =
    len_DeepModelTy (view_Iter_K_V self) = Seq.length visited + len_DeepModelTy (view_Iter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_Iter_K_V self) (deep_model_ref_K k) = Some v
        /\ get_DeepModelTy (view_Iter_K_V o) (deep_model_ref_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V o) k = Some v
        -> get_DeepModelTy (view_Iter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V self) k = Some v
        -> (exists k2: t_K. deep_model_ref_K k2 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v })
        \/ get_DeepModelTy (view_Iter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_Iter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_K_V
  
  constant ab : Seq.seq tup2_ref_K_ref_V
  
  constant b : t_Iter_K_V
  
  constant bc : Seq.seq tup2_ref_K_ref_V
  
  constant c : t_Iter_K_V
  
  function produces_trans_Iter_K_V (a: t_Iter_K_V) (ab: Seq.seq tup2_ref_K_ref_V) (b: t_Iter_K_V) (bc: Seq.seq tup2_ref_K_ref_V) (c: t_Iter_K_V) : ()
  
  goal vc_produces_trans_Iter_K_V: produces_Iter_K_V a ab b
    -> produces_Iter_K_V b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@expl:produces_trans ensures] produces_Iter_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IterMut_K_V__produces_refl (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IterMut_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap_DeepModelTy_ref_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_ref_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_ref_V. len_DeepModelTy self >= 0
  
  function view_IterMut_K_V (self: t_IterMut_K_V) : t_FMap_DeepModelTy_ref_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_ref_V = None | Some (MutBorrow.t t_V)
  
  function view_FMap_DeepModelTy_ref_V (self: t_FMap_DeepModelTy_ref_V) : Map.map t_DeepModelTy t_Option_ref_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_ref_V) (k: t_DeepModelTy) : t_Option_ref_V =
    Map.get (view_FMap_DeepModelTy_ref_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_IterMut_K_V [@inline:trivial] (self: t_IterMut_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_IterMut_K_V) =
    len_DeepModelTy (view_IterMut_K_V self) = Seq.length visited + len_DeepModelTy (view_IterMut_K_V o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IterMut_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IterMut_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V o) k = Some v
        -> get_DeepModelTy (view_IterMut_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_ref_K k1 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IterMut_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IterMut_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut_K_V
  
  function produces_refl_IterMut_K_V (self: t_IterMut_K_V) : ()
  
  goal vc_produces_refl_IterMut_K_V:
    [@expl:produces_refl ensures] produces_IterMut_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IterMut_K_V__produces_trans (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IterMut_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap_DeepModelTy_ref_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_ref_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_ref_V. len_DeepModelTy self >= 0
  
  function view_IterMut_K_V (self: t_IterMut_K_V) : t_FMap_DeepModelTy_ref_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_ref_V = None | Some (MutBorrow.t t_V)
  
  function view_FMap_DeepModelTy_ref_V (self: t_FMap_DeepModelTy_ref_V) : Map.map t_DeepModelTy t_Option_ref_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_ref_V) (k: t_DeepModelTy) : t_Option_ref_V =
    Map.get (view_FMap_DeepModelTy_ref_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_IterMut_K_V [@inline:trivial] (self: t_IterMut_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_IterMut_K_V) =
    len_DeepModelTy (view_IterMut_K_V self) = Seq.length visited + len_DeepModelTy (view_IterMut_K_V o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IterMut_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IterMut_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V o) k = Some v
        -> get_DeepModelTy (view_IterMut_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_ref_K k1 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IterMut_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IterMut_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut_K_V
  
  constant ab : Seq.seq tup2_ref_K_ref_V
  
  constant b : t_IterMut_K_V
  
  constant bc : Seq.seq tup2_ref_K_ref_V
  
  constant c : t_IterMut_K_V
  
  function produces_trans_IterMut_K_V (a: t_IterMut_K_V) (ab: Seq.seq tup2_ref_K_ref_V) (b: t_IterMut_K_V) (bc: Seq.seq tup2_ref_K_ref_V) (c: t_IterMut_K_V) : ()
  
  goal vc_produces_trans_IterMut_K_V: produces_IterMut_K_V a ab b
    -> produces_IterMut_K_V b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@expl:produces_trans ensures] produces_IterMut_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__set_produces_trans
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_I
  
  type t_T
  
  type t_DeepModelTy
  
  function view_I (self: t_I) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_I) (visited: Seq.seq t_T) (end': t_I) =
    Fset.cardinal (view_I start) = Seq.length visited + Fset.cardinal (view_I end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_I start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1) \/ contains_DeepModelTy (view_I end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_I start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_I end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_I end') x
        -> contains_DeepModelTy (view_I start) x /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  constant concat_contains_T: () = ()
  
  axiom concat_contains_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_T (Seq.(++) a b) x
        = contains_T a x
      \/ contains_T b x
  
  type t_Option_T = None | Some t_T
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_I
  
  constant ab : Seq.seq t_T
  
  constant b : t_I
  
  constant bc : Seq.seq t_T
  
  constant c : t_I
  
  function set_produces_trans_T (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  goal vc_set_produces_trans_T: set_produces_T a ab b
    -> set_produces_T b bc c
    -> (forall a'0: Seq.seq t_T, b'0: Seq.seq t_T, x: t_T. contains_T (Seq.(++) a'0 b'0) x = contains_T a'0 x
        \/ contains_T b'0 x)
    -> (let _ = concat_contains_T in (forall i: int, x: t_T. Seq.length ab <= i /\ get_T (Seq.(++) ab bc) i = Some x
        -> contains_T bc x)
    && (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@expl:set_produces_trans ensures] set_produces_T a (Seq.(++) ab bc) c))
end
module M_std__collections__hash_set__impl_IteratorSpec_for_IntoIter_T__produces_refl (* <std::collections::hash_set::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_IntoIter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_IntoIter_T (self: t_IntoIter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_IntoIter_T) (visited: Seq.seq t_T) (end': t_IntoIter_T) =
    Fset.cardinal (view_IntoIter_T start) = Seq.length visited + Fset.cardinal (view_IntoIter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1)
        \/ contains_DeepModelTy (view_IntoIter_T end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_IntoIter_T start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_IntoIter_T end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T end') x
        -> contains_DeepModelTy (view_IntoIter_T start) x
        /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    set_produces_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_T
  
  function produces_refl_IntoIter_T (self: t_IntoIter_T) : ()
  
  goal vc_produces_refl_IntoIter_T: [@expl:produces_refl ensures] produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_IntoIter_T__produces_trans (* <std::collections::hash_set::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_IntoIter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_IntoIter_T (self: t_IntoIter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_IntoIter_T) (visited: Seq.seq t_T) (end': t_IntoIter_T) =
    Fset.cardinal (view_IntoIter_T start) = Seq.length visited + Fset.cardinal (view_IntoIter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1)
        \/ contains_DeepModelTy (view_IntoIter_T end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_IntoIter_T start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_IntoIter_T end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T end') x
        -> contains_DeepModelTy (view_IntoIter_T start) x
        /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    set_produces_T self visited o
  
  constant concat_contains_T: () = ()
  
  axiom concat_contains_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_T (Seq.(++) a b) x
        = contains_T a x
      \/ contains_T b x
  
  function set_produces_trans_T (a: t_IntoIter_T) (ab: Seq.seq t_T) (b: t_IntoIter_T) (bc: Seq.seq t_T) (c: t_IntoIter_T) : ()
   = let _ = concat_contains_T in ()
  
  axiom set_produces_trans_T_spec:
    forall a: t_IntoIter_T, ab: Seq.seq t_T, b: t_IntoIter_T, bc: Seq.seq t_T, c: t_IntoIter_T. set_produces_T a ab b
      -> set_produces_T b bc c -> set_produces_T a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter_T
  
  function produces_trans_IntoIter_T (a: t_IntoIter_T) (ab: Seq.seq t_T) (b: t_IntoIter_T) (bc: Seq.seq t_T) (c: t_IntoIter_T) : ()
  
  goal vc_produces_trans_IntoIter_T: produces_IntoIter_T a ab b
    -> produces_IntoIter_T b bc c
    -> (([@expl:set_produces_trans requires #0] set_produces_T a ab b)
      && ([@expl:set_produces_trans requires #1] set_produces_T b bc c))
    /\ (set_produces_T a (Seq.(++) ab bc) c
    -> (let _ = set_produces_trans_T a ab b bc c in [@expl:produces_trans ensures] produces_IntoIter_T a (Seq.(++) ab bc) c))
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Iter_T__produces_refl (* <std::collections::hash_set::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Iter_T (self: t_Iter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Iter_T) (visited: Seq.seq t_T) (end': t_Iter_T) =
    Fset.cardinal (view_Iter_T start) = Seq.length visited + Fset.cardinal (view_Iter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Iter_T end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Iter_T start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Iter_T end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T end') x
        -> contains_DeepModelTy (view_Iter_T start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) = set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_T
  
  function produces_refl_Iter_T (self: t_Iter_T) : ()
  
  goal vc_produces_refl_Iter_T: [@expl:produces_refl ensures] produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Iter_T__produces_trans (* <std::collections::hash_set::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Iter_T (self: t_Iter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Iter_T) (visited: Seq.seq t_T) (end': t_Iter_T) =
    Fset.cardinal (view_Iter_T start) = Seq.length visited + Fset.cardinal (view_Iter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Iter_T end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Iter_T start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Iter_T end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T end') x
        -> contains_DeepModelTy (view_Iter_T start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) = set_produces_ref_T self visited o
  
  constant concat_contains_ref_T: () = ()
  
  axiom concat_contains_ref_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_ref_T (Seq.(++) a b) x
        = contains_ref_T a x
      \/ contains_ref_T b x
  
  function set_produces_trans_ref_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : () =
    let _ = concat_contains_ref_T in ()
  
  axiom set_produces_trans_ref_T_spec:
    forall a: t_Iter_T, ab: Seq.seq t_T, b: t_Iter_T, bc: Seq.seq t_T, c: t_Iter_T. set_produces_ref_T a ab b
      -> set_produces_ref_T b bc c -> set_produces_ref_T a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter_T
  
  function produces_trans_Iter_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : ()
  
  goal vc_produces_trans_Iter_T: produces_Iter_T a ab b
    -> produces_Iter_T b bc c
    -> (([@expl:set_produces_trans requires #0] set_produces_ref_T a ab b)
      && ([@expl:set_produces_trans requires #1] set_produces_ref_T b bc c))
    /\ (set_produces_ref_T a (Seq.(++) ab bc) c
    -> (let _ = set_produces_trans_ref_T a ab b bc c in [@expl:produces_trans ensures] produces_Iter_T a (Seq.(++) ab bc) c))
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Intersection_T_S__produces_refl (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Intersection_T_S
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Intersection_T_S (self: t_Intersection_T_S) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Intersection_T_S) (visited: Seq.seq t_T) (end': t_Intersection_T_S) =
    Fset.cardinal (view_Intersection_T_S start) = Seq.length visited + Fset.cardinal (view_Intersection_T_S end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Intersection_T_S end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Intersection_T_S start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Intersection_T_S end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S end') x
        -> contains_DeepModelTy (view_Intersection_T_S start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Intersection_T_S (self: t_Intersection_T_S) (visited: Seq.seq t_T) (o: t_Intersection_T_S) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Intersection_T_S
  
  function produces_refl_Intersection_T_S (self: t_Intersection_T_S) : ()
  
  goal vc_produces_refl_Intersection_T_S:
    [@expl:produces_refl ensures] produces_Intersection_T_S self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Intersection_T_S__produces_trans (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Intersection_T_S
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Intersection_T_S (self: t_Intersection_T_S) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Intersection_T_S) (visited: Seq.seq t_T) (end': t_Intersection_T_S) =
    Fset.cardinal (view_Intersection_T_S start) = Seq.length visited + Fset.cardinal (view_Intersection_T_S end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Intersection_T_S end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Intersection_T_S start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Intersection_T_S end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S end') x
        -> contains_DeepModelTy (view_Intersection_T_S start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Intersection_T_S (self: t_Intersection_T_S) (visited: Seq.seq t_T) (o: t_Intersection_T_S) =
    set_produces_ref_T self visited o
  
  constant concat_contains_ref_T: () = ()
  
  axiom concat_contains_ref_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_ref_T (Seq.(++) a b) x
        = contains_ref_T a x
      \/ contains_ref_T b x
  
  function set_produces_trans_ref_T (a: t_Intersection_T_S) (ab: Seq.seq t_T) (b: t_Intersection_T_S) (bc: Seq.seq t_T) (c: t_Intersection_T_S) : ()
   = let _ = concat_contains_ref_T in ()
  
  axiom set_produces_trans_ref_T_spec:
    forall a: t_Intersection_T_S, ab: Seq.seq t_T, b: t_Intersection_T_S, bc: Seq.seq t_T, c: t_Intersection_T_S. set_produces_ref_T a ab b
      -> set_produces_ref_T b bc c -> set_produces_ref_T a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Intersection_T_S
  
  constant ab : Seq.seq t_T
  
  constant b : t_Intersection_T_S
  
  constant bc : Seq.seq t_T
  
  constant c : t_Intersection_T_S
  
  function produces_trans_Intersection_T_S (a: t_Intersection_T_S) (ab: Seq.seq t_T) (b: t_Intersection_T_S) (bc: Seq.seq t_T) (c: t_Intersection_T_S) : ()
  
  goal vc_produces_trans_Intersection_T_S: produces_Intersection_T_S a ab b
    -> produces_Intersection_T_S b bc c
    -> (([@expl:set_produces_trans requires #0] set_produces_ref_T a ab b)
      && ([@expl:set_produces_trans requires #1] set_produces_ref_T b bc c))
    /\ (set_produces_ref_T a (Seq.(++) ab bc) c
    -> (let _ = set_produces_trans_ref_T a ab b bc c in [@expl:produces_trans ensures] produces_Intersection_T_S a (Seq.(++) ab bc) c))
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Difference_T_S__produces_refl (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Difference_T_S
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Difference_T_S (self: t_Difference_T_S) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Difference_T_S) (visited: Seq.seq t_T) (end': t_Difference_T_S) =
    Fset.cardinal (view_Difference_T_S start) = Seq.length visited + Fset.cardinal (view_Difference_T_S end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Difference_T_S end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Difference_T_S start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Difference_T_S end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S end') x
        -> contains_DeepModelTy (view_Difference_T_S start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Difference_T_S (self: t_Difference_T_S) (visited: Seq.seq t_T) (o: t_Difference_T_S) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Difference_T_S
  
  function produces_refl_Difference_T_S (self: t_Difference_T_S) : ()
  
  goal vc_produces_refl_Difference_T_S:
    [@expl:produces_refl ensures] produces_Difference_T_S self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Difference_T_S__produces_trans (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Difference_T_S
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Difference_T_S (self: t_Difference_T_S) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Difference_T_S) (visited: Seq.seq t_T) (end': t_Difference_T_S) =
    Fset.cardinal (view_Difference_T_S start) = Seq.length visited + Fset.cardinal (view_Difference_T_S end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Difference_T_S end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Difference_T_S start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Difference_T_S end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S end') x
        -> contains_DeepModelTy (view_Difference_T_S start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Difference_T_S (self: t_Difference_T_S) (visited: Seq.seq t_T) (o: t_Difference_T_S) =
    set_produces_ref_T self visited o
  
  constant concat_contains_ref_T: () = ()
  
  axiom concat_contains_ref_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_ref_T (Seq.(++) a b) x
        = contains_ref_T a x
      \/ contains_ref_T b x
  
  function set_produces_trans_ref_T (a: t_Difference_T_S) (ab: Seq.seq t_T) (b: t_Difference_T_S) (bc: Seq.seq t_T) (c: t_Difference_T_S) : ()
   = let _ = concat_contains_ref_T in ()
  
  axiom set_produces_trans_ref_T_spec:
    forall a: t_Difference_T_S, ab: Seq.seq t_T, b: t_Difference_T_S, bc: Seq.seq t_T, c: t_Difference_T_S. set_produces_ref_T a ab b
      -> set_produces_ref_T b bc c -> set_produces_ref_T a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Difference_T_S
  
  constant ab : Seq.seq t_T
  
  constant b : t_Difference_T_S
  
  constant bc : Seq.seq t_T
  
  constant c : t_Difference_T_S
  
  function produces_trans_Difference_T_S (a: t_Difference_T_S) (ab: Seq.seq t_T) (b: t_Difference_T_S) (bc: Seq.seq t_T) (c: t_Difference_T_S) : ()
  
  goal vc_produces_trans_Difference_T_S: produces_Difference_T_S a ab b
    -> produces_Difference_T_S b bc c
    -> (([@expl:set_produces_trans requires #0] set_produces_ref_T a ab b)
      && ([@expl:set_produces_trans requires #1] set_produces_ref_T b bc c))
    /\ (set_produces_ref_T a (Seq.(++) ab bc) c
    -> (let _ = set_produces_trans_ref_T a ab b bc c in [@expl:produces_trans ensures] produces_Difference_T_S a (Seq.(++) ab bc) c))
end
module M_std__cmp__extern_spec_std_cmp_PartialEq_Rhs_ne_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate invariant_ref_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_ref_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_ref_Self_
  
  predicate inv_ref_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_ref_Self_
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate invariant_ref_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_ref_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_ref_Rhs
  
  predicate inv_ref_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_ref_Rhs
  
  type t_DeepModelTy
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_ref_Self_ self
  
  meta "rewrite_def" function deep_model_ref_ref_Self_
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  function deep_model_ref_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_ref_Rhs self
  
  meta "rewrite_def" function deep_model_ref_ref_Rhs
  
  let rec eq_ref_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: bool)) =
    {[@expl:eq 'self_' type invariant] inv_ref_ref_Self_ self_}
    {[@expl:eq 'rhs' type invariant] inv_ref_ref_Rhs rhs}
    any
    [ return (result: bool) -> {result = (deep_model_ref_ref_Self_ self_ = deep_model_ref_ref_Rhs rhs)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialEq_Rhs_ne_body_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'self_' type invariant] inv_ref_Self_ self_}
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'rhs' type invariant] inv_ref_Rhs rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq_ref_Self_ {self_} {rhs} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- not _4 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self_: t_Self_ = self_ | & rhs: t_Rhs = rhs | & _4: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body ensures] result
      = (deep_model_ref_Self_ self_ <> deep_model_ref_Rhs rhs)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_PartialOrd_Rhs_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  type tup2_ref_Self__ref_Rhs = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs [precondition_partial_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_Rhs rhs
        /\ inv_ref_Self_ self_) -> precondition_partial_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs) (result: t_Option_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs, res: t_Option_Ordering [postcondition_once_partial_cmp () args res]. postcondition_once_partial_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res
      = Some (cmp_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Rhs rhs)))
  
  let rec partial_cmp_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option_Ordering)) =
    {[@expl:partial_cmp requires] precondition_partial_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Option_Ordering) -> {postcondition_once_partial_cmp () { f0 = self_; f1 = rhs } result}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0'0: t_Ordering)) = any
    [ good (f0'0: t_Ordering) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Ordering [Some f0'0: t_Option_Ordering]. Some f0'0 <> input} (! {false} any) ]
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_lt_body_Self_ (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'self_' type invariant] inv_ref_Self_ self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'other' type invariant] inv_ref_Rhs other}
    (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_Self_ {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: t_Self_ = self_
    | & other: t_Rhs = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body ensures] result
      = lt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Rhs other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_PartialOrd_Rhs_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  type tup2_ref_Self__ref_Rhs = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs [precondition_partial_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_Rhs rhs
        /\ inv_ref_Self_ self_) -> precondition_partial_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs) (result: t_Option_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs, res: t_Option_Ordering [postcondition_once_partial_cmp () args res]. postcondition_once_partial_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res
      = Some (cmp_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Rhs rhs)))
  
  let rec partial_cmp_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option_Ordering)) =
    {[@expl:partial_cmp requires] precondition_partial_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Option_Ordering) -> {postcondition_once_partial_cmp () { f0 = self_; f1 = rhs } result}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0'0: t_Ordering)) = any
    [ good (f0'0: t_Ordering) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Ordering [Some f0'0: t_Option_Ordering]. Some f0'0 <> input} (! {false} any) ]
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_le_body_Self_ (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'self_' type invariant] inv_ref_Self_ self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'other' type invariant] inv_ref_Rhs other}
    (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_Self_ {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: t_Self_ = self_
    | & other: t_Rhs = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body ensures] result
      = le_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Rhs other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_PartialOrd_Rhs_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  type tup2_ref_Self__ref_Rhs = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs [precondition_partial_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_Rhs rhs
        /\ inv_ref_Self_ self_) -> precondition_partial_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs) (result: t_Option_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs, res: t_Option_Ordering [postcondition_once_partial_cmp () args res]. postcondition_once_partial_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res
      = Some (cmp_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Rhs rhs)))
  
  let rec partial_cmp_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option_Ordering)) =
    {[@expl:partial_cmp requires] precondition_partial_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Option_Ordering) -> {postcondition_once_partial_cmp () { f0 = self_; f1 = rhs } result}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0'0: t_Ordering)) = any
    [ good (f0'0: t_Ordering) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Ordering [Some f0'0: t_Option_Ordering]. Some f0'0 <> input} (! {false} any) ]
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_gt_body_Self_ (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'self_' type invariant] inv_ref_Self_ self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'other' type invariant] inv_ref_Rhs other}
    (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_Self_ {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: t_Self_ = self_
    | & other: t_Rhs = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body ensures] result
      = gt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Rhs other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_PartialOrd_Rhs_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  type tup2_ref_Self__ref_Rhs = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs [precondition_partial_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_Rhs rhs
        /\ inv_ref_Self_ self_) -> precondition_partial_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs) (result: t_Option_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs, res: t_Option_Ordering [postcondition_once_partial_cmp () args res]. postcondition_once_partial_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res
      = Some (cmp_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Rhs rhs)))
  
  let rec partial_cmp_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option_Ordering)) =
    {[@expl:partial_cmp requires] precondition_partial_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Option_Ordering) -> {postcondition_once_partial_cmp () { f0 = self_; f1 = rhs } result}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0'0: t_Ordering)) = any
    [ good (f0'0: t_Ordering) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Ordering [Some f0'0: t_Option_Ordering]. Some f0'0 <> input} (! {false} any) ]
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_ge_body_Self_ (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'self_' type invariant] inv_ref_Self_ self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'other' type invariant] inv_ref_Rhs other}
    (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_Self_ {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: t_Self_ = self_
    | & other: t_Rhs = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body ensures] result
      = ge_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Rhs other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_Ord_max_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tup2_ref_Self__ref_Self_ = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_le (self: ()) (args: tup2_ref_Self__ref_Self_)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Self_ [precondition_le () args]. (let {f0 = self_; f1 = other} = args in inv_ref_Self_ other
        /\ inv_ref_Self_ self_) -> precondition_le () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  predicate postcondition_once_le (self: ()) (args: tup2_ref_Self__ref_Self_) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Self_, res: bool [postcondition_once_le () args res]. postcondition_once_le () args res
      -> (let {f0 = self_; f1 = other} = args in res
      = le_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Self_ other))
  
  let rec le_Self_ (self_: t_Self_) (other: t_Self_) (return (x: bool)) =
    {[@expl:le requires] precondition_le () { f0 = self_; f1 = other }}
    any [ return (result: bool) -> {postcondition_once_le () { f0 = self_; f1 = other } result} (! return {result}) ]
  
  predicate resolve_Self_ (_1: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_max_body_Self_ (self_: t_Self_) (o: t_Self_) (return (x: t_Self_)) =
    {[@expl:extern_spec_std_cmp_Ord_max_body 'self_' type invariant] inv_Self_ self_}
    {[@expl:extern_spec_std_cmp_Ord_max_body 'o' type invariant] inv_Self_ o}
    (! bb0
    [ bb0 = s0 [ s0 = le_Self_ {self_} {o} (fun (_ret: bool) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_8 = false} (! bb3) | br1 -> {_8} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_Self_ self_} s1
      | s1 = -{resolve_Self_ self_}- s2
      | s2 = [ &_0 <- o ] s3
      | s3 = bb6 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_Self_ o} s1
      | s1 = -{resolve_Self_ o}- s2
      | s2 = [ &_0 <- self_ ] s3
      | s3 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_Self_ = Any.any_l () | & self_: t_Self_ = self_ | & o: t_Self_ = o | & _8: bool = Any.any_l () ])
    [ return (result: t_Self_) -> {[@expl:extern_spec_std_cmp_Ord_max_body result type invariant] inv_Self_ result}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #0] ge_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ self_)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #1] ge_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ o)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #2] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #3] le_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Self_ o)
      -> result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #4] lt_log_DeepModelTy (deep_model_Self_ o) (deep_model_Self_ self_)
      -> result = self_}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_Ord_min_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tup2_ref_Self__ref_Self_ = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_lt (self: ()) (args: tup2_ref_Self__ref_Self_)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Self_ [precondition_lt () args]. (let {f0 = self_; f1 = other} = args in inv_ref_Self_ other
        /\ inv_ref_Self_ self_) -> precondition_lt () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  predicate postcondition_once_lt (self: ()) (args: tup2_ref_Self__ref_Self_) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Self_, res: bool [postcondition_once_lt () args res]. postcondition_once_lt () args res
      -> (let {f0 = self_; f1 = other} = args in res
      = lt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Self_ other))
  
  let rec lt_Self_ (self_: t_Self_) (other: t_Self_) (return (x: bool)) =
    {[@expl:lt requires] precondition_lt () { f0 = self_; f1 = other }}
    any [ return (result: bool) -> {postcondition_once_lt () { f0 = self_; f1 = other } result} (! return {result}) ]
  
  predicate resolve_Self_ (_1: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_min_body_Self_ (self_: t_Self_) (o: t_Self_) (return (x: t_Self_)) =
    {[@expl:extern_spec_std_cmp_Ord_min_body 'self_' type invariant] inv_Self_ self_}
    {[@expl:extern_spec_std_cmp_Ord_min_body 'o' type invariant] inv_Self_ o}
    (! bb0
    [ bb0 = s0 [ s0 = lt_Self_ {self_} {o} (fun (_ret: bool) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_8 = false} (! bb3) | br1 -> {_8} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_Self_ o} s1
      | s1 = -{resolve_Self_ o}- s2
      | s2 = [ &_0 <- self_ ] s3
      | s3 = bb6 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_Self_ self_} s1
      | s1 = -{resolve_Self_ self_}- s2
      | s2 = [ &_0 <- o ] s3
      | s3 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_Self_ = Any.any_l () | & self_: t_Self_ = self_ | & o: t_Self_ = o | & _8: bool = Any.any_l () ])
    [ return (result: t_Self_) -> {[@expl:extern_spec_std_cmp_Ord_min_body result type invariant] inv_Self_ result}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #0] le_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ self_)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #1] le_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ o)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #2] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #3] lt_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Self_ o)
      -> result = self_}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #4] le_log_DeepModelTy (deep_model_Self_ o) (deep_model_Self_ self_)
      -> result = o}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_Ord_clamp_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tup2_ref_Self__ref_Self_ = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_gt (self: ()) (args: tup2_ref_Self__ref_Self_)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Self_ [precondition_gt () args]. (let {f0 = self_; f1 = other} = args in inv_ref_Self_ other
        /\ inv_ref_Self_ self_) -> precondition_gt () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  predicate postcondition_once_gt (self: ()) (args: tup2_ref_Self__ref_Self_) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Self_, res: bool [postcondition_once_gt () args res]. postcondition_once_gt () args res
      -> (let {f0 = self_; f1 = other} = args in res
      = gt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Self_ other))
  
  let rec gt_Self_ (self_: t_Self_) (other: t_Self_) (return (x: bool)) =
    {[@expl:gt requires] precondition_gt () { f0 = self_; f1 = other }}
    any [ return (result: bool) -> {postcondition_once_gt () { f0 = self_; f1 = other } result} (! return {result}) ]
  
  predicate resolve_Self_ (_1: t_Self_)
  
  predicate precondition_lt (self: ()) (args: tup2_ref_Self__ref_Self_)
  
  axiom precondition_fndef'0:
    forall args: tup2_ref_Self__ref_Self_ [precondition_lt () args]. (let {f0 = self_; f1 = other} = args in inv_ref_Self_ other
        /\ inv_ref_Self_ self_) -> precondition_lt () args
  
  predicate postcondition_once_lt (self: ()) (args: tup2_ref_Self__ref_Self_) (result: bool)
  
  axiom postcondition_fndef'0:
    forall args: tup2_ref_Self__ref_Self_, res: bool [postcondition_once_lt () args res]. postcondition_once_lt () args res
      -> (let {f0 = self_; f1 = other} = args in res
      = lt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Self_ other))
  
  let rec lt_Self_ (self_: t_Self_) (other: t_Self_) (return (x: bool)) =
    {[@expl:lt requires] precondition_lt () { f0 = self_; f1 = other }}
    any [ return (result: bool) -> {postcondition_once_lt () { f0 = self_; f1 = other } result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_clamp_body_Self_ (self_: t_Self_) (min: t_Self_) (max: t_Self_)
    (return (x: t_Self_)) = {[@expl:extern_spec_std_cmp_Ord_clamp_body 'self_' type invariant] inv_Self_ self_}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'min' type invariant] inv_Self_ min}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'max' type invariant] inv_Self_ max}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body requires] le_log_DeepModelTy (deep_model_Self_ min) (deep_model_Self_ max)}
    (! bb0
    [ bb0 = s0 [ s0 = gt_Self_ {self_} {max} (fun (_ret: bool) -> [ &_9 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_9 = false} (! bb3) | br1 -> {_9} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_Self_ min} s1
      | s1 = -{resolve_Self_ min}- s2
      | s2 = {[@expl:type invariant] inv_Self_ self_} s3
      | s3 = -{resolve_Self_ self_}- s4
      | s4 = [ &_0 <- max ] s5
      | s5 = bb11 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_Self_ max} s1
      | s1 = -{resolve_Self_ max}- s2
      | s2 = lt_Self_ {self_} {min} (fun (_ret: bool) -> [ &_12 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_12 = false} (! bb6) | br1 -> {_12} (! bb5) ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_Self_ self_} s1
      | s1 = -{resolve_Self_ self_}- s2
      | s2 = [ &_0 <- min ] s3
      | s3 = bb11 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv_Self_ min} s1
      | s1 = -{resolve_Self_ min}- s2
      | s2 = [ &_0 <- self_ ] s3
      | s3 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_Self_ = Any.any_l ()
    | & self_: t_Self_ = self_
    | & min: t_Self_ = min
    | & max: t_Self_ = max
    | & _9: bool = Any.any_l ()
    | & _12: bool = Any.any_l () ])
    [ return (result: t_Self_) -> {[@expl:extern_spec_std_cmp_Ord_clamp_body result type invariant] inv_Self_ result}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #0] ge_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ min)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #1] le_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ max)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #2] result = self_ \/ result = min \/ result = max}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #3] if gt_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Self_ max) then
        result = max
      else
        if lt_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Self_ min) then result = min else result = self_
      }
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_max_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type tup2_T_T = { f0: t_T; f1: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate precondition_max (self: ()) (args: tup2_T_T)
  
  axiom precondition_fndef:
    forall args: tup2_T_T [precondition_max () args]. (let {f0 = self_; f1 = o} = args in inv_T o /\ inv_T self_)
      -> precondition_max () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once_max (self: ()) (args: tup2_T_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: tup2_T_T, res: t_T [postcondition_once_max () args res]. postcondition_once_max () args res
      -> (let {f0 = self_; f1 = o} = args in (lt_log_DeepModelTy (deep_model_T o) (deep_model_T self_) -> res = self_)
      /\ (le_log_DeepModelTy (deep_model_T self_) (deep_model_T o) -> res = o)
      /\ (res = self_ \/ res = o)
      /\ ge_log_DeepModelTy (deep_model_T res) (deep_model_T o)
      /\ ge_log_DeepModelTy (deep_model_T res) (deep_model_T self_) /\ inv_T res)
  
  let rec max_T (self_: t_T) (o: t_T) (return (x: t_T)) = {[@expl:max requires] precondition_max () { f0 = self_;
                                                                                                      f1 = o }}
    any [ return (result: t_T) -> {postcondition_once_max () { f0 = self_; f1 = o } result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_max_body_T (v1: t_T) (v2: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_cmp_max_body 'v1' type invariant] inv_T v1}
    {[@expl:extern_spec_std_cmp_max_body 'v2' type invariant] inv_T v2}
    (! bb0
    [ bb0 = s0 [ s0 = max_T {v1} {v2} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb3 ] | bb3 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & v1: t_T = v1 | & v2: t_T = v2 ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_cmp_max_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_cmp_max_body ensures #0] ge_log_DeepModelTy (deep_model_T result) (deep_model_T v1)}
      {[@expl:extern_spec_std_cmp_max_body ensures #1] ge_log_DeepModelTy (deep_model_T result) (deep_model_T v2)}
      {[@expl:extern_spec_std_cmp_max_body ensures #2] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #3] le_log_DeepModelTy (deep_model_T v1) (deep_model_T v2)
      -> result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #4] lt_log_DeepModelTy (deep_model_T v2) (deep_model_T v1)
      -> result = v1}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_std_cmp_min_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type tup2_T_T = { f0: t_T; f1: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate precondition_min (self: ()) (args: tup2_T_T)
  
  axiom precondition_fndef:
    forall args: tup2_T_T [precondition_min () args]. (let {f0 = self_; f1 = o} = args in inv_T o /\ inv_T self_)
      -> precondition_min () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once_min (self: ()) (args: tup2_T_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: tup2_T_T, res: t_T [postcondition_once_min () args res]. postcondition_once_min () args res
      -> (let {f0 = self_; f1 = o} = args in (le_log_DeepModelTy (deep_model_T o) (deep_model_T self_) -> res = o)
      /\ (lt_log_DeepModelTy (deep_model_T self_) (deep_model_T o) -> res = self_)
      /\ (res = self_ \/ res = o)
      /\ le_log_DeepModelTy (deep_model_T res) (deep_model_T o)
      /\ le_log_DeepModelTy (deep_model_T res) (deep_model_T self_) /\ inv_T res)
  
  let rec min_T (self_: t_T) (o: t_T) (return (x: t_T)) = {[@expl:min requires] precondition_min () { f0 = self_;
                                                                                                      f1 = o }}
    any [ return (result: t_T) -> {postcondition_once_min () { f0 = self_; f1 = o } result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_min_body_T (v1: t_T) (v2: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_cmp_min_body 'v1' type invariant] inv_T v1}
    {[@expl:extern_spec_std_cmp_min_body 'v2' type invariant] inv_T v2}
    (! bb0
    [ bb0 = s0 [ s0 = min_T {v1} {v2} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb3 ] | bb3 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & v1: t_T = v1 | & v2: t_T = v2 ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_cmp_min_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_cmp_min_body ensures #0] le_log_DeepModelTy (deep_model_T result) (deep_model_T v1)}
      {[@expl:extern_spec_std_cmp_min_body ensures #1] le_log_DeepModelTy (deep_model_T result) (deep_model_T v2)}
      {[@expl:extern_spec_std_cmp_min_body ensures #2] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_min_body ensures #3] lt_log_DeepModelTy (deep_model_T v1) (deep_model_T v2)
      -> result = v1}
      {[@expl:extern_spec_std_cmp_min_body ensures #4] le_log_DeepModelTy (deep_model_T v2) (deep_model_T v1)
      -> result = v2}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i8_i8_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i8 [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model_i8
  
  let rec partial_cmp_i8 (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i8 self_) (deep_model_i8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i8 [@inline:trivial] (self: Int8.t) : int = deep_model_i8 self
  
  meta "rewrite_def" function deep_model_ref_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_lt_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i8 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int8.t = self_
    | & other: Int8.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i8_i8_lt_body ensures] result
      = (deep_model_ref_i8 self_ < deep_model_ref_i8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i8_i8_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i8 [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model_i8
  
  let rec partial_cmp_i8 (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i8 self_) (deep_model_i8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i8 [@inline:trivial] (self: Int8.t) : int = deep_model_i8 self
  
  meta "rewrite_def" function deep_model_ref_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_le_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i8 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int8.t = self_
    | & other: Int8.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i8_i8_le_body ensures] result
      = (deep_model_ref_i8 self_ <= deep_model_ref_i8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i8_i8_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i8 [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model_i8
  
  let rec partial_cmp_i8 (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i8 self_) (deep_model_i8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i8 [@inline:trivial] (self: Int8.t) : int = deep_model_i8 self
  
  meta "rewrite_def" function deep_model_ref_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_gt_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i8 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int8.t = self_
    | & other: Int8.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i8_i8_gt_body ensures] result
      = (deep_model_ref_i8 self_ > deep_model_ref_i8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i8_i8_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i8 [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model_i8
  
  let rec partial_cmp_i8 (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i8 self_) (deep_model_i8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i8 [@inline:trivial] (self: Int8.t) : int = deep_model_i8 self
  
  meta "rewrite_def" function deep_model_ref_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_ge_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i8 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int8.t = self_
    | & other: Int8.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i8_i8_ge_body ensures] result
      = (deep_model_ref_i8 self_ >= deep_model_ref_i8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i16_i16_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i16 [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model_i16
  
  let rec partial_cmp_i16 (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i16 self_) (deep_model_i16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i16 [@inline:trivial] (self: Int16.t) : int = deep_model_i16 self
  
  meta "rewrite_def" function deep_model_ref_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_lt_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i16 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int16.t = self_
    | & other: Int16.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i16_i16_lt_body ensures] result
      = (deep_model_ref_i16 self_ < deep_model_ref_i16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i16_i16_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i16 [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model_i16
  
  let rec partial_cmp_i16 (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i16 self_) (deep_model_i16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i16 [@inline:trivial] (self: Int16.t) : int = deep_model_i16 self
  
  meta "rewrite_def" function deep_model_ref_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_le_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i16 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int16.t = self_
    | & other: Int16.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i16_i16_le_body ensures] result
      = (deep_model_ref_i16 self_ <= deep_model_ref_i16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i16_i16_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i16 [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model_i16
  
  let rec partial_cmp_i16 (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i16 self_) (deep_model_i16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i16 [@inline:trivial] (self: Int16.t) : int = deep_model_i16 self
  
  meta "rewrite_def" function deep_model_ref_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_gt_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i16 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int16.t = self_
    | & other: Int16.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i16_i16_gt_body ensures] result
      = (deep_model_ref_i16 self_ > deep_model_ref_i16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i16_i16_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i16 [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model_i16
  
  let rec partial_cmp_i16 (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i16 self_) (deep_model_i16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i16 [@inline:trivial] (self: Int16.t) : int = deep_model_i16 self
  
  meta "rewrite_def" function deep_model_ref_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_ge_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i16 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int16.t = self_
    | & other: Int16.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i16_i16_ge_body ensures] result
      = (deep_model_ref_i16 self_ >= deep_model_ref_i16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i32_i32_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  let rec partial_cmp_i32 (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i32 self_) (deep_model_i32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_lt_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i32 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int32.t = self_
    | & other: Int32.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i32_i32_lt_body ensures] result
      = (deep_model_ref_i32 self_ < deep_model_ref_i32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i32_i32_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  let rec partial_cmp_i32 (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i32 self_) (deep_model_i32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_le_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i32 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int32.t = self_
    | & other: Int32.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i32_i32_le_body ensures] result
      = (deep_model_ref_i32 self_ <= deep_model_ref_i32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i32_i32_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  let rec partial_cmp_i32 (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i32 self_) (deep_model_i32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_gt_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i32 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int32.t = self_
    | & other: Int32.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i32_i32_gt_body ensures] result
      = (deep_model_ref_i32 self_ > deep_model_ref_i32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i32_i32_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  let rec partial_cmp_i32 (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i32 self_) (deep_model_i32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_ge_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i32 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int32.t = self_
    | & other: Int32.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i32_i32_ge_body ensures] result
      = (deep_model_ref_i32 self_ >= deep_model_ref_i32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i64_i64_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i64 [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_i64
  
  let rec partial_cmp_i64 (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i64 self_) (deep_model_i64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i64 [@inline:trivial] (self: Int64.t) : int = deep_model_i64 self
  
  meta "rewrite_def" function deep_model_ref_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_lt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i64 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i64_i64_lt_body ensures] result
      = (deep_model_ref_i64 self_ < deep_model_ref_i64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i64_i64_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i64 [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_i64
  
  let rec partial_cmp_i64 (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i64 self_) (deep_model_i64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i64 [@inline:trivial] (self: Int64.t) : int = deep_model_i64 self
  
  meta "rewrite_def" function deep_model_ref_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_le_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i64 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i64_i64_le_body ensures] result
      = (deep_model_ref_i64 self_ <= deep_model_ref_i64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i64_i64_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i64 [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_i64
  
  let rec partial_cmp_i64 (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i64 self_) (deep_model_i64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i64 [@inline:trivial] (self: Int64.t) : int = deep_model_i64 self
  
  meta "rewrite_def" function deep_model_ref_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_gt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i64 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i64_i64_gt_body ensures] result
      = (deep_model_ref_i64 self_ > deep_model_ref_i64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i64_i64_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i64 [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_i64
  
  let rec partial_cmp_i64 (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i64 self_) (deep_model_i64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i64 [@inline:trivial] (self: Int64.t) : int = deep_model_i64 self
  
  meta "rewrite_def" function deep_model_ref_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_ge_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_i64 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i64_i64_ge_body ensures] result
      = (deep_model_ref_i64 self_ >= deep_model_ref_i64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i128_i128_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i128 [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model_i128
  
  let rec partial_cmp_i128 (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i128 self_) (deep_model_i128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i128 [@inline:trivial] (self: Int128.t) : int = deep_model_i128 self
  
  meta "rewrite_def" function deep_model_ref_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_lt_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i128 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i128_i128_lt_body ensures] result
      = (deep_model_ref_i128 self_ < deep_model_ref_i128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i128_i128_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i128 [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model_i128
  
  let rec partial_cmp_i128 (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i128 self_) (deep_model_i128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i128 [@inline:trivial] (self: Int128.t) : int = deep_model_i128 self
  
  meta "rewrite_def" function deep_model_ref_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_le_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i128 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i128_i128_le_body ensures] result
      = (deep_model_ref_i128 self_ <= deep_model_ref_i128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i128_i128_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i128 [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model_i128
  
  let rec partial_cmp_i128 (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i128 self_) (deep_model_i128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i128 [@inline:trivial] (self: Int128.t) : int = deep_model_i128 self
  
  meta "rewrite_def" function deep_model_ref_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_gt_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i128 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i128_i128_gt_body ensures] result
      = (deep_model_ref_i128 self_ > deep_model_ref_i128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i128_i128_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i128 [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model_i128
  
  let rec partial_cmp_i128 (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_i128 self_) (deep_model_i128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_i128 [@inline:trivial] (self: Int128.t) : int = deep_model_i128 self
  
  meta "rewrite_def" function deep_model_ref_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_ge_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i128 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_i128_i128_ge_body ensures] result
      = (deep_model_ref_i128 self_ >= deep_model_ref_i128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_isize_isize_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_isize [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_isize
  
  let rec partial_cmp_isize (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result
      = Some (cmp_log_Int (deep_model_isize self_) (deep_model_isize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_isize [@inline:trivial] (self: Int64.t) : int = deep_model_isize self
  
  meta "rewrite_def" function deep_model_ref_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_lt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_isize {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_isize_isize_lt_body ensures] result
      = (deep_model_ref_isize self_ < deep_model_ref_isize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_isize_isize_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_isize [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_isize
  
  let rec partial_cmp_isize (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result
      = Some (cmp_log_Int (deep_model_isize self_) (deep_model_isize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_isize [@inline:trivial] (self: Int64.t) : int = deep_model_isize self
  
  meta "rewrite_def" function deep_model_ref_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_le_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_isize {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_isize_isize_le_body ensures] result
      = (deep_model_ref_isize self_ <= deep_model_ref_isize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_isize_isize_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_isize [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_isize
  
  let rec partial_cmp_isize (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result
      = Some (cmp_log_Int (deep_model_isize self_) (deep_model_isize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_isize [@inline:trivial] (self: Int64.t) : int = deep_model_isize self
  
  meta "rewrite_def" function deep_model_ref_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_gt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_isize {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_isize_isize_gt_body ensures] result
      = (deep_model_ref_isize self_ > deep_model_ref_isize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_isize_isize_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_isize [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_isize
  
  let rec partial_cmp_isize (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result
      = Some (cmp_log_Int (deep_model_isize self_) (deep_model_isize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_isize [@inline:trivial] (self: Int64.t) : int = deep_model_isize self
  
  meta "rewrite_def" function deep_model_ref_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_ge_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_isize {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_isize_isize_ge_body ensures] result
      = (deep_model_ref_isize self_ >= deep_model_ref_isize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u8_u8_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u8 [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model_u8
  
  let rec partial_cmp_u8 (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u8 self_) (deep_model_u8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u8 [@inline:trivial] (self: UInt8.t) : int = deep_model_u8 self
  
  meta "rewrite_def" function deep_model_ref_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_lt_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u8 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt8.t = self_
    | & other: UInt8.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u8_u8_lt_body ensures] result
      = (deep_model_ref_u8 self_ < deep_model_ref_u8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u8_u8_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u8 [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model_u8
  
  let rec partial_cmp_u8 (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u8 self_) (deep_model_u8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u8 [@inline:trivial] (self: UInt8.t) : int = deep_model_u8 self
  
  meta "rewrite_def" function deep_model_ref_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_le_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u8 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt8.t = self_
    | & other: UInt8.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u8_u8_le_body ensures] result
      = (deep_model_ref_u8 self_ <= deep_model_ref_u8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u8_u8_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u8 [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model_u8
  
  let rec partial_cmp_u8 (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u8 self_) (deep_model_u8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u8 [@inline:trivial] (self: UInt8.t) : int = deep_model_u8 self
  
  meta "rewrite_def" function deep_model_ref_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_gt_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u8 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt8.t = self_
    | & other: UInt8.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u8_u8_gt_body ensures] result
      = (deep_model_ref_u8 self_ > deep_model_ref_u8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u8_u8_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u8 [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model_u8
  
  let rec partial_cmp_u8 (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u8 self_) (deep_model_u8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u8 [@inline:trivial] (self: UInt8.t) : int = deep_model_u8 self
  
  meta "rewrite_def" function deep_model_ref_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_ge_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u8 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt8.t = self_
    | & other: UInt8.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u8_u8_ge_body ensures] result
      = (deep_model_ref_u8 self_ >= deep_model_ref_u8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u16_u16_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u16 [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model_u16
  
  let rec partial_cmp_u16 (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u16 self_) (deep_model_u16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u16 [@inline:trivial] (self: UInt16.t) : int = deep_model_u16 self
  
  meta "rewrite_def" function deep_model_ref_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_lt_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u16 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u16_u16_lt_body ensures] result
      = (deep_model_ref_u16 self_ < deep_model_ref_u16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u16_u16_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u16 [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model_u16
  
  let rec partial_cmp_u16 (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u16 self_) (deep_model_u16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u16 [@inline:trivial] (self: UInt16.t) : int = deep_model_u16 self
  
  meta "rewrite_def" function deep_model_ref_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_le_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u16 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u16_u16_le_body ensures] result
      = (deep_model_ref_u16 self_ <= deep_model_ref_u16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u16_u16_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u16 [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model_u16
  
  let rec partial_cmp_u16 (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u16 self_) (deep_model_u16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u16 [@inline:trivial] (self: UInt16.t) : int = deep_model_u16 self
  
  meta "rewrite_def" function deep_model_ref_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_gt_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u16 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u16_u16_gt_body ensures] result
      = (deep_model_ref_u16 self_ > deep_model_ref_u16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u16_u16_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u16 [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model_u16
  
  let rec partial_cmp_u16 (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u16 self_) (deep_model_u16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u16 [@inline:trivial] (self: UInt16.t) : int = deep_model_u16 self
  
  meta "rewrite_def" function deep_model_ref_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_ge_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u16 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u16_u16_ge_body ensures] result
      = (deep_model_ref_u16 self_ >= deep_model_ref_u16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u32_u32_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  let rec partial_cmp_u32 (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u32 self_) (deep_model_u32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u32 [@inline:trivial] (self: UInt32.t) : int = deep_model_u32 self
  
  meta "rewrite_def" function deep_model_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_lt_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u32 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u32_u32_lt_body ensures] result
      = (deep_model_ref_u32 self_ < deep_model_ref_u32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u32_u32_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  let rec partial_cmp_u32 (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u32 self_) (deep_model_u32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u32 [@inline:trivial] (self: UInt32.t) : int = deep_model_u32 self
  
  meta "rewrite_def" function deep_model_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_le_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u32 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u32_u32_le_body ensures] result
      = (deep_model_ref_u32 self_ <= deep_model_ref_u32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u32_u32_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  let rec partial_cmp_u32 (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u32 self_) (deep_model_u32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u32 [@inline:trivial] (self: UInt32.t) : int = deep_model_u32 self
  
  meta "rewrite_def" function deep_model_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_gt_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u32 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u32_u32_gt_body ensures] result
      = (deep_model_ref_u32 self_ > deep_model_ref_u32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u32_u32_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  let rec partial_cmp_u32 (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u32 self_) (deep_model_u32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u32 [@inline:trivial] (self: UInt32.t) : int = deep_model_u32 self
  
  meta "rewrite_def" function deep_model_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_ge_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u32 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u32_u32_ge_body ensures] result
      = (deep_model_ref_u32 self_ >= deep_model_ref_u32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u64_u64_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec partial_cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u64 [@inline:trivial] (self: UInt64.t) : int = deep_model_u64 self
  
  meta "rewrite_def" function deep_model_ref_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_lt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u64 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u64_u64_lt_body ensures] result
      = (deep_model_ref_u64 self_ < deep_model_ref_u64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u64_u64_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec partial_cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u64 [@inline:trivial] (self: UInt64.t) : int = deep_model_u64 self
  
  meta "rewrite_def" function deep_model_ref_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_le_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u64 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u64_u64_le_body ensures] result
      = (deep_model_ref_u64 self_ <= deep_model_ref_u64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u64_u64_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec partial_cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u64 [@inline:trivial] (self: UInt64.t) : int = deep_model_u64 self
  
  meta "rewrite_def" function deep_model_ref_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_gt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u64 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u64_u64_gt_body ensures] result
      = (deep_model_ref_u64 self_ > deep_model_ref_u64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u64_u64_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec partial_cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u64 [@inline:trivial] (self: UInt64.t) : int = deep_model_u64 self
  
  meta "rewrite_def" function deep_model_ref_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_ge_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = partial_cmp_u64 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u64_u64_ge_body ensures] result
      = (deep_model_ref_u64 self_ >= deep_model_ref_u64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u128_u128_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u128 [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model_u128
  
  let rec partial_cmp_u128 (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u128 self_) (deep_model_u128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u128 [@inline:trivial] (self: UInt128.t) : int = deep_model_u128 self
  
  meta "rewrite_def" function deep_model_ref_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_lt_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u128 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u128_u128_lt_body ensures] result
      = (deep_model_ref_u128 self_ < deep_model_ref_u128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u128_u128_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u128 [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model_u128
  
  let rec partial_cmp_u128 (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u128 self_) (deep_model_u128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u128 [@inline:trivial] (self: UInt128.t) : int = deep_model_u128 self
  
  meta "rewrite_def" function deep_model_ref_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_le_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u128 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u128_u128_le_body ensures] result
      = (deep_model_ref_u128 self_ <= deep_model_ref_u128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u128_u128_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u128 [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model_u128
  
  let rec partial_cmp_u128 (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u128 self_) (deep_model_u128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u128 [@inline:trivial] (self: UInt128.t) : int = deep_model_u128 self
  
  meta "rewrite_def" function deep_model_ref_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_gt_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u128 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u128_u128_gt_body ensures] result
      = (deep_model_ref_u128 self_ > deep_model_ref_u128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u128_u128_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u128 [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model_u128
  
  let rec partial_cmp_u128 (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result = Some (cmp_log_Int (deep_model_u128 self_) (deep_model_u128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_u128 [@inline:trivial] (self: UInt128.t) : int = deep_model_u128 self
  
  meta "rewrite_def" function deep_model_ref_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_ge_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u128 {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_u128_u128_ge_body ensures] result
      = (deep_model_ref_u128 self_ >= deep_model_ref_u128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_usize_usize_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_usize [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_usize
  
  let rec partial_cmp_usize (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result
      = Some (cmp_log_Int (deep_model_usize self_) (deep_model_usize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_usize [@inline:trivial] (self: UInt64.t) : int = deep_model_usize self
  
  meta "rewrite_def" function deep_model_ref_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_lt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_usize {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_usize_usize_lt_body ensures] result
      = (deep_model_ref_usize self_ < deep_model_ref_usize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_usize_usize_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_usize [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_usize
  
  let rec partial_cmp_usize (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result
      = Some (cmp_log_Int (deep_model_usize self_) (deep_model_usize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_usize [@inline:trivial] (self: UInt64.t) : int = deep_model_usize self
  
  meta "rewrite_def" function deep_model_ref_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_le_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_usize {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_usize_usize_le_body ensures] result
      = (deep_model_ref_usize self_ <= deep_model_ref_usize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_usize_usize_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_usize [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_usize
  
  let rec partial_cmp_usize (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result
      = Some (cmp_log_Int (deep_model_usize self_) (deep_model_usize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_usize [@inline:trivial] (self: UInt64.t) : int = deep_model_usize self
  
  meta "rewrite_def" function deep_model_ref_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_gt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_usize {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_usize_usize_gt_body ensures] result
      = (deep_model_ref_usize self_ > deep_model_ref_usize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_usize_usize_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_usize [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_usize
  
  let rec partial_cmp_usize (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {result
      = Some (cmp_log_Int (deep_model_usize self_) (deep_model_usize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Ordering) (ret (f0: t_Ordering)) = any
    [ good (f0: t_Ordering) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Ordering [Some f0: t_Option_Ordering]. Some f0 <> input} (! {false} any) ]
  
  function deep_model_ref_usize [@inline:trivial] (self: UInt64.t) : int = deep_model_usize self
  
  meta "rewrite_def" function deep_model_ref_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_ge_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_usize {self_} {other} (fun (_ret: t_Option_Ordering) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = None} (! bb2) | br1 (x0: t_Ordering) -> {_4 = Some x0} (! bb3) ]
    | bb3 = elim_Some {_4}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb6 ]
    | bb5 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _4: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_PartialOrd_usize_usize_ge_body ensures] result
      = (deep_model_ref_usize self_ >= deep_model_ref_usize other)}
      (! return {result}) ]
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_le_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate le_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o <> Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function cmp_le_log_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_cmp_le_log_Reverse_T: [@expl:cmp_le_log ensures] le_log_Reverse_T x y = (cmp_log_Reverse_T x y <> Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_lt_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate lt_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o = Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function cmp_lt_log_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_cmp_lt_log_Reverse_T: [@expl:cmp_lt_log ensures] lt_log_Reverse_T x y = (cmp_log_Reverse_T x y = Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_ge_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate ge_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o <> Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function cmp_ge_log_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_cmp_ge_log_Reverse_T: [@expl:cmp_ge_log ensures] ge_log_Reverse_T x y = (cmp_log_Reverse_T x y <> Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_gt_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate gt_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o = Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function cmp_gt_log_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_cmp_gt_log_Reverse_T: [@expl:cmp_gt_log ensures] gt_log_Reverse_T x y = (cmp_log_Reverse_T x y = Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__refl (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  function refl_Reverse_T (x: t_Reverse_T) : ()
  
  goal vc_refl_Reverse_T: [@expl:refl ensures] cmp_log_Reverse_T x x = Equal
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__trans (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  constant z : t_Reverse_T
  
  constant o : t_Ordering
  
  function trans_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) (z: t_Reverse_T) (o: t_Ordering) : ()
  
  goal vc_trans_Reverse_T: cmp_log_Reverse_T x y = o
    -> cmp_log_Reverse_T y z = o -> ([@expl:trans ensures] cmp_log_Reverse_T x z = o)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__antisym1 (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function antisym1_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_antisym1_Reverse_T: cmp_log_Reverse_T x y = Less -> ([@expl:antisym1 ensures] cmp_log_Reverse_T y x = Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__antisym2 (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function antisym2_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_antisym2_Reverse_T: cmp_log_Reverse_T x y = Greater -> ([@expl:antisym2 ensures] cmp_log_Reverse_T y x = Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__eq_cmp (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function eq_cmp_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_eq_cmp_Reverse_T: [@expl:eq_cmp ensures] (x = y) = (cmp_log_Reverse_T x y = Equal)
end
module M_std__deque__impl_IteratorSpec_for_Iter_T__produces_refl (* <std::collections::vec_deque::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_T
  
  function produces_refl_Iter_T (self: t_Iter_T) : ()
  
  goal vc_produces_refl_Iter_T: [@expl:produces_refl ensures] produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__deque__impl_IteratorSpec_for_Iter_T__produces_trans (* <std::collections::vec_deque::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter_T
  
  function produces_trans_Iter_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : ()
  
  goal vc_produces_trans_Iter_T: produces_Iter_T a ab b
    -> produces_Iter_T b bc c -> ([@expl:produces_trans ensures] produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__hint__extern_spec_std_hint_assert_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_assert_unchecked_body (cond: bool) (return (x: ())) =
    {[@expl:extern_spec_std_hint_assert_unchecked_body requires] cond}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_std__hint__extern_spec_std_hint_black_box_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_black_box_body_T (dummy: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_hint_black_box_body 'dummy' type invariant] inv_T dummy}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- dummy ] s1 | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & dummy: t_T = dummy ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_hint_black_box_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_hint_black_box_body ensures] result = dummy}
      (! return {result}) ]
end
module M_std__hint__extern_spec_std_hint_spin_loop_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_spin_loop_body (return (x: ())) =
    {[@expl:extern_spec_std_hint_spin_loop_body requires] true}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:extern_spec_std_hint_spin_loop_body ensures] true} (! return {result}) ]
end
module M_std__hint__extern_spec_std_hint_unreachable_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  predicate inv_never [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_never
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_unreachable_unchecked_body (return (x: ())) =
    {[@expl:extern_spec_std_hint_unreachable_unchecked_body requires] false}
    (! bb0
    [ bb0 = {false} any ])
    [ return (result: ()) ->
    {[@expl:extern_spec_std_hint_unreachable_unchecked_body result type invariant] inv_never result}
      (! return {result}) ]
end
module M_std__hint__extern_spec_std_hint_must_use_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_must_use_body_T (value: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_hint_must_use_body 'value' type invariant] inv_T value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- value ] s1 | s1 = bb1 ] | bb1 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & value: t_T = value ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_hint_must_use_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_hint_must_use_body ensures] result = value}
      (! return {result}) ]
end
module M_std__intrinsics__extern_spec_core_intrinsics_assume_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_intrinsics_assume_body (b: bool) (return (x: ())) =
    {[@expl:extern_spec_core_intrinsics_assume_body requires] b}
    (! bb0
    [ bb0 = any [ br0 -> {b = false} (! bb1) | br1 -> {b} (! bb2) ] | bb2 = return {_0} | bb1 = {false} any ]
    [ & _0: () = Any.any_l () | & b: bool = b ]) [ return (result: ()) -> (! return {result}) ]
end
module M_std__io__extern_spec_std_io_print_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Arguments
  
  predicate inv_Arguments (_1: t_Arguments)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_io__print_body (args: t_Arguments) (return (x: ())) =
    {[@expl:extern_spec_std_io__print_body 'args' type invariant] inv_Arguments args}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:extern_spec_std_io__print_body ensures] true} (! return {result}) ]
end
module M_std__io__extern_spec_std_io_eprint_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Arguments
  
  predicate inv_Arguments (_1: t_Arguments)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_io__eprint_body (args: t_Arguments) (return (x: ())) =
    {[@expl:extern_spec_std_io__eprint_body 'args' type invariant] inv_Arguments args}
    (! bb0
    [ bb0 = return {_0} ] [ & _0: () = Any.any_l () ])
    [ return (result: ()) -> {[@expl:extern_spec_std_io__eprint_body ensures] true} (! return {result}) ]
end
module M_std__iter__cloned__impl_IteratorSpec_for_Cloned_I__produces_refl (* <std::iter::Cloned<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Cloned_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate produces_Cloned_I (self: t_Cloned_I) (visited: Seq.seq t_T) (o: t_Cloned_I) =
    exists s: Seq.seq t_T. produces_I (iter_Cloned_I self) s (iter_Cloned_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition_clone () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Cloned_I
  
  function produces_refl_Cloned_I (self: t_Cloned_I) : ()
  
  goal vc_produces_refl_Cloned_I: [@expl:produces_refl ensures] produces_Cloned_I self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__cloned__impl_IteratorSpec_for_Cloned_I__produces_trans (* <std::iter::Cloned<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Cloned_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate produces_Cloned_I (self: t_Cloned_I) (visited: Seq.seq t_T) (o: t_Cloned_I) =
    exists s: Seq.seq t_T. produces_I (iter_Cloned_I self) s (iter_Cloned_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition_clone () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Cloned_I
  
  constant ab : Seq.seq t_T
  
  constant b : t_Cloned_I
  
  constant bc : Seq.seq t_T
  
  constant c : t_Cloned_I
  
  function produces_trans_Cloned_I (a: t_Cloned_I) (ab: Seq.seq t_T) (b: t_Cloned_I) (bc: Seq.seq t_T) (c: t_Cloned_I) : ()
  
  goal vc_produces_trans_Cloned_I: produces_Cloned_I a ab b
    -> produces_Cloned_I b bc c -> ([@expl:produces_trans ensures] produces_Cloned_I a (Seq.(++) ab bc) c)
end
module M_std__iter__copied__impl_IteratorSpec_for_Copied_I__produces_refl (* <std::iter::Copied<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Copied_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate produces_Copied_I (self: t_Copied_I) (visited: Seq.seq t_T) (o: t_Copied_I) =
    exists s: Seq.seq t_T. produces_I (iter_Copied_I self) s (iter_Copied_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Copied_I
  
  function produces_refl_Copied_I (self: t_Copied_I) : ()
  
  goal vc_produces_refl_Copied_I: [@expl:produces_refl ensures] produces_Copied_I self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__copied__impl_IteratorSpec_for_Copied_I__produces_trans (* <std::iter::Copied<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Copied_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate produces_Copied_I (self: t_Copied_I) (visited: Seq.seq t_T) (o: t_Copied_I) =
    exists s: Seq.seq t_T. produces_I (iter_Copied_I self) s (iter_Copied_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Copied_I
  
  constant ab : Seq.seq t_T
  
  constant b : t_Copied_I
  
  constant bc : Seq.seq t_T
  
  constant c : t_Copied_I
  
  function produces_trans_Copied_I (a: t_Copied_I) (ab: Seq.seq t_T) (b: t_Copied_I) (bc: Seq.seq t_T) (c: t_Copied_I) : ()
  
  goal vc_produces_trans_Copied_I: produces_Copied_I a ab b
    -> produces_Copied_I b bc c -> ([@expl:produces_trans ensures] produces_Copied_I a (Seq.(++) ab bc) c)
end
module M_std__iter__empty__impl_IteratorSpec_for_Empty_T__produces_refl (* <std::iter::Empty<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty_T
  
  type t_T
  
  predicate produces_Empty_T (self: t_Empty_T) (visited: Seq.seq t_T) (o: t_Empty_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Empty_T
  
  function produces_refl_Empty_T (self: t_Empty_T) : ()
  
  goal vc_produces_refl_Empty_T: [@expl:produces_refl ensures] produces_Empty_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__empty__impl_IteratorSpec_for_Empty_T__produces_trans (* <std::iter::Empty<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty_T
  
  type t_T
  
  predicate produces_Empty_T (self: t_Empty_T) (visited: Seq.seq t_T) (o: t_Empty_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Empty_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Empty_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Empty_T
  
  function produces_trans_Empty_T (a: t_Empty_T) (ab: Seq.seq t_T) (b: t_Empty_T) (bc: Seq.seq t_T) (c: t_Empty_T) : ()
  
  goal vc_produces_trans_Empty_T: produces_Empty_T a ab b
    -> produces_Empty_T b bc c -> ([@expl:produces_trans ensures] produces_Empty_T a (Seq.(++) ab bc) c)
end
module M_std__iter__enumerate__impl_Invariant_for_Enumerate_I__invariant (* <std::iter::Enumerate<I> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Enumerate_I
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Enumerate_I
  
  predicate invariant_Enumerate_I (self: t_Enumerate_I)
  
  goal vc_invariant_Enumerate_I: if inv_I (iter_Enumerate_I self) then
      if forall s: Seq.seq t_Item, i: t_I [produces_I (iter_Enumerate_I self) s i]. produces_I (iter_Enumerate_I self) s i
        -> UInt64.t'int (n_Enumerate_I self) + Seq.length s < UInt64.t'int const_MAX then
        [@expl:invariant ensures] (forall i: MutBorrow.t t_I. completed_I i
            -> produces_I i.current (Seq.empty: Seq.seq t_Item) i.final) -> inv_I (iter_Enumerate_I self)
      else
        [@expl:invariant ensures] false -> inv_I (iter_Enumerate_I self)
    
    else
      [@expl:invariant ensures] false -> inv_I (iter_Enumerate_I self)

end
module M_std__iter__enumerate__impl_IteratorSpec_for_Enumerate_I__produces_refl (* <std::iter::Enumerate<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Enumerate_I
  
  type t_Item
  
  type tup2_usize_Item = { f0: UInt64.t; f1: t_Item }
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate produces_Enumerate_I (self: t_Enumerate_I) (visited: Seq.seq tup2_usize_Item) (o: t_Enumerate_I) =
    Seq.length visited = UInt64.t'int (n_Enumerate_I o) - UInt64.t'int (n_Enumerate_I self)
    /\ (exists s: Seq.seq t_Item. produces_I (iter_Enumerate_I self) s (iter_Enumerate_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n_Enumerate_I self) + i
        /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Enumerate_I
  
  function produces_refl_Enumerate_I (self: t_Enumerate_I) : ()
  
  goal vc_produces_refl_Enumerate_I:
    [@expl:produces_refl ensures] produces_Enumerate_I self (Seq.empty: Seq.seq tup2_usize_Item) self
end
module M_std__iter__enumerate__impl_IteratorSpec_for_Enumerate_I__produces_trans (* <std::iter::Enumerate<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Enumerate_I
  
  type t_Item
  
  type tup2_usize_Item = { f0: UInt64.t; f1: t_Item }
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate produces_Enumerate_I (self: t_Enumerate_I) (visited: Seq.seq tup2_usize_Item) (o: t_Enumerate_I) =
    Seq.length visited = UInt64.t'int (n_Enumerate_I o) - UInt64.t'int (n_Enumerate_I self)
    /\ (exists s: Seq.seq t_Item. produces_I (iter_Enumerate_I self) s (iter_Enumerate_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n_Enumerate_I self) + i
        /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Enumerate_I
  
  constant ab : Seq.seq tup2_usize_Item
  
  constant b : t_Enumerate_I
  
  constant bc : Seq.seq tup2_usize_Item
  
  constant c : t_Enumerate_I
  
  function produces_trans_Enumerate_I (a: t_Enumerate_I) (ab: Seq.seq tup2_usize_Item) (b: t_Enumerate_I) (bc: Seq.seq tup2_usize_Item) (c: t_Enumerate_I) : ()
  
  goal vc_produces_trans_Enumerate_I: produces_Enumerate_I a ab b
    -> produces_Enumerate_I b bc c -> ([@expl:produces_trans ensures] produces_Enumerate_I a (Seq.(++) ab bc) c)
end
module M_std__iter__filter__impl_Invariant_for_Filter_I_F__invariant (* <std::iter::Filter<I, F> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Filter_I_F
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  type t_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) = forall f: t_F, i: t_Item. precondition_F f i
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Filter_I_F
  
  predicate invariant_Filter_I_F (self: t_Filter_I_F)
  
  goal vc_invariant_Filter_I_F: if inv_I (iter_Filter_I_F self) then
      if inv_F (func_Filter_I_F self) then
        [@expl:invariant ensures] private_invariant_I self
        -> inv_I (iter_Filter_I_F self) /\ inv_F (func_Filter_I_F self)
      else
        [@expl:invariant ensures] false -> inv_I (iter_Filter_I_F self) /\ inv_F (func_Filter_I_F self)
    
    else
      [@expl:invariant ensures] false -> inv_I (iter_Filter_I_F self) /\ inv_F (func_Filter_I_F self)

end
module M_std__iter__filter__impl_IteratorSpec_for_Filter_I_F__produces_refl (* <std::iter::Filter<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Filter_I_F
  
  type t_Item
  
  type t_F
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) = forall f: t_F, i: t_Item. precondition_F f i
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  predicate produces_Filter_I_F (self: t_Filter_I_F) (visited: Seq.seq t_Item) (succ: t_Filter_I_F) =
    private_invariant_I self
    -> hist_inv_F (func_Filter_I_F self) (func_Filter_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_Filter_I_F self) s (iter_Filter_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_F (func_Filter_I_F self) (Seq.get s i) (func_Filter_I_F self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Filter_I_F
  
  function produces_refl_Filter_I_F (self: t_Filter_I_F) : ()
  
  goal vc_produces_refl_Filter_I_F:
    [@expl:produces_refl ensures] produces_Filter_I_F self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__filter__impl_IteratorSpec_for_Filter_I_F__produces_trans (* <std::iter::Filter<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Filter_I_F
  
  type t_Item
  
  type t_F
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) = forall f: t_F, i: t_Item. precondition_F f i
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  predicate produces_Filter_I_F (self: t_Filter_I_F) (visited: Seq.seq t_Item) (succ: t_Filter_I_F) =
    private_invariant_I self
    -> hist_inv_F (func_Filter_I_F self) (func_Filter_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_Filter_I_F self) s (iter_Filter_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_F (func_Filter_I_F self) (Seq.get s i) (func_Filter_I_F self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Filter_I_F
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Filter_I_F
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Filter_I_F
  
  function produces_trans_Filter_I_F (a: t_Filter_I_F) (ab: Seq.seq t_Item) (b: t_Filter_I_F) (bc: Seq.seq t_Item) (c: t_Filter_I_F) : ()
  
  goal vc_produces_trans_Filter_I_F: produces_Filter_I_F a ab b
    -> produces_Filter_I_F b bc c -> ([@expl:produces_trans ensures] produces_Filter_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__filter_map__impl_IteratorSpec_for_FilterMap_I_F__produces_refl (* <std::iter::FilterMap<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FilterMap_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_Item (f: t_F) = forall i: t_Item. precondition_F f i
  
  function func_FilterMap_I_F (self: t_FilterMap_I_F) : t_F
  
  type t_Option_B = None | Some t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_Option_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_Option_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_Option_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_Item (f: t_F) = forall g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_Item (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut_F f1 i f2 (Some b))
      /\ postcondition_mut_F f1 i f2 (None))
  
  predicate private_invariant_B (f: t_FilterMap_I_F) =
    no_precondition_Item (func_FilterMap_I_F f)
    /\ immutable_Item (func_FilterMap_I_F f) /\ precise_Item (func_FilterMap_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_FilterMap_I_F (self: t_FilterMap_I_F) : t_I
  
  predicate produces_FilterMap_I_F (self: t_FilterMap_I_F) (visited: Seq.seq t_B) (succ: t_FilterMap_I_F) =
    private_invariant_B self
    -> hist_inv_F (func_FilterMap_I_F self) (func_FilterMap_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_FilterMap_I_F self) s (iter_FilterMap_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s (Map.get f i)) (func_FilterMap_I_F self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s j) (func_FilterMap_I_F self) (None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FilterMap_I_F
  
  function produces_refl_FilterMap_I_F (self: t_FilterMap_I_F) : ()
  
  goal vc_produces_refl_FilterMap_I_F:
    [@expl:produces_refl ensures] produces_FilterMap_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__filter_map__impl_IteratorSpec_for_FilterMap_I_F__produces_trans (* <std::iter::FilterMap<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FilterMap_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_Item (f: t_F) = forall i: t_Item. precondition_F f i
  
  function func_FilterMap_I_F (self: t_FilterMap_I_F) : t_F
  
  type t_Option_B = None | Some t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_Option_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_Option_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_Option_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_Item (f: t_F) = forall g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_Item (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut_F f1 i f2 (Some b))
      /\ postcondition_mut_F f1 i f2 (None))
  
  predicate private_invariant_B (f: t_FilterMap_I_F) =
    no_precondition_Item (func_FilterMap_I_F f)
    /\ immutable_Item (func_FilterMap_I_F f) /\ precise_Item (func_FilterMap_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_FilterMap_I_F (self: t_FilterMap_I_F) : t_I
  
  predicate produces_FilterMap_I_F (self: t_FilterMap_I_F) (visited: Seq.seq t_B) (succ: t_FilterMap_I_F) =
    private_invariant_B self
    -> hist_inv_F (func_FilterMap_I_F self) (func_FilterMap_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_FilterMap_I_F self) s (iter_FilterMap_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s (Map.get f i)) (func_FilterMap_I_F self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s j) (func_FilterMap_I_F self) (None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FilterMap_I_F
  
  constant ab : Seq.seq t_B
  
  constant b : t_FilterMap_I_F
  
  constant bc : Seq.seq t_B
  
  constant c : t_FilterMap_I_F
  
  function produces_trans_FilterMap_I_F (a: t_FilterMap_I_F) (ab: Seq.seq t_B) (b: t_FilterMap_I_F) (bc: Seq.seq t_B) (c: t_FilterMap_I_F) : ()
  
  goal vc_produces_trans_FilterMap_I_F: produces_FilterMap_I_F a ab b
    -> produces_FilterMap_I_F b bc c -> ([@expl:produces_trans ensures] produces_FilterMap_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__fuse__impl_IteratorSpec_for_Fuse_I__produces_refl (* <std::iter::Fuse<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Fuse_I
  
  function produces_refl_Fuse_I (self: t_Fuse_I) : ()
  
  goal vc_produces_refl_Fuse_I: [@expl:produces_refl ensures] produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__fuse__impl_IteratorSpec_for_Fuse_I__produces_trans (* <std::iter::Fuse<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Fuse_I
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Fuse_I
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Fuse_I
  
  function produces_trans_Fuse_I (a: t_Fuse_I) (ab: Seq.seq t_Item) (b: t_Fuse_I) (bc: Seq.seq t_Item) (c: t_Fuse_I) : ()
  
  goal vc_produces_trans_Fuse_I: produces_Fuse_I a ab b
    -> produces_Fuse_I b bc c -> ([@expl:produces_trans ensures] produces_Fuse_I a (Seq.(++) ab bc) c)
end
module M_std__iter__fuse__impl_FusedIterator_for_Fuse_I__is_fused (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  function produces_trans_Fuse_I (a: t_Fuse_I) (ab: Seq.seq t_Item) (b: t_Fuse_I) (bc: Seq.seq t_Item) (c: t_Fuse_I) : ()
   = ()
  
  axiom produces_trans_Fuse_I_spec:
    forall a: t_Fuse_I, ab: Seq.seq t_Item, b: t_Fuse_I, bc: Seq.seq t_Item, c: t_Fuse_I. produces_Fuse_I a ab b
      -> produces_Fuse_I b bc c -> produces_Fuse_I a (Seq.(++) ab bc) c
  
  function produces_refl_Fuse_I (self: t_Fuse_I) : () = ()
  
  axiom produces_refl_Fuse_I_spec: forall self: t_Fuse_I. produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate completed_Fuse_I (self: MutBorrow.t t_Fuse_I) =
    (view_Fuse_I self.current = None
      \/ (exists it: MutBorrow.t t_I. completed_I it /\ view_Fuse_I self.current = Some (it.current)))
    /\ view_Fuse_I self.final = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_Fuse_I
  
  constant steps : Seq.seq t_Item
  
  constant next : t_Fuse_I
  
  function is_fused_Fuse_I (self: MutBorrow.t t_Fuse_I) (steps: Seq.seq t_Item) (next: t_Fuse_I) : ()
  
  goal vc_is_fused_Fuse_I: completed_Fuse_I self
    -> produces_Fuse_I self.final steps next -> ([@expl:is_fused ensures] steps = (Seq.empty: Seq.seq t_Item))
end
module M_std__iter__map__impl_Invariant_for_Map_I_F__invariant (* <std::iter::Map<I, F> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_Map_I_F
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate next_precondition_I (iter: t_I) (func: t_F) =
    forall e: t_Item, i: t_I [produces_I iter (Seq.singleton e) i]. produces_I iter (Seq.singleton e) i
      -> precondition_F func e
  
  type t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate preservation_I (iter: t_I) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I [produces_I iter (Seq.snoc (Seq.snoc s e1) e2) i, postcondition_mut_F f.current e1 f.final b]. hist_inv_F func f.current
      -> produces_I iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current e1 -> postcondition_mut_F f.current e1 f.final b -> precondition_F f.final e2
  
  predicate reinitialize_I =
    forall iter: MutBorrow.t t_I, func: t_F. completed_I iter
      -> next_precondition_I iter.final func /\ preservation_I iter.final func
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map_I_F
  
  predicate invariant_Map_I_F (self: t_Map_I_F)
  
  goal vc_invariant_Map_I_F: if inv_I (iter_Map_I_F self) then
      if inv_F (func_Map_I_F self) then
        if reinitialize_I then
          if preservation_I (iter_Map_I_F self) (func_Map_I_F self) then
            [@expl:invariant ensures] next_precondition_I (iter_Map_I_F self) (func_Map_I_F self)
            -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)
          else
            [@expl:invariant ensures] false -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)
        
        else
          [@expl:invariant ensures] false -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)
      
      else
        [@expl:invariant ensures] false -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)
    
    else
      [@expl:invariant ensures] false -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)

end
module M_std__iter__map__impl_IteratorSpec_for_Map_I_F__produces_refl (* <std::iter::Map<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Map_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate produces_Map_I_F [@inline:trivial] (self: t_Map_I_F) (visited: Seq.seq t_B) (succ: t_Map_I_F) =
    hist_inv_F (func_Map_I_F self) (func_Map_I_F succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)]. Seq.length s
          = Seq.length visited
        /\ produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func_Map_I_F self = func_Map_I_F succ
          else
            (Seq.get fs 0).current = func_Map_I_F self
            /\ (Seq.get fs (Seq.length visited - 1)).final = func_Map_I_F succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F (func_Map_I_F self) (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current (Seq.get s i)
          /\ postcondition_mut_F (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map_I_F
  
  function produces_refl_Map_I_F (self: t_Map_I_F) : ()
  
  goal vc_produces_refl_Map_I_F: [@expl:produces_refl ensures] produces_Map_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__map__impl_IteratorSpec_for_Map_I_F__produces_trans (* <std::iter::Map<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Map_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate produces_Map_I_F [@inline:trivial] (self: t_Map_I_F) (visited: Seq.seq t_B) (succ: t_Map_I_F) =
    hist_inv_F (func_Map_I_F self) (func_Map_I_F succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)]. Seq.length s
          = Seq.length visited
        /\ produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func_Map_I_F self = func_Map_I_F succ
          else
            (Seq.get fs 0).current = func_Map_I_F self
            /\ (Seq.get fs (Seq.length visited - 1)).final = func_Map_I_F succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F (func_Map_I_F self) (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current (Seq.get s i)
          /\ postcondition_mut_F (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Map_I_F
  
  constant ab : Seq.seq t_B
  
  constant b : t_Map_I_F
  
  constant bc : Seq.seq t_B
  
  constant c : t_Map_I_F
  
  function produces_trans_Map_I_F (a: t_Map_I_F) (ab: Seq.seq t_B) (b: t_Map_I_F) (bc: Seq.seq t_B) (c: t_Map_I_F) : ()
  
  goal vc_produces_trans_Map_I_F: produces_Map_I_F a ab b
    -> produces_Map_I_F b bc c -> ([@expl:produces_trans ensures] produces_Map_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__map_inv__impl_IteratorSpec_for_MapInv_I_F__produces_refl (* <std::iter::map_inv::MapInv<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current { f0 = Seq.get s i; f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv_I_F
  
  function produces_refl_MapInv_I_F (self: t_MapInv_I_F) : ()
  
  goal vc_produces_refl_MapInv_I_F: [@expl:produces_refl ensures] produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__map_inv__impl_IteratorSpec_for_MapInv_I_F__produces_trans (* <std::iter::map_inv::MapInv<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current { f0 = Seq.get s i; f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_MapInv_I_F
  
  constant ab : Seq.seq t_B
  
  constant b : t_MapInv_I_F
  
  constant bc : Seq.seq t_B
  
  constant c : t_MapInv_I_F
  
  function produces_trans_MapInv_I_F (a: t_MapInv_I_F) (ab: Seq.seq t_B) (b: t_MapInv_I_F) (bc: Seq.seq t_B) (c: t_MapInv_I_F) : ()
  
  goal vc_produces_trans_MapInv_I_F: produces_MapInv_I_F a ab b
    -> produces_MapInv_I_F b bc c -> ([@expl:produces_trans ensures] produces_MapInv_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__map_inv__impl_Iterator_for_MapInv_I_F__next (* <std::iter::map_inv::MapInv<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  predicate inv_I (_1: t_I)
  
  type t_Option_Item = None | Some t_Item
  
  predicate invariant_ref_I [@inline:trivial] (self: MutBorrow.t t_I) = inv_I self.current /\ inv_I self.final
  
  meta "rewrite_def" predicate invariant_ref_I
  
  predicate inv_ref_I [@inline:trivial] (_1: MutBorrow.t t_I) = invariant_ref_I _1
  
  meta "rewrite_def" predicate inv_ref_I
  
  predicate precondition_next (self: ()) (args: MutBorrow.t t_I)
  
  axiom precondition_fndef:
    forall args: MutBorrow.t t_I [precondition_next () args]. (let self_ = args in inv_ref_I self_)
      -> precondition_next () args
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate inv_Item (_1: t_Item)
  
  predicate inv_Option_Item (_1: t_Option_Item)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_Item [inv_Option_Item x]. inv_Option_Item x
      = match x with
        | None -> true
        | Some f0 -> inv_Item f0
        end
  
  predicate postcondition_once_next (self: ()) (args: MutBorrow.t t_I) (result: t_Option_Item)
  
  axiom postcondition_fndef:
    forall args: MutBorrow.t t_I, res: t_Option_Item [postcondition_once_next () args res]. postcondition_once_next () args res
      -> (let self_ = args in match res with
          | None -> completed_I self_
          | Some v -> produces_I self_.current (Seq.singleton v) self_.final
          end
      /\ inv_Option_Item res)
  
  let rec next_I (self_: MutBorrow.t t_I) (return (x: t_Option_Item)) =
    {[@expl:next requires] precondition_next () self_}
    any [ return (result: t_Option_Item) -> {postcondition_once_next () self_ result} (! return {result}) ]
  
  let rec elim_Some (input: t_Option_Item) (ret (f0: t_Item)) = any
    [ good (f0: t_Item) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Item [Some f0: t_Option_Item]. Some f0 <> input} (! {false} any) ]
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate inv_F (_1: t_F)
  
  type t_B
  
  predicate invariant_ref_F [@inline:trivial] (self: MutBorrow.t t_F) = inv_F self.current /\ inv_F self.final
  
  meta "rewrite_def" predicate invariant_ref_F
  
  predicate inv_ref_F [@inline:trivial] (_1: MutBorrow.t t_F) = invariant_ref_F _1
  
  meta "rewrite_def" predicate inv_ref_F
  
  predicate inv_tup2_Item_Snapshot_Seq_Item [@inline:trivial] (_1: tup2_Item_Snapshot_Seq_Item) = inv_Item _1.f0
  
  meta "rewrite_def" predicate inv_tup2_Item_Snapshot_Seq_Item
  
  predicate inv_B (_1: t_B)
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  let rec call_mut_F (self_: MutBorrow.t t_F) (arg: tup2_Item_Snapshot_Seq_Item) (return (x: t_B)) =
    {[@expl:call_mut 'self_' type invariant] inv_ref_F self_}
    {[@expl:call_mut 'arg' type invariant] inv_tup2_Item_Snapshot_Seq_Item arg}
    {[@expl:call_mut requires] precondition_F self_.current arg}
    any
    [ return (result: t_B) -> {inv_B result}
      {postcondition_mut_F self_.current arg self_.final result}
      (! return {result}) ]
  
  predicate next_precondition_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. produces_I iter'0 (Seq.singleton e) i -> precondition_F func'0 { f0 = e; f1 = produced'0 }
  
  predicate preservation_I (iter'0: t_I) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current { f0 = e1; f1 = s }
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize_I =
    forall iter'0: MutBorrow.t t_I, func'0: t_F. completed_I iter'0
      -> next_precondition_I iter'0.final func'0 (Seq.empty: Seq.seq t_Item) /\ preservation_I iter'0.final func'0
  
  predicate preservation_inv_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s }
      -> postcondition_mut_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced'0 s) e1 }
  
  axiom preservation_inv_I_spec: forall iter'0: t_I, func'0: t_F, produced'0: Seq.seq t_Item. produced'0
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv_I iter'0 func'0 produced'0 = preservation_I iter'0 func'0
  
  predicate invariant_MapInv_I_F (self: t_MapInv_I_F) =
    reinitialize_I
    /\ preservation_inv_I self.iter self.func self.produced /\ next_precondition_I self.iter self.func self.produced
  
  function produces_one_invariant_I (self: t_MapInv_I_F) (e: t_Item) (r: t_B) (f: MutBorrow.t t_F) (iter'0: t_I) : () =
    ()
  
  axiom produces_one_invariant_I_spec:
    forall self: t_MapInv_I_F, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter'0: t_I. invariant_MapInv_I_F self
      -> produces_I self.iter (Seq.singleton e) iter'0
      -> f.current = self.func
      -> postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final r
      -> preservation_inv_I iter'0 f.final (Seq.snoc self.produced e)
  
  axiom produces_one_invariant_I_spec'0:
    forall self: t_MapInv_I_F, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter'0: t_I. invariant_MapInv_I_F self
      -> produces_I self.iter (Seq.singleton e) iter'0
      -> f.current = self.func
      -> postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final r
      -> next_precondition_I iter'0 f.final (Seq.snoc self.produced e)
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current { f0 = Seq.get s i; f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  function produces_trans_MapInv_I_F (a: t_MapInv_I_F) (ab: Seq.seq t_B) (b: t_MapInv_I_F) (bc: Seq.seq t_B) (c: t_MapInv_I_F) : ()
   = ()
  
  axiom produces_trans_MapInv_I_F_spec:
    forall a: t_MapInv_I_F, ab: Seq.seq t_B, b: t_MapInv_I_F, bc: Seq.seq t_B, c: t_MapInv_I_F. produces_MapInv_I_F a ab b
      -> produces_MapInv_I_F b bc c -> produces_MapInv_I_F a (Seq.(++) ab bc) c
  
  function produces_refl_MapInv_I_F (self: t_MapInv_I_F) : () = ()
  
  axiom produces_refl_MapInv_I_F_spec: forall self: t_MapInv_I_F. produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
  
  predicate produces_one_I (self: t_MapInv_I_F) (visited: t_B) (succ: t_MapInv_I_F) =
    exists f: MutBorrow.t t_F, e: t_Item. f.current = self.func
      /\ f.final = succ.func
      /\ produces_I self.iter (Seq.singleton e) succ.iter
      /\ succ.produced = Seq.snoc self.produced e
      /\ precondition_F f.current { f0 = e; f1 = self.produced }
      /\ postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final visited
  
  axiom produces_one_I_spec:
    forall self: t_MapInv_I_F, visited: t_B, succ: t_MapInv_I_F. produces_one_I self visited succ
      = produces_MapInv_I_F self (Seq.singleton visited) succ
  
  predicate inv_MapInv_I_F (_1: t_MapInv_I_F)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_MapInv_I_F [inv_MapInv_I_F x]. inv_MapInv_I_F x
      = (invariant_MapInv_I_F x /\ inv_I x.iter /\ inv_F x.func)
  
  predicate invariant_ref_MapInv_I_F [@inline:trivial] (self: MutBorrow.t t_MapInv_I_F) =
    inv_MapInv_I_F self.current /\ inv_MapInv_I_F self.final
  
  meta "rewrite_def" predicate invariant_ref_MapInv_I_F
  
  predicate inv_ref_MapInv_I_F [@inline:trivial] (_1: MutBorrow.t t_MapInv_I_F) = invariant_ref_MapInv_I_F _1
  
  meta "rewrite_def" predicate inv_ref_MapInv_I_F
  
  predicate resolve_ref_MapInv_I_F [@inline:trivial] (_1: MutBorrow.t t_MapInv_I_F) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_MapInv_I_F
  
  type t_Option_B = None'0 | Some'0 t_B
  
  predicate inv_Option_B (_1: t_Option_B)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_B [inv_Option_B x]. inv_Option_B x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_B f0'0
        end
  
  predicate completed_MapInv_I_F (self: MutBorrow.t t_MapInv_I_F) =
    self.final.produced = (Seq.empty: Seq.seq t_Item)
    /\ completed_I (MutBorrow.borrow_logic self.current.iter self.final.iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ self.current.func = self.final.func
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_MapInv_I_F (self: MutBorrow.t t_MapInv_I_F) (return (x: t_Option_B)) =
    {[@expl:next 'self' type invariant] inv_ref_MapInv_I_F self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self.current ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_I self.current.iter}
        MutBorrow.borrow_final <t_I> {self.current.iter} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_I) ->
            [ &_6 <- _ret ] -{inv_I _ret.final}-
            [ &self <- { self with current = { self.current with iter = _ret.final } } ] s1)
      | s1 = next_I {_6} (fun (_ret: t_Option_Item) -> [ &_5 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_5 = None} (! bb5) | br1 (x0: t_Item) -> {_5 = Some x0} (! bb6) ]
    | bb6 = s0
      [ s0 = elim_Some {_5} (fun (r0: t_Item) -> [ &v <- r0 ] s1)
      | s1 = {[@expl:assertion] precondition_F self.current.func { f0 = v; f1 = self.current.produced }} s2
      | s2 = [ &produced'0 <- Seq.snoc self.current.produced v ] s3
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = {inv_F self.current.func}
        MutBorrow.borrow_final <t_F> {self.current.func} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_F) ->
            [ &_14 <- _ret ] -{inv_F _ret.final}-
            [ &self <- { self with current = { self.current with func = _ret.final } } ] s1)
      | s1 = [ &_15 <- { f0 = v; f1 = self.current.produced } ] s2
      | s2 = call_mut_F {_14} {_15} (fun (_ret: t_B) -> [ &r <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0
      [ s0 = [ &self <- { self with current = { self.current with produced = produced'0 } } ] s1
      | s1 = [ &_19 <- () ] s2
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {[@expl:assertion] produces_one_I old_self r self.current} s1
      | s1 = {[@expl:type invariant] inv_ref_MapInv_I_F self} s2
      | s2 = -{resolve_ref_MapInv_I_F self}- s3
      | s3 = [ &_0 <- Some'0 r ] s4
      | s4 = bb16 ]
    | bb5 = s0 [ s0 = [ &_24 <- Seq.empty: Seq.seq t_Item ] s1 | s1 = bb14 ]
    | bb14 = s0
      [ s0 = [ &self <- { self with current = { self.current with produced = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_MapInv_I_F self} s2
      | s2 = -{resolve_ref_MapInv_I_F self}- s3
      | s3 = [ &_0 <- None'0 ] s4
      | s4 = bb16 ]
    | bb16 = return {_0} ]
    [ & _0: t_Option_B = Any.any_l ()
    | & self: MutBorrow.t t_MapInv_I_F = self
    | & old_self: t_MapInv_I_F = Any.any_l ()
    | & _5: t_Option_Item = Any.any_l ()
    | & _6: MutBorrow.t t_I = Any.any_l ()
    | & v: t_Item = Any.any_l ()
    | & produced'0: Seq.seq t_Item = Any.any_l ()
    | & r: t_B = Any.any_l ()
    | & _14: MutBorrow.t t_F = Any.any_l ()
    | & _15: tup2_Item_Snapshot_Seq_Item = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _24: Seq.seq t_Item = Any.any_l () ])
    [ return (result: t_Option_B) -> {[@expl:next result type invariant] inv_Option_B result}
      {[@expl:next ensures] match result with
        | None'0 -> completed_MapInv_I_F self
        | Some'0 v -> produces_one_I self.current v self.final
        end}
      (! return {result}) ]
end
module M_std__iter__map_inv__impl_MapInv_I_F__preservation_inv (* std::iter::map_inv::MapInv<I, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  type t_B
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate preservation_I (iter: t_I) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func f.current
      -> produces_I iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current { f0 = e1; f1 = s }
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant iter : t_I
  
  constant func : t_F
  
  constant produced : Seq.seq t_Item
  
  predicate preservation_inv_I (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
  goal vc_preservation_inv_I: [@expl:preservation_inv ensures] produced = (Seq.empty: Seq.seq t_Item)
    -> (forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func f.current
        -> produces_I iter (Seq.snoc (Seq.snoc s e1) e2) i
        -> precondition_F f.current { f0 = e1; f1 = Seq.(++) produced s }
        -> postcondition_mut_F f.current { f0 = e1; f1 = Seq.(++) produced s } f.final b
        -> precondition_F f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced s) e1 })
    = preservation_I iter func
end
module M_std__iter__map_inv__impl_MapInv_I_F__produces_one_invariant (* std::iter::map_inv::MapInv<I, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate next_precondition_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. produces_I iter'0 (Seq.singleton e) i -> precondition_F func'0 { f0 = e; f1 = produced'0 }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate preservation_I (iter'0: t_I) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current { f0 = e1; f1 = s }
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize_I =
    forall iter'0: MutBorrow.t t_I, func'0: t_F. completed_I iter'0
      -> next_precondition_I iter'0.final func'0 (Seq.empty: Seq.seq t_Item) /\ preservation_I iter'0.final func'0
  
  predicate preservation_inv_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s }
      -> postcondition_mut_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced'0 s) e1 }
  
  axiom preservation_inv_I_spec: forall iter'0: t_I, func'0: t_F, produced'0: Seq.seq t_Item. produced'0
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv_I iter'0 func'0 produced'0 = preservation_I iter'0 func'0
  
  predicate invariant_MapInv_I_F (self: t_MapInv_I_F) =
    reinitialize_I
    /\ preservation_inv_I self.iter self.func self.produced /\ next_precondition_I self.iter self.func self.produced
  
  function push_front_Item [@inline:trivial] (self: Seq.seq t_Item) (x: t_Item) : Seq.seq t_Item = Seq.cons x self
  
  meta "rewrite_def" function push_front_Item
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv_I_F
  
  constant e : t_Item
  
  constant r : t_B
  
  constant f : MutBorrow.t t_F
  
  constant iter'0 : t_I
  
  function produces_one_invariant_I (self: t_MapInv_I_F) (e: t_Item) (r: t_B) (f: MutBorrow.t t_F) (iter'0: t_I) : ()
  
  goal vc_produces_one_invariant_I: invariant_MapInv_I_F self
    -> produces_I self.iter (Seq.singleton e) iter'0
    -> f.current = self.func
    -> postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final r
    -> (forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, i: t_I. produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
        -> produces_I self.iter (Seq.snoc (Seq.snoc (push_front_Item s e) e1) e2) i)
    && ([@expl:produces_one_invariant ensures #0] preservation_inv_I iter'0 f.final (Seq.snoc self.produced e))
    && ([@expl:produces_one_invariant ensures #1] next_precondition_I iter'0 f.final (Seq.snoc self.produced e))
end
module M_std__iter__map_inv__impl_MapInv_I_F__produces_one (* std::iter::map_inv::MapInv<I, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current { f0 = Seq.get s i; f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  function produces_trans_MapInv_I_F (a: t_MapInv_I_F) (ab: Seq.seq t_B) (b: t_MapInv_I_F) (bc: Seq.seq t_B) (c: t_MapInv_I_F) : ()
   = ()
  
  axiom produces_trans_MapInv_I_F_spec:
    forall a: t_MapInv_I_F, ab: Seq.seq t_B, b: t_MapInv_I_F, bc: Seq.seq t_B, c: t_MapInv_I_F. produces_MapInv_I_F a ab b
      -> produces_MapInv_I_F b bc c -> produces_MapInv_I_F a (Seq.(++) ab bc) c
  
  function produces_refl_MapInv_I_F (self: t_MapInv_I_F) : () = ()
  
  axiom produces_refl_MapInv_I_F_spec: forall self: t_MapInv_I_F. produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv_I_F
  
  constant visited : t_B
  
  constant succ : t_MapInv_I_F
  
  predicate produces_one_I (self: t_MapInv_I_F) (visited: t_B) (succ: t_MapInv_I_F)
  
  goal vc_produces_one_I: [@expl:produces_one ensures] (exists f: MutBorrow.t t_F, e: t_Item. f.current = self.func
        /\ f.final = succ.func
        /\ produces_I self.iter (Seq.singleton e) succ.iter
        /\ succ.produced = Seq.snoc self.produced e
        /\ precondition_F f.current { f0 = e; f1 = self.produced }
        /\ postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final visited)
    = produces_MapInv_I_F self (Seq.singleton visited) succ
end
module M_std__iter__once__impl_IteratorSpec_for_Once_T__produces_refl (* <std::iter::Once<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_Once_T (self: t_Once_T) : t_Option_T
  
  predicate produces_Once_T (self: t_Once_T) (visited: Seq.seq t_T) (o: t_Once_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Once_T self = Some e /\ visited = Seq.singleton e /\ view_Once_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Once_T
  
  function produces_refl_Once_T (self: t_Once_T) : ()
  
  goal vc_produces_refl_Once_T: [@expl:produces_refl ensures] produces_Once_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__once__impl_IteratorSpec_for_Once_T__produces_trans (* <std::iter::Once<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_Once_T (self: t_Once_T) : t_Option_T
  
  predicate produces_Once_T (self: t_Once_T) (visited: Seq.seq t_T) (o: t_Once_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Once_T self = Some e /\ visited = Seq.singleton e /\ view_Once_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Once_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Once_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Once_T
  
  function produces_trans_Once_T (a: t_Once_T) (ab: Seq.seq t_T) (b: t_Once_T) (bc: Seq.seq t_T) (c: t_Once_T) : ()
  
  goal vc_produces_trans_Once_T: produces_Once_T a ab b
    -> produces_Once_T b bc c -> ([@expl:produces_trans ensures] produces_Once_T a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_IteratorSpec_for_Range_Idx__produces_refl (* <std::ops::Range<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.end' = o.end'
    /\ deep_model_Idx self.start <= deep_model_Idx o.start
    /\ (Seq.length visited > 0 -> deep_model_Idx o.start <= deep_model_Idx o.end')
    /\ Seq.length visited = deep_model_Idx o.start - deep_model_Idx self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Range_Idx
  
  function produces_refl_Range_Idx (self: t_Range_Idx) : ()
  
  goal vc_produces_refl_Range_Idx: [@expl:produces_refl ensures] produces_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_IteratorSpec_for_Range_Idx__produces_trans (* <std::ops::Range<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.end' = o.end'
    /\ deep_model_Idx self.start <= deep_model_Idx o.start
    /\ (Seq.length visited > 0 -> deep_model_Idx o.start <= deep_model_Idx o.end')
    /\ Seq.length visited = deep_model_Idx o.start - deep_model_Idx self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Range_Idx
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_Range_Idx
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_Range_Idx
  
  function produces_trans_Range_Idx (a: t_Range_Idx) (ab: Seq.seq t_Idx) (b: t_Range_Idx) (bc: Seq.seq t_Idx) (c: t_Range_Idx) : ()
  
  goal vc_produces_trans_Range_Idx: produces_Range_Idx a ab b
    -> produces_Range_Idx b bc c -> ([@expl:produces_trans ensures] produces_Range_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_Range_Idx__produces_back_refl (* <std::ops::Range<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_back_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.start = o.start
    /\ deep_model_Idx self.end' >= deep_model_Idx o.end'
    /\ (Seq.length visited > 0 -> deep_model_Idx o.end' >= deep_model_Idx o.start)
    /\ Seq.length visited = deep_model_Idx o.end' - deep_model_Idx self.end'
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.end' - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Range_Idx
  
  function produces_back_refl_Range_Idx (self: t_Range_Idx) : ()
  
  goal vc_produces_back_refl_Range_Idx:
    [@expl:produces_back_refl ensures] produces_back_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_Range_Idx__produces_back_trans (* <std::ops::Range<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_back_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.start = o.start
    /\ deep_model_Idx self.end' >= deep_model_Idx o.end'
    /\ (Seq.length visited > 0 -> deep_model_Idx o.end' >= deep_model_Idx o.start)
    /\ Seq.length visited = deep_model_Idx o.end' - deep_model_Idx self.end'
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.end' - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Range_Idx
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_Range_Idx
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_Range_Idx
  
  function produces_back_trans_Range_Idx (a: t_Range_Idx) (ab: Seq.seq t_Idx) (b: t_Range_Idx) (bc: Seq.seq t_Idx) (c: t_Range_Idx) : ()
  
  goal vc_produces_back_trans_Range_Idx: produces_back_Range_Idx a ab b
    -> produces_back_Range_Idx b bc c
    -> ([@expl:produces_back_trans ensures] produces_back_Range_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__range_inclusive_len
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant r : t_RangeInclusive_Idx
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int
  
  goal vc_range_inclusive_len_Idx: not is_empty_log_RangeInclusive_Idx r
      -> deep_model_Idx (start_log_RangeInclusive_Idx r) <= deep_model_Idx (end_log_RangeInclusive_Idx r)
    -> (if is_empty_log_RangeInclusive_Idx r then
      [@expl:range_inclusive_len ensures] is_empty_log_RangeInclusive_Idx r = (0 = 0)
    else
      [@expl:range_inclusive_len ensures] is_empty_log_RangeInclusive_Idx r
      = (deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1 = 0)
    )
end
module M_std__iter__range__impl_IteratorSpec_for_RangeInclusive_Idx__produces_refl (* <std::ops::RangeInclusive<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ end_log_RangeInclusive_Idx self = end_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (start_log_RangeInclusive_Idx self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_RangeInclusive_Idx
  
  function produces_refl_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : ()
  
  goal vc_produces_refl_RangeInclusive_Idx:
    [@expl:produces_refl ensures] produces_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_IteratorSpec_for_RangeInclusive_Idx__produces_trans (* <std::ops::RangeInclusive<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ end_log_RangeInclusive_Idx self = end_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (start_log_RangeInclusive_Idx self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_RangeInclusive_Idx
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_RangeInclusive_Idx
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_RangeInclusive_Idx
  
  function produces_trans_RangeInclusive_Idx (a: t_RangeInclusive_Idx) (ab: Seq.seq t_Idx) (b: t_RangeInclusive_Idx) (bc: Seq.seq t_Idx) (c: t_RangeInclusive_Idx) : ()
  
  goal vc_produces_trans_RangeInclusive_Idx: produces_RangeInclusive_Idx a ab b
    -> produces_RangeInclusive_Idx b bc c
    -> ([@expl:produces_trans ensures] produces_RangeInclusive_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_RangeInclusive_Idx__produces_back_refl (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_back_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ start_log_RangeInclusive_Idx self = start_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (end_log_RangeInclusive_Idx self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_RangeInclusive_Idx
  
  function produces_back_refl_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : ()
  
  goal vc_produces_back_refl_RangeInclusive_Idx:
    [@expl:produces_back_refl ensures] produces_back_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_RangeInclusive_Idx__produces_back_trans (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_back_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ start_log_RangeInclusive_Idx self = start_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (end_log_RangeInclusive_Idx self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_RangeInclusive_Idx
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_RangeInclusive_Idx
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_RangeInclusive_Idx
  
  function produces_back_trans_RangeInclusive_Idx (a: t_RangeInclusive_Idx) (ab: Seq.seq t_Idx) (b: t_RangeInclusive_Idx) (bc: Seq.seq t_Idx) (c: t_RangeInclusive_Idx) : ()
  
  goal vc_produces_back_trans_RangeInclusive_Idx: produces_back_RangeInclusive_Idx a ab b
    -> produces_back_RangeInclusive_Idx b bc c
    -> ([@expl:produces_back_trans ensures] produces_back_RangeInclusive_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__repeat__impl_IteratorSpec_for_Repeat_T__produces_refl (* <std::iter::Repeat<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Repeat_T
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_Repeat_T (self: t_Repeat_T) : t_T
  
  predicate produces_Repeat_T (self: t_Repeat_T) (visited: Seq.seq t_T) (o: t_Repeat_T) =
    self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> postcondition_clone () (view_Repeat_T self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Repeat_T
  
  function produces_refl_Repeat_T (self: t_Repeat_T) : ()
  
  goal vc_produces_refl_Repeat_T: [@expl:produces_refl ensures] produces_Repeat_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__repeat__impl_IteratorSpec_for_Repeat_T__produces_trans (* <std::iter::Repeat<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Repeat_T
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_Repeat_T (self: t_Repeat_T) : t_T
  
  predicate produces_Repeat_T (self: t_Repeat_T) (visited: Seq.seq t_T) (o: t_Repeat_T) =
    self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> postcondition_clone () (view_Repeat_T self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Repeat_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Repeat_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Repeat_T
  
  function produces_trans_Repeat_T (a: t_Repeat_T) (ab: Seq.seq t_T) (b: t_Repeat_T) (bc: Seq.seq t_T) (c: t_Repeat_T) : ()
  
  goal vc_produces_trans_Repeat_T: produces_Repeat_T a ab b
    -> produces_Repeat_T b bc c -> ([@expl:produces_trans ensures] produces_Repeat_T a (Seq.(++) ab bc) c)
end
module M_std__iter__rev__impl_IteratorSpec_for_Rev_I__produces_refl (* <std::iter::Rev<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev_I
  
  type t_Item
  
  type t_I
  
  predicate produces_back_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_I_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back_I a ab b
      -> produces_back_I b bc c -> produces_back_I a (Seq.(++) ab bc) c
  
  function produces_back_refl_I (self: t_I) : ()
  
  axiom produces_back_refl_I_spec: forall self: t_I. produces_back_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Rev_I (self: t_Rev_I) : t_I
  
  predicate produces_Rev_I (self: t_Rev_I) (visited: Seq.seq t_Item) (o: t_Rev_I) =
    produces_back_I (iter_Rev_I self) visited (iter_Rev_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Rev_I
  
  function produces_refl_Rev_I (self: t_Rev_I) : ()
  
  goal vc_produces_refl_Rev_I: [@expl:produces_refl ensures] produces_Rev_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__rev__impl_IteratorSpec_for_Rev_I__produces_trans (* <std::iter::Rev<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev_I
  
  type t_Item
  
  type t_I
  
  predicate produces_back_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_I_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back_I a ab b
      -> produces_back_I b bc c -> produces_back_I a (Seq.(++) ab bc) c
  
  function produces_back_refl_I (self: t_I) : ()
  
  axiom produces_back_refl_I_spec: forall self: t_I. produces_back_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Rev_I (self: t_Rev_I) : t_I
  
  predicate produces_Rev_I (self: t_Rev_I) (visited: Seq.seq t_Item) (o: t_Rev_I) =
    produces_back_I (iter_Rev_I self) visited (iter_Rev_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Rev_I
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Rev_I
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Rev_I
  
  function produces_trans_Rev_I (a: t_Rev_I) (ab: Seq.seq t_Item) (b: t_Rev_I) (bc: Seq.seq t_Item) (c: t_Rev_I) : ()
  
  goal vc_produces_trans_Rev_I: produces_Rev_I a ab b
    -> produces_Rev_I b bc c -> ([@expl:produces_trans ensures] produces_Rev_I a (Seq.(++) ab bc) c)
end
module M_std__iter__skip__impl_IteratorSpec_for_Skip_I__produces_refl (* <std::iter::Skip<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Skip_I
  
  type t_Item
  
  function n_Skip_I (self: t_Skip_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Item (_1: t_Item)
  
  predicate produces_Skip_I (self: t_Skip_I) (visited: Seq.seq t_Item) (o: t_Skip_I) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n_Skip_I o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n_Skip_I self)
      /\ produces_I (iter_Skip_I self) (Seq.(++) s visited) (iter_Skip_I o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve_Item (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Skip_I
  
  function produces_refl_Skip_I (self: t_Skip_I) : ()
  
  goal vc_produces_refl_Skip_I: [@expl:produces_refl ensures] produces_Skip_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__skip__impl_IteratorSpec_for_Skip_I__produces_trans (* <std::iter::Skip<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Skip_I
  
  type t_Item
  
  function n_Skip_I (self: t_Skip_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Item (_1: t_Item)
  
  predicate produces_Skip_I (self: t_Skip_I) (visited: Seq.seq t_Item) (o: t_Skip_I) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n_Skip_I o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n_Skip_I self)
      /\ produces_I (iter_Skip_I self) (Seq.(++) s visited) (iter_Skip_I o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve_Item (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Skip_I
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Skip_I
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Skip_I
  
  function produces_trans_Skip_I (a: t_Skip_I) (ab: Seq.seq t_Item) (b: t_Skip_I) (bc: Seq.seq t_Item) (c: t_Skip_I) : ()
  
  goal vc_produces_trans_Skip_I: produces_Skip_I a ab b
    -> produces_Skip_I b bc c -> ([@expl:produces_trans ensures] produces_Skip_I a (Seq.(++) ab bc) c)
end
module M_std__iter__take__impl_IteratorSpec_for_Take_I__produces_refl (* <std::iter::Take<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Take_I
  
  type t_Item
  
  function n_Take_I (self: t_Take_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate produces_Take_I (self: t_Take_I) (visited: Seq.seq t_Item) (o: t_Take_I) =
    UInt64.t'int (n_Take_I self) = UInt64.t'int (n_Take_I o) + Seq.length visited
    /\ produces_I (iter_Take_I self) visited (iter_Take_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Take_I
  
  function produces_refl_Take_I (self: t_Take_I) : ()
  
  goal vc_produces_refl_Take_I: [@expl:produces_refl ensures] produces_Take_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__take__impl_IteratorSpec_for_Take_I__produces_trans (* <std::iter::Take<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Take_I
  
  type t_Item
  
  function n_Take_I (self: t_Take_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate produces_Take_I (self: t_Take_I) (visited: Seq.seq t_Item) (o: t_Take_I) =
    UInt64.t'int (n_Take_I self) = UInt64.t'int (n_Take_I o) + Seq.length visited
    /\ produces_I (iter_Take_I self) visited (iter_Take_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Take_I
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Take_I
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Take_I
  
  function produces_trans_Take_I (a: t_Take_I) (ab: Seq.seq t_Item) (b: t_Take_I) (bc: Seq.seq t_Item) (c: t_Take_I) : ()
  
  goal vc_produces_trans_Take_I: produces_Take_I a ab b
    -> produces_Take_I b bc c -> ([@expl:produces_trans ensures] produces_Take_I a (Seq.(++) ab bc) c)
end
module M_std__iter__zip__impl_IteratorSpec_for_Zip_A_B__produces_refl (* <std::iter::Zip<A, B> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Zip_A_B
  
  type t_Item
  
  type t_Item'0
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a ab b
      -> produces_A b bc c -> produces_A a (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  function itera_Zip_A_B (self: t_Zip_A_B) : t_A
  
  type t_B
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a ab b
      -> produces_B b bc c -> produces_B a (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb_Zip_A_B (self: t_Zip_A_B) : t_B
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (o: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A (itera_Zip_A_B self) p1 (itera_Zip_A_B o) /\ produces_B (iterb_Zip_A_B self) p2 (iterb_Zip_A_B o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Zip_A_B
  
  function produces_refl_Zip_A_B (self: t_Zip_A_B) : ()
  
  goal vc_produces_refl_Zip_A_B:
    [@expl:produces_refl ensures] produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
end
module M_std__iter__zip__impl_IteratorSpec_for_Zip_A_B__produces_trans (* <std::iter::Zip<A, B> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Zip_A_B
  
  type t_Item
  
  type t_Item'0
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a ab b
      -> produces_A b bc c -> produces_A a (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  function itera_Zip_A_B (self: t_Zip_A_B) : t_A
  
  type t_B
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a ab b
      -> produces_B b bc c -> produces_B a (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb_Zip_A_B (self: t_Zip_A_B) : t_B
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (o: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A (itera_Zip_A_B self) p1 (itera_Zip_A_B o) /\ produces_B (iterb_Zip_A_B self) p2 (iterb_Zip_A_B o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Zip_A_B
  
  constant ab : Seq.seq tup2_Item_Item
  
  constant b : t_Zip_A_B
  
  constant bc : Seq.seq tup2_Item_Item
  
  constant c : t_Zip_A_B
  
  function produces_trans_Zip_A_B (a: t_Zip_A_B) (ab: Seq.seq tup2_Item_Item) (b: t_Zip_A_B) (bc: Seq.seq tup2_Item_Item) (c: t_Zip_A_B) : ()
  
  goal vc_produces_trans_Zip_A_B: produces_Zip_A_B a ab b
    -> produces_Zip_A_B b bc c -> ([@expl:produces_trans ensures] produces_Zip_A_B a (Seq.(++) ab bc) c)
end
module M_std__iter__trait_IteratorSpec__map_inv
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Any
  use creusot.prelude.MutBorrow
  
  type t_Item
  
  type t_Self
  
  type t_F
  
  type t_MapInv_Self_F = { iter: t_Self; func: t_F; produced: Seq.seq t_Item }
  
  predicate inv_Self (_1: t_Self)
  
  predicate inv_F (_1: t_F)
  
  predicate produces_Self (self: t_Self) (visited: Seq.seq t_Item) (o: t_Self)
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate completed_Self (self: MutBorrow.t t_Self)
  
  predicate next_precondition_Self (iter'0: t_Self) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall e: t_Item, i: t_Self. produces_Self iter'0 (Seq.singleton e) i
      -> precondition_F func'0 { f0 = e; f1 = produced'0 }
  
  type t_B
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate preservation_Self (iter'0: t_Self) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_Self. hist_inv_F func'0 f.current
      -> produces_Self iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current { f0 = e1; f1 = s }
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize_Self =
    forall iter'0: MutBorrow.t t_Self, func'0: t_F. completed_Self iter'0
      -> next_precondition_Self iter'0.final func'0 (Seq.empty: Seq.seq t_Item) /\ preservation_Self iter'0.final func'0
  
  predicate preservation_inv_Self (iter'0: t_Self) (func'0: t_F) (produced'0: Seq.seq t_Item)
  
  axiom preservation_inv_Self_spec: forall iter'0: t_Self, func'0: t_F, produced'0: Seq.seq t_Item. produced'0
        = (Seq.empty: Seq.seq t_Item)
      -> preservation_inv_Self iter'0 func'0 produced'0 = preservation_Self iter'0 func'0
  
  predicate invariant_MapInv_Self_F (self: t_MapInv_Self_F) =
    reinitialize_Self
    /\ preservation_inv_Self self.iter self.func self.produced
    /\ next_precondition_Self self.iter self.func self.produced
  
  predicate inv_MapInv_Self_F (_1: t_MapInv_Self_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv_Self_F [inv_MapInv_Self_F x]. inv_MapInv_Self_F x
      = (invariant_MapInv_Self_F x /\ inv_Self x.iter /\ inv_F x.func)
  
  type tup2_Self_F = { f0'0: t_Self; f1'0: t_F }
  
  predicate precondition_map_inv (self: ()) (args: tup2_Self_F)
  
  axiom precondition_fndef:
    forall args: tup2_Self_F [precondition_map_inv () args]. (let {f0'0 = self; f1'0 = func'0} = args in preservation_Self self func'0
        /\ reinitialize_Self
        /\ (forall e: t_Item, i2: t_Self. produces_Self self (Seq.singleton e) i2
            -> precondition_F func'0 { f0 = e; f1 = Seq.empty: Seq.seq t_Item })
        /\ inv_F func'0 /\ inv_Self self) -> precondition_map_inv () args
  
  predicate postcondition_once_map_inv (self: ()) (args: tup2_Self_F) (result: t_MapInv_Self_F)
  
  axiom postcondition_fndef:
    forall args: tup2_Self_F, res: t_MapInv_Self_F [postcondition_once_map_inv () args res]. postcondition_once_map_inv () args res
      -> (let {f0'0 = self; f1'0 = func'0} = args in res
        = { iter = self; func = func'0; produced = Seq.empty: Seq.seq t_Item }
      /\ inv_MapInv_Self_F res)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec map_inv_Self (self: t_Self) (func'0: t_F) (return (x: t_MapInv_Self_F)) =
    {[@expl:map_inv 'self' type invariant] inv_Self self}
    {[@expl:map_inv 'func' type invariant] inv_F func'0}
    {[@expl:map_inv requires #0] forall e: t_Item, i2: t_Self. produces_Self self (Seq.singleton e) i2
      -> precondition_F func'0 { f0 = e; f1 = Seq.empty: Seq.seq t_Item }}
    {[@expl:map_inv requires #1] reinitialize_Self}
    {[@expl:map_inv requires #2] preservation_Self self func'0}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = [ &_9 <- Seq.empty: Seq.seq t_Item ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- { iter = self; func = func'0; produced = _9 } ] s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_MapInv_Self_F = Any.any_l ()
    | & self: t_Self = self
    | & func'0: t_F = func'0
    | & _9: Seq.seq t_Item = Any.any_l () ])
    [ return (result: t_MapInv_Self_F) -> {[@expl:map_inv result type invariant] inv_MapInv_Self_F result}
      {[@expl:map_inv ensures] result = { iter = self; func = func'0; produced = Seq.empty: Seq.seq t_Item }}
      (! return {result}) ]
end
module M_std__iter__impl_IteratorSpec_for_ref_I__produces_refl (* <&mut I as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_ref_I (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces_I self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_I
  
  function produces_refl_ref_I (self: MutBorrow.t t_I) : ()
  
  goal vc_produces_refl_ref_I: [@expl:produces_refl ensures] produces_ref_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__impl_IteratorSpec_for_ref_I__produces_trans (* <&mut I as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_ref_I (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces_I self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : MutBorrow.t t_I
  
  constant ab : Seq.seq t_Item
  
  constant b : MutBorrow.t t_I
  
  constant bc : Seq.seq t_Item
  
  constant c : MutBorrow.t t_I
  
  function produces_trans_ref_I (a: MutBorrow.t t_I) (ab: Seq.seq t_Item) (b: MutBorrow.t t_I) (bc: Seq.seq t_Item) (c: MutBorrow.t t_I) : ()
  
  goal vc_produces_trans_ref_I: produces_ref_I a ab b
    -> produces_ref_I b bc c -> ([@expl:produces_trans ensures] produces_ref_I a (Seq.(++) ab bc) c)
end
module M_std__mem__extern_spec_std_mem_replace_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  let rec swap_T (x: MutBorrow.t t_T) (y: MutBorrow.t t_T) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_T x}
    {[@expl:swap 'y' type invariant] inv_ref_T y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_replace_body_T (dest: MutBorrow.t t_T) (src: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_mem_replace_body 'dest' type invariant] inv_ref_T dest}
    {[@expl:extern_spec_std_mem_replace_body 'src' type invariant] inv_T src}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &src'0 <- src ] s1
      | s1 = {inv_T src'0}
        MutBorrow.borrow_mut <t_T> {src'0}
          (fun (_ret: MutBorrow.t t_T) -> [ &_9 <- _ret ] -{inv_T _ret.final}- [ &src'0 <- _ret.final ] s2)
      | s2 = {inv_T dest.current}
        MutBorrow.borrow_final <t_T> {dest.current} {MutBorrow.get_id dest}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_7 <- _ret ] -{inv_T _ret.final}-
            [ &dest <- { dest with current = _ret.final } ] s3)
      | s3 = {inv_T _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_8 <- _ret ] -{inv_T _ret.final}-
            [ &_9 <- { _9 with current = _ret.final } ] s4)
      | s4 = swap_T {_7} {_8} (fun (_ret: ()) -> [ &_6 <- _ret ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_ref_T _9} s1
      | s1 = -{resolve_ref_T _9}- s2
      | s2 = {[@expl:type invariant] inv_ref_T dest} s3
      | s3 = -{resolve_ref_T dest}- s4
      | s4 = [ &_0 <- src'0 ] s5
      | s5 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_T = Any.any_l ()
    | & dest: MutBorrow.t t_T = dest
    | & src: t_T = src
    | & src'0: t_T = Any.any_l ()
    | & _6: () = Any.any_l ()
    | & _7: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_mem_replace_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_mem_replace_body ensures #0] dest.final = src}
      {[@expl:extern_spec_std_mem_replace_body ensures #1] result = dest.current}
      (! return {result}) ]
end
module M_std__mem__extern_spec_std_mem_take_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition_default (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition_default () args]. (let () = args in true)
      -> precondition_default () args
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once_default () args res]. postcondition_once_default () args res
      -> (let () = args in inv_T res)
  
  let rec default_T (return (x: t_T)) = {[@expl:default requires] precondition_default () ()}
    any [ return (result: t_T) -> {postcondition_once_default () () result} (! return {result}) ]
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  let rec replace_T (dest: MutBorrow.t t_T) (src: t_T) (return (x: t_T)) =
    {[@expl:replace 'dest' type invariant] inv_ref_T dest}
    {[@expl:replace 'src' type invariant] inv_T src}
    any [ return (result: t_T) -> {inv_T result} {dest.final = src} {result = dest.current} (! return {result}) ]
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut_default () args () res]. postcondition_mut_default () args () res
      -> (let () = args in inv_T res)
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: (), res: t_T [postcondition_default () args res]. postcondition_default () args res
      -> (let () = args in inv_T res)
  
  function fn_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_take_body_T (dest: MutBorrow.t t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_mem_take_body 'dest' type invariant] inv_ref_T dest}
    (! bb0
    [ bb0 = s0 [ s0 = default_T (fun (_ret: t_T) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_T dest.current}
        MutBorrow.borrow_final <t_T> {dest.current} {MutBorrow.get_id dest}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_4 <- _ret ] -{inv_T _ret.final}-
            [ &dest <- { dest with current = _ret.final } ] s1)
      | s1 = replace_T {_4} {_5} (fun (_ret: t_T) -> [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv_ref_T dest} s1 | s1 = -{resolve_ref_T dest}- s2 | s2 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & dest: MutBorrow.t t_T = dest
    | & _4: MutBorrow.t t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_mem_take_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_mem_take_body ensures #0] result = dest.current}
      {[@expl:extern_spec_std_mem_take_body ensures #1] postcondition_default () () dest.final}
      (! return {result}) ]
end
module M_std__mem__extern_spec_std_mem_drop_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_drop_body_T (t: t_T) (return (x: ())) =
    {[@expl:extern_spec_std_mem_drop_body 't' type invariant] inv_T t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv_T t} s1 | s1 = -{resolve_T t}- s2 | s2 = bb1 ] | bb1 = return {_0} ]
    [ & _0: () = Any.any_l () | & t: t_T = t ])
    [ return (result: ()) -> {[@expl:extern_spec_std_mem_drop_body ensures] resolve_T t} (! return {result}) ]
end
module M_std__mem__extern_spec_std_mem_forget_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_forget_body_T (t: t_T) (return (x: ())) =
    {[@expl:extern_spec_std_mem_forget_body 't' type invariant] inv_T t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv_T t} s1 | s1 = -{resolve_T t}- s2 | s2 = bb1 ] | bb1 = return {_0} ]
    [ & _0: () = Any.any_l () | & t: t_T = t ])
    [ return (result: ()) -> {[@expl:extern_spec_std_mem_forget_body ensures] resolve_T t} (! return {result}) ]
end
module M_std__num__extern_spec_Default_u8_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u8_default_body (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt8.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt8.t = Any.any_l () ])
    [ return (result: UInt8.t) -> {[@expl:extern_spec_Default_u8_default_body ensures] result = (0: UInt8.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u8_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u8_clone_body (self_: UInt8.t) (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt8.t = Any.any_l () | & self_: UInt8.t = self_ ])
    [ return (result: UInt8.t) -> {[@expl:extern_spec_Clone_u8_clone_body ensures] result = self_} (! return {result}) ]
end
module M_std__num__extern_spec_Default_u16_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u16_default_body (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt16.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt16.t = Any.any_l () ])
    [ return (result: UInt16.t) -> {[@expl:extern_spec_Default_u16_default_body ensures] result = (0: UInt16.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u16_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u16_clone_body (self_: UInt16.t) (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt16.t = Any.any_l () | & self_: UInt16.t = self_ ])
    [ return (result: UInt16.t) -> {[@expl:extern_spec_Clone_u16_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_u32_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u32_default_body (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt32.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt32.t = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@expl:extern_spec_Default_u32_default_body ensures] result = (0: UInt32.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u32_clone_body (self_: UInt32.t) (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt32.t = Any.any_l () | & self_: UInt32.t = self_ ])
    [ return (result: UInt32.t) -> {[@expl:extern_spec_Clone_u32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_u64_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u64_default_body (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt64.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:extern_spec_Default_u64_default_body ensures] result = (0: UInt64.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u64_clone_body (self_: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & self_: UInt64.t = self_ ])
    [ return (result: UInt64.t) -> {[@expl:extern_spec_Clone_u64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_u128_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u128_default_body (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt128.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt128.t = Any.any_l () ])
    [ return (result: UInt128.t) -> {[@expl:extern_spec_Default_u128_default_body ensures] result = (0: UInt128.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u128_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u128_clone_body (self_: UInt128.t) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt128.t = Any.any_l () | & self_: UInt128.t = self_ ])
    [ return (result: UInt128.t) -> {[@expl:extern_spec_Clone_u128_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_usize_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_usize_default_body (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: UInt64.t) ] s1 | s1 = return {_0} ] ] [ & _0: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:extern_spec_Default_usize_default_body ensures] result = (0: UInt64.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_usize_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_usize_clone_body (self_: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l () | & self_: UInt64.t = self_ ])
    [ return (result: UInt64.t) -> {[@expl:extern_spec_Clone_usize_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i8_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i8_default_body (return (x: Int8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int8.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int8.t = Any.any_l () ])
    [ return (result: Int8.t) -> {[@expl:extern_spec_Default_i8_default_body ensures] result = (0: Int8.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i8_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i8_clone_body (self_: Int8.t) (return (x: Int8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int8.t = Any.any_l () | & self_: Int8.t = self_ ])
    [ return (result: Int8.t) -> {[@expl:extern_spec_Clone_i8_clone_body ensures] result = self_} (! return {result}) ]
end
module M_std__num__extern_spec_Default_i16_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i16_default_body (return (x: Int16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int16.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int16.t = Any.any_l () ])
    [ return (result: Int16.t) -> {[@expl:extern_spec_Default_i16_default_body ensures] result = (0: Int16.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i16_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i16_clone_body (self_: Int16.t) (return (x: Int16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int16.t = Any.any_l () | & self_: Int16.t = self_ ])
    [ return (result: Int16.t) -> {[@expl:extern_spec_Clone_i16_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i32_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i32_default_body (return (x: Int32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int32.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int32.t = Any.any_l () ])
    [ return (result: Int32.t) -> {[@expl:extern_spec_Default_i32_default_body ensures] result = (0: Int32.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i32_clone_body (self_: Int32.t) (return (x: Int32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int32.t = Any.any_l () | & self_: Int32.t = self_ ])
    [ return (result: Int32.t) -> {[@expl:extern_spec_Clone_i32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i64_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i64_default_body (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int64.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:extern_spec_Default_i64_default_body ensures] result = (0: Int64.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i64_clone_body (self_: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & self_: Int64.t = self_ ])
    [ return (result: Int64.t) -> {[@expl:extern_spec_Clone_i64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i128_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i128_default_body (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int128.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int128.t = Any.any_l () ])
    [ return (result: Int128.t) -> {[@expl:extern_spec_Default_i128_default_body ensures] result = (0: Int128.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i128_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i128_clone_body (self_: Int128.t) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int128.t = Any.any_l () | & self_: Int128.t = self_ ])
    [ return (result: Int128.t) -> {[@expl:extern_spec_Clone_i128_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_isize_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_isize_default_body (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- (0: Int64.t) ] s1 | s1 = return {_0} ] ] [ & _0: Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:extern_spec_Default_isize_default_body ensures] result = (0: Int64.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_isize_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_isize_clone_body (self_: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l () | & self_: Int64.t = self_ ])
    [ return (result: Int64.t) -> {[@expl:extern_spec_Clone_isize_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_option_T_Try_Option_T_from_output_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Try_Option_T_from_output_body_T (output: t_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body 'output' type invariant] inv_T output}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- Some output ] s1 | s1 = bb2 ] | bb2 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l () | & output: t_T = output ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body ensures] result = Some output}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_option_T_Try_Option_T_branch_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_Option_Infallible = None'0 | Some'0 ()
  
  type t_ControlFlow_Option_Infallible_T = Continue t_T | Break t_Option_Infallible
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_Infallible f0
        end
  
  predicate inv_ControlFlow_Option_Infallible_T (_1: t_ControlFlow_Option_Infallible_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_T [inv_ControlFlow_Option_Infallible_T x]. inv_ControlFlow_Option_Infallible_T x
      = match x with
        | Continue f0 -> inv_T f0
        | Break f0 -> inv_Option_Infallible f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Try_Option_T_branch_body_T (self_: t_Option_T)
    (return (x: t_ControlFlow_Option_Infallible_T)) =
    {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body 'self_' type invariant] inv_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &v <- r0 ] s1) | s1 = [ &_0 <- Continue v ] s2 | s2 = bb8 ]
    | bb3 = s0 [ s0 = [ &_6 <- None'0 ] s1 | s1 = [ &_0 <- Break _6 ] s2 | s2 = bb8 ]
    | bb8 = return {_0} ]
    [ & _0: t_ControlFlow_Option_Infallible_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & v: t_T = Any.any_l ()
    | & _6: t_Option_Infallible = Any.any_l () ])
    [ return (result: t_ControlFlow_Option_Infallible_T) ->
    {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body result type invariant] inv_ControlFlow_Option_Infallible_T result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body ensures] match self_ with
        | Some v -> result = Continue v
        | None -> result = Break (None'0)
        end}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Infallible = None'0 | Some'0 ()
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_Infallible f0
        end
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body_T
    (residual: t_Option_Infallible) (return (x: t_Option_T)) =
    {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body 'residual' type invariant] inv_Option_Infallible residual}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = return {_0} ] ] [ & _0: t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body ensures] result
      = None}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_result_T_E_Try_Result_T_E_from_output_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  predicate inv_T (_1: t_T)
  
  predicate inv_E (_1: t_E)
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_from_output_body_T (output: t_T) (return (x: t_Result_T_E)) =
    {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body 'output' type invariant] inv_T output}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- Ok output ] s1 | s1 = bb2 ] | bb2 = return {_0} ]
    [ & _0: t_Result_T_E = Any.any_l () | & output: t_T = output ])
    [ return (result: t_Result_T_E) ->
    {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body result type invariant] inv_Result_T_E result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body ensures] result = Ok output}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_result_T_E_Try_Result_T_E_branch_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  let rec elim_Err (input: t_Result_T_E) (ret (f0: t_E)) = any
    [ good (f0: t_E) -> {Err f0 = input} (! ret {f0})
    | bad -> {forall f0: t_E [Err f0: t_Result_T_E]. Err f0 <> input} (! {false} any) ]
  
  type t_Result_Infallible_E = Ok'0 () | Err'0 t_E
  
  type t_ControlFlow_Result_Infallible_E_T = Continue t_T | Break t_Result_Infallible_E
  
  let rec elim_Ok (input: t_Result_T_E) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Ok f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Ok f0: t_Result_T_E]. Ok f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_E (_1: t_E)
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Result_Infallible_E (_1: t_Result_Infallible_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_Infallible_E [inv_Result_Infallible_E x]. inv_Result_Infallible_E x
      = match x with
        | Ok'0 f0 -> inv_Infallible f0
        | Err'0 f0 -> inv_E f0
        end
  
  predicate inv_ControlFlow_Result_Infallible_E_T (_1: t_ControlFlow_Result_Infallible_E_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_ControlFlow_Result_Infallible_E_T [inv_ControlFlow_Result_Infallible_E_T x]. inv_ControlFlow_Result_Infallible_E_T x
      = match x with
        | Continue f0 -> inv_T f0
        | Break f0 -> inv_Result_Infallible_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_branch_body_T (self_: t_Result_T_E)
    (return (x: t_ControlFlow_Result_Infallible_E_T)) =
    {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body 'self_' type invariant] inv_Result_T_E self_}
    (! bb0
    [ bb0 = any [ br0 (x0: t_T) -> {self_ = Ok x0} (! bb4) | br1 (x0: t_E) -> {self_ = Err x0} (! bb3) ]
    | bb3 = s0 [ s0 = elim_Err {self_} (fun (r0: t_E) -> [ &e <- r0 ] s1) | s1 = [ &_7 <- Err'0 e ] s2 | s2 = bb7 ]
    | bb7 = s0 [ s0 = [ &_0 <- Break _7 ] s1 | s1 = bb11 ]
    | bb4 = s0 [ s0 = elim_Ok {self_} (fun (r0: t_T) -> [ &v <- r0 ] s1) | s1 = [ &_0 <- Continue v ] s2 | s2 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_ControlFlow_Result_Infallible_E_T = Any.any_l ()
    | & self_: t_Result_T_E = self_
    | & v: t_T = Any.any_l ()
    | & e: t_E = Any.any_l ()
    | & _7: t_Result_Infallible_E = Any.any_l () ])
    [ return (result: t_ControlFlow_Result_Infallible_E_T) ->
    {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body result type invariant] inv_ControlFlow_Result_Infallible_E_T result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body ensures] match self_ with
        | Ok v -> result = Continue v
        | Err e -> result = Break (Err'0 e)
        end}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_E
  
  type t_Result_Infallible_E = Ok () | Err t_E
  
  let rec elim_Err (input: t_Result_Infallible_E) (ret (f0: t_E)) = any
    [ good (f0: t_E) -> {Err f0 = input} (! ret {f0})
    | bad -> {forall f0: t_E [Err f0: t_Result_Infallible_E]. Err f0 <> input} (! {false} any) ]
  
  type t_F
  
  predicate inv_E (_1: t_E)
  
  predicate precondition_from (self: ()) (args: t_E)
  
  axiom precondition_fndef: forall args: t_E [precondition_from () args]. (let value = args in inv_E value)
      -> precondition_from () args
  
  predicate inv_F (_1: t_F)
  
  predicate postcondition_once_from (self: ()) (args: t_E) (result: t_F)
  
  axiom postcondition_fndef:
    forall args: t_E, res: t_F [postcondition_once_from () args res]. postcondition_once_from () args res
      -> (let value = args in inv_F res)
  
  let rec from_F (value: t_E) (return (x: t_F)) = {[@expl:from requires] precondition_from () value}
    any [ return (result: t_F) -> {postcondition_once_from () value result} (! return {result}) ]
  
  type t_T
  
  type t_Result_T_F = Ok'0 t_T | Err'0 t_F
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Result_Infallible_E (_1: t_Result_Infallible_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_Infallible_E [inv_Result_Infallible_E x]. inv_Result_Infallible_E x
      = match x with
        | Ok f0 -> inv_Infallible f0
        | Err f0 -> inv_E f0
        end
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Result_T_F (_1: t_Result_T_F)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_T_F [inv_Result_T_F x]. inv_Result_T_F x
      = match x with
        | Ok'0 f0 -> inv_T f0
        | Err'0 f0 -> inv_F f0
        end
  
  type tup2_Result_T_F_Result_Infallible_E = { f0: t_Result_T_F; f1: t_Result_Infallible_E }
  
  predicate resolve_from [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_from
  
  predicate postcondition_mut_from (self: ()) (args: t_E) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_E, res: t_F [postcondition_mut_from () args () res]. postcondition_mut_from () args () res
      -> (let value = args in inv_F res)
  
  function fn_mut_once_from (self: ()) (args: t_E) (res: t_F) : () = ()
  
  axiom fn_mut_once_from_spec: forall self: (), args: t_E, res: t_F. postcondition_once_from self args res
      = (exists res_state: (). postcondition_mut_from self args res_state res /\ resolve_from res_state)
  
  predicate hist_inv_from [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_from
  
  function hist_inv_trans_from (self: ()) (b: ()) (c: ()) : () = ()
  
  axiom hist_inv_trans_from_spec: forall self: (), b: (), c: (). hist_inv_from self b
      -> hist_inv_from b c -> hist_inv_from self c
  
  function hist_inv_refl_from (self: ()) : () = ()
  
  axiom hist_inv_refl_from_spec: forall self: (). hist_inv_from self self
  
  function postcondition_mut_hist_inv_from (self: ()) (args: t_E) (res_state: ()) (res: t_F) : () = ()
  
  axiom postcondition_mut_hist_inv_from_spec:
    forall self: (), args: t_E, res_state: (), res: t_F. postcondition_mut_from self args res_state res
      -> hist_inv_from self res_state
  
  function fn_hist_inv_from (self: ()) (res_state: ()) : () = ()
  
  axiom fn_hist_inv_from_spec: forall self: (), res_state: (). hist_inv_from self res_state = (self = res_state)
  
  predicate postcondition_from (self: ()) (args: t_E) (result: t_F)
  
  axiom postcondition_fndef'1:
    forall args: t_E, res: t_F [postcondition_from () args res]. postcondition_from () args res
      -> (let value = args in inv_F res)
  
  function fn_once_from (self: ()) (args: t_E) (res: t_F) : () = ()
  
  axiom fn_once_from_spec: forall self: (), args: t_E, res: t_F. postcondition_once_from self args res
      = (postcondition_from self args res /\ resolve_from self)
  
  function fn_mut_from (self: ()) (args: t_E) (res_state: ()) (res: t_F) : () = ()
  
  axiom fn_mut_from_spec:
    forall self: (), args: t_E, res_state: (), res: t_F. postcondition_mut_from self args res_state res
      = (postcondition_from self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body_T
    (residual: t_Result_Infallible_E) (return (x: t_Result_T_F)) =
    {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body 'residual' type invariant] inv_Result_Infallible_E residual}
    (! bb0
    [ bb0 = s0
      [ s0 = elim_Err {residual} (fun (r0: t_E) -> [ &e <- r0 ] s1)
      | s1 = from_F {e} (fun (_ret: t_F) -> [ &_4 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- Err'0 _4 ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_Result_T_F = Any.any_l ()
    | & residual: t_Result_Infallible_E = residual
    | & e: t_E = Any.any_l ()
    | & _4: t_F = Any.any_l () ])
    [ return (result: t_Result_T_F) ->
    {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body result type invariant] inv_Result_T_F result}
      {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body ensures] match { f0 = result;
                                                                                                                            f1 = residual } with
        | {f0 = Err'0 result'0; f1 = Err residual'0} -> postcondition_from () residual'0 result'0
        | _ -> false
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_T_PartialEq_Option_T_eq_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type tup2_ref_Option_T_ref_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  let rec elim_Some (input: t_Option_T) (ret (f0'0: t_T)) = any
    [ good (f0'0: t_T) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_T [Some f0'0: t_Option_T]. Some f0'0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_ref_ref_T [@inline:trivial] (self: t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_T
  
  predicate inv_ref_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_T
  
  type t_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  function deep_model_ref_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_ref_T self
  
  meta "rewrite_def" function deep_model_ref_ref_T
  
  let rec eq_ref_T (self_: t_T) (rhs: t_T) (return (x: bool)) = {[@expl:eq 'self_' type invariant] inv_ref_ref_T self_}
    {[@expl:eq 'rhs' type invariant] inv_ref_ref_T rhs}
    any
    [ return (result: bool) -> {result = (deep_model_ref_ref_T self_ = deep_model_ref_ref_T rhs)} (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0'0 -> inv_T f0'0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  type t_Option_DeepModelTy = None'0 | Some'0 t_DeepModelTy
  
  function deep_model_Option_T [@inline:trivial] (self: t_Option_T) : t_Option_DeepModelTy = match self with
      | Some t -> Some'0 (deep_model_T t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_T
  
  function deep_model_ref_Option_T [@inline:trivial] (self: t_Option_T) : t_Option_DeepModelTy =
    deep_model_Option_T self
  
  meta "rewrite_def" function deep_model_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_PartialEq_Option_T_eq_body_T (self_: t_Option_T) (rhs: t_Option_T) (return (x: bool)) =
    {[@expl:extern_spec_T_PartialEq_Option_T_eq_body 'self_' type invariant] inv_ref_Option_T self_}
    {[@expl:extern_spec_T_PartialEq_Option_T_eq_body 'rhs' type invariant] inv_ref_Option_T rhs}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- { f0 = self_; f1 = rhs } ] s1
      | s1 = any [ br0 -> {_4.f0 = None} (! bb2) | br1 (x0: t_T) -> {_4.f0 = Some x0} (! bb4) ] ]
    | bb4 = any [ br0 -> {_4.f1 = None} (! bb1) | br1 (x0: t_T) -> {_4.f1 = Some x0} (! bb6) ]
    | bb6 = s0
      [ s0 = elim_Some {_4.f0} (fun (r0: t_T) -> [ &x <- r0 ] s1)
      | s1 = elim_Some {_4.f1} (fun (r0: t_T) -> [ &y <- r0 ] s2)
      | s2 = eq_ref_T {x} {y} (fun (_ret: bool) -> [ &_0 <- _ret ] s3)
      | s3 = bb9 ]
    | bb2 = any [ br0 -> {_4.f1 = None} (! bb7) | br1 (x0: t_T) -> {_4.f1 = Some x0} (! bb1) ]
    | bb1 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb9 ]
    | bb7 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: t_Option_T = self_
    | & rhs: t_Option_T = rhs
    | & _4: tup2_ref_Option_T_ref_Option_T = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & y: t_T = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T_PartialEq_Option_T_eq_body ensures] result
      = (deep_model_ref_Option_T self_ = deep_model_ref_Option_T rhs)}
      (! return {result}) ]
end
module M_std__option__extern_spec_T_Clone_Option_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate precondition_clone (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_clone () args]. (let self_ = args in inv_ref_T self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  let rec clone_T (self_: t_T) (return (x: t_T)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_T) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone_Option_T_clone_body_T (self_: t_Option_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_T_Clone_Option_T_clone_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &x <- r0 ] s1)
      | s1 = clone_T {x} (fun (_ret: t_T) -> [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- Some _5 ] s1 | s1 = bb7 ]
    | bb4 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & x: t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_T_Clone_Option_T_clone_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_T_Clone_Option_T_clone_body ensures] match { f0 = self_; f1 = result } with
        | {f0 = None; f1 = None} -> true
        | {f0 = Some s; f1 = Some r} -> postcondition_clone () s r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_is_some_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_some_body_T (self_: t_Option_T) (return (x: bool)) =
    {[@expl:extern_spec_std_option_T_Option_T_is_some_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb5 ]
    | bb3 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ] [ & _0: bool = Any.any_l () | & self_: t_Option_T = self_ ])
    [ return (result: bool) -> {[@expl:extern_spec_std_option_T_Option_T_is_some_body ensures] result = (self_ <> None)}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_is_some_and_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct
  
  predicate inv_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct (_1: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct (self: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct) (args: t_T)
  
  predicate postcondition_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct (self: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct) (args: t_T) (result: bool)
  
  let rec call_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct
    (self_: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct) (arg: t_T) (return (x: bool)) =
    {[@expl:call_once 'self_' type invariant] inv_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct self_}
    {[@expl:call_once 'arg' type invariant] inv_tup1_T arg}
    {[@expl:call_once requires] precondition_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct self_ arg}
    any
    [ return (result: bool) ->
    {postcondition_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct self_ arg result}
      (! return {result}) ]
  
  predicate resolve_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct (_1: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_some_and_body_T (self_: t_Option_T)
    (f: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct) (return (x: bool)) =
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'f' type invariant] inv_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body requires] match self_ with
      | None -> true
      | Some t -> precondition_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_9 <- t ] s2
      | s2 = call_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct {f} {_9}
          (fun (_ret: bool) -> [ &_0 <- _ret ] s3)
      | s3 = bb11 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f} s1
      | s1 = -{resolve_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f}- s2
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct = f
    | & t: t_T = Any.any_l ()
    | & _9: t_T = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body ensures] match self_ with
        | None -> result = false
        | Some t -> postcondition_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f t result
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_is_none_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  let rec is_some_T (self_: t_Option_T) (return (x: bool)) =
    {[@expl:is_some 'self_' type invariant] inv_ref_Option_T self_}
    any [ return (result: bool) -> {result = (self_ <> None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_none_body_T (self_: t_Option_T) (return (x: bool)) =
    {[@expl:extern_spec_std_option_T_Option_T_is_none_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = s0 [ s0 = is_some_T {self_} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- not _4 ] s1 | s1 = return {_0} ] ]
    [ & _0: bool = Any.any_l () | & self_: t_Option_T = self_ | & _4: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_std_option_T_Option_T_is_none_body ensures] result = (self_ = None)}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_as_ref_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_Option_ref_T = None'0 | Some'0 t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_ref_body_T (self_: t_Option_T) (return (x: t_Option_ref_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_as_ref_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- Some'0 t ] s2 | s2 = bb5 ]
    | bb3 = s0 [ s0 = [ &_0 <- None'0 ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: t_Option_ref_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_ref_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_as_ref_body result type invariant] inv_Option_ref_T result}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #0] self_ = None -> result = None'0}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #1] self_ = None
      \/ (exists r: t_T. result = Some'0 r /\ self_ = Some r)}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_as_mut_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  type t_Option_ref_T = None'0 | Some'0 (MutBorrow.t t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  predicate resolve_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_mut_body_T (self_: MutBorrow.t t_Option_T) (return (x: t_Option_ref_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_as_mut_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb3) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            {inv_T r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &t <- _ret ] -{inv_T _ret.final}-
                [ &self_ <- { self_ with current = Some _ret.final } ] s1))
      | s1 = {inv_T t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_7 <- _ret ] -{inv_T _ret.final}-
            [ &t <- { t with current = _ret.final } ] s2)
      | s2 = [ &_0 <- Some'0 _7 ] s3
      | s3 = {[@expl:type invariant] inv_ref_T t} s4
      | s4 = -{resolve_ref_T t}- s5
      | s5 = bb5 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1
      | s1 = -{resolve_ref_Option_T self_}- s2
      | s2 = [ &_0 <- None'0 ] s3
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1
      | s1 = -{resolve_ref_Option_T self_}- s2
      | s2 = return {_0} ] ]
    [ & _0: t_Option_ref_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _7: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_Option_ref_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_as_mut_body result type invariant] inv_Option_ref_T result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #0] self_.current = None
      -> result = None'0 /\ self_.final = None}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #1] self_.current = None
      \/ (exists r: MutBorrow.t t_T. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_as_slice_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  let rec from_ref_T (s: t_T) (return (x: Slice64.slice t_T)) = {[@expl:from_ref 's' type invariant] inv_ref_T s}
    any
    [ return (result: Slice64.slice t_T) -> {inv_ref_slice_T result}
      {Seq.length (Slice64.view result) = 1}
      {Seq.get (Slice64.view result) 0 = s}
      (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_slice_body_T (self_: t_Option_T) (return (x: Slice64.slice t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_as_slice_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = from_ref_T {t} (fun (_ret: Slice64.slice t_T) -> [ &_9 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_3 <- _9 ] s1 | s1 = bb6 ]
    | bb4 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array t_T) -> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array t_T = Any.any_l () | & _1: Slice64.array t_T = Any.any_l () ]
        [ _const_ret (_const: Slice64.array t_T) -> [ &_11 <- _const ] s1 ]
      | s1 = [ &_6 <- _11 ] s2
      | s2 = [ &_3 <- _6 ] s3
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = [ &_0 <- _3 ] s1 | s1 = return {_0} ] ]
    [ & _0: Slice64.slice t_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & _3: Slice64.slice t_T = Any.any_l ()
    | & _6: Slice64.array t_T = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _9: Slice64.slice t_T = Any.any_l ()
    | & _11: Slice64.array t_T = Any.any_l () ])
    [ return (result: Slice64.slice t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_as_slice_body result type invariant] inv_ref_slice_T result}
      {[@expl:extern_spec_std_option_T_Option_T_as_slice_body ensures] match self_ with
        | None -> Seq.length (Slice64.view result) = 0
        | Some t -> Seq.length (Slice64.view result) = 1 /\ Seq.get (Slice64.view result) 0 = t
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_as_mut_slice_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv_slice_T self.current /\ inv_slice_T self.final
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  let rec from_mut_T (s: MutBorrow.t t_T) (return (x: MutBorrow.t (Slice64.slice t_T))) =
    {[@expl:from_mut 's' type invariant] inv_ref_T s}
    any
    [ return (result: MutBorrow.t (Slice64.slice t_T)) -> {inv_ref_slice_T result}
      {Seq.length (Slice64.view result.current) = 1}
      {Seq.get (Slice64.view result.current) 0 = s.current}
      {Seq.length (Slice64.view result.final) = 1}
      {Seq.get (Slice64.view result.final) 0 = s.final}
      (! return {result}) ]
  
  predicate resolve_ref_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_slice_T
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  predicate resolve_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_T
  
  predicate invariant_array_T_0 (self: Slice64.array t_T) =
    inv_Seq_T (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (0: UInt64.t)
  
  predicate inv_array_T_0 [@inline:trivial] (_1: Slice64.array t_T) = invariant_array_T_0 _1
  
  meta "rewrite_def" predicate inv_array_T_0
  
  predicate invariant_ref_array_T_0 [@inline:trivial] (self: MutBorrow.t (Slice64.array t_T)) =
    inv_array_T_0 self.current /\ inv_array_T_0 self.final
  
  meta "rewrite_def" predicate invariant_ref_array_T_0
  
  predicate inv_ref_array_T_0 [@inline:trivial] (_1: MutBorrow.t (Slice64.array t_T)) = invariant_ref_array_T_0 _1
  
  meta "rewrite_def" predicate inv_ref_array_T_0
  
  predicate resolve_ref_array_T_0 [@inline:trivial] (_1: MutBorrow.t (Slice64.array t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_array_T_0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_mut_slice_body_T (self_: MutBorrow.t t_Option_T)
    (return (x: MutBorrow.t (Slice64.slice t_T))) =
    {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb2) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            {inv_T r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &t <- _ret ] -{inv_T _ret.final}-
                [ &self_ <- { self_ with current = Some _ret.final } ] s1))
      | s1 = {inv_T t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_11 <- _ret ] -{inv_T _ret.final}-
            [ &t <- { t with current = _ret.final } ] s2)
      | s2 = from_mut_T {_11} (fun (_ret: MutBorrow.t (Slice64.slice t_T)) -> [ &_10 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = {inv_slice_T _10.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_4 <- _ret ] -{inv_slice_T _ret.final}-
            [ &_10 <- { _10 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_slice_T _10} s2
      | s2 = -{resolve_ref_slice_T _10}- s3
      | s3 = {[@expl:type invariant] inv_ref_T t} s4
      | s4 = -{resolve_ref_T t}- s5
      | s5 = bb6 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1 | s1 = -{resolve_ref_Option_T self_}- s2 | s2 = bb4 ]
    | bb4 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array t_T) -> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = {inv_array_T_0 _1}
            MutBorrow.borrow_mut <Slice64.array t_T> {_1}
              (fun (_ret: MutBorrow.t (Slice64.array t_T)) ->
                [ &_0'0 <- _ret ] -{inv_array_T_0 _ret.final}-
                [ &_1 <- _ret.final ] s2'0)
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: MutBorrow.t (Slice64.array t_T) = Any.any_l () | & _1: Slice64.array t_T = Any.any_l () ]
        [ _const_ret (_const: MutBorrow.t (Slice64.array t_T)) -> [ &_12 <- _const ] s1 ]
      | s1 = {inv_array_T_0 _12.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t (Slice64.array t_T)) ->
            [ &_7 <- _ret ] -{inv_array_T_0 _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = {inv_array_T_0 _7.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_7.current} {MutBorrow.get_id _7}
          (fun (_ret: MutBorrow.t (Slice64.array t_T)) ->
            [ &_6 <- _ret ] -{inv_array_T_0 _ret.final}-
            [ &_7 <- { _7 with current = _ret.final } ] s3)
      | s3 = [ &_4 <- _6 ] s4
      | s4 = {[@expl:type invariant] inv_ref_array_T_0 _7} s5
      | s5 = -{resolve_ref_array_T_0 _7}- s6
      | s6 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_ref_array_T_0 _12} s1 | s1 = -{resolve_ref_array_T_0 _12}- s2 | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {inv_slice_T _4.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_4.current} {MutBorrow.get_id _4}
          (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_2 <- _ret ] -{inv_slice_T _ret.final}-
            [ &_4 <- { _4 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_slice_T _4} s2
      | s2 = -{resolve_ref_slice_T _4}- s3
      | s3 = {inv_slice_T _2.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_0 <- _ret ] -{inv_slice_T _ret.final}-
            [ &_2 <- { _2 with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv_ref_slice_T _2} s5
      | s5 = -{resolve_ref_slice_T _2}- s6
      | s6 = {[@expl:type invariant] inv_ref_Option_T self_} s7
      | s7 = -{resolve_ref_Option_T self_}- s8
      | s8 = return {_0} ] ]
    [ & _0: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & _2: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _4: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _6: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & _7: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _11: MutBorrow.t t_T = Any.any_l ()
    | & _12: MutBorrow.t (Slice64.array t_T) = Any.any_l () ])
    [ return (result: MutBorrow.t (Slice64.slice t_T)) ->
    {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body result type invariant] inv_ref_slice_T result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body ensures] match self_.current with
        | None -> Seq.length (Slice64.view result.current) = 0
        | Some _ -> exists b: MutBorrow.t t_T. self_.current = Some (b.current)
          /\ self_.final = Some (b.final)
          /\ Seq.get (Slice64.view result.current) 0 = b.current
          /\ Seq.get (Slice64.view result.final) 0 = b.final
          /\ Seq.length (Slice64.view result.current) = 1 /\ Seq.length (Slice64.view result.final) = 1
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_expect_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_expect_body_T (self_: t_Option_T) (msg: string) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_expect_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_expect_body requires] self_ <> None}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb6 ]
    | bb6 = return {_0}
    | bb4 = {false} any ] [ & _0: t_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_option_T_Option_T_expect_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_option_T_Option_T_expect_body ensures] Some result = self_}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_unwrap_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_body_T (self_: t_Option_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_body requires] self_ <> None}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb6 ]
    | bb6 = return {_0}
    | bb4 = {false} any ] [ & _0: t_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:extern_spec_std_option_T_Option_T_unwrap_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_body ensures] Some result = self_}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_unwrap_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_body_T (self_: t_Option_T) (default: t_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'default' type invariant] inv_T default}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv_T default} s1 | s1 = -{resolve_T default}- s2 | s2 = bb5 ]
    | bb5 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb9 ]
    | bb4 = s0 [ s0 = [ &_0 <- default ] s1 | s1 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: t_T = Any.any_l () | & self_: t_Option_T = self_ | & default: t_T = default | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #0] self_ = None -> result = default}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #1] self_ = None
      \/ self_ = Some result /\ resolve_T default}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_F (_1: t_F)
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate precondition_F (self: t_F) (args: ())
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_F (self: t_F) (args: ()) (result: t_T)
  
  let rec call_once_F (self_: t_F) (arg: ()) (return (x: t_T)) = {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once requires] precondition_F self_ arg}
    any [ return (result: t_T) -> {inv_T result} {postcondition_once_F self_ arg result} (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body_T (self_: t_Option_T) (f: t_F) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'f' type invariant] inv_F f}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body requires] self_ = None -> precondition_F f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv_F f} s1 | s1 = -{resolve_F f}- s2 | s2 = bb5 ]
    | bb5 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb10 ]
    | bb4 = s0 [ s0 = call_once_F {f} {_9} (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _9: () = Any.any_l () ])
    [ return (result: t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body ensures] match self_ with
        | None -> postcondition_once_F f () result
        | Some t -> result = t
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_unwrap_or_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate precondition_default (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition_default () args]. (let () = args in true)
      -> precondition_default () args
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once_default () args res]. postcondition_once_default () args res
      -> (let () = args in inv_T res)
  
  let rec default_T (return (x: t_T)) = {[@expl:default requires] precondition_default () ()}
    any [ return (result: t_T) -> {postcondition_once_default () () result} (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut_default () args () res]. postcondition_mut_default () args () res
      -> (let () = args in inv_T res)
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: (), res: t_T [postcondition_default () args res]. postcondition_default () args res
      -> (let () = args in inv_T res)
  
  function fn_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_default_body_T (self_: t_Option_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body 'self_' type invariant] inv_Option_T self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb5) ]
    | bb5 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb8 ]
    | bb4 = s0 [ s0 = default_T (fun (_ret: t_T) -> [ &_0 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = return {_0} ] [ & _0: t_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #0] self_ = None
      -> postcondition_default () () result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #1] self_ = None \/ self_ = Some result}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_unwrap_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_unchecked_body_T (self_: t_Option_T) (return (x: t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body requires] self_ <> None}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- t ] s2 | s2 = bb6 ]
    | bb6 = return {_0}
    | bb4 = {false} any ] [ & _0: t_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body result type invariant] inv_T result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body ensures] Some result = self_}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_map_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_F
  
  type t_U
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate inv_U (_1: t_U)
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: t_U)) = {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once 'arg' type invariant] inv_tup1_T arg}
    {[@expl:call_once requires] precondition_F self_ arg}
    any [ return (result: t_U) -> {inv_U result} {postcondition_once_F self_ arg result} (! return {result}) ]
  
  type t_Option_U = None'0 | Some'0 t_U
  
  predicate resolve_F (_1: t_F)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_U f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_body_T (self_: t_Option_T) (f: t_F) (return (x: t_Option_U)) =
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'f' type invariant] inv_F f}
    {[@expl:extern_spec_std_option_T_Option_T_map_body requires] match self_ with
      | None -> true
      | Some t -> precondition_F f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb5) ]
    | bb5 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_10 <- t ] s2
      | s2 = call_once_F {f} {_10} (fun (_ret: t_U) -> [ &_8 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = [ &_0 <- Some'0 _8 ] s1 | s1 = bb12 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv_F f} s1 | s1 = -{resolve_F f}- s2 | s2 = [ &_0 <- None'0 ] s3 | s3 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: t_Option_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: t_U = Any.any_l ()
    | & _10: t_T = Any.any_l () ])
    [ return (result: t_Option_U) ->
    {[@expl:extern_spec_std_option_T_Option_T_map_body result type invariant] inv_Option_U result}
      {[@expl:extern_spec_std_option_T_Option_T_map_body ensures] match self_ with
        | None -> result = None'0
        | Some t -> exists r: t_U. result = Some'0 r /\ postcondition_once_F f t r
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_inspect_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_tup1_ref_T [@inline:trivial] (_1: t_T) = inv_ref_T _1
  
  meta "rewrite_def" predicate inv_tup1_ref_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: ())
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: ())) = {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once 'arg' type invariant] inv_tup1_ref_T arg}
    {[@expl:call_once requires] precondition_F self_ arg}
    any [ return (result: ()) -> {postcondition_once_F self_ arg result} (! return {result}) ]
  
  predicate resolve_F (_1: t_F)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_inspect_body_T (self_: t_Option_T) (f: t_F) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'f' type invariant] inv_F f}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body requires] match self_ with
      | None -> true
      | Some t -> precondition_F f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_12 <- t ] s2
      | s2 = [ &_10 <- _12 ] s3
      | s3 = call_once_F {f} {_10} (fun (_ret: ()) -> [ &_8 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- Some t ] s1 | s1 = bb10 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv_F f} s1 | s1 = -{resolve_F f}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _10: t_T = Any.any_l ()
    | & _12: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #0] result = self_}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #1] match self_ with
        | None -> true
        | Some t -> postcondition_once_F f t ()
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_map_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_U
  
  predicate inv_U (_1: t_U)
  
  predicate resolve_U (_1: t_U)
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: t_U)) = {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once 'arg' type invariant] inv_tup1_T arg}
    {[@expl:call_once requires] precondition_F self_ arg}
    any [ return (result: t_U) -> {inv_U result} {postcondition_once_F self_ arg result} (! return {result}) ]
  
  predicate resolve_F (_1: t_F)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_or_body_T (self_: t_Option_T) (default: t_U) (f: t_F)
    (return (x: t_U)) =
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'default' type invariant] inv_U default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'f' type invariant] inv_F f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body requires] match self_ with
      | None -> true
      | Some t -> precondition_F f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_U default} s1
      | s1 = -{resolve_U default}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_9 <- t ] s4
      | s4 = call_once_F {f} {_9} (fun (_ret: t_U) -> [ &_0 <- _ret ] s5)
      | s5 = bb11 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv_F f} s1 | s1 = -{resolve_F f}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- default ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & default: t_U = default
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _9: t_T = Any.any_l () ])
    [ return (result: t_U) -> {[@expl:extern_spec_std_option_T_Option_T_map_or_body result type invariant] inv_U result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_body ensures] match self_ with
        | None -> result = default
        | Some t -> postcondition_once_F f t result
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_map_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_D
  
  predicate inv_D (_1: t_D)
  
  predicate resolve_D (_1: t_D)
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_F
  
  type t_U
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate inv_U (_1: t_U)
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: t_U)) = {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once 'arg' type invariant] inv_tup1_T arg}
    {[@expl:call_once requires] precondition_F self_ arg}
    any [ return (result: t_U) -> {inv_U result} {postcondition_once_F self_ arg result} (! return {result}) ]
  
  predicate resolve_F (_1: t_F)
  
  predicate precondition_D (self: t_D) (args: ())
  
  predicate postcondition_once_D (self: t_D) (args: ()) (result: t_U)
  
  let rec call_once_D (self_: t_D) (arg: ()) (return (x: t_U)) = {[@expl:call_once 'self_' type invariant] inv_D self_}
    {[@expl:call_once requires] precondition_D self_ arg}
    any [ return (result: t_U) -> {inv_U result} {postcondition_once_D self_ arg result} (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body_T (self_: t_Option_T) (default: t_D) (f: t_F)
    (return (x: t_U)) =
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'default' type invariant] inv_D default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'f' type invariant] inv_F f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body requires] match self_ with
      | None -> precondition_D default ()
      | Some t -> precondition_F f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_D default} s1
      | s1 = -{resolve_D default}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_11 <- t ] s4
      | s4 = call_once_F {f} {_11} (fun (_ret: t_U) -> [ &_0 <- _ret ] s5)
      | s5 = bb12 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv_F f} s1 | s1 = -{resolve_F f}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = call_once_D {default} {_8} (fun (_ret: t_U) -> [ &_0 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: t_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & default: t_D = default
    | & f: t_F = f
    | & _8: () = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _11: t_T = Any.any_l () ])
    [ return (result: t_U) ->
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body result type invariant] inv_U result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body ensures] match self_ with
        | None -> postcondition_once_D default () result
        | Some t -> postcondition_once_F f t result
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_ok_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_E
  
  predicate inv_E (_1: t_E)
  
  predicate resolve_E (_1: t_E)
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_ok_or_body_T (self_: t_Option_T) (err: t_E) (return (x: t_Result_T_E)) =
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'err' type invariant] inv_E err}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_E err} s1
      | s1 = -{resolve_E err}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_0 <- Ok t ] s4
      | s4 = bb10 ]
    | bb4 = s0 [ s0 = [ &_0 <- Err err ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Result_T_E = Any.any_l () | & self_: t_Option_T = self_ | & err: t_E = err | & t: t_T = Any.any_l () ])
    [ return (result: t_Result_T_E) ->
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body result type invariant] inv_Result_T_E result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_body ensures] match self_ with
        | None -> result = Err err
        | Some t -> result = Ok t /\ resolve_E err
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_ok_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_F (_1: t_F)
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  predicate precondition_F (self: t_F) (args: ())
  
  predicate inv_E (_1: t_E)
  
  predicate postcondition_once_F (self: t_F) (args: ()) (result: t_E)
  
  let rec call_once_F (self_: t_F) (arg: ()) (return (x: t_E)) = {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once requires] precondition_F self_ arg}
    any [ return (result: t_E) -> {inv_E result} {postcondition_once_F self_ arg result} (! return {result}) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body_T (self_: t_Option_T) (err: t_F)
    (return (x: t_Result_T_E)) =
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'err' type invariant] inv_F err}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body requires] self_ = None -> precondition_F err ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_F err} s1
      | s1 = -{resolve_F err}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_0 <- Ok t ] s4
      | s4 = bb11 ]
    | bb4 = s0 [ s0 = call_once_F {err} {_8} (fun (_ret: t_E) -> [ &_6 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- Err _6 ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: t_Result_T_E = Any.any_l ()
    | & self_: t_Option_T = self_
    | & err: t_F = err
    | & _6: t_E = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Result_T_E) ->
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body result type invariant] inv_Result_T_E result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body ensures] match self_ with
        | None -> exists r: t_E. result = Err r /\ postcondition_once_F err () r
        | Some t -> result = Ok t
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_and_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  type t_U
  
  type t_Option_U = None'0 | Some'0 t_U
  
  predicate inv_U (_1: t_U)
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_U f0
        end
  
  predicate resolve_U (_1: t_U)
  
  predicate resolve_Option_U (_1: t_Option_U)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Option_U [resolve_Option_U x]. resolve_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_U x0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_and_body_T (self_: t_Option_T) (optb: t_Option_U) (return (x: t_Option_U)) =
    {[@expl:extern_spec_std_option_T_Option_T_and_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_body 'optb' type invariant] inv_Option_U optb}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_Option_T self_} s1
      | s1 = -{resolve_Option_T self_}- s2
      | s2 = [ &_0 <- optb ] s3
      | s3 = bb7 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_Option_U optb} s1
      | s1 = -{resolve_Option_U optb}- s2
      | s2 = {[@expl:type invariant] inv_Option_T self_} s3
      | s3 = -{resolve_Option_T self_}- s4
      | s4 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- None'0 ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ] [ & _0: t_Option_U = Any.any_l () | & self_: t_Option_T = self_ | & optb: t_Option_U = optb ])
    [ return (result: t_Option_U) ->
    {[@expl:extern_spec_std_option_T_Option_T_and_body result type invariant] inv_Option_U result}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #0] self_ = None
      -> result = None'0 /\ resolve_Option_U optb}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #1] self_ = None
      \/ result = optb /\ resolve_Option_T self_}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_and_then_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_F
  
  type t_U
  
  type t_Option_U = None'0 | Some'0 t_U
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate inv_U (_1: t_U)
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_U f0
        end
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: t_Option_U)
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: t_Option_U)) =
    {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once 'arg' type invariant] inv_tup1_T arg}
    {[@expl:call_once requires] precondition_F self_ arg}
    any
    [ return (result: t_Option_U) -> {inv_Option_U result} {postcondition_once_F self_ arg result} (! return {result}) ]
  
  predicate resolve_F (_1: t_F)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_and_then_body_T (self_: t_Option_T) (f: t_F) (return (x: t_Option_U)) =
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'f' type invariant] inv_F f}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body requires] match self_ with
      | None -> true
      | Some t -> precondition_F f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_8 <- t ] s2
      | s2 = call_once_F {f} {_8} (fun (_ret: t_Option_U) -> [ &_0 <- _ret ] s3)
      | s3 = bb10 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv_F f} s1 | s1 = -{resolve_F f}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- None'0 ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Option_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: t_T = Any.any_l () ])
    [ return (result: t_Option_U) ->
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body result type invariant] inv_Option_U result}
      {[@expl:extern_spec_std_option_T_Option_T_and_then_body ensures] match self_ with
        | None -> result = None'0
        | Some t -> postcondition_once_F f t result
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_filter_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  type t_P
  
  predicate inv_P (_1: t_P)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_tup1_ref_T [@inline:trivial] (_1: t_T) = inv_ref_T _1
  
  meta "rewrite_def" predicate inv_tup1_ref_T
  
  predicate precondition_P (self: t_P) (args: t_T)
  
  predicate postcondition_once_P (self: t_P) (args: t_T) (result: bool)
  
  let rec call_once_P (self_: t_P) (arg: t_T) (return (x: bool)) =
    {[@expl:call_once 'self_' type invariant] inv_P self_}
    {[@expl:call_once 'arg' type invariant] inv_tup1_ref_T arg}
    {[@expl:call_once requires] precondition_P self_ arg}
    any [ return (result: bool) -> {postcondition_once_P self_ arg result} (! return {result}) ]
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_P (_1: t_P)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_filter_body_T (self_: t_Option_T) (predicate': t_P)
    (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'predicate' type invariant] inv_P predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body requires] match self_ with
      | None -> true
      | Some t -> precondition_P predicate' t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_11 <- t ] s2
      | s2 = [ &_9 <- _11 ] s3
      | s3 = call_once_P {predicate'} {_9} (fun (_ret: bool) -> [ &_7 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb6) ]
    | bb6 = s0 [ s0 = [ &_0 <- Some t ] s1 | s1 = bb14 ]
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv_T t} s1 | s1 = -{resolve_T t}- s2 | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = bb14 ]
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv_P predicate'} s1 | s1 = -{resolve_P predicate'}- s2 | s2 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = bb14 ]
    | bb14 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & predicate': t_P = predicate'
    | & t: t_T = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_T = Any.any_l ()
    | & _11: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_filter_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_T_filter_body ensures] match self_ with
        | None -> result = None
        | Some t -> match result with
          | None -> postcondition_once_P predicate' t false /\ resolve_T t
          | Some r -> postcondition_once_P predicate' t true /\ r = t
          end
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_or_body_T (self_: t_Option_T) (optb: t_Option_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_or_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_body 'optb' type invariant] inv_Option_T optb}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_Option_T optb} s1
      | s1 = -{resolve_Option_T optb}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_0 <- Some t ] s4
      | s4 = bb9 ]
    | bb4 = s0 [ s0 = [ &_0 <- optb ] s1 | s1 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & optb: t_Option_T = optb
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_or_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #0] self_ = None -> result = optb}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #1] self_ = None
      \/ result = self_ /\ resolve_Option_T optb}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_F (_1: t_F)
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate precondition_F (self: t_F) (args: ())
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate postcondition_once_F (self: t_F) (args: ()) (result: t_Option_T)
  
  let rec call_once_F (self_: t_F) (arg: ()) (return (x: t_Option_T)) =
    {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once requires] precondition_F self_ arg}
    any
    [ return (result: t_Option_T) -> {inv_Option_T result} {postcondition_once_F self_ arg result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_or_else_body_T (self_: t_Option_T) (f: t_F) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'f' type invariant] inv_F f}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body requires] self_ = None -> precondition_F f ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_F f} s1
      | s1 = -{resolve_F f}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_0 <- Some t ] s4
      | s4 = bb10 ]
    | bb4 = s0 [ s0 = call_once_F {f} {_7} (fun (_ret: t_Option_T) -> [ &_0 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & _7: () = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_T_or_else_body ensures] match self_ with
        | None -> postcondition_once_F f () result
        | Some t -> result = Some t
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_xor_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0'0 -> inv_T f0'0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  let rec elim_Some (input: t_Option_T) (ret (f0'0: t_T)) = any
    [ good (f0'0: t_T) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_T [Some f0'0: t_Option_T]. Some f0'0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_xor_body_T (self_: t_Option_T) (optb: t_Option_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_xor_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_xor_body 'optb' type invariant] inv_Option_T optb}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- { f0 = self_; f1 = optb } ] s1 | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4.f0 = None} (! bb6) | br1 (x0: t_T) -> {_4.f0 = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv_Option_T _4.f1} s1
      | s1 = -{resolve_Option_T _4.f1}- s2
      | s2 = any [ br0 -> {_4.f1 = None} (! bb9) | br1 (x0: t_T) -> {_4.f1 = Some x0} (! bb24) ] ]
    | bb24 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {f0 = Some x} -> inv_T x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {f0 = Some x} -> resolve_T x
          | _ -> true
          end}-
        s2
      | s2 = bb3 ]
    | bb9 = s0 [ s0 = elim_Some {_4.f0} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = bb10 ]
    | bb6 = any [ br0 -> {_4.f1 = None} (! bb23) | br1 (x0: t_T) -> {_4.f1 = Some x0} (! bb8) ]
    | bb23 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {f1 = Some x} -> inv_T x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {f1 = Some x} -> resolve_T x
          | _ -> true
          end}-
        s2
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = bb16 ]
    | bb8 = s0 [ s0 = elim_Some {_4.f1} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = [ &_0 <- Some t ] s1 | s1 = bb16 ]
    | bb16 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & optb: t_Option_T = optb
    | & _4: tup2_Option_T_Option_T = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_xor_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_T_xor_body ensures] match { f0 = self_; f1 = optb } with
        | {f0 = None; f1 = None} -> result = None
        | {f0 = Some t1; f1 = Some t2} -> result = None /\ resolve_T t1 /\ resolve_T t2
        | {f0 = Some t; f1 = None} -> result = Some t
        | {f0 = None; f1 = Some t} -> result = Some t
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_insert_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  predicate resolve_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_insert_body_T (self_: MutBorrow.t t_Option_T) (value: t_T)
    (return (x: MutBorrow.t t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_insert_body 'self_' type invariant] inv_ref_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_insert_body 'value' type invariant] inv_T value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_6 <- Some value ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_Option_T self_.current} s1
      | s1 = -{resolve_Option_T self_.current}- s2
      | s2 = [ &self_ <- { self_ with current = _6 } ] s3
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {self_.current = None} (! bb6) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb7) ]
    | bb7 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            {inv_T r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &v <- _ret ] -{inv_T _ret.final}-
                [ &self_ <- { self_ with current = Some _ret.final } ] s1))
      | s1 = {inv_T v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_8 <- _ret ] -{inv_T _ret.final}-
            [ &v <- { v with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_T v} s3
      | s3 = -{resolve_ref_T v}- s4
      | s4 = {inv_T _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_3 <- _ret ] -{inv_T _ret.final}-
            [ &_8 <- { _8 with current = _ret.final } ] s5)
      | s5 = {[@expl:type invariant] inv_ref_T _8} s6
      | s6 = -{resolve_ref_T _8}- s7
      | s7 = {inv_T _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_0 <- _ret ] -{inv_T _ret.final}-
            [ &_3 <- { _3 with current = _ret.final } ] s8)
      | s8 = {[@expl:type invariant] inv_ref_T _3} s9
      | s9 = -{resolve_ref_T _3}- s10
      | s10 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1
      | s1 = -{resolve_ref_Option_T self_}- s2
      | s2 = return {_0} ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1 | s1 = -{resolve_ref_Option_T self_}- s2 | s2 = bb8 ]
    | bb8 = {false} any ]
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & value: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _6: t_Option_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_insert_body result type invariant] inv_ref_T result}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #0] match self_.current with
        | Some t -> resolve_T t
        | None -> true
        end}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #1] result.current = value
      /\ self_.final = Some (result.final)}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_get_or_insert_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  predicate resolve_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_body_T (self_: MutBorrow.t t_Option_T) (value: t_T)
    (return (x: MutBorrow.t t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'self_' type invariant] inv_ref_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'value' type invariant] inv_T value}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb4) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv_T value} s1 | s1 = -{resolve_T value}- s2 | s2 = bb9 ]
    | bb4 = s0 [ s0 = [ &_7 <- Some value ] s1 | s1 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv_Option_T self_.current} s1
      | s1 = -{resolve_Option_T self_.current}- s2
      | s2 = [ &self_ <- { self_ with current = _7 } ] s3
      | s3 = bb9 ]
    | bb9 = any [ br0 -> {self_.current = None} (! bb11) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb12) ]
    | bb12 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            {inv_T r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &v <- _ret ] -{inv_T _ret.final}-
                [ &self_ <- { self_ with current = Some _ret.final } ] s1))
      | s1 = {inv_T v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_9 <- _ret ] -{inv_T _ret.final}-
            [ &v <- { v with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_T v} s3
      | s3 = -{resolve_ref_T v}- s4
      | s4 = {inv_T _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_3 <- _ret ] -{inv_T _ret.final}-
            [ &_9 <- { _9 with current = _ret.final } ] s5)
      | s5 = {[@expl:type invariant] inv_ref_T _9} s6
      | s6 = -{resolve_ref_T _9}- s7
      | s7 = {inv_T _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_0 <- _ret ] -{inv_T _ret.final}-
            [ &_3 <- { _3 with current = _ret.final } ] s8)
      | s8 = {[@expl:type invariant] inv_ref_T _3} s9
      | s9 = -{resolve_ref_T _3}- s10
      | s10 = bb14 ]
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1
      | s1 = -{resolve_ref_Option_T self_}- s2
      | s2 = return {_0} ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1 | s1 = -{resolve_ref_Option_T self_}- s2 | s2 = bb13 ]
    | bb13 = {false} any ]
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & value: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _7: t_Option_T = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body result type invariant] inv_ref_T result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body ensures] match self_.current with
        | None -> result.current = value /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final) /\ resolve_T value
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_F (_1: t_F)
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate precondition_F (self: t_F) (args: ())
  
  predicate postcondition_once_F (self: t_F) (args: ()) (result: t_T)
  
  let rec call_once_F (self_: t_F) (arg: ()) (return (x: t_T)) = {[@expl:call_once 'self_' type invariant] inv_F self_}
    {[@expl:call_once requires] precondition_F self_ arg}
    any [ return (result: t_T) -> {inv_T result} {postcondition_once_F self_ arg result} (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  type t_Option_ref_T = None'0 | Some'0 (MutBorrow.t t_T)
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_T f0
        end
  
  let rec as_mut_T (self_: MutBorrow.t t_Option_T) (return (x: t_Option_ref_T)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_T self_}
    any
    [ return (result: t_Option_ref_T) -> {inv_Option_ref_T result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_T. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_T (self_: t_Option_ref_T) (return (x: MutBorrow.t t_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any [ return (result: MutBorrow.t t_T) -> {inv_ref_T result} {Some'0 result = self_} (! return {result}) ]
  
  predicate resolve_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body_T (self_: MutBorrow.t t_Option_T) (f: t_F)
    (return (x: MutBorrow.t t_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] inv_ref_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'f' type invariant] inv_F f}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body requires] self_.current = None
    -> precondition_F f ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb4) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_F f} s1
      | s1 = -{resolve_F f}- s2
      | s2 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            {inv_T r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &t <- _ret ] -{inv_T _ret.final}-
                [ &self_ <- { self_ with current = Some _ret.final } ] s3))
      | s3 = {inv_T t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_6 <- _ret ] -{inv_T _ret.final}-
            [ &t <- { t with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv_ref_T t} s5
      | s5 = -{resolve_ref_T t}- s6
      | s6 = bb12 ]
    | bb4 = s0 [ s0 = call_once_F {f} {_12} (fun (_ret: t_T) -> [ &_10 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = [ &_9 <- Some _10 ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_Option_T self_.current} s1
      | s1 = -{resolve_Option_T self_.current}- s2
      | s2 = [ &self_ <- { self_ with current = _9 } ] s3
      | s3 = bb9 ]
    | bb9 = s0
      [ s0 = {inv_Option_T self_.current}
        MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret: MutBorrow.t t_Option_T) ->
            [ &_15 <- _ret ] -{inv_Option_T _ret.final}-
            [ &self_ <- { self_ with current = _ret.final } ] s1)
      | s1 = as_mut_T {_15} (fun (_ret: t_Option_ref_T) -> [ &_14 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0 [ s0 = unwrap_ref_T {_14} (fun (_ret: MutBorrow.t t_T) -> [ &_13 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = {inv_T _13.current}
        MutBorrow.borrow_final <t_T> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_8 <- _ret ] -{inv_T _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_T _13} s2
      | s2 = -{resolve_ref_T _13}- s3
      | s3 = {inv_T _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_6 <- _ret ] -{inv_T _ret.final}-
            [ &_8 <- { _8 with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv_ref_T _8} s5
      | s5 = -{resolve_ref_T _8}- s6
      | s6 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_T _6.current}
        MutBorrow.borrow_final <t_T> {_6.current} {MutBorrow.get_id _6}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_3 <- _ret ] -{inv_T _ret.final}-
            [ &_6 <- { _6 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_T _6} s2
      | s2 = -{resolve_ref_T _6}- s3
      | s3 = {inv_T _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_0 <- _ret ] -{inv_T _ret.final}-
            [ &_3 <- { _3 with current = _ret.final } ] s4)
      | s4 = {[@expl:type invariant] inv_ref_T _3} s5
      | s5 = -{resolve_ref_T _3}- s6
      | s6 = bb13 ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1
      | s1 = -{resolve_ref_Option_T self_}- s2
      | s2 = return {_0} ] ]
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & f: t_F = f
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _6: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: t_Option_T = Any.any_l ()
    | & _10: t_T = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & _13: MutBorrow.t t_T = Any.any_l ()
    | & _14: t_Option_ref_T = Any.any_l ()
    | & _15: MutBorrow.t t_Option_T = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body result type invariant] inv_ref_T result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body ensures] match self_.current with
        | None -> postcondition_once_F f () result.current /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final)
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_take_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  let rec replace_Option_T (dest: MutBorrow.t t_Option_T) (src: t_Option_T) (return (x: t_Option_T)) =
    {[@expl:replace 'dest' type invariant] inv_ref_Option_T dest}
    {[@expl:replace 'src' type invariant] inv_Option_T src}
    any
    [ return (result: t_Option_T) -> {inv_Option_T result}
      {dest.final = src}
      {result = dest.current}
      (! return {result}) ]
  
  predicate resolve_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_take_body_T (self_: MutBorrow.t t_Option_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_take_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- None ] s1
      | s1 = {inv_Option_T self_.current}
        MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret: MutBorrow.t t_Option_T) ->
            [ &_3 <- _ret ] -{inv_Option_T _ret.final}-
            [ &self_ <- { self_ with current = _ret.final } ] s2)
      | s2 = replace_Option_T {_3} {_4} (fun (_ret: t_Option_T) -> [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1
      | s1 = -{resolve_ref_Option_T self_}- s2
      | s2 = return {_0} ] ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & _3: MutBorrow.t t_Option_T = Any.any_l ()
    | & _4: t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_take_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_T_take_body ensures] result = self_.current /\ self_.final = None}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_take_if_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  type t_P
  
  predicate inv_P (_1: t_P)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_tup1_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = inv_ref_T _1
  
  meta "rewrite_def" predicate inv_tup1_ref_T
  
  predicate precondition_P (self: t_P) (args: MutBorrow.t t_T)
  
  predicate postcondition_once_P (self: t_P) (args: MutBorrow.t t_T) (result: bool)
  
  let rec call_once_P (self_: t_P) (arg: MutBorrow.t t_T) (return (x: bool)) =
    {[@expl:call_once 'self_' type invariant] inv_P self_}
    {[@expl:call_once 'arg' type invariant] inv_tup1_ref_T arg}
    {[@expl:call_once requires] precondition_P self_ arg}
    any [ return (result: bool) -> {postcondition_once_P self_ arg result} (! return {result}) ]
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  let rec take_T (self_: MutBorrow.t t_Option_T) (return (x: t_Option_T)) =
    {[@expl:take 'self_' type invariant] inv_ref_Option_T self_}
    any
    [ return (result: t_Option_T) -> {inv_Option_T result}
      {result = self_.current /\ self_.final = None}
      (! return {result}) ]
  
  predicate resolve_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_T
  
  predicate resolve_P (_1: t_P)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_take_if_body_T (self_: MutBorrow.t t_Option_T) (predicate': t_P)
    (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'self_' type invariant] inv_ref_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'predicate' type invariant] inv_P predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body requires] match self_.current with
      | None -> true
      | Some t -> forall b: MutBorrow.t t_T. inv_ref_T b /\ b.current = t -> precondition_P predicate' b
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb2) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            {inv_T r0}
            MutBorrow.borrow_mut <t_T> {r0}
              (fun (_ret: MutBorrow.t t_T) ->
                [ &t <- _ret ] -{inv_T _ret.final}-
                [ &self_ <- { self_ with current = Some _ret.final } ] s1))
      | s1 = {inv_T t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret: MutBorrow.t t_T) ->
            [ &_10 <- _ret ] -{inv_T _ret.final}-
            [ &t <- { t with current = _ret.final } ] s2)
      | s2 = [ &_9 <- _10 ] s3
      | s3 = call_once_P {predicate'} {_9} (fun (_ret: bool) -> [ &_7 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_T t} s1
      | s1 = -{resolve_ref_T t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb6) ] ]
    | bb6 = s0
      [ s0 = {inv_Option_T self_.current}
        MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret: MutBorrow.t t_Option_T) ->
            [ &_11 <- _ret ] -{inv_Option_T _ret.final}-
            [ &self_ <- { self_ with current = _ret.final } ] s1)
      | s1 = take_T {_11} (fun (_ret: t_Option_T) -> [ &_0 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1 | s1 = -{resolve_ref_Option_T self_}- s2 | s2 = bb12 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1 | s1 = -{resolve_ref_Option_T self_}- s2 | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = bb12 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_P predicate'} s1
      | s1 = -{resolve_P predicate'}- s2
      | s2 = {[@expl:type invariant] inv_ref_Option_T self_} s3
      | s3 = -{resolve_ref_Option_T self_}- s4
      | s4 = bb4 ]
    | bb4 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & predicate': t_P = predicate'
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l ()
    | & _11: MutBorrow.t t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_T_take_if_body ensures] match self_.current with
        | None -> result = None /\ self_.final = None
        | Some cur -> exists b: MutBorrow.t t_T, res: bool. inv_ref_T b
          /\ cur = b.current
          /\ postcondition_once_P predicate' b res
          /\ (if res then
            self_.final = None /\ result = Some (b.final)
          else
            self_.final = Some (b.final) /\ result = None
          )
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_replace_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  let rec replace_Option_T (dest: MutBorrow.t t_Option_T) (src: t_Option_T) (return (x: t_Option_T)) =
    {[@expl:replace 'dest' type invariant] inv_ref_Option_T dest}
    {[@expl:replace 'src' type invariant] inv_Option_T src}
    any
    [ return (result: t_Option_T) -> {inv_Option_T result}
      {dest.final = src}
      {result = dest.current}
      (! return {result}) ]
  
  predicate resolve_ref_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_replace_body_T (self_: MutBorrow.t t_Option_T) (value: t_T)
    (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_T_replace_body 'self_' type invariant] inv_ref_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_replace_body 'value' type invariant] inv_T value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- Some value ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_T self_.current}
        MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret: MutBorrow.t t_Option_T) ->
            [ &_4 <- _ret ] -{inv_Option_T _ret.final}-
            [ &self_ <- { self_ with current = _ret.final } ] s1)
      | s1 = replace_Option_T {_4} {_5} (fun (_ret: t_Option_T) -> [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_T self_} s1 | s1 = -{resolve_ref_Option_T self_}- s2 | s2 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & value: t_T = value
    | & _4: MutBorrow.t t_Option_T = Any.any_l ()
    | & _5: t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_T_replace_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_T_replace_body ensures] result = self_.current
      /\ self_.final = Some value}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_T_zip_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_U
  
  type t_Option_U = None'0 | Some'0 t_U
  
  type tup2_Option_T_Option_U = { f0: t_Option_T; f1: t_Option_U }
  
  predicate inv_U (_1: t_U)
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_U f0'0
        end
  
  predicate resolve_U (_1: t_U)
  
  predicate resolve_Option_U (_1: t_Option_U)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_U [resolve_Option_U x]. resolve_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_U x0
        end
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  type tup2_T_U = { f0'0: t_T; f1'0: t_U }
  
  type t_Option_tup2_T_U = None'1 | Some'1 tup2_T_U
  
  let rec elim_Some (input: t_Option_T) (ret (f0'1: t_T)) = any
    [ good (f0'1: t_T) -> {Some f0'1 = input} (! ret {f0'1})
    | bad -> {forall f0'1: t_T [Some f0'1: t_Option_T]. Some f0'1 <> input} (! {false} any) ]
  
  let rec elim_Some'0 (input: t_Option_U) (ret (f0'1: t_U)) = any
    [ good (f0'1: t_U) -> {Some'0 f0'1 = input} (! ret {f0'1})
    | bad -> {forall f0'1: t_U [Some'0 f0'1: t_Option_U]. Some'0 f0'1 <> input} (! {false} any) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0'1 -> inv_T f0'1
        end
  
  predicate inv_tup2_T_U [@inline:trivial] (_1: tup2_T_U) = inv_T _1.f0'0 /\ inv_U _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_T_U
  
  predicate inv_Option_tup2_T_U (_1: t_Option_tup2_T_U)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_tup2_T_U [inv_Option_tup2_T_U x]. inv_Option_tup2_T_U x
      = match x with
        | None'1 -> true
        | Some'1 f0'1 -> inv_tup2_T_U f0'1
        end
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_zip_body_T (self_: t_Option_T) (other: t_Option_U)
    (return (x: t_Option_tup2_T_U)) =
    {[@expl:extern_spec_std_option_T_Option_T_zip_body 'self_' type invariant] inv_Option_T self_}
    {[@expl:extern_spec_std_option_T_Option_T_zip_body 'other' type invariant] inv_Option_U other}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- { f0 = self_; f1 = other } ] s1 | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4.f0 = None} (! bb25) | br1 (x0: t_T) -> {_4.f0 = Some x0} (! bb4) ]
    | bb25 = s0
      [ s0 = {[@expl:type invariant] inv_Option_U _4.f1} s1
      | s1 = -{resolve_Option_U _4.f1}- s2
      | s2 = {[@expl:type invariant] match _4 with
          | {f0 = Some x} -> inv_T x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {f0 = Some x} -> resolve_T x
          | _ -> true
          end}-
        s4
      | s4 = bb3 ]
    | bb4 = any [ br0 -> {_4.f1 = None'0} (! bb26) | br1 (x0: t_U) -> {_4.f1 = Some'0 x0} (! bb6) ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {f1 = Some'0 x} -> inv_U x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {f1 = Some'0 x} -> resolve_U x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {f0 = Some x} -> inv_T x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {f0 = Some x} -> resolve_T x
          | _ -> true
          end}-
        s4
      | s4 = bb3 ]
    | bb3 = s0 [ s0 = [ &_0 <- None'1 ] s1 | s1 = bb15 ]
    | bb6 = s0
      [ s0 = elim_Some {_4.f0} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = elim_Some'0 {_4.f1} (fun (r0: t_U) -> [ &u <- r0 ] s2)
      | s2 = [ &_11 <- { f0'0 = t; f1'0 = u } ] s3
      | s3 = bb8 ]
    | bb8 = s0 [ s0 = [ &_0 <- Some'1 _11 ] s1 | s1 = bb15 ]
    | bb15 = return {_0} ]
    [ & _0: t_Option_tup2_T_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & other: t_Option_U = other
    | & _4: tup2_Option_T_Option_U = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _11: tup2_T_U = Any.any_l () ])
    [ return (result: t_Option_tup2_T_U) ->
    {[@expl:extern_spec_std_option_T_Option_T_zip_body result type invariant] inv_Option_tup2_T_U result}
      {[@expl:extern_spec_std_option_T_Option_T_zip_body ensures] match { f0 = self_; f1 = other } with
        | {f0 = None} -> result = None'1 /\ resolve_Option_U other
        | {f1 = None'0} -> result = None'1 /\ resolve_Option_T self_
        | {f0 = Some t; f1 = Some'0 u} -> result = Some'1 { f0'0 = t; f1'0 = u }
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_U_Option_tuple2_T_U_unzip_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  let rec elim_Some (input: t_Option_tup2_T_U) (ret (f0'0: tup2_T_U)) = any
    [ good (f0'0: tup2_T_U) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: tup2_T_U [Some f0'0: t_Option_tup2_T_U]. Some f0'0 <> input} (! {false} any) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_U (_1: t_U)
  
  predicate inv_tup2_T_U [@inline:trivial] (_1: tup2_T_U) = inv_T _1.f0 /\ inv_U _1.f1
  
  meta "rewrite_def" predicate inv_tup2_T_U
  
  predicate inv_Option_tup2_T_U (_1: t_Option_tup2_T_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_tup2_T_U [inv_Option_tup2_T_U x]. inv_Option_tup2_T_U x
      = match x with
        | None -> true
        | Some f0'1 -> inv_tup2_T_U f0'1
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'1 -> inv_T f0'1
        end
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'1 -> true
        | Some'1 f0'1 -> inv_U f0'1
        end
  
  predicate inv_tup2_Option_T_Option_U [@inline:trivial] (_1: tup2_Option_T_Option_U) =
    inv_Option_T _1.f0'0 /\ inv_Option_U _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_Option_T_Option_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body_T (self_: t_Option_tup2_T_U)
    (return (x: tup2_Option_T_Option_U)) =
    {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body 'self_' type invariant] inv_Option_tup2_T_U self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: tup2_T_U) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_} (fun (r0: tup2_T_U) -> [ &t <- r0.f0 ] s1)
      | s1 = elim_Some {self_} (fun (r0: tup2_T_U) -> [ &u <- r0.f1 ] s2)
      | s2 = [ &_6 <- Some'0 t ] s3
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = [ &_8 <- Some'1 u ] s1 | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &_0 <- { f0'0 = _6; f1'0 = _8 } ] s1 | s1 = bb14 ]
    | bb3 = s0
      [ s0 = [ &_10 <- None'0 ] s1
      | s1 = [ &_11 <- None'1 ] s2
      | s2 = [ &_0 <- { f0'0 = _10; f1'0 = _11 } ] s3
      | s3 = bb14 ]
    | bb14 = return {_0} ]
    [ & _0: tup2_Option_T_Option_U = Any.any_l ()
    | & self_: t_Option_tup2_T_U = self_
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _6: t_Option_T = Any.any_l ()
    | & _8: t_Option_U = Any.any_l ()
    | & _10: t_Option_T = Any.any_l ()
    | & _11: t_Option_U = Any.any_l () ])
    [ return (result: tup2_Option_T_Option_U) ->
    {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body result type invariant] inv_tup2_Option_T_Option_U result}
      {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body ensures] match self_ with
        | None -> result = { f0'0 = None'0; f1'0 = None'1 }
        | Some {f0 = t; f1 = u} -> result = { f0'0 = Some'0 t; f1'0 = Some'1 u }
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_ref_T_copied_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_ref_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_ref_T]. Some f0 <> input} (! {false} any) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option__ref_T_copied_body_T (self_: t_Option_ref_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body 'self_' type invariant] inv_Option_ref_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0 [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_0 <- Some'0 t ] s2 | s2 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- None'0 ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l () | & self_: t_Option_ref_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body ensures] match self_ with
        | None -> result = None'0
        | Some s -> result = Some'0 s
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_ref_T_cloned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  let rec elim_Some (input: t_Option_ref_T) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Some f0: t_Option_ref_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate precondition_clone (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_clone () args]. (let self_ = args in inv_ref_T self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  let rec clone_T (self_: t_T) (return (x: t_T)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_T) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  type tup2_Option_ref_T_Option_T = { f0: t_Option_ref_T; f1: t_Option_T }
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option__ref_T_cloned_body_T (self_: t_Option_ref_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body 'self_' type invariant] inv_Option_ref_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = clone_T {t} (fun (_ret: t_T) -> [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- Some'0 _5 ] s1 | s1 = bb7 ]
    | bb4 = s0 [ s0 = [ &_0 <- None'0 ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: t_Option_ref_T = self_
    | & t: t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body ensures] match { f0 = self_; f1 = result } with
        | {f0 = None; f1 = None'0} -> true
        | {f0 = Some s; f1 = Some'0 r} -> postcondition_clone () s r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_refmut_T_copied_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_ref_T = None | Some (MutBorrow.t t_T)
  
  let rec elim_Some (input: t_Option_ref_T) (ret (f0: MutBorrow.t t_T)) = any
    [ good (f0: MutBorrow.t t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: MutBorrow.t t_T [Some f0: t_Option_ref_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  type t_Option_T = None'0 | Some'0 t_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option__refmut_T_copied_body_T (self_: t_Option_ref_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body 'self_' type invariant] inv_Option_ref_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: MutBorrow.t t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: MutBorrow.t t_T) -> [ &t <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_T t} s2
      | s2 = -{resolve_ref_T t}- s3
      | s3 = [ &_0 <- Some'0 (t.current) ] s4
      | s4 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- None'0 ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l () | & self_: t_Option_ref_T = self_ | & t: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body ensures] match self_ with
        | None -> result = None'0
        | Some s -> result = Some'0 (s.current) /\ s.final = s.current
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_refmut_T_cloned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_ref_T = None | Some (MutBorrow.t t_T)
  
  let rec elim_Some (input: t_Option_ref_T) (ret (f0: MutBorrow.t t_T)) = any
    [ good (f0: MutBorrow.t t_T) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: MutBorrow.t t_T [Some f0: t_Option_ref_T]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  predicate invariant_ref_T'0 [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T'0
  
  predicate inv_ref_T'0 [@inline:trivial] (_1: t_T) = invariant_ref_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_T'0
  
  predicate precondition_clone (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_clone () args]. (let self_ = args in inv_ref_T'0 self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  let rec clone_T (self_: t_T) (return (x: t_T)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_T) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  type tup2_Option_ref_T_Option_T = { f0: t_Option_ref_T; f1: t_Option_T }
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option__refmut_T_cloned_body_T (self_: t_Option_ref_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body 'self_' type invariant] inv_Option_ref_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: MutBorrow.t t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: MutBorrow.t t_T) -> [ &t <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_T t} s2
      | s2 = -{resolve_ref_T t}- s3
      | s3 = clone_T {t.current} (fun (_ret: t_T) -> [ &_5 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- Some'0 _5 ] s1 | s1 = bb7 ]
    | bb4 = s0 [ s0 = [ &_0 <- None'0 ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l ()
    | & self_: t_Option_ref_T = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body ensures] match { f0 = self_; f1 = result } with
        | {f0 = None; f1 = None'0} -> true
        | {f0 = Some s; f1 = Some'0 r} -> postcondition_clone () s.current r /\ s.final = s.current
        | _ -> false
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_E_Option_Result_T_E_transpose_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  type t_Option_Result_T_E = None | Some t_Result_T_E
  
  let rec elim_Some (input: t_Option_Result_T_E) (ret (f0: t_Result_T_E)) = any
    [ good (f0: t_Result_T_E) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Result_T_E [Some f0: t_Option_Result_T_E]. Some f0 <> input} (! {false} any) ]
  
  let rec elim_Err (input: t_Result_T_E) (ret (f0: t_E)) = any
    [ good (f0: t_E) -> {Err f0 = input} (! ret {f0})
    | bad -> {forall f0: t_E [Err f0: t_Result_T_E]. Err f0 <> input} (! {false} any) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Result_Option_T_E = Ok'0 t_Option_T | Err'0 t_E
  
  let rec elim_Ok (input: t_Result_T_E) (ret (f0: t_T)) = any
    [ good (f0: t_T) -> {Ok f0 = input} (! ret {f0})
    | bad -> {forall f0: t_T [Ok f0: t_Result_T_E]. Ok f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_E (_1: t_E)
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  predicate inv_Option_Result_T_E (_1: t_Option_Result_T_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_Result_T_E [inv_Option_Result_T_E x]. inv_Option_Result_T_E x
      = match x with
        | None -> true
        | Some f0 -> inv_Result_T_E f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  predicate inv_Result_Option_T_E (_1: t_Result_Option_T_E)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Result_Option_T_E [inv_Result_Option_T_E x]. inv_Result_Option_T_E x
      = match x with
        | Ok'0 f0 -> inv_Option_T f0
        | Err'0 f0 -> inv_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_E_Option_Result_T_E_transpose_body_T (self_: t_Option_Result_T_E)
    (return (x: t_Result_Option_T_E)) =
    {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body 'self_' type invariant] inv_Option_Result_T_E self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb7) | br1 (x0: t_Result_T_E) -> {self_ = Some x0} (! bb3) ]
    | bb3 = elim_Some {self_}
        (fun (r0: t_Result_T_E) ->
          any [ br0 (x0: t_T) -> {r0 = Ok x0} (! bb6) | br1 (x0: t_E) -> {r0 = Err x0} (! bb5) ])
    | bb5 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_Result_T_E) -> elim_Err {r0} (fun (r0'0: t_E) -> [ &err <- r0'0 ] s1))
      | s1 = [ &_0 <- Err'0 err ] s2
      | s2 = bb15 ]
    | bb6 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_Result_T_E) -> elim_Ok {r0} (fun (r0'0: t_T) -> [ &ok <- r0'0 ] s1))
      | s1 = [ &_7 <- Some'0 ok ] s2
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- Ok'0 _7 ] s1 | s1 = bb15 ]
    | bb7 = s0 [ s0 = [ &_5 <- None'0 ] s1 | s1 = [ &_0 <- Ok'0 _5 ] s2 | s2 = bb15 ]
    | bb15 = return {_0} ]
    [ & _0: t_Result_Option_T_E = Any.any_l ()
    | & self_: t_Option_Result_T_E = self_
    | & _5: t_Option_T = Any.any_l ()
    | & ok: t_T = Any.any_l ()
    | & _7: t_Option_T = Any.any_l ()
    | & err: t_E = Any.any_l () ])
    [ return (result: t_Result_Option_T_E) ->
    {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body result type invariant] inv_Result_Option_T_E result}
      {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body ensures] match self_ with
        | None -> result = Ok'0 (None'0)
        | Some (Ok ok) -> result = Ok'0 (Some'0 ok)
        | Some (Err err) -> result = Err'0 err
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_std_option_T_Option_Option_T_flatten_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  let rec elim_Some (input: t_Option_Option_T) (ret (f0: t_Option_T)) = any
    [ good (f0: t_Option_T) -> {Some'0 f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Option_T [Some'0 f0: t_Option_Option_T]. Some'0 f0 <> input} (! {false} any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Option_Option_T (_1: t_Option_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_Option_T [inv_Option_Option_T x]. inv_Option_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_Option_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_Option_T_flatten_body_T (self_: t_Option_Option_T) (return (x: t_Option_T)) =
    {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body 'self_' type invariant] inv_Option_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None'0} (! bb4) | br1 (x0: t_Option_T) -> {self_ = Some'0 x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_Option_T) -> [ &opt <- r0 ] s1) | s1 = [ &_0 <- opt ] s2 | s2 = bb7 ]
    | bb4 = s0 [ s0 = [ &_0 <- None ] s1 | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Option_T = Any.any_l () | & self_: t_Option_Option_T = self_ | & opt: t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body result type invariant] inv_Option_T result}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #0] self_ = None'0 -> result = None}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #1] self_ = None'0 \/ self_ = Some'0 result}
      (! return {result}) ]
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_le_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate le_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o <> Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function cmp_le_log_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_cmp_le_log_Option_T: [@expl:cmp_le_log ensures] le_log_Option_T x y = (cmp_log_Option_T x y <> Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_lt_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate lt_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o = Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function cmp_lt_log_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_cmp_lt_log_Option_T: [@expl:cmp_lt_log ensures] lt_log_Option_T x y = (cmp_log_Option_T x y = Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_ge_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate ge_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o <> Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function cmp_ge_log_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_cmp_ge_log_Option_T: [@expl:cmp_ge_log ensures] ge_log_Option_T x y = (cmp_log_Option_T x y <> Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_gt_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate gt_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o = Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function cmp_gt_log_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_cmp_gt_log_Option_T: [@expl:cmp_gt_log ensures] gt_log_Option_T x y = (cmp_log_Option_T x y = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__refl (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  function refl_Option_T (x: t_Option_T) : ()
  
  goal vc_refl_Option_T: [@expl:refl ensures] cmp_log_Option_T x x = Equal
end
module M_std__option__impl_OrdLogic_for_Option_T__trans (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  constant z : t_Option_T
  
  constant o : t_Ordering
  
  function trans_Option_T (x: t_Option_T) (y: t_Option_T) (z: t_Option_T) (o: t_Ordering) : ()
  
  goal vc_trans_Option_T: cmp_log_Option_T x y = o
    -> cmp_log_Option_T y z = o -> ([@expl:trans ensures] cmp_log_Option_T x z = o)
end
module M_std__option__impl_OrdLogic_for_Option_T__antisym1 (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function antisym1_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_antisym1_Option_T: cmp_log_Option_T x y = Less -> ([@expl:antisym1 ensures] cmp_log_Option_T y x = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__antisym2 (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function antisym2_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_antisym2_Option_T: cmp_log_Option_T x y = Greater -> ([@expl:antisym2 ensures] cmp_log_Option_T y x = Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__eq_cmp (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function eq_cmp_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_eq_cmp_Option_T: [@expl:eq_cmp ensures] (x = y) = (cmp_log_Option_T x y = Equal)
end
module M_std__option__impl_IteratorSpec_for_IntoIter_T__produces_refl (* <std::option::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : t_Option_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_IntoIter_T self = Some e /\ visited = Seq.singleton e /\ view_IntoIter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_T
  
  function produces_refl_IntoIter_T (self: t_IntoIter_T) : ()
  
  goal vc_produces_refl_IntoIter_T: [@expl:produces_refl ensures] produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__option__impl_IteratorSpec_for_IntoIter_T__produces_trans (* <std::option::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : t_Option_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_IntoIter_T self = Some e /\ visited = Seq.singleton e /\ view_IntoIter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter_T
  
  function produces_trans_IntoIter_T (a: t_IntoIter_T) (ab: Seq.seq t_T) (b: t_IntoIter_T) (bc: Seq.seq t_T) (c: t_IntoIter_T) : ()
  
  goal vc_produces_trans_IntoIter_T: produces_IntoIter_T a ab b
    -> produces_IntoIter_T b bc c -> ([@expl:produces_trans ensures] produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_Iter_T__produces_refl (* <std::option::Iter<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter_T
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_Iter_T (self: t_Iter_T) : t_Option_ref_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Iter_T self = Some e /\ visited = Seq.singleton e /\ view_Iter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_T
  
  function produces_refl_Iter_T (self: t_Iter_T) : ()
  
  goal vc_produces_refl_Iter_T: [@expl:produces_refl ensures] produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__option__impl_IteratorSpec_for_Iter_T__produces_trans (* <std::option::Iter<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter_T
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_Iter_T (self: t_Iter_T) : t_Option_ref_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Iter_T self = Some e /\ visited = Seq.singleton e /\ view_Iter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter_T
  
  function produces_trans_Iter_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : ()
  
  goal vc_produces_trans_Iter_T: produces_Iter_T a ab b
    -> produces_Iter_T b bc c -> ([@expl:produces_trans ensures] produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_IterMut_T__produces_refl (* <std::option::IterMut<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut_T
  
  type t_T
  
  type t_Option_ref_T = None | Some (MutBorrow.t t_T)
  
  function view_IterMut_T (self: t_IterMut_T) : t_Option_ref_T
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut_T) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view_IterMut_T self = Some e /\ visited = Seq.singleton e /\ view_IterMut_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut_T
  
  function produces_refl_IterMut_T (self: t_IterMut_T) : ()
  
  goal vc_produces_refl_IterMut_T:
    [@expl:produces_refl ensures] produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_std__option__impl_IteratorSpec_for_IterMut_T__produces_trans (* <std::option::IterMut<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut_T
  
  type t_T
  
  type t_Option_ref_T = None | Some (MutBorrow.t t_T)
  
  function view_IterMut_T (self: t_IterMut_T) : t_Option_ref_T
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut_T) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view_IterMut_T self = Some e /\ visited = Seq.singleton e /\ view_IterMut_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut_T
  
  constant ab : Seq.seq (MutBorrow.t t_T)
  
  constant b : t_IterMut_T
  
  constant bc : Seq.seq (MutBorrow.t t_T)
  
  constant c : t_IterMut_T
  
  function produces_trans_IterMut_T (a: t_IterMut_T) (ab: Seq.seq (MutBorrow.t t_T)) (b: t_IterMut_T) (bc: Seq.seq (MutBorrow.t t_T)) (c: t_IterMut_T) : ()
  
  goal vc_produces_trans_IterMut_T: produces_IterMut_T a ab b
    -> produces_IterMut_T b bc c -> ([@expl:produces_trans ensures] produces_IterMut_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_OptionExt_for_Option_T__unwrap_logic (* <std::option::Option<T> as std::option::OptionExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate index_Mapping_T_bool [@inline:trivial] (self: Map.map t_T bool) (a: t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T_bool
  
  function such_that_T (p: Map.map t_T bool) : t_T
  
  axiom such_that_T_spec: forall p: Map.map t_T bool. (exists x: t_T. index_Mapping_T_bool p x)
      -> index_Mapping_T_bool p (such_that_T p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  function unwrap_Option_T (self: t_Option_T) : t_T
  
  goal vc_unwrap_Option_T: self <> None
    -> match self with
      | Some x -> true
      | None -> [@expl:such_that requires] exists x: t_T. index_Mapping_T_bool (fun (__0: t_T) -> true) x
      end
end
module M_std__ptr__extern_spec_T_ptrconst_T_cast_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrconst_T_cast_body_T (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- Opaque.thin self_ ] s1 | s1 = [ &_0 <- _4 ] s2 | s2 = return {_0} ] ]
    [ & _0: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ | & _4: Opaque.ptr = Any.any_l () ])
    [ return (result: Opaque.ptr) -> {[@expl:extern_spec_T__ptrconst_T_cast_body ensures] result = Opaque.thin self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrconst_T_is_aligned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_T : UInt64.t
  
  axiom align_of_T_spec: (0: UInt64.t) <> align_of_T
    /\ UInt64.bw_and align_of_T (UInt64.sub align_of_T (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_T_spec'0: Int.mod size_of_T (UInt64.t'int align_of_T) = 0
  
  let rec align_of_T'0 (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = align_of_T} (! return {result}) ]
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  let rec is_aligned_to_T (self_: Opaque.ptr) (align: UInt64.t) (return (x: bool)) =
    {[@expl:is_aligned_to requires] align <> (0: UInt64.t)
    /\ UInt64.bw_and align (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)}
    any [ return (result: bool) -> {result = is_aligned_to_ptr_T self_ align} (! return {result}) ]
  
  predicate is_aligned_T [@inline:trivial] (ptr: Opaque.ptr) = is_aligned_to_ptr_T ptr align_of_T
  
  meta "rewrite_def" predicate is_aligned_T
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrconst_T_is_aligned_body_T (self_: Opaque.ptr) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = align_of_T'0 (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = is_aligned_to_T {self_} {_5} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: bool = Any.any_l () | & self_: Opaque.ptr = self_ | & _5: UInt64.t = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T__ptrconst_T_is_aligned_body ensures] result
      = is_aligned_ptr_T self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrconst_T_is_aligned_to_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64BW
  use creusot.prelude.Opaque
  use creusot.prelude.PtrBW
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use seq.Seq
  
  let rec is_power_of_two (self_: UInt64BW.t) (return (x: bool)) = any
    [ return (result: bool) -> {result
      = (self_ <> (0: UInt64BW.t) /\ UInt64BW.bw_and self_ (UInt64BW.sub self_ (1: UInt64BW.t)) = (0: UInt64BW.t))}
      (! return {result}) ]
  
  let rec addr_T (self_: Opaque.ptr) (return (x: UInt64BW.t)) = any
    [ return (result: UInt64BW.t) -> {result = PtrBW.addr_logic_u64 self_} (! return {result}) ]
  
  type t_Arguments
  
  predicate inv_Seq_ref_str [@inline:trivial] (_1: Seq.seq string) = true
  
  meta "rewrite_def" predicate inv_Seq_ref_str
  
  predicate invariant_array_ref_str_1 (self: Slice64.array string) =
    inv_Seq_ref_str (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64BW.t'int (1: UInt64BW.t)
  
  predicate inv_array_ref_str_1 [@inline:trivial] (_1: Slice64.array string) = invariant_array_ref_str_1 _1
  
  meta "rewrite_def" predicate inv_array_ref_str_1
  
  predicate invariant_ref_array_ref_str_1 [@inline:trivial] (self: Slice64.array string) = inv_array_ref_str_1 self
  
  meta "rewrite_def" predicate invariant_ref_array_ref_str_1
  
  predicate inv_ref_array_ref_str_1 [@inline:trivial] (_1: Slice64.array string) = invariant_ref_array_ref_str_1 _1
  
  meta "rewrite_def" predicate inv_ref_array_ref_str_1
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64BW.t) (o: UInt64BW.t) : t_Ordering = if UInt64BW.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. cmp_log_usize x y = Greater
      -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. cmp_log_usize x y = Less
      -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64BW.t) (y: UInt64BW.t) (z: UInt64BW.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t, z: UInt64BW.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64BW.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64BW.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.le x y = (cmp_log_usize x y <> Greater)
  
  predicate inv_Arguments (_1: t_Arguments)
  
  let rec new_const (pieces: Slice64.array string) (return (x: t_Arguments)) =
    {[@expl:new_const 'pieces' type invariant] inv_ref_array_ref_str_1 pieces}
    {[@expl:new_const requires] UInt64BW.le (1: UInt64BW.t) (1: UInt64BW.t)}
    any [ return (result: t_Arguments) -> {inv_Arguments result} (! return {result}) ]
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64BW.t) =
    UInt64BW.bw_and (PtrBW.addr_logic_u64 self) (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrconst_T_is_aligned_to_body_T (self_: Opaque.ptr) (align: UInt64BW.t) (return (x: bool)) =
    {[@expl:extern_spec_T__ptrconst_T_is_aligned_to_body requires] align <> (0: UInt64BW.t)
    /\ UInt64BW.bw_and align (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = is_power_of_two {align} (fun (_ret: bool) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_7 = false} (! bb3) | br1 -> {_7} (! bb2) ]
    | bb2 = s0 [ s0 = addr_T {self_} (fun (_ret: UInt64BW.t) -> [ &_17 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = UInt64BW.sub {align} {(1: UInt64BW.t)} (fun (_ret: UInt64BW.t) -> [ &_19 <- _ret ] s1)
      | s1 = [ &_16 <- UInt64BW.bw_and _17 _19 ] s2
      | s2 = [ &_0 <- _16 = (0: UInt64BW.t) ] s3
      | s3 = return {_0} ]
    | bb3 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array string) -> (! -{Seq.get __arr_temp.Slice64.elts 0
                = "is_aligned_to: align is not a power-of-two"
              /\ Seq.length __arr_temp.Slice64.elts = 1}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array string = Any.any_l () | & _1: Slice64.array string = Any.any_l () ]
        [ _const_ret (_const: Slice64.array string) -> [ &_21 <- _const ] s1 ]
      | s1 = [ &_14 <- _21 ] s2
      | s2 = new_const {_14} (fun (_ret: t_Arguments) -> [ &_12 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = {false} any ]
    [ & _0: bool = Any.any_l ()
    | & self_: Opaque.ptr = self_
    | & align: UInt64BW.t = align
    | & _7: bool = Any.any_l ()
    | & _12: t_Arguments = Any.any_l ()
    | & _14: Slice64.array string = Any.any_l ()
    | & _16: UInt64BW.t = Any.any_l ()
    | & _17: UInt64BW.t = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: Slice64.array string = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T__ptrconst_T_is_aligned_to_body ensures] result
      = is_aligned_to_ptr_T self_ align}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrmut_T_cast_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrmut_T_cast_body_T (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- Opaque.thin self_ ] s1 | s1 = [ &_0 <- _4 ] s2 | s2 = return {_0} ] ]
    [ & _0: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ | & _4: Opaque.ptr = Any.any_l () ])
    [ return (result: Opaque.ptr) -> {[@expl:extern_spec_T__ptrmut_T_cast_body ensures] result = Opaque.thin self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrmut_T_is_aligned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_T : UInt64.t
  
  axiom align_of_T_spec: (0: UInt64.t) <> align_of_T
    /\ UInt64.bw_and align_of_T (UInt64.sub align_of_T (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_T_spec'0: Int.mod size_of_T (UInt64.t'int align_of_T) = 0
  
  let rec align_of_T'0 (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = align_of_T} (! return {result}) ]
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  let rec is_aligned_to_T (self_: Opaque.ptr) (align: UInt64.t) (return (x: bool)) =
    {[@expl:is_aligned_to requires] align <> (0: UInt64.t)
    /\ UInt64.bw_and align (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)}
    any [ return (result: bool) -> {result = is_aligned_to_ptr_T self_ align} (! return {result}) ]
  
  predicate is_aligned_to_ptr_T'0 (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  predicate is_aligned_T [@inline:trivial] (ptr: Opaque.ptr) = is_aligned_to_ptr_T'0 ptr align_of_T
  
  meta "rewrite_def" predicate is_aligned_T
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrmut_T_is_aligned_body_T (self_: Opaque.ptr) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = align_of_T'0 (fun (_ret: UInt64.t) -> [ &_5 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = is_aligned_to_T {self_} {_5} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = return {_0} ] [ & _0: bool = Any.any_l () | & self_: Opaque.ptr = self_ | & _5: UInt64.t = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T__ptrmut_T_is_aligned_body ensures] result = is_aligned_ptr_T self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrmut_T_is_aligned_to_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64BW
  use creusot.prelude.Opaque
  use creusot.prelude.PtrBW
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use seq.Seq
  
  let rec is_power_of_two (self_: UInt64BW.t) (return (x: bool)) = any
    [ return (result: bool) -> {result
      = (self_ <> (0: UInt64BW.t) /\ UInt64BW.bw_and self_ (UInt64BW.sub self_ (1: UInt64BW.t)) = (0: UInt64BW.t))}
      (! return {result}) ]
  
  let rec addr_T (self_: Opaque.ptr) (return (x: UInt64BW.t)) = any
    [ return (result: UInt64BW.t) -> {result = PtrBW.addr_logic_u64 self_} (! return {result}) ]
  
  type t_Arguments
  
  predicate inv_Seq_ref_str [@inline:trivial] (_1: Seq.seq string) = true
  
  meta "rewrite_def" predicate inv_Seq_ref_str
  
  predicate invariant_array_ref_str_1 (self: Slice64.array string) =
    inv_Seq_ref_str (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64BW.t'int (1: UInt64BW.t)
  
  predicate inv_array_ref_str_1 [@inline:trivial] (_1: Slice64.array string) = invariant_array_ref_str_1 _1
  
  meta "rewrite_def" predicate inv_array_ref_str_1
  
  predicate invariant_ref_array_ref_str_1 [@inline:trivial] (self: Slice64.array string) = inv_array_ref_str_1 self
  
  meta "rewrite_def" predicate invariant_ref_array_ref_str_1
  
  predicate inv_ref_array_ref_str_1 [@inline:trivial] (_1: Slice64.array string) = invariant_ref_array_ref_str_1 _1
  
  meta "rewrite_def" predicate inv_ref_array_ref_str_1
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64BW.t) (o: UInt64BW.t) : t_Ordering = if UInt64BW.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. cmp_log_usize x y = Greater
      -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. cmp_log_usize x y = Less
      -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64BW.t) (y: UInt64BW.t) (z: UInt64BW.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t, z: UInt64BW.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64BW.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64BW.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64BW.t) (y: UInt64BW.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64BW.t, y: UInt64BW.t. UInt64BW.le x y = (cmp_log_usize x y <> Greater)
  
  predicate inv_Arguments (_1: t_Arguments)
  
  let rec new_const (pieces: Slice64.array string) (return (x: t_Arguments)) =
    {[@expl:new_const 'pieces' type invariant] inv_ref_array_ref_str_1 pieces}
    {[@expl:new_const requires] UInt64BW.le (1: UInt64BW.t) (1: UInt64BW.t)}
    any [ return (result: t_Arguments) -> {inv_Arguments result} (! return {result}) ]
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64BW.t) =
    UInt64BW.bw_and (PtrBW.addr_logic_u64 self) (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrmut_T_is_aligned_to_body_T (self_: Opaque.ptr) (align: UInt64BW.t) (return (x: bool)) =
    {[@expl:extern_spec_T__ptrmut_T_is_aligned_to_body requires] align <> (0: UInt64BW.t)
    /\ UInt64BW.bw_and align (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = is_power_of_two {align} (fun (_ret: bool) -> [ &_7 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_7 = false} (! bb3) | br1 -> {_7} (! bb2) ]
    | bb2 = s0 [ s0 = addr_T {self_} (fun (_ret: UInt64BW.t) -> [ &_17 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = UInt64BW.sub {align} {(1: UInt64BW.t)} (fun (_ret: UInt64BW.t) -> [ &_19 <- _ret ] s1)
      | s1 = [ &_16 <- UInt64BW.bw_and _17 _19 ] s2
      | s2 = [ &_0 <- _16 = (0: UInt64BW.t) ] s3
      | s3 = return {_0} ]
    | bb3 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array string) -> (! -{Seq.get __arr_temp.Slice64.elts 0
                = "is_aligned_to: align is not a power-of-two"
              /\ Seq.length __arr_temp.Slice64.elts = 1}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_0'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Slice64.array string = Any.any_l () | & _1: Slice64.array string = Any.any_l () ]
        [ _const_ret (_const: Slice64.array string) -> [ &_21 <- _const ] s1 ]
      | s1 = [ &_14 <- _21 ] s2
      | s2 = new_const {_14} (fun (_ret: t_Arguments) -> [ &_12 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = {false} any ]
    [ & _0: bool = Any.any_l ()
    | & self_: Opaque.ptr = self_
    | & align: UInt64BW.t = align
    | & _7: bool = Any.any_l ()
    | & _12: t_Arguments = Any.any_l ()
    | & _14: Slice64.array string = Any.any_l ()
    | & _16: UInt64BW.t = Any.any_l ()
    | & _17: UInt64BW.t = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: Slice64.array string = Any.any_l () ])
    [ return (result: bool) -> {[@expl:extern_spec_T__ptrmut_T_is_aligned_to_body ensures] result
      = is_aligned_to_ptr_T self_ align}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_Clone_ptrmut_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone__ptrmut_T_clone_body_T (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ ])
    [ return (result: Opaque.ptr) -> {[@expl:extern_spec_T_Clone__ptrmut_T_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_Clone_ptrconst_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone__ptrconst_T_clone_body_T (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self_ ] s1 | s1 = return {_0} ] ]
    [ & _0: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ ])
    [ return (result: Opaque.ptr) -> {[@expl:extern_spec_T_Clone__ptrconst_T_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_Range_T_legacy_Range_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Range_T = { start: t_T; end': t_T }
  
  type t_Range_T'0 = { start'0: t_T; end''0: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Range_T (_1: t_Range_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Range_T [inv_Range_T x]. inv_Range_T x = (inv_T x.start /\ inv_T x.end')
  
  predicate inv_Range_T'0 (_1: t_Range_T'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Range_T'0 [inv_Range_T'0 x]. inv_Range_T'0 x
      = (inv_T x.start'0 /\ inv_T x.end''0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_Range_T_legacy_Range_T_from_body_T (value: t_Range_T) (return (x: t_Range_T'0)) =
    {[@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body 'value' type invariant] inv_Range_T value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = [ &_0 <- { start'0 = value.start; end''0 = value.end' } ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ] [ & _0: t_Range_T'0 = Any.any_l () | & value: t_Range_T = value ])
    [ return (result: t_Range_T'0) ->
    {[@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body result type invariant] inv_Range_T'0 result}
      {[@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body ensures] result
      = { start'0 = value.start; end''0 = value.end' }}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_legacy_Range_T_Range_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Range_T = { start: t_T; end': t_T }
  
  type t_Range_T'0 = { start'0: t_T; end''0: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Range_T (_1: t_Range_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Range_T [inv_Range_T x]. inv_Range_T x = (inv_T x.start /\ inv_T x.end')
  
  predicate inv_Range_T'0 (_1: t_Range_T'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Range_T'0 [inv_Range_T'0 x]. inv_Range_T'0 x
      = (inv_T x.start'0 /\ inv_T x.end''0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_legacy_Range_T_Range_T_from_body_T (value: t_Range_T) (return (x: t_Range_T'0)) =
    {[@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body 'value' type invariant] inv_Range_T value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = [ &_0 <- { start'0 = value.start; end''0 = value.end' } ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ] [ & _0: t_Range_T'0 = Any.any_l () | & value: t_Range_T = value ])
    [ return (result: t_Range_T'0) ->
    {[@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body result type invariant] inv_Range_T'0 result}
      {[@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body ensures] result
      = { start'0 = value.start; end''0 = value.end' }}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeFrom_T = { start: t_T }
  
  type t_RangeFrom_T'0 = { start'0: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_RangeFrom_T (_1: t_RangeFrom_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeFrom_T [inv_RangeFrom_T x]. inv_RangeFrom_T x = inv_T x.start
  
  predicate inv_RangeFrom_T'0 (_1: t_RangeFrom_T'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_RangeFrom_T'0 [inv_RangeFrom_T'0 x]. inv_RangeFrom_T'0 x = inv_T x.start'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body_T (value: t_RangeFrom_T)
    (return (x: t_RangeFrom_T'0)) =
    {[@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body 'value' type invariant] inv_RangeFrom_T value}
    (! bb0
    [ bb0 = bb1 | bb1 = s0 [ s0 = [ &_0 <- { start'0 = value.start } ] s1 | s1 = bb3 ] | bb3 = return {_0} ]
    [ & _0: t_RangeFrom_T'0 = Any.any_l () | & value: t_RangeFrom_T = value ])
    [ return (result: t_RangeFrom_T'0) ->
    {[@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body result type invariant] inv_RangeFrom_T'0 result}
      {[@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body ensures] result = { start'0 = value.start }}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeFrom_T = { start: t_T }
  
  type t_RangeFrom_T'0 = { start'0: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_RangeFrom_T (_1: t_RangeFrom_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeFrom_T [inv_RangeFrom_T x]. inv_RangeFrom_T x = inv_T x.start
  
  predicate inv_RangeFrom_T'0 (_1: t_RangeFrom_T'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_RangeFrom_T'0 [inv_RangeFrom_T'0 x]. inv_RangeFrom_T'0 x = inv_T x.start'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body_T (value: t_RangeFrom_T)
    (return (x: t_RangeFrom_T'0)) =
    {[@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body 'value' type invariant] inv_RangeFrom_T value}
    (! bb0
    [ bb0 = bb1 | bb1 = s0 [ s0 = [ &_0 <- { start'0 = value.start } ] s1 | s1 = bb3 ] | bb3 = return {_0} ]
    [ & _0: t_RangeFrom_T'0 = Any.any_l () | & value: t_RangeFrom_T = value ])
    [ return (result: t_RangeFrom_T'0) ->
    {[@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body result type invariant] inv_RangeFrom_T'0 result}
      {[@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body ensures] result = { start'0 = value.start }}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeInclusive_T = { start: t_T; last: t_T }
  
  type t_RangeInclusive_T'0
  
  predicate inv_T (_1: t_T)
  
  predicate inv_RangeInclusive_T (_1: t_RangeInclusive_T'0)
  
  function start_log_RangeInclusive_T (self: t_RangeInclusive_T'0) : t_T
  
  function end_log_RangeInclusive_T (self: t_RangeInclusive_T'0) : t_T
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate is_empty_log_RangeInclusive_T (self: t_RangeInclusive_T'0)
  
  axiom is_empty_log_RangeInclusive_T_spec: forall self: t_RangeInclusive_T'0. not is_empty_log_RangeInclusive_T self
      -> le_log_DeepModelTy (deep_model_T (start_log_RangeInclusive_T self)) (deep_model_T (end_log_RangeInclusive_T self))
  
  let rec new_T (start'0: t_T) (end': t_T) (return (x: t_RangeInclusive_T'0)) =
    {[@expl:new 'start' type invariant] inv_T start'0}
    {[@expl:new 'end' type invariant] inv_T end'}
    any
    [ return (result: t_RangeInclusive_T'0) -> {inv_RangeInclusive_T result}
      {start_log_RangeInclusive_T result = start'0}
      {end_log_RangeInclusive_T result = end'}
      {le_log_DeepModelTy (deep_model_T start'0) (deep_model_T end') -> not is_empty_log_RangeInclusive_T result}
      (! return {result}) ]
  
  predicate inv_RangeInclusive_T'0 (_1: t_RangeInclusive_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeInclusive_T [inv_RangeInclusive_T'0 x]. inv_RangeInclusive_T'0 x
      = (inv_T x.start /\ inv_T x.last)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body_T (value: t_RangeInclusive_T)
    (return (x: t_RangeInclusive_T'0)) =
    {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body 'value' type invariant] inv_RangeInclusive_T'0 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = new_T {value.start} {value.last} (fun (_ret: t_RangeInclusive_T'0) -> [ &_0 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = return {_0} ] [ & _0: t_RangeInclusive_T'0 = Any.any_l () | & value: t_RangeInclusive_T = value ])
    [ return (result: t_RangeInclusive_T'0) ->
    {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body result type invariant] inv_RangeInclusive_T result}
      {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #0] start_log_RangeInclusive_T result
      = value.start}
      {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #1] end_log_RangeInclusive_T result
      = value.last}
      {[@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #2] le_log_DeepModelTy (deep_model_T value.start) (deep_model_T value.last)
      -> not is_empty_log_RangeInclusive_T result}
      (! return {result}) ]
end
module M_std__slice__impl_SliceExt_for_slice_T__as_ptr_own (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn_slice_T
  
  type tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T = { f0: Opaque.ptr; f1: t_PtrOwn_slice_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  predicate is_null_ptr_slice_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_slice_T (self: t_PtrOwn_slice_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_slice_T (self: t_PtrOwn_slice_T)
  
  predicate metadata_matches_slice_T [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches_slice_T
  
  function val_slice_T (self: t_PtrOwn_slice_T) : Slice64.slice t_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_slice_T [@inline:trivial] (val': Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val')
  
  meta "rewrite_def" function size_of_val_slice_T
  
  axiom size_of_val_slice_T_spec: forall val': Slice64.slice t_T. 0 <= size_of_val_slice_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_PtrOwn_slice_T (self: t_PtrOwn_slice_T) =
    not is_null_ptr_slice_T (ptr_slice_T self)
    /\ ptr_is_aligned_opaque_slice_T self
    /\ metadata_matches_slice_T (val_slice_T self) (metadata_slice_T (ptr_slice_T self))
    /\ size_of_val_slice_T (val_slice_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_slice_T self)) + size_of_val_slice_T (val_slice_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_slice_T (val_slice_T self)
  
  predicate inv_PtrOwn_slice_T (_1: t_PtrOwn_slice_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_slice_T [inv_PtrOwn_slice_T x]. inv_PtrOwn_slice_T x
      = invariant_PtrOwn_slice_T x
  
  predicate invariant_ref_PtrOwn_slice_T [@inline:trivial] (self: t_PtrOwn_slice_T) = inv_PtrOwn_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_slice_T
  
  predicate inv_ref_PtrOwn_slice_T [@inline:trivial] (_1: t_PtrOwn_slice_T) = invariant_ref_PtrOwn_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_slice_T
  
  predicate invariant_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (self: t_PtrOwn_slice_T) = inv_ref_PtrOwn_slice_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_slice_T
  
  predicate inv_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: t_PtrOwn_slice_T) =
    invariant_Ghost_ref_PtrOwn_slice_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_slice_T
  
  predicate inv_tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T) =
    inv_Ghost_ref_PtrOwn_slice_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T
  
  let rec from_ref_slice_T (r: Slice64.slice t_T) (return (x: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T)) =
    {[@expl:from_ref 'r' type invariant] inv_ref_slice_T r}
    any
    [ return (result: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T) ->
    {inv_tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T result}
      {ptr_slice_T result.f1 = result.f0}
      {val_slice_T result.f1 = r}
      (! return {result}) ]
  
  type tup2_ptr_T_Ghost_ref_PtrOwn_slice_T = { f0'0: Opaque.ptr; f1'0: t_PtrOwn_slice_T }
  
  predicate inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T) =
    inv_Ghost_ref_PtrOwn_slice_T _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_ptr_own_slice_T (self: Slice64.slice t_T) (return (x: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T)) =
    {[@expl:as_ptr_own 'self' type invariant] inv_ref_slice_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = from_ref_slice_T {self} (fun (_ret: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T) -> [ &_7 <- _ret ] s1)
      | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &ptr <- _7.f0 ] s1
      | s1 = [ &own <- _7.f1 ] s2
      | s2 = [ &_9 <- Opaque.thin ptr ] s3
      | s3 = [ &_0 <- { f0'0 = _9; f1'0 = own } ] s4
      | s4 = return {_0} ] ]
    [ & _0: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T = Any.any_l ()
    | & self: Slice64.slice t_T = self
    | & ptr: Opaque.ptr = Any.any_l ()
    | & own: t_PtrOwn_slice_T = Any.any_l ()
    | & _7: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T = Any.any_l ()
    | & _9: Opaque.ptr = Any.any_l () ])
    [ return (result: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T) ->
    {[@expl:as_ptr_own result type invariant] inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T result}
      {[@expl:as_ptr_own ensures #0] result.f0'0 = Opaque.thin (ptr_slice_T result.f1'0)}
      {[@expl:as_ptr_own ensures #1] self = val_slice_T result.f1'0}
      (! return {result}) ]
end
module M_std__slice__impl_SliceExt_for_slice_T__as_mut_ptr_own (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  type t_PtrOwn_slice_T
  
  type tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T = { f0: Opaque.ptr; f1: MutBorrow.t t_PtrOwn_slice_T }
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv_slice_T self.current /\ inv_slice_T self.final
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  predicate is_null_ptr_slice_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_slice_T (self: t_PtrOwn_slice_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_slice_T (self: t_PtrOwn_slice_T)
  
  predicate metadata_matches_slice_T [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches_slice_T
  
  function val_slice_T (self: t_PtrOwn_slice_T) : Slice64.slice t_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_slice_T [@inline:trivial] (val': Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val')
  
  meta "rewrite_def" function size_of_val_slice_T
  
  axiom size_of_val_slice_T_spec: forall val': Slice64.slice t_T. 0 <= size_of_val_slice_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_ref_slice_T'0 [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T'0
  
  predicate inv_ref_slice_T'0 [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_slice_T'0
  
  predicate invariant_PtrOwn_slice_T (self: t_PtrOwn_slice_T) =
    not is_null_ptr_slice_T (ptr_slice_T self)
    /\ ptr_is_aligned_opaque_slice_T self
    /\ metadata_matches_slice_T (val_slice_T self) (metadata_slice_T (ptr_slice_T self))
    /\ size_of_val_slice_T (val_slice_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_slice_T self)) + size_of_val_slice_T (val_slice_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_slice_T'0 (val_slice_T self)
  
  predicate inv_PtrOwn_slice_T (_1: t_PtrOwn_slice_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_slice_T [inv_PtrOwn_slice_T x]. inv_PtrOwn_slice_T x
      = invariant_PtrOwn_slice_T x
  
  predicate invariant_ref_PtrOwn_slice_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_slice_T) =
    inv_PtrOwn_slice_T self.current /\ inv_PtrOwn_slice_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_slice_T
  
  predicate inv_ref_PtrOwn_slice_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_slice_T) =
    invariant_ref_PtrOwn_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_slice_T
  
  predicate invariant_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_slice_T) =
    inv_ref_PtrOwn_slice_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_slice_T
  
  predicate inv_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_slice_T) =
    invariant_Ghost_ref_PtrOwn_slice_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_slice_T
  
  predicate inv_tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T) =
    inv_Ghost_ref_PtrOwn_slice_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T
  
  let rec from_mut_slice_T (r: MutBorrow.t (Slice64.slice t_T))
    (return (x: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T)) = {[@expl:from_mut 'r' type invariant] inv_ref_slice_T r}
    any
    [ return (result: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T) ->
    {inv_tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T result}
      {ptr_slice_T result.f1.current = result.f0}
      {val_slice_T result.f1.current = r.current}
      {val_slice_T result.f1.final = r.final}
      (! return {result}) ]
  
  type tup2_ptr_T_Ghost_ref_PtrOwn_slice_T = { f0'0: Opaque.ptr; f1'0: MutBorrow.t t_PtrOwn_slice_T }
  
  predicate resolve_ref_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_slice_T
  
  predicate inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T) =
    inv_Ghost_ref_PtrOwn_slice_T _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T
  
  function fin_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_slice_T) : t_PtrOwn_slice_T =
    self.final
  
  meta "rewrite_def" function fin_Ghost_ref_PtrOwn_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_mut_ptr_own_slice_T (self: MutBorrow.t (Slice64.slice t_T))
    (return (x: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T)) =
    {[@expl:as_mut_ptr_own 'self' type invariant] inv_ref_slice_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_slice_T self.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_9 <- _ret ] -{inv_slice_T _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = from_mut_slice_T {_9} (fun (_ret: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T) -> [ &_8 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &ptr <- _8.f0 ] s1
      | s1 = [ &own <- _8.f1 ] s2
      | s2 = [ &_10 <- Opaque.thin ptr ] s3
      | s3 = [ &_0 <- { f0'0 = _10; f1'0 = own } ] s4
      | s4 = {[@expl:type invariant] inv_ref_slice_T self} s5
      | s5 = -{resolve_ref_slice_T self}- s6
      | s6 = return {_0} ] ]
    [ & _0: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T = Any.any_l ()
    | & self: MutBorrow.t (Slice64.slice t_T) = self
    | & ptr: Opaque.ptr = Any.any_l ()
    | & own: MutBorrow.t t_PtrOwn_slice_T = Any.any_l ()
    | & _8: tup2_ptr_slice_T_Ghost_ref_PtrOwn_slice_T = Any.any_l ()
    | & _9: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _10: Opaque.ptr = Any.any_l () ])
    [ return (result: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T) ->
    {[@expl:as_mut_ptr_own result type invariant] inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T result}
      {[@expl:as_mut_ptr_own ensures #0] result.f0'0 = Opaque.thin (ptr_slice_T result.f1'0.current)}
      {[@expl:as_mut_ptr_own ensures #1] self.current = val_slice_T result.f1'0.current}
      {[@expl:as_mut_ptr_own ensures #2] self.final = val_slice_T (fin_Ghost_ref_PtrOwn_slice_T result.f1'0)}
      (! return {result}) ]
end
module M_std__slice__impl_IteratorSpec_for_Iter_T__produces_refl (* <std::slice::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_T
  
  function produces_refl_Iter_T (self: t_Iter_T) : ()
  
  goal vc_produces_refl_Iter_T: [@expl:produces_refl ensures] produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__slice__impl_IteratorSpec_for_Iter_T__produces_trans (* <std::slice::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter_T
  
  function produces_trans_Iter_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : ()
  
  goal vc_produces_trans_Iter_T: produces_Iter_T a ab b
    -> produces_Iter_T b bc c -> ([@expl:produces_trans ensures] produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__slice__impl_IteratorSpec_for_IterMut_T__produces_refl (* <std::slice::IterMut<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_IterMut_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_mut_seq_slice_T (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_slice_T_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq_slice_T self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_slice_T_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq_slice_T self)
        -> Seq.get (to_mut_seq_slice_T self) i
        = MutBorrow.borrow_logic (index_slice_T self.current i) (index_slice_T self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut_T) =
    to_mut_seq_slice_T (view_IterMut_T self) = Seq.(++) visited (to_mut_seq_slice_T (view_IterMut_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut_T
  
  function produces_refl_IterMut_T (self: t_IterMut_T) : ()
  
  goal vc_produces_refl_IterMut_T:
    [@expl:produces_refl ensures] produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_std__slice__impl_IteratorSpec_for_IterMut_T__produces_trans (* <std::slice::IterMut<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_IterMut_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_mut_seq_slice_T (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_slice_T_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq_slice_T self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_slice_T_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq_slice_T self)
        -> Seq.get (to_mut_seq_slice_T self) i
        = MutBorrow.borrow_logic (index_slice_T self.current i) (index_slice_T self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut_T) =
    to_mut_seq_slice_T (view_IterMut_T self) = Seq.(++) visited (to_mut_seq_slice_T (view_IterMut_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut_T
  
  constant ab : Seq.seq (MutBorrow.t t_T)
  
  constant b : t_IterMut_T
  
  constant bc : Seq.seq (MutBorrow.t t_T)
  
  constant c : t_IterMut_T
  
  function produces_trans_IterMut_T (a: t_IterMut_T) (ab: Seq.seq (MutBorrow.t t_T)) (b: t_IterMut_T) (bc: Seq.seq (MutBorrow.t t_T)) (c: t_IterMut_T) : ()
  
  goal vc_produces_trans_IterMut_T: produces_IterMut_T a ab b
    -> produces_IterMut_T b bc c -> ([@expl:produces_trans ensures] produces_IterMut_T a (Seq.(++) ab bc) c)
end
module M_std__vec__impl_IteratorSpec_for_IntoIter_T_A__produces_refl (* <std::vec::IntoIter<T, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T_A
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate produces_IntoIter_T_A (self: t_IntoIter_T_A) (visited: Seq.seq t_T) (rhs: t_IntoIter_T_A) =
    view_IntoIter_T_A self = Seq.(++) visited (view_IntoIter_T_A rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_T_A
  
  function produces_refl_IntoIter_T_A (self: t_IntoIter_T_A) : ()
  
  goal vc_produces_refl_IntoIter_T_A:
    [@expl:produces_refl ensures] produces_IntoIter_T_A self (Seq.empty: Seq.seq t_T) self
end
module M_std__vec__impl_IteratorSpec_for_IntoIter_T_A__produces_trans (* <std::vec::IntoIter<T, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T_A
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate produces_IntoIter_T_A (self: t_IntoIter_T_A) (visited: Seq.seq t_T) (rhs: t_IntoIter_T_A) =
    view_IntoIter_T_A self = Seq.(++) visited (view_IntoIter_T_A rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_T_A
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter_T_A
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter_T_A
  
  function produces_trans_IntoIter_T_A (a: t_IntoIter_T_A) (ab: Seq.seq t_T) (b: t_IntoIter_T_A) (bc: Seq.seq t_T) (c: t_IntoIter_T_A) : ()
  
  goal vc_produces_trans_IntoIter_T_A: produces_IntoIter_T_A a ab b
    -> produces_IntoIter_T_A b bc c -> ([@expl:produces_trans ensures] produces_IntoIter_T_A a (Seq.(++) ab bc) c)
end
module M_cell__permcell__impl_Resolve_for_PermCellOwn_T__resolve_coherence__refines (* <cell::permcell::PermCellOwn<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_PermCellOwn_T
  
  predicate structural_resolve_PermCellOwn_T (_1: t_PermCellOwn_T)
  
  predicate inv_PermCellOwn_T (_1: t_PermCellOwn_T)
  
  type t_T
  
  predicate resolve_ref_T [@inline:trivial] (_1: t_T) = true
  
  meta "rewrite_def" predicate resolve_ref_T
  
  function val_T (self: t_PermCellOwn_T) : t_T
  
  predicate resolve_PermCellOwn_T [@inline:trivial] (self: t_PermCellOwn_T) = resolve_ref_T (val_T self)
  
  meta "rewrite_def" predicate resolve_PermCellOwn_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_PermCellOwn_T. structural_resolve_PermCellOwn_T self /\ inv_PermCellOwn_T self
      -> structural_resolve_PermCellOwn_T self
      /\ inv_PermCellOwn_T self /\ (forall result: (). resolve_PermCellOwn_T self -> resolve_PermCellOwn_T self)
end
module M_invariant__impl_Resolve_for_Subset_T__resolve_coherence__refines (* <invariant::Subset<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_T
  
  predicate structural_resolve_Subset_T (_1: t_Subset_T)
  
  predicate inv_Subset_T [@inline:trivial] (_1: t_Subset_T) = true
  
  meta "rewrite_def" predicate inv_Subset_T
  
  type t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate invariant_T (self: t_T)
  
  function view_Subset_T (self: t_Subset_T) : t_T
  
  axiom view_Subset_T_spec: forall self: t_Subset_T. invariant_T (view_Subset_T self)
  
  predicate resolve_Subset_T [@inline:trivial] (self: t_Subset_T) = resolve_T (view_Subset_T self)
  
  meta "rewrite_def" predicate resolve_Subset_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Subset_T. structural_resolve_Subset_T self /\ inv_Subset_T self
      -> structural_resolve_Subset_T self /\ (forall result: (). resolve_Subset_T self -> resolve_Subset_T self)
end
module M_logic__fmap__impl_Resolve_for_FMap_K_V__resolve_coherence__refines (* <logic::fmap::FMap<K, V> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  predicate structural_resolve_FMap_K_V (_1: t_FMap_K_V)
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_FMap_K_V (self: t_FMap_K_V) =
    forall k: t_K, v: t_V. get_K self k = Some v -> resolve_K k /\ resolve_V v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. structural_resolve_FMap_K_V self /\ inv_FMap_K_V self
      -> structural_resolve_FMap_K_V self /\ (forall result: (). resolve_FMap_K_V self -> resolve_FMap_K_V self)
end
module M_logic__fmap__impl_Resolve_for_FMapIter_K_V__resolve_coherence__refines (* <logic::fmap::FMapIter<K, V> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_FMapIter_K_V = { inner: t_FMap_K_V }
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_FMap_K_V (self: t_FMap_K_V) =
    forall k: t_K, v: t_V. get_K self k = Some v -> resolve_K k /\ resolve_V v
  
  predicate resolve_FMap_K_V'0 (_1: t_FMap_K_V)
  
  axiom resolve_axiom: forall x: t_FMap_K_V [resolve_FMap_K_V'0 x]. resolve_FMap_K_V'0 x -> resolve_FMap_K_V x
  
  predicate structural_resolve_FMapIter_K_V (_1: t_FMapIter_K_V) = resolve_FMap_K_V'0 _1.inner
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate inv_FMapIter_K_V (_1: t_FMapIter_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMapIter_K_V [inv_FMapIter_K_V x]. inv_FMapIter_K_V x = inv_FMap_K_V x.inner
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V = self.inner
  
  predicate resolve_FMapIter_K_V (self: t_FMapIter_K_V) = resolve_FMap_K_V'0 (view_FMapIter_K_V self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMapIter_K_V. structural_resolve_FMapIter_K_V self /\ inv_FMapIter_K_V self
      -> structural_resolve_FMapIter_K_V self
      /\ (forall result: (). resolve_FMapIter_K_V self -> resolve_FMapIter_K_V self)
end
module M_logic__fset__impl_Resolve_for_FSet_T__resolve_coherence__refines (* <logic::fset::FSet<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate structural_resolve_FSet_T (_1: Fset.fset t_T)
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_FSet_T [@inline:trivial] (self: Fset.fset t_T) = forall x: t_T. contains_T self x -> inv_T x
  
  meta "rewrite_def" predicate invariant_FSet_T
  
  predicate inv_FSet_T [@inline:trivial] (_1: Fset.fset t_T) = invariant_FSet_T _1
  
  meta "rewrite_def" predicate inv_FSet_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_FSet_T (self: Fset.fset t_T) = forall x: t_T. contains_T self x -> resolve_T x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Fset.fset t_T. structural_resolve_FSet_T self /\ inv_FSet_T self
      -> structural_resolve_FSet_T self /\ (forall result: (). resolve_FSet_T self -> resolve_FSet_T self)
end
module M_logic__seq__impl_Resolve_for_Seq_T__resolve_coherence__refines (* <logic::seq::Seq<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate structural_resolve_Seq_T (_1: Seq.seq t_T)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  type t_Option_T = None | Some t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  predicate resolve_Seq_T (self: Seq.seq t_T) = forall i: int. resolve_Option_T (get_T self i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Seq.seq t_T. structural_resolve_Seq_T self /\ inv_Seq_T self
      -> structural_resolve_Seq_T self /\ (forall result: (). resolve_Seq_T self -> resolve_Seq_T self)
end
module M_logic__seq__impl_Resolve_for_SeqIter_T__resolve_coherence__refines (* <logic::seq::SeqIter<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  type t_Option_T = None | Some t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  predicate resolve_Seq_T (self: Seq.seq t_T) = forall i: int. resolve_Option_T (get_T self i)
  
  predicate resolve_Seq_T'0 (_1: Seq.seq t_T)
  
  axiom resolve_axiom'0: forall x: Seq.seq t_T [resolve_Seq_T'0 x]. resolve_Seq_T'0 x -> resolve_Seq_T x
  
  predicate structural_resolve_SeqIter_T (_1: t_SeqIter_T) = resolve_Seq_T'0 _1.inner
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate inv_SeqIter_T (_1: t_SeqIter_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter_T [inv_SeqIter_T x]. inv_SeqIter_T x = inv_Seq_T x.inner
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate resolve_SeqIter_T [@inline:trivial] (self: t_SeqIter_T) = resolve_Seq_T'0 (view_SeqIter_T self)
  
  meta "rewrite_def" predicate resolve_SeqIter_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIter_T. structural_resolve_SeqIter_T self /\ inv_SeqIter_T self
      -> structural_resolve_SeqIter_T self /\ (forall result: (). resolve_SeqIter_T self -> resolve_SeqIter_T self)
end
module M_resolve__impl_Resolve_for_ref_T__resolve_coherence__refines (* <&'a T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate structural_resolve_ref_T (_1: t_T) = true
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate resolve_ref_T (self: t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_T. structural_resolve_ref_T self /\ inv_ref_T self
      -> (forall result: (). resolve_ref_T self -> resolve_ref_T self)
end
module M_resolve__impl_Resolve_for_ref_T_0__resolve_coherence__refines (* <&'a mut T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate structural_resolve_ref_T (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate resolve_ref_T (self: MutBorrow.t t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t t_T. structural_resolve_ref_T self /\ inv_ref_T self
      -> (forall result: (). resolve_ref_T self -> resolve_ref_T self)
end
module M_std__array__impl_Resolve_for_array_T_n__resolve_coherence__refines (* <[T; N] as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  
  type t_T
  
  predicate structural_resolve_array_T_n (_1: Slice64.array t_T)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  constant const_N : UInt64.t
  
  predicate invariant_array_T_n (self: Slice64.array t_T) =
    inv_Seq_T (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int const_N
  
  predicate inv_array_T_n [@inline:trivial] (_1: Slice64.array t_T) = invariant_array_T_n _1
  
  meta "rewrite_def" predicate inv_array_T_n
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_array_T_n [@inline:trivial] (self: Slice64.array t_T) =
    forall i: int. 0 <= i /\ i < UInt64.t'int const_N -> resolve_T (Seq.get (Slice64.view self) i)
  
  meta "rewrite_def" predicate resolve_array_T_n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.array t_T. structural_resolve_array_T_n self /\ inv_array_T_n self
      -> structural_resolve_array_T_n self /\ (forall result: (). resolve_array_T_n self -> resolve_array_T_n self)
end
module M_std__boxed__impl_Resolve_for_Box_T_A__resolve_coherence__refines (* <std::boxed::Box<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate structural_resolve_Box_T_A (_1: t_T) = resolve_T _1
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_A (self: t_T) = inv_T self
  
  predicate inv_Box_T_A [@inline:trivial] (_1: t_T) = invariant_Box_T_A _1
  
  meta "rewrite_def" predicate inv_Box_T_A
  
  predicate resolve_Box_T_A [@inline:trivial] (self: t_T) = true
  
  meta "rewrite_def" predicate resolve_Box_T_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_T. structural_resolve_Box_T_A self /\ inv_Box_T_A self
      -> structural_resolve_Box_T_A self /\ (forall result: (). resolve_Box_T_A self -> resolve_Box_T_A self)
end
module M_std__deque__impl_Resolve_for_VecDeque_T_A__resolve_coherence__refines (* <std::collections::VecDeque<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  
  type t_VecDeque_T_A
  
  predicate structural_resolve_VecDeque_T_A (_1: t_VecDeque_T_A)
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_VecDeque_T_A (self: t_VecDeque_T_A) : Seq.seq t_T
  
  axiom view_VecDeque_T_A_spec: forall self: t_VecDeque_T_A. Seq.length (view_VecDeque_T_A self)
      <= UInt64.t'int const_MAX
  
  predicate invariant_VecDeque_T_A (self: t_VecDeque_T_A) = inv_Seq_T (view_VecDeque_T_A self)
  
  predicate inv_VecDeque_T_A (_1: t_VecDeque_T_A)
  
  axiom inv_axiom: forall x: t_VecDeque_T_A [inv_VecDeque_T_A x]. inv_VecDeque_T_A x -> invariant_VecDeque_T_A x
  
  predicate resolve_T (_1: t_T)
  
  function index_VecDeque_T_A [@inline:trivial] (self: t_VecDeque_T_A) (ix: int) : t_T =
    Seq.get (view_VecDeque_T_A self) ix
  
  meta "rewrite_def" function index_VecDeque_T_A
  
  predicate resolve_VecDeque_T_A [@inline:trivial] (self: t_VecDeque_T_A) =
    forall i: int. 0 <= i /\ i < Seq.length (view_VecDeque_T_A self) -> resolve_T (index_VecDeque_T_A self i)
  
  meta "rewrite_def" predicate resolve_VecDeque_T_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_VecDeque_T_A. structural_resolve_VecDeque_T_A self /\ inv_VecDeque_T_A self
      -> structural_resolve_VecDeque_T_A self
      /\ (forall result: (). resolve_VecDeque_T_A self -> resolve_VecDeque_T_A self)
end
module M_std__iter__cloned__impl_Resolve_for_Cloned_I__resolve_coherence__refines (* <std::iter::Cloned<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Cloned_I
  
  predicate structural_resolve_Cloned_I (_1: t_Cloned_I)
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate invariant_Cloned_I [@inline:trivial] (self: t_Cloned_I) = inv_I (iter_Cloned_I self)
  
  meta "rewrite_def" predicate invariant_Cloned_I
  
  predicate inv_Cloned_I (_1: t_Cloned_I)
  
  axiom inv_axiom: forall x: t_Cloned_I [inv_Cloned_I x]. inv_Cloned_I x -> invariant_Cloned_I x
  
  predicate resolve_I (_1: t_I)
  
  predicate resolve_Cloned_I [@inline:trivial] (self: t_Cloned_I) = resolve_I (iter_Cloned_I self)
  
  meta "rewrite_def" predicate resolve_Cloned_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Cloned_I. structural_resolve_Cloned_I self /\ inv_Cloned_I self
      -> structural_resolve_Cloned_I self /\ (forall result: (). resolve_Cloned_I self -> resolve_Cloned_I self)
end
module M_std__iter__copied__impl_Resolve_for_Copied_I__resolve_coherence__refines (* <std::iter::Copied<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Copied_I
  
  predicate structural_resolve_Copied_I (_1: t_Copied_I)
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate invariant_Copied_I [@inline:trivial] (self: t_Copied_I) = inv_I (iter_Copied_I self)
  
  meta "rewrite_def" predicate invariant_Copied_I
  
  predicate inv_Copied_I (_1: t_Copied_I)
  
  axiom inv_axiom: forall x: t_Copied_I [inv_Copied_I x]. inv_Copied_I x -> invariant_Copied_I x
  
  predicate resolve_I (_1: t_I)
  
  predicate resolve_Copied_I [@inline:trivial] (self: t_Copied_I) = resolve_I (iter_Copied_I self)
  
  meta "rewrite_def" predicate resolve_Copied_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Copied_I. structural_resolve_Copied_I self /\ inv_Copied_I self
      -> structural_resolve_Copied_I self /\ (forall result: (). resolve_Copied_I self -> resolve_Copied_I self)
end
module M_std__iter__enumerate__impl_Resolve_for_Enumerate_I__resolve_coherence__refines (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Enumerate_I
  
  predicate structural_resolve_Enumerate_I (_1: t_Enumerate_I)
  
  predicate inv_Enumerate_I (_1: t_Enumerate_I)
  
  type t_I
  
  predicate resolve_I (_1: t_I)
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate resolve_Enumerate_I [@inline:trivial] (self: t_Enumerate_I) = resolve_I (iter_Enumerate_I self)
  
  meta "rewrite_def" predicate resolve_Enumerate_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Enumerate_I. structural_resolve_Enumerate_I self /\ inv_Enumerate_I self
      -> structural_resolve_Enumerate_I self
      /\ (forall result: (). resolve_Enumerate_I self -> resolve_Enumerate_I self)
end
module M_std__iter__map__impl_Resolve_for_Map_I_F__resolve_coherence__refines (* <std::iter::Map<I, F> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Map_I_F
  
  predicate structural_resolve_Map_I_F (_1: t_Map_I_F)
  
  predicate inv_Map_I_F (_1: t_Map_I_F)
  
  type t_I
  
  predicate resolve_I (_1: t_I)
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  type t_F
  
  predicate resolve_F (_1: t_F)
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  predicate resolve_Map_I_F [@inline:trivial] (self: t_Map_I_F) =
    resolve_I (iter_Map_I_F self) /\ resolve_F (func_Map_I_F self)
  
  meta "rewrite_def" predicate resolve_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map_I_F. structural_resolve_Map_I_F self /\ inv_Map_I_F self
      -> structural_resolve_Map_I_F self /\ (forall result: (). resolve_Map_I_F self -> resolve_Map_I_F self)
end
module M_std__iter__skip__impl_Resolve_for_Skip_I__resolve_coherence__refines (* <std::iter::Skip<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Skip_I
  
  predicate structural_resolve_Skip_I (_1: t_Skip_I)
  
  predicate inv_Skip_I (_1: t_Skip_I)
  
  type t_I
  
  predicate resolve_I (_1: t_I)
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Skip_I [@inline:trivial] (self: t_Skip_I) = resolve_I (iter_Skip_I self)
  
  meta "rewrite_def" predicate resolve_Skip_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Skip_I. structural_resolve_Skip_I self /\ inv_Skip_I self
      -> structural_resolve_Skip_I self /\ (forall result: (). resolve_Skip_I self -> resolve_Skip_I self)
end
module M_std__iter__take__impl_Resolve_for_Take_I__resolve_coherence__refines (* <std::iter::Take<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Take_I
  
  predicate structural_resolve_Take_I (_1: t_Take_I)
  
  predicate inv_Take_I (_1: t_Take_I)
  
  type t_I
  
  predicate resolve_I (_1: t_I)
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate resolve_Take_I [@inline:trivial] (self: t_Take_I) = resolve_I (iter_Take_I self)
  
  meta "rewrite_def" predicate resolve_Take_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Take_I. structural_resolve_Take_I self /\ inv_Take_I self
      -> structural_resolve_Take_I self /\ (forall result: (). resolve_Take_I self -> resolve_Take_I self)
end
module M_std__slice__impl_Resolve_for_slice_T__resolve_coherence__refines (* <[T] as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate structural_resolve_slice_T (_1: Slice64.slice t_T)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate resolve_T (_1: t_T)
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  predicate resolve_slice_T [@inline:trivial] (self: Slice64.slice t_T) =
    forall i: int. 0 <= i /\ i < Seq.length (Slice64.view self) -> resolve_T (index_slice_T self i)
  
  meta "rewrite_def" predicate resolve_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.slice t_T. structural_resolve_slice_T self /\ inv_slice_T self
      -> structural_resolve_slice_T self /\ (forall result: (). resolve_slice_T self -> resolve_slice_T self)
end
module M_std__slice__impl_Resolve_for_IterMut_T__resolve_coherence__refines (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  
  type t_IterMut_T
  
  predicate structural_resolve_IterMut_T (_1: t_IterMut_T)
  
  predicate inv_IterMut_T (_1: t_IterMut_T)
  
  type t_T
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate resolve_IterMut_T [@inline:trivial] (self: t_IterMut_T) =
    (view_IterMut_T self).current = (view_IterMut_T self).final
  
  meta "rewrite_def" predicate resolve_IterMut_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IterMut_T. structural_resolve_IterMut_T self /\ inv_IterMut_T self
      -> structural_resolve_IterMut_T self /\ (forall result: (). resolve_IterMut_T self -> resolve_IterMut_T self)
end
module M_std__vec__impl_Resolve_for_Vec_T_A__resolve_coherence__refines (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  
  type t_Vec_T_A
  
  predicate structural_resolve_Vec_T_A (_1: t_Vec_T_A)
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_T_A (self: t_Vec_T_A) : Seq.seq t_T
  
  axiom view_Vec_T_A_spec: forall self: t_Vec_T_A. Seq.length (view_Vec_T_A self) <= UInt64.t'int const_MAX
  
  predicate invariant_Vec_T_A (self: t_Vec_T_A) = inv_Seq_T (view_Vec_T_A self)
  
  predicate inv_Vec_T_A (_1: t_Vec_T_A)
  
  axiom inv_axiom: forall x: t_Vec_T_A [inv_Vec_T_A x]. inv_Vec_T_A x -> invariant_Vec_T_A x
  
  predicate resolve_T (_1: t_T)
  
  function index_Vec_T_A [@inline:trivial] (self: t_Vec_T_A) (ix: int) : t_T = Seq.get (view_Vec_T_A self) ix
  
  meta "rewrite_def" function index_Vec_T_A
  
  predicate resolve_Vec_T_A [@inline:trivial] (self: t_Vec_T_A) =
    forall i: int. 0 <= i /\ i < Seq.length (view_Vec_T_A self) -> resolve_T (index_Vec_T_A self i)
  
  meta "rewrite_def" predicate resolve_Vec_T_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Vec_T_A. structural_resolve_Vec_T_A self /\ inv_Vec_T_A self
      -> structural_resolve_Vec_T_A self /\ (forall result: (). resolve_Vec_T_A self -> resolve_Vec_T_A self)
end
module M_std__vec__impl_Resolve_for_IntoIter_T_A__resolve_coherence__refines (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  use seq.Seq
  
  type t_IntoIter_T_A
  
  predicate structural_resolve_IntoIter_T_A (_1: t_IntoIter_T_A)
  
  predicate inv_IntoIter_T_A (_1: t_IntoIter_T_A)
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_IntoIter_T_A [@inline:trivial] (self: t_IntoIter_T_A) =
    forall i: int. 0 <= i /\ i < Seq.length (view_IntoIter_T_A self) -> resolve_T (Seq.get (view_IntoIter_T_A self) i)
  
  meta "rewrite_def" predicate resolve_IntoIter_T_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T_A. structural_resolve_IntoIter_T_A self /\ inv_IntoIter_T_A self
      -> structural_resolve_IntoIter_T_A self
      /\ (forall result: (). resolve_IntoIter_T_A self -> resolve_IntoIter_T_A self)
end
module M_ghost__fn_ghost__impl_Clone_for_FnGhostWrapper_F__clone__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  predicate invariant_ref_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) = inv_FnGhostWrapper_F self
  
  meta "rewrite_def" predicate invariant_ref_FnGhostWrapper_F
  
  predicate inv_ref_FnGhostWrapper_F [@inline:trivial] (_1: t_FnGhostWrapper_F) = invariant_ref_FnGhostWrapper_F _1
  
  meta "rewrite_def" predicate inv_ref_FnGhostWrapper_F
  
  predicate postcondition_once_clone (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef:
    forall args: t_F, res: t_F [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_F res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_F, res: t_F [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_F res)
  
  function fn_mut_once_clone (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_F, res: t_F. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1:
    forall args: t_F, res: t_F [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_F res)
  
  function fn_once_clone (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_F, res: t_F. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate invariant_ref_F [@inline:trivial] (self: t_F) = inv_F self
  
  meta "rewrite_def" predicate invariant_ref_F
  
  predicate inv_ref_F [@inline:trivial] (_1: t_F) = invariant_ref_F _1
  
  meta "rewrite_def" predicate inv_ref_F
  
  predicate precondition_clone (self: ()) (args: t_F)
  
  axiom precondition_fndef: forall args: t_F [precondition_clone () args]. (let self_ = args in inv_ref_F self_)
      -> precondition_clone () args
  
  let rec clone_F (self_: t_F) (return (x: t_F)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_F) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  function view_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) : t_F = self.f0
  
  meta "rewrite_def" function view_FnGhostWrapper_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper_F. inv_ref_FnGhostWrapper_F self_
      -> inv_ref_FnGhostWrapper_F self_
      /\ (forall result: t_FnGhostWrapper_F. postcondition_clone () (view_FnGhostWrapper_F self_) (view_FnGhostWrapper_F result)
          /\ inv_FnGhostWrapper_F result -> inv_FnGhostWrapper_F result)
end
module M_ghost__resource__fmap_view__impl_Clone_for_Fragment_K_V__clone__refines (* <ghost::resource::fmap_view::Fragment<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  type t_K
  
  type t_V
  
  type t_Fragment_K_V = { f0: t_Resource_View_AuthViewRel_FMap_K_Ag_V; f1: t_K; f2: t_V }
  
  type t_FMap_K_Ag_V
  
  type t_Ag_V = { f0'0: t_V }
  
  type t_Option_Ag_V = None | Some t_Ag_V
  
  function view_FMap_K_Ag_V (self: t_FMap_K_Ag_V) : Map.map t_K t_Option_Ag_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_Ag_V) (k: t_K) : t_Option_Ag_V = Map.get (view_FMap_K_Ag_V self) k
  
  meta "rewrite_def" function get_K
  
  type t_View_AuthViewRel_FMap_K_Ag_V
  
  type t_Option_FMap_K_Ag_V = None'0 | Some'0 t_FMap_K_Ag_V
  
  function and_then_Option_FMap_K_Ag_V (self: t_Option_FMap_K_Ag_V) (f: Map.map t_FMap_K_Ag_V t_Option_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type t_Option_Option_Ag_V = None'1 | Some'1 t_Option_Ag_V
  
  function and_then_Option_Option_Ag_V (self: t_Option_Option_Ag_V) (f: Map.map t_Option_Ag_V t_Option_Option_Ag_V) : t_Option_Option_Ag_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_Ag_V_Option_Ag_V = { f0'1: t_Option_Ag_V; f1'1: t_Option_Ag_V }
  
  function map_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Option_Ag_V =
    match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_Ag_V (self: t_Option_Ag_V) (f: Map.map t_Ag_V t_Option_Ag_V) : t_Option_Ag_V =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Ag_V (self: t_Ag_V) (other: t_Ag_V) : t_Option_Ag_V = if self.f0'0 = other.f0'0 then Some self else None
  
  function associative_Ag_V (a: t_Ag_V) (b: t_Ag_V) (c: t_Ag_V) : ()
  
  axiom associative_Ag_V_spec:
    forall a: t_Ag_V, b: t_Ag_V, c: t_Ag_V. and_then_Option_Ag_V (op_Ag_V a b) (fun (ab: t_Ag_V) -> op_Ag_V ab c)
      = and_then_Option_Ag_V (op_Ag_V b c) (fun (bc: t_Ag_V) -> op_Ag_V a bc)
  
  function commutative_Ag_V (a: t_Ag_V) (b: t_Ag_V) : ()
  
  axiom commutative_Ag_V_spec: forall a: t_Ag_V, b: t_Ag_V. op_Ag_V a b = op_Ag_V b a
  
  function op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) : t_Option_Option_Ag_V = match { f0'1 = self;
                                                                                                        f1'1 = other } with
      | {f0'1 = None} -> Some'1 other
      | {f1'1 = None} -> Some'1 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_Ag_V (op_Ag_V x y) (fun (z: t_Ag_V) -> Some z)
      end
  
  function associative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom associative_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. and_then_Option_Option_Ag_V (op_Option_Ag_V a b) (fun (ab: t_Option_Ag_V) -> op_Option_Ag_V ab c)
      = and_then_Option_Option_Ag_V (op_Option_Ag_V b c) (fun (bc: t_Option_Ag_V) -> op_Option_Ag_V a bc)
  
  function commutative_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) : ()
  
  axiom commutative_Option_Ag_V_spec: forall a: t_Option_Ag_V, b: t_Option_Ag_V. op_Option_Ag_V a b = op_Option_Ag_V b a
  
  function total_op_K (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V. (forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k)
          <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_Ag_V (get_K self k) (get_K other k))
  
  function op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. op_Option_Ag_V (get_K self k) (get_K other k) <> None'1 then
      Some'0 (total_op_K self other)
    else
      None'0
  
  
  function associative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom associative_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V a b) (fun (ab: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V ab c)
      = and_then_Option_FMap_K_Ag_V (op_FMap_K_Ag_V b c) (fun (bc: t_FMap_K_Ag_V) -> op_FMap_K_Ag_V a bc)
  
  function commutative_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) : ()
  
  axiom commutative_FMap_K_Ag_V_spec: forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V. op_FMap_K_Ag_V a b = op_FMap_K_Ag_V b a
  
  function len_K (self: t_FMap_K_Ag_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_Ag_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_Ag_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_Ag_V empty_K = Const.const (None)
  
  constant unit_FMap_K_Ag_V: t_FMap_K_Ag_V = empty_K
  
  axiom unit_FMap_K_Ag_V_spec:
    forall x: t_FMap_K_Ag_V [op_FMap_K_Ag_V x unit_FMap_K_Ag_V]. op_FMap_K_Ag_V x unit_FMap_K_Ag_V = Some'0 x
  
  function factor_Ag_V (self: t_Ag_V) (factor: t_Ag_V) : t_Option_Ag_V = op_Ag_V self factor
  
  axiom factor_Ag_V_spec: forall self: t_Ag_V, factor: t_Ag_V. match factor_Ag_V self factor with
        | Some c -> op_Ag_V factor c = Some self
        | None -> forall c: t_Ag_V. op_Ag_V factor c <> Some self
        end
  
  function factor_Option_Ag_V (self: t_Option_Ag_V) (factor: t_Option_Ag_V) : t_Option_Option_Ag_V =
    match { f0'1 = self; f1'1 = factor } with
      | {f0'1 = x; f1'1 = None} -> Some'1 x
      | {f0'1 = None} -> None'1
      | {f0'1 = Some x; f1'1 = Some y} -> match factor_Ag_V x y with
        | Some z -> Some'1 (Some z)
        | None -> if x = y then Some'1 (None) else None'1
        end
      end
  
  axiom factor_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, factor: t_Option_Ag_V. match factor_Option_Ag_V self factor with
        | Some'1 c -> op_Option_Ag_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_Ag_V. op_Option_Ag_V factor c <> Some'1 self
        end
  
  predicate incl_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) = factor_Option_Ag_V other self <> None'1
  
  function incl_transitive_Option_Ag_V (a: t_Option_Ag_V) (b: t_Option_Ag_V) (c: t_Option_Ag_V) : ()
  
  axiom incl_transitive_Option_Ag_V_spec:
    forall a: t_Option_Ag_V, b: t_Option_Ag_V, c: t_Option_Ag_V. incl_Option_Ag_V a b
      -> incl_Option_Ag_V b c -> incl_Option_Ag_V a c
  
  function incl_op_Option_Ag_V (self: t_Option_Ag_V) (other: t_Option_Ag_V) (comb: t_Option_Ag_V) : ()
  
  axiom incl_op_Option_Ag_V_spec:
    forall self: t_Option_Ag_V, other: t_Option_Ag_V, comb: t_Option_Ag_V. op_Option_Ag_V self other = Some'1 comb
      -> incl_Option_Ag_V self comb
  
  type tup2_K_Ag_V = { f0'2: t_K; f1'2: t_Ag_V }
  
  function index_Mapping_tup2_K_Ag_V_Option_Ag_V [@inline:trivial] (self: Map.map tup2_K_Ag_V t_Option_Ag_V) (a: tup2_K_Ag_V) : t_Option_Ag_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_Ag_V_Option_Ag_V
  
  function filter_map_K (self: t_FMap_K_Ag_V) (f: Map.map tup2_K_Ag_V t_Option_Ag_V) : t_FMap_K_Ag_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_Ag_V, f: Map.map tup2_K_Ag_V t_Option_Ag_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None -> None
          | Some v -> index_Mapping_tup2_K_Ag_V_Option_Ag_V f { f0'2 = k; f1'2 = v }
          end
  
  function factor_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (factor: t_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V =
    if forall k: t_K. incl_Option_Ag_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_Ag_V) -> let {f0'2 = k; f1'2 = vo} = __0 in match factor_Option_Ag_V (Some vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None
        end) in Some'0 res
    else
      None'0
  
  
  axiom factor_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, factor: t_FMap_K_Ag_V. match factor_FMap_K_Ag_V self factor with
        | Some'0 c -> op_FMap_K_Ag_V factor c = Some'0 self
        | None'0 -> forall c: t_FMap_K_Ag_V. op_FMap_K_Ag_V factor c <> Some'0 self
        end
  
  predicate incl_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) = factor_FMap_K_Ag_V other self <> None'0
  
  function incl_transitive_FMap_K_Ag_V (a: t_FMap_K_Ag_V) (b: t_FMap_K_Ag_V) (c: t_FMap_K_Ag_V) : ()
  
  axiom incl_transitive_FMap_K_Ag_V_spec:
    forall a: t_FMap_K_Ag_V, b: t_FMap_K_Ag_V, c: t_FMap_K_Ag_V. incl_FMap_K_Ag_V a b
      -> incl_FMap_K_Ag_V b c -> incl_FMap_K_Ag_V a c
  
  function incl_op_FMap_K_Ag_V (self: t_FMap_K_Ag_V) (other: t_FMap_K_Ag_V) (comb: t_FMap_K_Ag_V) : ()
  
  axiom incl_op_FMap_K_Ag_V_spec:
    forall self: t_FMap_K_Ag_V, other: t_FMap_K_Ag_V, comb: t_FMap_K_Ag_V. op_FMap_K_Ag_V self other = Some'0 comb
      -> incl_FMap_K_Ag_V self comb
  
  predicate rel_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) =
    match a with
      | Some'0 a'0 -> incl_FMap_K_Ag_V f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) : ()
  
  axiom rel_unit_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a unit_FMap_K_Ag_V
  
  function rel_none_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f: t_FMap_K_Ag_V) : ()
  
  axiom rel_none_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (None'0) f
  
  function rel_mono_AuthViewRel_FMap_K_Ag_V (a: t_Option_FMap_K_Ag_V) (f1'0: t_FMap_K_Ag_V) (f2'0: t_FMap_K_Ag_V) : ()
  
  axiom rel_mono_AuthViewRel_FMap_K_Ag_V_spec:
    forall a: t_Option_FMap_K_Ag_V, f1'0: t_FMap_K_Ag_V, f2'0: t_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V a f1'0
      -> incl_FMap_K_Ag_V f2'0 f1'0 -> rel_AuthViewRel_FMap_K_Ag_V a f2'0
  
  function auth_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_Option_FMap_K_Ag_V
  
  function frag_AuthViewRel_FMap_K_Ag_V (self: t_View_AuthViewRel_FMap_K_Ag_V) : t_FMap_K_Ag_V
  
  axiom frag_AuthViewRel_FMap_K_Ag_V_spec:
    forall self: t_View_AuthViewRel_FMap_K_Ag_V. rel_AuthViewRel_FMap_K_Ag_V (auth_AuthViewRel_FMap_K_Ag_V self) (frag_AuthViewRel_FMap_K_Ag_V self)
  
  function val_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
  
  function view_Resource_View_AuthViewRel_FMap_K_Ag_V [@inline:trivial] (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_View_AuthViewRel_FMap_K_Ag_V
   = val_View_AuthViewRel_FMap_K_Ag_V self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_FMap_K_Ag_V
  
  predicate invariant_Fragment_K_V (self: t_Fragment_K_V) =
    get_K (frag_AuthViewRel_FMap_K_Ag_V (view_Resource_View_AuthViewRel_FMap_K_Ag_V self.f0)) self.f1
    = Some { f0'0 = self.f2 }
  
  predicate inv_Fragment_K_V (_1: t_Fragment_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment_K_V [inv_Fragment_K_V x]. inv_Fragment_K_V x
      = invariant_Fragment_K_V x
  
  predicate invariant_ref_Fragment_K_V [@inline:trivial] (self: t_Fragment_K_V) = inv_Fragment_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Fragment_K_V
  
  predicate inv_ref_Fragment_K_V [@inline:trivial] (_1: t_Fragment_K_V) = invariant_ref_Fragment_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Fragment_K_V
  
  type t_Id
  
  function id_View_AuthViewRel_FMap_K_Ag_V (self: t_Resource_View_AuthViewRel_FMap_K_Ag_V) : t_Id
  
  function id_K (self: t_Fragment_K_V) : t_Id = id_View_AuthViewRel_FMap_K_Ag_V self.f0
  
  type tup2_K_V = { f0'3: t_K; f1'3: t_V }
  
  function view_Fragment_K_V (self: t_Fragment_K_V) : tup2_K_V = { f0'3 = self.f1; f1'3 = self.f2 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Fragment_K_V. inv_ref_Fragment_K_V self_
      -> inv_ref_Fragment_K_V self_
      /\ (forall result: t_Fragment_K_V. id_K result = id_K self_
          /\ view_Fragment_K_V result = view_Fragment_K_V self_ /\ inv_Fragment_K_V result -> inv_Fragment_K_V result)
end
module M_ghost__impl_Clone_for_Ghost_T__clone__refines (* <ghost::Ghost<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Ghost_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_Ghost_T
  
  predicate inv_Ghost_T [@inline:trivial] (_1: t_T) = invariant_Ghost_T _1
  
  meta "rewrite_def" predicate inv_Ghost_T
  
  predicate invariant_ref_Ghost_T [@inline:trivial] (self: t_T) = inv_Ghost_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_T
  
  predicate inv_ref_Ghost_T [@inline:trivial] (_1: t_T) = invariant_ref_Ghost_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_T. inv_ref_Ghost_T self_
      -> inv_ref_Ghost_T self_ /\ (forall result: t_T. result = self_ /\ inv_Ghost_T result -> inv_Ghost_T result)
end
module M_logic__fmap__impl_Clone_for_FMap_K_V__clone__refines (* <logic::fmap::FMap<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FMap_K_V. inv_ref_FMap_K_V self_
      -> inv_ref_FMap_K_V self_
      /\ (forall result: t_FMap_K_V. result = self_ /\ inv_FMap_K_V result -> inv_FMap_K_V result)
end
module M_logic__fset__impl_Clone_for_FSet_T__clone__refines (* <logic::fset::FSet<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_FSet_T [@inline:trivial] (self: Fset.fset t_T) = forall x: t_T. contains_T self x -> inv_T x
  
  meta "rewrite_def" predicate invariant_FSet_T
  
  predicate inv_FSet_T [@inline:trivial] (_1: Fset.fset t_T) = invariant_FSet_T _1
  
  meta "rewrite_def" predicate inv_FSet_T
  
  predicate invariant_ref_FSet_T [@inline:trivial] (self: Fset.fset t_T) = inv_FSet_T self
  
  meta "rewrite_def" predicate invariant_ref_FSet_T
  
  predicate inv_ref_FSet_T [@inline:trivial] (_1: Fset.fset t_T) = invariant_ref_FSet_T _1
  
  meta "rewrite_def" predicate inv_ref_FSet_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: Fset.fset t_T. inv_ref_FSet_T self_
      -> inv_ref_FSet_T self_
      /\ (forall result: Fset.fset t_T. result = self_ /\ inv_FSet_T result -> inv_FSet_T result)
end
module M_logic__seq__impl_Clone_for_Seq_T__clone__refines (* <logic::seq::Seq<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: Seq.seq t_T. inv_ref_Seq_T self_
      -> inv_ref_Seq_T self_ /\ (forall result: Seq.seq t_T. result = self_ /\ inv_Seq_T result -> inv_Seq_T result)
end
module M_ghost__fn_ghost__impl_FnOnce_for_FnGhostWrapper_F__call_once__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::FnOnce<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  type t_I
  
  predicate precondition_F (self: t_F) (args: t_I)
  
  predicate precondition_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) =
    precondition_F self.f0 args
  
  meta "rewrite_def" predicate precondition_FnGhostWrapper_F
  
  predicate inv_I (_1: t_I)
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  type t_Output
  
  predicate postcondition_F (self: t_F) (args: t_I) (result: t_Output)
  
  predicate postcondition_once_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) (result: t_Output) =
    postcondition_F self.f0 args result
  
  meta "rewrite_def" predicate postcondition_once_FnGhostWrapper_F
  
  predicate inv_Output (_1: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper_F. forall arg: t_I. precondition_FnGhostWrapper_F self_ arg
          /\ inv_I arg /\ inv_FnGhostWrapper_F self_
        -> precondition_FnGhostWrapper_F self_ arg
        /\ inv_I arg
        /\ inv_FnGhostWrapper_F self_
        /\ (forall result: t_Output. postcondition_once_FnGhostWrapper_F self_ arg result /\ inv_Output result
          -> postcondition_once_FnGhostWrapper_F self_ arg result /\ inv_Output result)
end
module M_ghost__fn_ghost__impl_FnMut_for_FnGhostWrapper_F__call_mut__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::FnMut<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  type t_I
  
  predicate precondition_F (self: t_F) (args: t_I)
  
  predicate precondition_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) =
    precondition_F self.f0 args
  
  meta "rewrite_def" predicate precondition_FnGhostWrapper_F
  
  predicate inv_I (_1: t_I)
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  predicate invariant_ref_FnGhostWrapper_F [@inline:trivial] (self: MutBorrow.t t_FnGhostWrapper_F) =
    inv_FnGhostWrapper_F self.current /\ inv_FnGhostWrapper_F self.final
  
  meta "rewrite_def" predicate invariant_ref_FnGhostWrapper_F
  
  predicate inv_ref_FnGhostWrapper_F [@inline:trivial] (_1: MutBorrow.t t_FnGhostWrapper_F) =
    invariant_ref_FnGhostWrapper_F _1
  
  meta "rewrite_def" predicate inv_ref_FnGhostWrapper_F
  
  type t_Output
  
  predicate postcondition_F (self: t_F) (args: t_I) (result: t_Output)
  
  predicate postcondition_mut_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) (result_state: t_FnGhostWrapper_F) (result: t_Output) =
    postcondition_F self.f0 args result /\ self = result_state
  
  meta "rewrite_def" predicate postcondition_mut_FnGhostWrapper_F
  
  predicate inv_Output (_1: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self_: MutBorrow.t t_FnGhostWrapper_F. forall arg: t_I. precondition_FnGhostWrapper_F self_.current arg
          /\ inv_I arg /\ inv_ref_FnGhostWrapper_F self_
        -> precondition_FnGhostWrapper_F self_.current arg
        /\ inv_I arg
        /\ inv_ref_FnGhostWrapper_F self_
        /\ (forall result: t_Output. postcondition_mut_FnGhostWrapper_F self_.current arg self_.final result
            /\ inv_Output result
          -> postcondition_mut_FnGhostWrapper_F self_.current arg self_.final result /\ inv_Output result)
end
module M_ghost__fn_ghost__impl_Fn_for_FnGhostWrapper_F__call__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::Fn<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  type t_I
  
  predicate precondition_F (self: t_F) (args: t_I)
  
  predicate precondition_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) =
    precondition_F self.f0 args
  
  meta "rewrite_def" predicate precondition_FnGhostWrapper_F
  
  predicate inv_I (_1: t_I)
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  predicate invariant_ref_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) = inv_FnGhostWrapper_F self
  
  meta "rewrite_def" predicate invariant_ref_FnGhostWrapper_F
  
  predicate inv_ref_FnGhostWrapper_F [@inline:trivial] (_1: t_FnGhostWrapper_F) = invariant_ref_FnGhostWrapper_F _1
  
  meta "rewrite_def" predicate inv_ref_FnGhostWrapper_F
  
  type t_Output
  
  predicate postcondition_F (self: t_F) (args: t_I) (result: t_Output)
  
  predicate postcondition_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) (result: t_Output) =
    postcondition_F self.f0 args result
  
  meta "rewrite_def" predicate postcondition_FnGhostWrapper_F
  
  predicate inv_Output (_1: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper_F. forall arg: t_I. precondition_FnGhostWrapper_F self_ arg
          /\ inv_I arg /\ inv_ref_FnGhostWrapper_F self_
        -> precondition_FnGhostWrapper_F self_ arg
        /\ inv_I arg
        /\ inv_ref_FnGhostWrapper_F self_
        /\ (forall result: t_Output. postcondition_FnGhostWrapper_F self_ arg result /\ inv_Output result
          -> postcondition_FnGhostWrapper_F self_ arg result /\ inv_Output result)
end
module M_invariant__impl_PartialEq_for_Subset_T__eq__refines (* <invariant::Subset<T> as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_T
  
  type t_DeepModelTy
  
  type t_T
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate invariant_T (self: t_T)
  
  function view_Subset_T (self: t_Subset_T) : t_T
  
  axiom view_Subset_T_spec: forall self: t_Subset_T. invariant_T (view_Subset_T self)
  
  function deep_model_Subset_T [@inline:trivial] (self: t_Subset_T) : t_DeepModelTy = deep_model_T (view_Subset_T self)
  
  meta "rewrite_def" function deep_model_Subset_T
  
  function deep_model_ref_Subset_T [@inline:trivial] (self: t_Subset_T) : t_DeepModelTy = deep_model_Subset_T self
  
  meta "rewrite_def" function deep_model_ref_Subset_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Subset_T. forall rhs: t_Subset_T. forall result: bool. result
            = (deep_model_ref_Subset_T self_ = deep_model_ref_Subset_T rhs)
          -> result = (deep_model_ref_Subset_T self_ = deep_model_ref_Subset_T rhs)
end
module M_logic__id__impl_PartialEq_for_Id__ne__refines (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Id
  
  function deep_model_Id [@inline:trivial] (self: t_Id) : t_Id = self
  
  meta "rewrite_def" function deep_model_Id
  
  function deep_model_ref_Id [@inline:trivial] (self: t_Id) : t_Id = deep_model_Id self
  
  meta "rewrite_def" function deep_model_ref_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Id. forall rhs: t_Id. forall result: bool. result <> (self_ = rhs)
          -> result = (deep_model_ref_Id self_ <> deep_model_ref_Id rhs)
end
module M_logic__id__impl_PartialEq_for_Id__eq__refines (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Id
  
  function deep_model_Id [@inline:trivial] (self: t_Id) : t_Id = self
  
  meta "rewrite_def" function deep_model_Id
  
  function deep_model_ref_Id [@inline:trivial] (self: t_Id) : t_Id = deep_model_Id self
  
  meta "rewrite_def" function deep_model_ref_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Id. forall rhs: t_Id. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model_ref_Id self_ = deep_model_ref_Id rhs)
end
module M_logic__int__impl_PartialEq_for_Int__eq__refines (* <logic::int::Int as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall rhs: int. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model_ref_Int self_ = deep_model_ref_Int rhs)
end
module M_peano__impl_PartialEq_for_PeanoInt__eq__refines (* <peano::PeanoInt as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model_ref_PeanoInt self_ = deep_model_ref_PeanoInt rhs)
end
module M_logic__fmap__impl_Iterator_for_FMapIter_K_V__next__refines (* <logic::fmap::FMapIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use seq.Seq
  use mach.int.Int
  use map.Const
  
  type t_FMap_K_V
  
  type t_FMapIter_K_V = { inner: t_FMap_K_V }
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate inv_FMapIter_K_V (_1: t_FMapIter_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMapIter_K_V [inv_FMapIter_K_V x]. inv_FMapIter_K_V x = inv_FMap_K_V x.inner
  
  predicate invariant_ref_FMapIter_K_V [@inline:trivial] (self: MutBorrow.t t_FMapIter_K_V) =
    inv_FMapIter_K_V self.current /\ inv_FMapIter_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMapIter_K_V
  
  predicate inv_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = invariant_ref_FMapIter_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMapIter_K_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None'0 | Some'0 tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V = self.inner
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some'0 { f0 = k; f1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  function produces_trans_FMapIter_K_V (a: t_FMapIter_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMapIter_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMapIter_K_V) : ()
   = let ac = Seq.(++) ab bc in ()
  
  axiom produces_trans_FMapIter_K_V_spec:
    forall a: t_FMapIter_K_V, ab: Seq.seq tup2_K_V, b: t_FMapIter_K_V, bc: Seq.seq tup2_K_V, c: t_FMapIter_K_V. produces_FMapIter_K_V a ab b
      -> produces_FMapIter_K_V b bc c -> produces_FMapIter_K_V a (Seq.(++) ab bc) c
  
  function produces_refl_FMapIter_K_V (self: t_FMapIter_K_V) : () = ()
  
  axiom produces_refl_FMapIter_K_V_spec:
    forall self: t_FMapIter_K_V. produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_V empty_K = Const.const (None)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  predicate completed_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) = is_empty_K (view_FMapIter_K_V self.current)
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_tup2_K_V f0'0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_FMapIter_K_V. inv_ref_FMapIter_K_V self_
      -> inv_ref_FMapIter_K_V self_
      /\ (forall result: t_Option_tup2_K_V. match result with
              | None'0 -> completed_FMapIter_K_V self_
              | Some'0 {f0 = k; f1 = v} -> produces_FMapIter_K_V self_.current (Seq.singleton { f0 = k;
                                                                                                f1 = v }) self_.final
              /\ view_FMapIter_K_V self_.current = insert_K (view_FMapIter_K_V self_.final) k v
              end
          /\ inv_Option_tup2_K_V result
        -> match result with
            | None'0 -> completed_FMapIter_K_V self_
            | Some'0 v -> produces_FMapIter_K_V self_.current (Seq.singleton v) self_.final
            end
        /\ inv_Option_tup2_K_V result)
end
module M_logic__fmap__impl_Iterator_for_FMapIterRef_K_V__next__refines (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use seq.Seq
  
  type t_FMap_ref_K_ref_V
  
  type t_FMapIterRef_K_V = { inner: t_FMap_ref_K_ref_V }
  
  type t_K
  
  type t_V
  
  type t_Option_ref_V = None | Some t_V
  
  function view_FMap_ref_K_ref_V (self: t_FMap_ref_K_ref_V) : Map.map t_K t_Option_ref_V
  
  function get_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_Option_ref_V =
    Map.get (view_FMap_ref_K_ref_V self) k
  
  meta "rewrite_def" function get_ref_K
  
  predicate contains_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) = get_ref_K self k <> None
  
  meta "rewrite_def" predicate contains_ref_K
  
  predicate inv_K (_1: t_K)
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate inv_V (_1: t_V)
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate index_Mapping_ref_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_ref_V_bool
  
  function such_that_ref_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_ref_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_ref_V_bool p x)
      -> index_Mapping_ref_V_bool p (such_that_ref_V p)
  
  function unwrap_Option_ref_V (self: t_Option_ref_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_ref_V (fun (__0: t_V) -> true)
      end
  
  function lookup_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_V =
    unwrap_Option_ref_V (get_ref_K self k)
  
  meta "rewrite_def" function lookup_ref_K
  
  function index_FMap_ref_K_ref_V [@inline:trivial] (self: t_FMap_ref_K_ref_V) (key: t_K) : t_V = lookup_ref_K self key
  
  meta "rewrite_def" function index_FMap_ref_K_ref_V
  
  predicate invariant_FMap_ref_K_ref_V [@inline:trivial] (self: t_FMap_ref_K_ref_V) =
    forall k: t_K. contains_ref_K self k -> inv_ref_K k /\ inv_ref_V (index_FMap_ref_K_ref_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_ref_K_ref_V
  
  predicate inv_FMap_ref_K_ref_V (_1: t_FMap_ref_K_ref_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_ref_K_ref_V [inv_FMap_ref_K_ref_V x]. inv_FMap_ref_K_ref_V x
      = invariant_FMap_ref_K_ref_V x
  
  predicate inv_FMapIterRef_K_V (_1: t_FMapIterRef_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMapIterRef_K_V [inv_FMapIterRef_K_V x]. inv_FMapIterRef_K_V x
      = inv_FMap_ref_K_ref_V x.inner
  
  predicate invariant_ref_FMapIterRef_K_V [@inline:trivial] (self: MutBorrow.t t_FMapIterRef_K_V) =
    inv_FMapIterRef_K_V self.current /\ inv_FMapIterRef_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMapIterRef_K_V
  
  predicate inv_ref_FMapIterRef_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIterRef_K_V) =
    invariant_ref_FMapIterRef_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMapIterRef_K_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_ref_K_ref_V = None'0 | Some'0 tup2_ref_K_ref_V
  
  type t_FMap_K_V
  
  type t_Option_V = None'1 | Some'1 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_V empty_K = Const.const (None'1)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function view_FMapIterRef_K_V (self: t_FMapIterRef_K_V) : t_FMap_K_V =
    such_that_FMap_K_V (fun (m: t_FMap_K_V) -> forall k: t_K, v: t_V. (get_K m k = Some'1 v)
      = (get_ref_K self.inner k = Some v))
  
  predicate completed_FMapIterRef_K_V (self: MutBorrow.t t_FMapIterRef_K_V) =
    is_empty_K (view_FMapIterRef_K_V self.current)
  
  function get_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (ix: int) : t_Option_tup2_ref_K_ref_V = if 0 <= ix
    /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'1
  
  meta "rewrite_def" predicate contains_K
  
  predicate produces_FMapIterRef_K_V (self: t_FMapIterRef_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_FMapIterRef_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_ref_K_ref_V visited i = Some'0 { f0 = k; f1 = v }
        -> not contains_K (view_FMapIterRef_K_V o) k /\ get_K (view_FMapIterRef_K_V self) k = Some'1 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIterRef_K_V o) k = get_K (view_FMapIterRef_K_V self) k)
  
  predicate inv_tup2_ref_K_ref_V [@inline:trivial] (_1: tup2_ref_K_ref_V) = inv_ref_K _1.f0 /\ inv_ref_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ref_K_ref_V
  
  predicate inv_Option_tup2_ref_K_ref_V (_1: t_Option_tup2_ref_K_ref_V)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_tup2_ref_K_ref_V [inv_Option_tup2_ref_K_ref_V x]. inv_Option_tup2_ref_K_ref_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_tup2_ref_K_ref_V f0'0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_FMapIterRef_K_V. inv_ref_FMapIterRef_K_V self_
      -> inv_ref_FMapIterRef_K_V self_
      /\ (forall result: t_Option_tup2_ref_K_ref_V. match result with
              | None'0 -> completed_FMapIterRef_K_V self_
              | Some'0 v -> produces_FMapIterRef_K_V self_.current (Seq.singleton v) self_.final
              end
          /\ inv_Option_tup2_ref_K_ref_V result
        -> match result with
            | None'0 -> completed_FMapIterRef_K_V self_
            | Some'0 v -> produces_FMapIterRef_K_V self_.current (Seq.singleton v) self_.final
            end
        /\ inv_Option_tup2_ref_K_ref_V result)
end
module M_logic__seq__impl_Iterator_for_SeqIter_T__next__refines (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate inv_SeqIter_T (_1: t_SeqIter_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter_T [inv_SeqIter_T x]. inv_SeqIter_T x = inv_Seq_T x.inner
  
  predicate invariant_ref_SeqIter_T [@inline:trivial] (self: MutBorrow.t t_SeqIter_T) =
    inv_SeqIter_T self.current /\ inv_SeqIter_T self.final
  
  meta "rewrite_def" predicate invariant_ref_SeqIter_T
  
  predicate inv_ref_SeqIter_T [@inline:trivial] (_1: MutBorrow.t t_SeqIter_T) = invariant_ref_SeqIter_T _1
  
  meta "rewrite_def" predicate inv_ref_SeqIter_T
  
  type t_Option_T = None | Some t_T
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  function produces_trans_SeqIter_T (a: t_SeqIter_T) (ab: Seq.seq t_T) (b: t_SeqIter_T) (bc: Seq.seq t_T) (c: t_SeqIter_T) : ()
   = ()
  
  axiom produces_trans_SeqIter_T_spec:
    forall a: t_SeqIter_T, ab: Seq.seq t_T, b: t_SeqIter_T, bc: Seq.seq t_T, c: t_SeqIter_T. produces_SeqIter_T a ab b
      -> produces_SeqIter_T b bc c -> produces_SeqIter_T a (Seq.(++) ab bc) c
  
  function produces_refl_SeqIter_T (self: t_SeqIter_T) : () = ()
  
  axiom produces_refl_SeqIter_T_spec: forall self: t_SeqIter_T. produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
  
  predicate completed_SeqIter_T (self: MutBorrow.t t_SeqIter_T) = view_SeqIter_T self.current = (Seq.empty: Seq.seq t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_SeqIter_T. inv_ref_SeqIter_T self_
      -> inv_ref_SeqIter_T self_
      /\ (forall result: t_Option_T. match result with
              | None -> completed_SeqIter_T self_
              | Some v -> produces_SeqIter_T self_.current (Seq.singleton v) self_.final
              end
          /\ inv_Option_T result
        -> match result with
            | None -> completed_SeqIter_T self_
            | Some v -> produces_SeqIter_T self_.current (Seq.singleton v) self_.final
            end
        /\ inv_Option_T result)
end
module M_logic__seq__impl_Iterator_for_SeqIterRef_T__next__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  predicate invariant_SeqIterRef_T (self: t_SeqIterRef_T) = 0 <= self.index /\ self.index <= Seq.length self.inner
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  predicate inv_SeqIterRef_T (_1: t_SeqIterRef_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIterRef_T [inv_SeqIterRef_T x]. inv_SeqIterRef_T x
      = (invariant_SeqIterRef_T x /\ inv_ref_Seq_T x.inner)
  
  predicate invariant_ref_SeqIterRef_T [@inline:trivial] (self: MutBorrow.t t_SeqIterRef_T) =
    inv_SeqIterRef_T self.current /\ inv_SeqIterRef_T self.final
  
  meta "rewrite_def" predicate invariant_ref_SeqIterRef_T
  
  predicate inv_ref_SeqIterRef_T [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef_T) = invariant_ref_SeqIterRef_T _1
  
  meta "rewrite_def" predicate inv_ref_SeqIterRef_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  function produces_trans_SeqIterRef_T (a: t_SeqIterRef_T) (ab: Seq.seq t_T) (b: t_SeqIterRef_T) (bc: Seq.seq t_T) (c: t_SeqIterRef_T) : ()
   = ()
  
  axiom produces_trans_SeqIterRef_T_spec:
    forall a: t_SeqIterRef_T, ab: Seq.seq t_T, b: t_SeqIterRef_T, bc: Seq.seq t_T, c: t_SeqIterRef_T. produces_SeqIterRef_T a ab b
      -> produces_SeqIterRef_T b bc c -> produces_SeqIterRef_T a (Seq.(++) ab bc) c
  
  function produces_refl_SeqIterRef_T (self: t_SeqIterRef_T) : () = ()
  
  axiom produces_refl_SeqIterRef_T_spec:
    forall self: t_SeqIterRef_T. produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
  
  predicate completed_SeqIterRef_T (self: MutBorrow.t t_SeqIterRef_T) =
    view_SeqIterRef_T self.current = (Seq.empty: Seq.seq t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_SeqIterRef_T. inv_ref_SeqIterRef_T self_
      -> inv_ref_SeqIterRef_T self_
      /\ (forall result: t_Option_ref_T. match result with
              | None -> completed_SeqIterRef_T self_
              | Some v -> produces_SeqIterRef_T self_.current (Seq.singleton v) self_.final
              end
          /\ inv_Option_ref_T result
        -> match result with
            | None -> completed_SeqIterRef_T self_
            | Some v -> produces_SeqIterRef_T self_.current (Seq.singleton v) self_.final
            end
        /\ inv_Option_ref_T result)
end
module M_std__iter__map_inv__impl_Iterator_for_MapInv_I_F__next__refines (* <std::iter::map_inv::MapInv<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate next_precondition_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. produces_I iter'0 (Seq.singleton e) i -> precondition_F func'0 { f0 = e; f1 = produced'0 }
  
  type t_B
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate preservation_I (iter'0: t_I) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current { f0 = e1; f1 = s }
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  predicate reinitialize_I =
    forall iter'0: MutBorrow.t t_I, func'0: t_F. completed_I iter'0
      -> next_precondition_I iter'0.final func'0 (Seq.empty: Seq.seq t_Item) /\ preservation_I iter'0.final func'0
  
  predicate preservation_inv_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> precondition_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s }
      -> postcondition_mut_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced'0 s) e1 }
  
  axiom preservation_inv_I_spec: forall iter'0: t_I, func'0: t_F, produced'0: Seq.seq t_Item. produced'0
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv_I iter'0 func'0 produced'0 = preservation_I iter'0 func'0
  
  predicate invariant_MapInv_I_F (self: t_MapInv_I_F) =
    reinitialize_I
    /\ preservation_inv_I self.iter self.func self.produced /\ next_precondition_I self.iter self.func self.produced
  
  predicate inv_I (_1: t_I)
  
  predicate inv_F (_1: t_F)
  
  predicate inv_MapInv_I_F (_1: t_MapInv_I_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv_I_F [inv_MapInv_I_F x]. inv_MapInv_I_F x
      = (invariant_MapInv_I_F x /\ inv_I x.iter /\ inv_F x.func)
  
  predicate invariant_ref_MapInv_I_F [@inline:trivial] (self: MutBorrow.t t_MapInv_I_F) =
    inv_MapInv_I_F self.current /\ inv_MapInv_I_F self.final
  
  meta "rewrite_def" predicate invariant_ref_MapInv_I_F
  
  predicate inv_ref_MapInv_I_F [@inline:trivial] (_1: MutBorrow.t t_MapInv_I_F) = invariant_ref_MapInv_I_F _1
  
  meta "rewrite_def" predicate inv_ref_MapInv_I_F
  
  type t_Option_B = None | Some t_B
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current { f0 = Seq.get s i; f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  function produces_trans_MapInv_I_F (a: t_MapInv_I_F) (ab: Seq.seq t_B) (b: t_MapInv_I_F) (bc: Seq.seq t_B) (c: t_MapInv_I_F) : ()
   = ()
  
  axiom produces_trans_MapInv_I_F_spec:
    forall a: t_MapInv_I_F, ab: Seq.seq t_B, b: t_MapInv_I_F, bc: Seq.seq t_B, c: t_MapInv_I_F. produces_MapInv_I_F a ab b
      -> produces_MapInv_I_F b bc c -> produces_MapInv_I_F a (Seq.(++) ab bc) c
  
  function produces_refl_MapInv_I_F (self: t_MapInv_I_F) : () = ()
  
  axiom produces_refl_MapInv_I_F_spec: forall self: t_MapInv_I_F. produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
  
  predicate completed_MapInv_I_F (self: MutBorrow.t t_MapInv_I_F) =
    self.final.produced = (Seq.empty: Seq.seq t_Item)
    /\ completed_I (MutBorrow.borrow_logic self.current.iter self.final.iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ self.current.func = self.final.func
  
  predicate produces_one_I (self: t_MapInv_I_F) (visited: t_B) (succ: t_MapInv_I_F) =
    exists f: MutBorrow.t t_F, e: t_Item. f.current = self.func
      /\ f.final = succ.func
      /\ produces_I self.iter (Seq.singleton e) succ.iter
      /\ succ.produced = Seq.snoc self.produced e
      /\ precondition_F f.current { f0 = e; f1 = self.produced }
      /\ postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final visited
  
  axiom produces_one_I_spec:
    forall self: t_MapInv_I_F, visited: t_B, succ: t_MapInv_I_F. produces_one_I self visited succ
      = produces_MapInv_I_F self (Seq.singleton visited) succ
  
  predicate inv_B (_1: t_B)
  
  predicate inv_Option_B (_1: t_Option_B)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_B [inv_Option_B x]. inv_Option_B x
      = match x with
        | None -> true
        | Some f0'0 -> inv_B f0'0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_MapInv_I_F. inv_ref_MapInv_I_F self_
      -> inv_ref_MapInv_I_F self_
      /\ (forall result: t_Option_B. match result with
              | None -> completed_MapInv_I_F self_
              | Some v -> produces_one_I self_.current v self_.final
              end
          /\ inv_Option_B result
        -> match result with
            | None -> completed_MapInv_I_F self_
            | Some v -> produces_MapInv_I_F self_.current (Seq.singleton v) self_.final
            end
        /\ inv_Option_B result)
end
module M_logic__fmap__impl_IteratorSpec_for_FMapIter_K_V__produces_refl__refines (* <logic::fmap::FMapIter<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap_K_V
  
  type t_FMapIter_K_V = { inner: t_FMap_K_V }
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None | Some tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V = self.inner
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some'0 v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_FMapIter_K_V. forall result: (). produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
        -> produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
end
module M_logic__fmap__impl_IteratorSpec_for_FMapIter_K_V__produces_trans__refines (* <logic::fmap::FMapIter<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap_K_V
  
  type t_FMapIter_K_V = { inner: t_FMap_K_V }
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None | Some tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V = self.inner
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some'0 v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FMapIter_K_V. forall ab: Seq.seq tup2_K_V. forall b: t_FMapIter_K_V. forall bc: Seq.seq tup2_K_V. forall c: t_FMapIter_K_V. produces_FMapIter_K_V b bc c
                /\ produces_FMapIter_K_V a ab b
              -> produces_FMapIter_K_V b bc c
              /\ produces_FMapIter_K_V a ab b
              /\ (forall result: (). produces_FMapIter_K_V a (Seq.(++) ab bc) c
                -> produces_FMapIter_K_V a (Seq.(++) ab bc) c)
end
module M_logic__fmap__impl_IteratorSpec_for_FMapIterRef_K_V__produces_refl__refines (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap_ref_K_ref_V
  
  type t_FMapIterRef_K_V = { inner: t_FMap_ref_K_ref_V }
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_ref_K_ref_V = None | Some tup2_ref_K_ref_V
  
  function get_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (ix: int) : t_Option_tup2_ref_K_ref_V = if 0 <= ix
    /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_FMap_K_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  type t_Option_ref_V = None'1 | Some'1 t_V
  
  function view_FMap_ref_K_ref_V (self: t_FMap_ref_K_ref_V) : Map.map t_K t_Option_ref_V
  
  function get_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_Option_ref_V =
    Map.get (view_FMap_ref_K_ref_V self) k
  
  meta "rewrite_def" function get_ref_K
  
  function view_FMapIterRef_K_V (self: t_FMapIterRef_K_V) : t_FMap_K_V =
    such_that_FMap_K_V (fun (m: t_FMap_K_V) -> forall k: t_K, v: t_V. (get_K m k = Some'0 v)
      = (get_ref_K self.inner k = Some'1 v))
  
  predicate produces_FMapIterRef_K_V (self: t_FMapIterRef_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_FMapIterRef_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_ref_K_ref_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K (view_FMapIterRef_K_V o) k /\ get_K (view_FMapIterRef_K_V self) k = Some'0 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIterRef_K_V o) k = get_K (view_FMapIterRef_K_V self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_FMapIterRef_K_V. forall result: (). produces_FMapIterRef_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
        -> produces_FMapIterRef_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
end
module M_logic__fmap__impl_IteratorSpec_for_FMapIterRef_K_V__produces_trans__refines (* <logic::fmap::FMapIterRef<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FMap_ref_K_ref_V
  
  type t_FMapIterRef_K_V = { inner: t_FMap_ref_K_ref_V }
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_ref_K_ref_V = None | Some tup2_ref_K_ref_V
  
  function get_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (ix: int) : t_Option_tup2_ref_K_ref_V = if 0 <= ix
    /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_FMap_K_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  type t_Option_ref_V = None'1 | Some'1 t_V
  
  function view_FMap_ref_K_ref_V (self: t_FMap_ref_K_ref_V) : Map.map t_K t_Option_ref_V
  
  function get_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_Option_ref_V =
    Map.get (view_FMap_ref_K_ref_V self) k
  
  meta "rewrite_def" function get_ref_K
  
  function view_FMapIterRef_K_V (self: t_FMapIterRef_K_V) : t_FMap_K_V =
    such_that_FMap_K_V (fun (m: t_FMap_K_V) -> forall k: t_K, v: t_V. (get_K m k = Some'0 v)
      = (get_ref_K self.inner k = Some'1 v))
  
  predicate produces_FMapIterRef_K_V (self: t_FMapIterRef_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_FMapIterRef_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_ref_K_ref_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K (view_FMapIterRef_K_V o) k /\ get_K (view_FMapIterRef_K_V self) k = Some'0 v)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIterRef_K_V o) k = get_K (view_FMapIterRef_K_V self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FMapIterRef_K_V. forall ab: Seq.seq tup2_ref_K_ref_V. forall b: t_FMapIterRef_K_V. forall bc: Seq.seq tup2_ref_K_ref_V. forall c: t_FMapIterRef_K_V. produces_FMapIterRef_K_V b bc c
                /\ produces_FMapIterRef_K_V a ab b
              -> produces_FMapIterRef_K_V b bc c
              /\ produces_FMapIterRef_K_V a ab b
              /\ (forall result: (). produces_FMapIterRef_K_V a (Seq.(++) ab bc) c
                -> produces_FMapIterRef_K_V a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_IteratorSpec_for_SeqIter_T__produces_trans__refines (* <logic::seq::SeqIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_SeqIter_T. forall ab: Seq.seq t_T. forall b: t_SeqIter_T. forall bc: Seq.seq t_T. forall c: t_SeqIter_T. produces_SeqIter_T b bc c
                /\ produces_SeqIter_T a ab b
              -> produces_SeqIter_T b bc c
              /\ produces_SeqIter_T a ab b
              /\ (forall result: (). produces_SeqIter_T a (Seq.(++) ab bc) c -> produces_SeqIter_T a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_IteratorSpec_for_SeqIter_T__produces_refl__refines (* <logic::seq::SeqIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIter_T. forall result: (). produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_logic__seq__impl_IteratorSpec_for_SeqIterRef_T__produces_trans__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_SeqIterRef_T. forall ab: Seq.seq t_T. forall b: t_SeqIterRef_T. forall bc: Seq.seq t_T. forall c: t_SeqIterRef_T. produces_SeqIterRef_T b bc c
                /\ produces_SeqIterRef_T a ab b
              -> produces_SeqIterRef_T b bc c
              /\ produces_SeqIterRef_T a ab b
              /\ (forall result: (). produces_SeqIterRef_T a (Seq.(++) ab bc) c
                -> produces_SeqIterRef_T a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_IteratorSpec_for_SeqIterRef_T__produces_refl__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIterRef_T. forall result: (). produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
        -> produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__array__impl_IteratorSpec_for_IntoIter_T__produces_refl__refines (* <std::array::IntoIter<T, N> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : Seq.seq t_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    view_IntoIter_T self = Seq.(++) visited (view_IntoIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T. forall result: (). produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__array__impl_IteratorSpec_for_IntoIter_T__produces_trans__refines (* <std::array::IntoIter<T, N> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : Seq.seq t_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    view_IntoIter_T self = Seq.(++) visited (view_IntoIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_T. forall ab: Seq.seq t_T. forall b: t_IntoIter_T. forall bc: Seq.seq t_T. forall c: t_IntoIter_T. produces_IntoIter_T b bc c
                /\ produces_IntoIter_T a ab b
              -> produces_IntoIter_T b bc c
              /\ produces_IntoIter_T a ab b
              /\ (forall result: (). produces_IntoIter_T a (Seq.(++) ab bc) c
                -> produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IntoIter_K_V__produces_trans__refines (* <std::collections::hash_map::IntoIter<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IntoIter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_IntoIter_K_V (self: t_IntoIter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_DeepModelTy_V (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (view_FMap_DeepModelTy_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate produces_IntoIter_K_V [@inline:trivial] (self: t_IntoIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_IntoIter_K_V) =
    len_DeepModelTy (view_IntoIter_K_V self) = Seq.length visited + len_DeepModelTy (view_IntoIter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_K_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IntoIter_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IntoIter_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V o) k = Some v
        -> get_DeepModelTy (view_IntoIter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_K k2 = k /\ contains_tup2_K_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_K k1 = k /\ contains_tup2_K_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IntoIter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model_K (Seq.get visited i1).f0 = deep_model_K (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IntoIter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_K_V. forall ab: Seq.seq tup2_K_V. forall b: t_IntoIter_K_V. forall bc: Seq.seq tup2_K_V. forall c: t_IntoIter_K_V. produces_IntoIter_K_V b bc c
                /\ produces_IntoIter_K_V a ab b
              -> produces_IntoIter_K_V b bc c
              /\ produces_IntoIter_K_V a ab b
              /\ (forall result: (). produces_IntoIter_K_V a (Seq.(++) ab bc) c
                -> produces_IntoIter_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IntoIter_K_V__produces_refl__refines (* <std::collections::hash_map::IntoIter<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IntoIter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_IntoIter_K_V (self: t_IntoIter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_DeepModelTy_V (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (view_FMap_DeepModelTy_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate produces_IntoIter_K_V [@inline:trivial] (self: t_IntoIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_IntoIter_K_V) =
    len_DeepModelTy (view_IntoIter_K_V self) = Seq.length visited + len_DeepModelTy (view_IntoIter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_K_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IntoIter_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IntoIter_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V o) k = Some v
        -> get_DeepModelTy (view_IntoIter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_K k2 = k /\ contains_tup2_K_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_K k1 = k /\ contains_tup2_K_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IntoIter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model_K (Seq.get visited i1).f0 = deep_model_K (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IntoIter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IntoIter_K_V. forall result: (). produces_IntoIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
        -> produces_IntoIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_Iter_K_V__produces_trans__refines (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_Iter_K_V (self: t_Iter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_DeepModelTy_V (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (view_FMap_DeepModelTy_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_Iter_K_V [@inline:trivial] (self: t_Iter_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_Iter_K_V) =
    len_DeepModelTy (view_Iter_K_V self) = Seq.length visited + len_DeepModelTy (view_Iter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_Iter_K_V self) (deep_model_ref_K k) = Some v
        /\ get_DeepModelTy (view_Iter_K_V o) (deep_model_ref_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V o) k = Some v
        -> get_DeepModelTy (view_Iter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V self) k = Some v
        -> (exists k2: t_K. deep_model_ref_K k2 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v })
        \/ get_DeepModelTy (view_Iter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_Iter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_K_V. forall ab: Seq.seq tup2_ref_K_ref_V. forall b: t_Iter_K_V. forall bc: Seq.seq tup2_ref_K_ref_V. forall c: t_Iter_K_V. produces_Iter_K_V b bc c
                /\ produces_Iter_K_V a ab b
              -> produces_Iter_K_V b bc c
              /\ produces_Iter_K_V a ab b
              /\ (forall result: (). produces_Iter_K_V a (Seq.(++) ab bc) c -> produces_Iter_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_Iter_K_V__produces_refl__refines (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Iter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_Iter_K_V (self: t_Iter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_DeepModelTy_V (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (view_FMap_DeepModelTy_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_Iter_K_V [@inline:trivial] (self: t_Iter_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_Iter_K_V) =
    len_DeepModelTy (view_Iter_K_V self) = Seq.length visited + len_DeepModelTy (view_Iter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_Iter_K_V self) (deep_model_ref_K k) = Some v
        /\ get_DeepModelTy (view_Iter_K_V o) (deep_model_ref_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V o) k = Some v
        -> get_DeepModelTy (view_Iter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V self) k = Some v
        -> (exists k2: t_K. deep_model_ref_K k2 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v })
        \/ get_DeepModelTy (view_Iter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_Iter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Iter_K_V. forall result: (). produces_Iter_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
        -> produces_Iter_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IterMut_K_V__produces_trans__refines (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IterMut_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap_DeepModelTy_ref_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_ref_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_ref_V. len_DeepModelTy self >= 0
  
  function view_IterMut_K_V (self: t_IterMut_K_V) : t_FMap_DeepModelTy_ref_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_ref_V = None | Some (MutBorrow.t t_V)
  
  function view_FMap_DeepModelTy_ref_V (self: t_FMap_DeepModelTy_ref_V) : Map.map t_DeepModelTy t_Option_ref_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_ref_V) (k: t_DeepModelTy) : t_Option_ref_V =
    Map.get (view_FMap_DeepModelTy_ref_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_IterMut_K_V [@inline:trivial] (self: t_IterMut_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_IterMut_K_V) =
    len_DeepModelTy (view_IterMut_K_V self) = Seq.length visited + len_DeepModelTy (view_IterMut_K_V o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IterMut_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IterMut_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V o) k = Some v
        -> get_DeepModelTy (view_IterMut_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_ref_K k1 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IterMut_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IterMut_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut_K_V. forall ab: Seq.seq tup2_ref_K_ref_V. forall b: t_IterMut_K_V. forall bc: Seq.seq tup2_ref_K_ref_V. forall c: t_IterMut_K_V. produces_IterMut_K_V b bc c
                /\ produces_IterMut_K_V a ab b
              -> produces_IterMut_K_V b bc c
              /\ produces_IterMut_K_V a ab b
              /\ (forall result: (). produces_IterMut_K_V a (Seq.(++) ab bc) c
                -> produces_IterMut_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IterMut_K_V__produces_refl__refines (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_IterMut_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap_DeepModelTy_ref_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_ref_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_ref_V. len_DeepModelTy self >= 0
  
  function view_IterMut_K_V (self: t_IterMut_K_V) : t_FMap_DeepModelTy_ref_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_ref_V = None | Some (MutBorrow.t t_V)
  
  function view_FMap_DeepModelTy_ref_V (self: t_FMap_DeepModelTy_ref_V) : Map.map t_DeepModelTy t_Option_ref_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_ref_V) (k: t_DeepModelTy) : t_Option_ref_V =
    Map.get (view_FMap_DeepModelTy_ref_V self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_IterMut_K_V [@inline:trivial] (self: t_IterMut_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_IterMut_K_V) =
    len_DeepModelTy (view_IterMut_K_V self) = Seq.length visited + len_DeepModelTy (view_IterMut_K_V o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IterMut_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IterMut_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V o) k = Some v
        -> get_DeepModelTy (view_IterMut_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_ref_K k1 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IterMut_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IterMut_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IterMut_K_V. forall result: (). produces_IterMut_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
        -> produces_IterMut_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_IntoIter_T__produces_refl__refines (* <std::collections::hash_set::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_IntoIter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_IntoIter_T (self: t_IntoIter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_IntoIter_T) (visited: Seq.seq t_T) (end': t_IntoIter_T) =
    Fset.cardinal (view_IntoIter_T start) = Seq.length visited + Fset.cardinal (view_IntoIter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1)
        \/ contains_DeepModelTy (view_IntoIter_T end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_IntoIter_T start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_IntoIter_T end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T end') x
        -> contains_DeepModelTy (view_IntoIter_T start) x
        /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    set_produces_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T. forall result: (). produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_IntoIter_T__produces_trans__refines (* <std::collections::hash_set::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_IntoIter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_IntoIter_T (self: t_IntoIter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_IntoIter_T) (visited: Seq.seq t_T) (end': t_IntoIter_T) =
    Fset.cardinal (view_IntoIter_T start) = Seq.length visited + Fset.cardinal (view_IntoIter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1)
        \/ contains_DeepModelTy (view_IntoIter_T end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_IntoIter_T start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_IntoIter_T end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T end') x
        -> contains_DeepModelTy (view_IntoIter_T start) x
        /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    set_produces_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_T. forall ab: Seq.seq t_T. forall b: t_IntoIter_T. forall bc: Seq.seq t_T. forall c: t_IntoIter_T. produces_IntoIter_T b bc c
                /\ produces_IntoIter_T a ab b
              -> produces_IntoIter_T b bc c
              /\ produces_IntoIter_T a ab b
              /\ (forall result: (). produces_IntoIter_T a (Seq.(++) ab bc) c
                -> produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Iter_T__produces_trans__refines (* <std::collections::hash_set::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Iter_T (self: t_Iter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Iter_T) (visited: Seq.seq t_T) (end': t_Iter_T) =
    Fset.cardinal (view_Iter_T start) = Seq.length visited + Fset.cardinal (view_Iter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Iter_T end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Iter_T start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Iter_T end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T end') x
        -> contains_DeepModelTy (view_Iter_T start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) = set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_T. forall ab: Seq.seq t_T. forall b: t_Iter_T. forall bc: Seq.seq t_T. forall c: t_Iter_T. produces_Iter_T b bc c
                /\ produces_Iter_T a ab b
              -> produces_Iter_T b bc c
              /\ produces_Iter_T a ab b
              /\ (forall result: (). produces_Iter_T a (Seq.(++) ab bc) c -> produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Iter_T__produces_refl__refines (* <std::collections::hash_set::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Iter_T (self: t_Iter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Iter_T) (visited: Seq.seq t_T) (end': t_Iter_T) =
    Fset.cardinal (view_Iter_T start) = Seq.length visited + Fset.cardinal (view_Iter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Iter_T end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Iter_T start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Iter_T end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T end') x
        -> contains_DeepModelTy (view_Iter_T start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) = set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter_T. forall result: (). produces_Iter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Intersection_T_S__produces_refl__refines (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Intersection_T_S
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Intersection_T_S (self: t_Intersection_T_S) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Intersection_T_S) (visited: Seq.seq t_T) (end': t_Intersection_T_S) =
    Fset.cardinal (view_Intersection_T_S start) = Seq.length visited + Fset.cardinal (view_Intersection_T_S end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Intersection_T_S end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Intersection_T_S start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Intersection_T_S end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S end') x
        -> contains_DeepModelTy (view_Intersection_T_S start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Intersection_T_S (self: t_Intersection_T_S) (visited: Seq.seq t_T) (o: t_Intersection_T_S) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Intersection_T_S. forall result: (). produces_Intersection_T_S self (Seq.empty: Seq.seq t_T) self
        -> produces_Intersection_T_S self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Intersection_T_S__produces_trans__refines (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Intersection_T_S
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Intersection_T_S (self: t_Intersection_T_S) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Intersection_T_S) (visited: Seq.seq t_T) (end': t_Intersection_T_S) =
    Fset.cardinal (view_Intersection_T_S start) = Seq.length visited + Fset.cardinal (view_Intersection_T_S end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Intersection_T_S end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Intersection_T_S start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Intersection_T_S end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S end') x
        -> contains_DeepModelTy (view_Intersection_T_S start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Intersection_T_S (self: t_Intersection_T_S) (visited: Seq.seq t_T) (o: t_Intersection_T_S) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Intersection_T_S. forall ab: Seq.seq t_T. forall b: t_Intersection_T_S. forall bc: Seq.seq t_T. forall c: t_Intersection_T_S. produces_Intersection_T_S b bc c
                /\ produces_Intersection_T_S a ab b
              -> produces_Intersection_T_S b bc c
              /\ produces_Intersection_T_S a ab b
              /\ (forall result: (). produces_Intersection_T_S a (Seq.(++) ab bc) c
                -> produces_Intersection_T_S a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Difference_T_S__produces_trans__refines (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Difference_T_S
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Difference_T_S (self: t_Difference_T_S) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Difference_T_S) (visited: Seq.seq t_T) (end': t_Difference_T_S) =
    Fset.cardinal (view_Difference_T_S start) = Seq.length visited + Fset.cardinal (view_Difference_T_S end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Difference_T_S end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Difference_T_S start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Difference_T_S end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S end') x
        -> contains_DeepModelTy (view_Difference_T_S start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Difference_T_S (self: t_Difference_T_S) (visited: Seq.seq t_T) (o: t_Difference_T_S) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Difference_T_S. forall ab: Seq.seq t_T. forall b: t_Difference_T_S. forall bc: Seq.seq t_T. forall c: t_Difference_T_S. produces_Difference_T_S b bc c
                /\ produces_Difference_T_S a ab b
              -> produces_Difference_T_S b bc c
              /\ produces_Difference_T_S a ab b
              /\ (forall result: (). produces_Difference_T_S a (Seq.(++) ab bc) c
                -> produces_Difference_T_S a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Difference_T_S__produces_refl__refines (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_Difference_T_S
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Difference_T_S (self: t_Difference_T_S) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Difference_T_S) (visited: Seq.seq t_T) (end': t_Difference_T_S) =
    Fset.cardinal (view_Difference_T_S start) = Seq.length visited + Fset.cardinal (view_Difference_T_S end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Difference_T_S end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Difference_T_S start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Difference_T_S end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S end') x
        -> contains_DeepModelTy (view_Difference_T_S start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Difference_T_S (self: t_Difference_T_S) (visited: Seq.seq t_T) (o: t_Difference_T_S) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Difference_T_S. forall result: (). produces_Difference_T_S self (Seq.empty: Seq.seq t_T) self
        -> produces_Difference_T_S self (Seq.empty: Seq.seq t_T) self
end
module M_std__deque__impl_IteratorSpec_for_Iter_T__produces_refl__refines (* <std::collections::vec_deque::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter_T. forall result: (). produces_Iter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__deque__impl_IteratorSpec_for_Iter_T__produces_trans__refines (* <std::collections::vec_deque::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_T. forall ab: Seq.seq t_T. forall b: t_Iter_T. forall bc: Seq.seq t_T. forall c: t_Iter_T. produces_Iter_T b bc c
                /\ produces_Iter_T a ab b
              -> produces_Iter_T b bc c
              /\ produces_Iter_T a ab b
              /\ (forall result: (). produces_Iter_T a (Seq.(++) ab bc) c -> produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__iter__cloned__impl_IteratorSpec_for_Cloned_I__produces_trans__refines (* <std::iter::Cloned<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Cloned_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate produces_Cloned_I (self: t_Cloned_I) (visited: Seq.seq t_T) (o: t_Cloned_I) =
    exists s: Seq.seq t_T. produces_I (iter_Cloned_I self) s (iter_Cloned_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition_clone () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Cloned_I. forall ab: Seq.seq t_T. forall b: t_Cloned_I. forall bc: Seq.seq t_T. forall c: t_Cloned_I. produces_Cloned_I b bc c
                /\ produces_Cloned_I a ab b
              -> produces_Cloned_I b bc c
              /\ produces_Cloned_I a ab b
              /\ (forall result: (). produces_Cloned_I a (Seq.(++) ab bc) c -> produces_Cloned_I a (Seq.(++) ab bc) c)
end
module M_std__iter__cloned__impl_IteratorSpec_for_Cloned_I__produces_refl__refines (* <std::iter::Cloned<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Cloned_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate produces_Cloned_I (self: t_Cloned_I) (visited: Seq.seq t_T) (o: t_Cloned_I) =
    exists s: Seq.seq t_T. produces_I (iter_Cloned_I self) s (iter_Cloned_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition_clone () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Cloned_I. forall result: (). produces_Cloned_I self (Seq.empty: Seq.seq t_T) self
        -> produces_Cloned_I self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__copied__impl_IteratorSpec_for_Copied_I__produces_trans__refines (* <std::iter::Copied<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Copied_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate produces_Copied_I (self: t_Copied_I) (visited: Seq.seq t_T) (o: t_Copied_I) =
    exists s: Seq.seq t_T. produces_I (iter_Copied_I self) s (iter_Copied_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Copied_I. forall ab: Seq.seq t_T. forall b: t_Copied_I. forall bc: Seq.seq t_T. forall c: t_Copied_I. produces_Copied_I b bc c
                /\ produces_Copied_I a ab b
              -> produces_Copied_I b bc c
              /\ produces_Copied_I a ab b
              /\ (forall result: (). produces_Copied_I a (Seq.(++) ab bc) c -> produces_Copied_I a (Seq.(++) ab bc) c)
end
module M_std__iter__copied__impl_IteratorSpec_for_Copied_I__produces_refl__refines (* <std::iter::Copied<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Copied_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate produces_Copied_I (self: t_Copied_I) (visited: Seq.seq t_T) (o: t_Copied_I) =
    exists s: Seq.seq t_T. produces_I (iter_Copied_I self) s (iter_Copied_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Copied_I. forall result: (). produces_Copied_I self (Seq.empty: Seq.seq t_T) self
        -> produces_Copied_I self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__empty__impl_IteratorSpec_for_Empty_T__produces_refl__refines (* <std::iter::Empty<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty_T
  
  type t_T
  
  predicate produces_Empty_T (self: t_Empty_T) (visited: Seq.seq t_T) (o: t_Empty_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Empty_T. forall result: (). produces_Empty_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Empty_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__empty__impl_IteratorSpec_for_Empty_T__produces_trans__refines (* <std::iter::Empty<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty_T
  
  type t_T
  
  predicate produces_Empty_T (self: t_Empty_T) (visited: Seq.seq t_T) (o: t_Empty_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Empty_T. forall ab: Seq.seq t_T. forall b: t_Empty_T. forall bc: Seq.seq t_T. forall c: t_Empty_T. produces_Empty_T b bc c
                /\ produces_Empty_T a ab b
              -> produces_Empty_T b bc c
              /\ produces_Empty_T a ab b
              /\ (forall result: (). produces_Empty_T a (Seq.(++) ab bc) c -> produces_Empty_T a (Seq.(++) ab bc) c)
end
module M_std__iter__enumerate__impl_IteratorSpec_for_Enumerate_I__produces_trans__refines (* <std::iter::Enumerate<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Enumerate_I
  
  type t_Item
  
  type tup2_usize_Item = { f0: UInt64.t; f1: t_Item }
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate produces_Enumerate_I (self: t_Enumerate_I) (visited: Seq.seq tup2_usize_Item) (o: t_Enumerate_I) =
    Seq.length visited = UInt64.t'int (n_Enumerate_I o) - UInt64.t'int (n_Enumerate_I self)
    /\ (exists s: Seq.seq t_Item. produces_I (iter_Enumerate_I self) s (iter_Enumerate_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n_Enumerate_I self) + i
        /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Enumerate_I. forall ab: Seq.seq tup2_usize_Item. forall b: t_Enumerate_I. forall bc: Seq.seq tup2_usize_Item. forall c: t_Enumerate_I. produces_Enumerate_I b bc c
                /\ produces_Enumerate_I a ab b
              -> produces_Enumerate_I b bc c
              /\ produces_Enumerate_I a ab b
              /\ (forall result: (). produces_Enumerate_I a (Seq.(++) ab bc) c
                -> produces_Enumerate_I a (Seq.(++) ab bc) c)
end
module M_std__iter__enumerate__impl_IteratorSpec_for_Enumerate_I__produces_refl__refines (* <std::iter::Enumerate<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Enumerate_I
  
  type t_Item
  
  type tup2_usize_Item = { f0: UInt64.t; f1: t_Item }
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate produces_Enumerate_I (self: t_Enumerate_I) (visited: Seq.seq tup2_usize_Item) (o: t_Enumerate_I) =
    Seq.length visited = UInt64.t'int (n_Enumerate_I o) - UInt64.t'int (n_Enumerate_I self)
    /\ (exists s: Seq.seq t_Item. produces_I (iter_Enumerate_I self) s (iter_Enumerate_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n_Enumerate_I self) + i
        /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Enumerate_I. forall result: (). produces_Enumerate_I self (Seq.empty: Seq.seq tup2_usize_Item) self
        -> produces_Enumerate_I self (Seq.empty: Seq.seq tup2_usize_Item) self
end
module M_std__iter__filter__impl_IteratorSpec_for_Filter_I_F__produces_trans__refines (* <std::iter::Filter<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Filter_I_F
  
  type t_Item
  
  type t_F
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) = forall f: t_F, i: t_Item. precondition_F f i
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  predicate produces_Filter_I_F (self: t_Filter_I_F) (visited: Seq.seq t_Item) (succ: t_Filter_I_F) =
    private_invariant_I self
    -> hist_inv_F (func_Filter_I_F self) (func_Filter_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_Filter_I_F self) s (iter_Filter_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_F (func_Filter_I_F self) (Seq.get s i) (func_Filter_I_F self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Filter_I_F. forall ab: Seq.seq t_Item. forall b: t_Filter_I_F. forall bc: Seq.seq t_Item. forall c: t_Filter_I_F. produces_Filter_I_F b bc c
                /\ produces_Filter_I_F a ab b
              -> produces_Filter_I_F b bc c
              /\ produces_Filter_I_F a ab b
              /\ (forall result: (). produces_Filter_I_F a (Seq.(++) ab bc) c
                -> produces_Filter_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__filter__impl_IteratorSpec_for_Filter_I_F__produces_refl__refines (* <std::iter::Filter<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_Filter_I_F
  
  type t_Item
  
  type t_F
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) = forall f: t_F, i: t_Item. precondition_F f i
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  predicate produces_Filter_I_F (self: t_Filter_I_F) (visited: Seq.seq t_Item) (succ: t_Filter_I_F) =
    private_invariant_I self
    -> hist_inv_F (func_Filter_I_F self) (func_Filter_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_Filter_I_F self) s (iter_Filter_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_F (func_Filter_I_F self) (Seq.get s i) (func_Filter_I_F self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Filter_I_F. forall result: (). produces_Filter_I_F self (Seq.empty: Seq.seq t_Item) self
        -> produces_Filter_I_F self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__filter_map__impl_IteratorSpec_for_FilterMap_I_F__produces_refl__refines (* <std::iter::FilterMap<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FilterMap_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_Item (f: t_F) = forall i: t_Item. precondition_F f i
  
  function func_FilterMap_I_F (self: t_FilterMap_I_F) : t_F
  
  type t_Option_B = None | Some t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_Option_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_Option_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_Option_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_Item (f: t_F) = forall g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_Item (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut_F f1 i f2 (Some b))
      /\ postcondition_mut_F f1 i f2 (None))
  
  predicate private_invariant_B (f: t_FilterMap_I_F) =
    no_precondition_Item (func_FilterMap_I_F f)
    /\ immutable_Item (func_FilterMap_I_F f) /\ precise_Item (func_FilterMap_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_FilterMap_I_F (self: t_FilterMap_I_F) : t_I
  
  predicate produces_FilterMap_I_F (self: t_FilterMap_I_F) (visited: Seq.seq t_B) (succ: t_FilterMap_I_F) =
    private_invariant_B self
    -> hist_inv_F (func_FilterMap_I_F self) (func_FilterMap_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_FilterMap_I_F self) s (iter_FilterMap_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s (Map.get f i)) (func_FilterMap_I_F self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s j) (func_FilterMap_I_F self) (None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_FilterMap_I_F. forall result: (). produces_FilterMap_I_F self (Seq.empty: Seq.seq t_B) self
        -> produces_FilterMap_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__filter_map__impl_IteratorSpec_for_FilterMap_I_F__produces_trans__refines (* <std::iter::FilterMap<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_FilterMap_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_Item (f: t_F) = forall i: t_Item. precondition_F f i
  
  function func_FilterMap_I_F (self: t_FilterMap_I_F) : t_F
  
  type t_Option_B = None | Some t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_Option_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_Option_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_Option_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_Item (f: t_F) = forall g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_Item (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut_F f1 i f2 (Some b))
      /\ postcondition_mut_F f1 i f2 (None))
  
  predicate private_invariant_B (f: t_FilterMap_I_F) =
    no_precondition_Item (func_FilterMap_I_F f)
    /\ immutable_Item (func_FilterMap_I_F f) /\ precise_Item (func_FilterMap_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_FilterMap_I_F (self: t_FilterMap_I_F) : t_I
  
  predicate produces_FilterMap_I_F (self: t_FilterMap_I_F) (visited: Seq.seq t_B) (succ: t_FilterMap_I_F) =
    private_invariant_B self
    -> hist_inv_F (func_FilterMap_I_F self) (func_FilterMap_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_FilterMap_I_F self) s (iter_FilterMap_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s (Map.get f i)) (func_FilterMap_I_F self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s j) (func_FilterMap_I_F self) (None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FilterMap_I_F. forall ab: Seq.seq t_B. forall b: t_FilterMap_I_F. forall bc: Seq.seq t_B. forall c: t_FilterMap_I_F. produces_FilterMap_I_F b bc c
                /\ produces_FilterMap_I_F a ab b
              -> produces_FilterMap_I_F b bc c
              /\ produces_FilterMap_I_F a ab b
              /\ (forall result: (). produces_FilterMap_I_F a (Seq.(++) ab bc) c
                -> produces_FilterMap_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__fuse__impl_IteratorSpec_for_Fuse_I__produces_trans__refines (* <std::iter::Fuse<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Fuse_I. forall ab: Seq.seq t_Item. forall b: t_Fuse_I. forall bc: Seq.seq t_Item. forall c: t_Fuse_I. produces_Fuse_I b bc c
                /\ produces_Fuse_I a ab b
              -> produces_Fuse_I b bc c
              /\ produces_Fuse_I a ab b
              /\ (forall result: (). produces_Fuse_I a (Seq.(++) ab bc) c -> produces_Fuse_I a (Seq.(++) ab bc) c)
end
module M_std__iter__fuse__impl_IteratorSpec_for_Fuse_I__produces_refl__refines (* <std::iter::Fuse<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Fuse_I. forall result: (). produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__map__impl_IteratorSpec_for_Map_I_F__produces_trans__refines (* <std::iter::Map<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Map_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate produces_Map_I_F [@inline:trivial] (self: t_Map_I_F) (visited: Seq.seq t_B) (succ: t_Map_I_F) =
    hist_inv_F (func_Map_I_F self) (func_Map_I_F succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)]. Seq.length s
          = Seq.length visited
        /\ produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func_Map_I_F self = func_Map_I_F succ
          else
            (Seq.get fs 0).current = func_Map_I_F self
            /\ (Seq.get fs (Seq.length visited - 1)).final = func_Map_I_F succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F (func_Map_I_F self) (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current (Seq.get s i)
          /\ postcondition_mut_F (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Map_I_F. forall ab: Seq.seq t_B. forall b: t_Map_I_F. forall bc: Seq.seq t_B. forall c: t_Map_I_F. produces_Map_I_F b bc c
                /\ produces_Map_I_F a ab b
              -> produces_Map_I_F b bc c
              /\ produces_Map_I_F a ab b
              /\ (forall result: (). produces_Map_I_F a (Seq.(++) ab bc) c -> produces_Map_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__map__impl_IteratorSpec_for_Map_I_F__produces_refl__refines (* <std::iter::Map<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_Map_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate produces_Map_I_F [@inline:trivial] (self: t_Map_I_F) (visited: Seq.seq t_B) (succ: t_Map_I_F) =
    hist_inv_F (func_Map_I_F self) (func_Map_I_F succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)]. Seq.length s
          = Seq.length visited
        /\ produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func_Map_I_F self = func_Map_I_F succ
          else
            (Seq.get fs 0).current = func_Map_I_F self
            /\ (Seq.get fs (Seq.length visited - 1)).final = func_Map_I_F succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F (func_Map_I_F self) (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current (Seq.get s i)
          /\ postcondition_mut_F (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map_I_F. forall result: (). produces_Map_I_F self (Seq.empty: Seq.seq t_B) self
        -> produces_Map_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__map_inv__impl_IteratorSpec_for_MapInv_I_F__produces_trans__refines (* <std::iter::map_inv::MapInv<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current { f0 = Seq.get s i; f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_MapInv_I_F. forall ab: Seq.seq t_B. forall b: t_MapInv_I_F. forall bc: Seq.seq t_B. forall c: t_MapInv_I_F. produces_MapInv_I_F b bc c
                /\ produces_MapInv_I_F a ab b
              -> produces_MapInv_I_F b bc c
              /\ produces_MapInv_I_F a ab b
              /\ (forall result: (). produces_MapInv_I_F a (Seq.(++) ab bc) c
                -> produces_MapInv_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__map_inv__impl_IteratorSpec_for_MapInv_I_F__produces_refl__refines (* <std::iter::map_inv::MapInv<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ precondition_F (Seq.get fs i).current { f0 = Seq.get s i; f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) }
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_MapInv_I_F. forall result: (). produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
        -> produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__once__impl_IteratorSpec_for_Once_T__produces_refl__refines (* <std::iter::Once<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_Once_T (self: t_Once_T) : t_Option_T
  
  predicate produces_Once_T (self: t_Once_T) (visited: Seq.seq t_T) (o: t_Once_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Once_T self = Some e /\ visited = Seq.singleton e /\ view_Once_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Once_T. forall result: (). produces_Once_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Once_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__once__impl_IteratorSpec_for_Once_T__produces_trans__refines (* <std::iter::Once<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_Once_T (self: t_Once_T) : t_Option_T
  
  predicate produces_Once_T (self: t_Once_T) (visited: Seq.seq t_T) (o: t_Once_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Once_T self = Some e /\ visited = Seq.singleton e /\ view_Once_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Once_T. forall ab: Seq.seq t_T. forall b: t_Once_T. forall bc: Seq.seq t_T. forall c: t_Once_T. produces_Once_T b bc c
                /\ produces_Once_T a ab b
              -> produces_Once_T b bc c
              /\ produces_Once_T a ab b
              /\ (forall result: (). produces_Once_T a (Seq.(++) ab bc) c -> produces_Once_T a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_IteratorSpec_for_Range_Idx__produces_refl__refines (* <std::ops::Range<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.end' = o.end'
    /\ deep_model_Idx self.start <= deep_model_Idx o.start
    /\ (Seq.length visited > 0 -> deep_model_Idx o.start <= deep_model_Idx o.end')
    /\ Seq.length visited = deep_model_Idx o.start - deep_model_Idx self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Range_Idx. forall result: (). produces_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
        -> produces_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_IteratorSpec_for_Range_Idx__produces_trans__refines (* <std::ops::Range<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.end' = o.end'
    /\ deep_model_Idx self.start <= deep_model_Idx o.start
    /\ (Seq.length visited > 0 -> deep_model_Idx o.start <= deep_model_Idx o.end')
    /\ Seq.length visited = deep_model_Idx o.start - deep_model_Idx self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Range_Idx. forall ab: Seq.seq t_Idx. forall b: t_Range_Idx. forall bc: Seq.seq t_Idx. forall c: t_Range_Idx. produces_Range_Idx b bc c
                /\ produces_Range_Idx a ab b
              -> produces_Range_Idx b bc c
              /\ produces_Range_Idx a ab b
              /\ (forall result: (). produces_Range_Idx a (Seq.(++) ab bc) c -> produces_Range_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_IteratorSpec_for_RangeInclusive_Idx__produces_trans__refines (* <std::ops::RangeInclusive<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ end_log_RangeInclusive_Idx self = end_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (start_log_RangeInclusive_Idx self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_RangeInclusive_Idx. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive_Idx. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive_Idx. produces_RangeInclusive_Idx b bc c
                /\ produces_RangeInclusive_Idx a ab b
              -> produces_RangeInclusive_Idx b bc c
              /\ produces_RangeInclusive_Idx a ab b
              /\ (forall result: (). produces_RangeInclusive_Idx a (Seq.(++) ab bc) c
                -> produces_RangeInclusive_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_IteratorSpec_for_RangeInclusive_Idx__produces_refl__refines (* <std::ops::RangeInclusive<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ end_log_RangeInclusive_Idx self = end_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (start_log_RangeInclusive_Idx self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_RangeInclusive_Idx. forall result: (). produces_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
        -> produces_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__repeat__impl_IteratorSpec_for_Repeat_T__produces_trans__refines (* <std::iter::Repeat<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Repeat_T
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_Repeat_T (self: t_Repeat_T) : t_T
  
  predicate produces_Repeat_T (self: t_Repeat_T) (visited: Seq.seq t_T) (o: t_Repeat_T) =
    self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> postcondition_clone () (view_Repeat_T self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Repeat_T. forall ab: Seq.seq t_T. forall b: t_Repeat_T. forall bc: Seq.seq t_T. forall c: t_Repeat_T. produces_Repeat_T b bc c
                /\ produces_Repeat_T a ab b
              -> produces_Repeat_T b bc c
              /\ produces_Repeat_T a ab b
              /\ (forall result: (). produces_Repeat_T a (Seq.(++) ab bc) c -> produces_Repeat_T a (Seq.(++) ab bc) c)
end
module M_std__iter__repeat__impl_IteratorSpec_for_Repeat_T__produces_refl__refines (* <std::iter::Repeat<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Repeat_T
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_Repeat_T (self: t_Repeat_T) : t_T
  
  predicate produces_Repeat_T (self: t_Repeat_T) (visited: Seq.seq t_T) (o: t_Repeat_T) =
    self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> postcondition_clone () (view_Repeat_T self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Repeat_T. forall result: (). produces_Repeat_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Repeat_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__rev__impl_IteratorSpec_for_Rev_I__produces_refl__refines (* <std::iter::Rev<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev_I
  
  type t_Item
  
  type t_I
  
  predicate produces_back_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_I_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back_I a ab b
      -> produces_back_I b bc c -> produces_back_I a (Seq.(++) ab bc) c
  
  function produces_back_refl_I (self: t_I) : ()
  
  axiom produces_back_refl_I_spec: forall self: t_I. produces_back_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Rev_I (self: t_Rev_I) : t_I
  
  predicate produces_Rev_I (self: t_Rev_I) (visited: Seq.seq t_Item) (o: t_Rev_I) =
    produces_back_I (iter_Rev_I self) visited (iter_Rev_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Rev_I. forall result: (). produces_Rev_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_Rev_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__rev__impl_IteratorSpec_for_Rev_I__produces_trans__refines (* <std::iter::Rev<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev_I
  
  type t_Item
  
  type t_I
  
  predicate produces_back_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_I_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back_I a ab b
      -> produces_back_I b bc c -> produces_back_I a (Seq.(++) ab bc) c
  
  function produces_back_refl_I (self: t_I) : ()
  
  axiom produces_back_refl_I_spec: forall self: t_I. produces_back_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Rev_I (self: t_Rev_I) : t_I
  
  predicate produces_Rev_I (self: t_Rev_I) (visited: Seq.seq t_Item) (o: t_Rev_I) =
    produces_back_I (iter_Rev_I self) visited (iter_Rev_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Rev_I. forall ab: Seq.seq t_Item. forall b: t_Rev_I. forall bc: Seq.seq t_Item. forall c: t_Rev_I. produces_Rev_I b bc c
                /\ produces_Rev_I a ab b
              -> produces_Rev_I b bc c
              /\ produces_Rev_I a ab b
              /\ (forall result: (). produces_Rev_I a (Seq.(++) ab bc) c -> produces_Rev_I a (Seq.(++) ab bc) c)
end
module M_std__iter__skip__impl_IteratorSpec_for_Skip_I__produces_trans__refines (* <std::iter::Skip<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Skip_I
  
  type t_Item
  
  function n_Skip_I (self: t_Skip_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Item (_1: t_Item)
  
  predicate produces_Skip_I (self: t_Skip_I) (visited: Seq.seq t_Item) (o: t_Skip_I) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n_Skip_I o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n_Skip_I self)
      /\ produces_I (iter_Skip_I self) (Seq.(++) s visited) (iter_Skip_I o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve_Item (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Skip_I. forall ab: Seq.seq t_Item. forall b: t_Skip_I. forall bc: Seq.seq t_Item. forall c: t_Skip_I. produces_Skip_I b bc c
                /\ produces_Skip_I a ab b
              -> produces_Skip_I b bc c
              /\ produces_Skip_I a ab b
              /\ (forall result: (). produces_Skip_I a (Seq.(++) ab bc) c -> produces_Skip_I a (Seq.(++) ab bc) c)
end
module M_std__iter__skip__impl_IteratorSpec_for_Skip_I__produces_refl__refines (* <std::iter::Skip<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Skip_I
  
  type t_Item
  
  function n_Skip_I (self: t_Skip_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Item (_1: t_Item)
  
  predicate produces_Skip_I (self: t_Skip_I) (visited: Seq.seq t_Item) (o: t_Skip_I) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n_Skip_I o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n_Skip_I self)
      /\ produces_I (iter_Skip_I self) (Seq.(++) s visited) (iter_Skip_I o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve_Item (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Skip_I. forall result: (). produces_Skip_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_Skip_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__take__impl_IteratorSpec_for_Take_I__produces_trans__refines (* <std::iter::Take<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Take_I
  
  type t_Item
  
  function n_Take_I (self: t_Take_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate produces_Take_I (self: t_Take_I) (visited: Seq.seq t_Item) (o: t_Take_I) =
    UInt64.t'int (n_Take_I self) = UInt64.t'int (n_Take_I o) + Seq.length visited
    /\ produces_I (iter_Take_I self) visited (iter_Take_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Take_I. forall ab: Seq.seq t_Item. forall b: t_Take_I. forall bc: Seq.seq t_Item. forall c: t_Take_I. produces_Take_I b bc c
                /\ produces_Take_I a ab b
              -> produces_Take_I b bc c
              /\ produces_Take_I a ab b
              /\ (forall result: (). produces_Take_I a (Seq.(++) ab bc) c -> produces_Take_I a (Seq.(++) ab bc) c)
end
module M_std__iter__take__impl_IteratorSpec_for_Take_I__produces_refl__refines (* <std::iter::Take<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Take_I
  
  type t_Item
  
  function n_Take_I (self: t_Take_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate produces_Take_I (self: t_Take_I) (visited: Seq.seq t_Item) (o: t_Take_I) =
    UInt64.t'int (n_Take_I self) = UInt64.t'int (n_Take_I o) + Seq.length visited
    /\ produces_I (iter_Take_I self) visited (iter_Take_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Take_I. forall result: (). produces_Take_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_Take_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__zip__impl_IteratorSpec_for_Zip_A_B__produces_refl__refines (* <std::iter::Zip<A, B> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Zip_A_B
  
  type t_Item
  
  type t_Item'0
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a ab b
      -> produces_A b bc c -> produces_A a (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  function itera_Zip_A_B (self: t_Zip_A_B) : t_A
  
  type t_B
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a ab b
      -> produces_B b bc c -> produces_B a (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb_Zip_A_B (self: t_Zip_A_B) : t_B
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (o: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A (itera_Zip_A_B self) p1 (itera_Zip_A_B o) /\ produces_B (iterb_Zip_A_B self) p2 (iterb_Zip_A_B o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Zip_A_B. forall result: (). produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
        -> produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
end
module M_std__iter__zip__impl_IteratorSpec_for_Zip_A_B__produces_trans__refines (* <std::iter::Zip<A, B> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Zip_A_B
  
  type t_Item
  
  type t_Item'0
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a ab b
      -> produces_A b bc c -> produces_A a (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  function itera_Zip_A_B (self: t_Zip_A_B) : t_A
  
  type t_B
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a ab b
      -> produces_B b bc c -> produces_B a (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb_Zip_A_B (self: t_Zip_A_B) : t_B
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (o: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A (itera_Zip_A_B self) p1 (itera_Zip_A_B o) /\ produces_B (iterb_Zip_A_B self) p2 (iterb_Zip_A_B o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Zip_A_B. forall ab: Seq.seq tup2_Item_Item. forall b: t_Zip_A_B. forall bc: Seq.seq tup2_Item_Item. forall c: t_Zip_A_B. produces_Zip_A_B b bc c
                /\ produces_Zip_A_B a ab b
              -> produces_Zip_A_B b bc c
              /\ produces_Zip_A_B a ab b
              /\ (forall result: (). produces_Zip_A_B a (Seq.(++) ab bc) c -> produces_Zip_A_B a (Seq.(++) ab bc) c)
end
module M_std__iter__impl_IteratorSpec_for_ref_I__produces_refl__refines (* <&mut I as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_ref_I (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces_I self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t t_I. forall result: (). produces_ref_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_ref_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__impl_IteratorSpec_for_ref_I__produces_trans__refines (* <&mut I as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_ref_I (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces_I self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: MutBorrow.t t_I. forall ab: Seq.seq t_Item. forall b: MutBorrow.t t_I. forall bc: Seq.seq t_Item. forall c: MutBorrow.t t_I. produces_ref_I b bc c
                /\ produces_ref_I a ab b
              -> produces_ref_I b bc c
              /\ produces_ref_I a ab b
              /\ (forall result: (). produces_ref_I a (Seq.(++) ab bc) c -> produces_ref_I a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_IntoIter_T__produces_trans__refines (* <std::option::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : t_Option_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_IntoIter_T self = Some e /\ visited = Seq.singleton e /\ view_IntoIter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_T. forall ab: Seq.seq t_T. forall b: t_IntoIter_T. forall bc: Seq.seq t_T. forall c: t_IntoIter_T. produces_IntoIter_T b bc c
                /\ produces_IntoIter_T a ab b
              -> produces_IntoIter_T b bc c
              /\ produces_IntoIter_T a ab b
              /\ (forall result: (). produces_IntoIter_T a (Seq.(++) ab bc) c
                -> produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_IntoIter_T__produces_refl__refines (* <std::option::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : t_Option_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_IntoIter_T self = Some e /\ visited = Seq.singleton e /\ view_IntoIter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T. forall result: (). produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__option__impl_IteratorSpec_for_Iter_T__produces_refl__refines (* <std::option::Iter<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter_T
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_Iter_T (self: t_Iter_T) : t_Option_ref_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Iter_T self = Some e /\ visited = Seq.singleton e /\ view_Iter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter_T. forall result: (). produces_Iter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__option__impl_IteratorSpec_for_Iter_T__produces_trans__refines (* <std::option::Iter<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter_T
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_Iter_T (self: t_Iter_T) : t_Option_ref_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Iter_T self = Some e /\ visited = Seq.singleton e /\ view_Iter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_T. forall ab: Seq.seq t_T. forall b: t_Iter_T. forall bc: Seq.seq t_T. forall c: t_Iter_T. produces_Iter_T b bc c
                /\ produces_Iter_T a ab b
              -> produces_Iter_T b bc c
              /\ produces_Iter_T a ab b
              /\ (forall result: (). produces_Iter_T a (Seq.(++) ab bc) c -> produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_IterMut_T__produces_trans__refines (* <std::option::IterMut<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut_T
  
  type t_T
  
  type t_Option_ref_T = None | Some (MutBorrow.t t_T)
  
  function view_IterMut_T (self: t_IterMut_T) : t_Option_ref_T
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut_T) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view_IterMut_T self = Some e /\ visited = Seq.singleton e /\ view_IterMut_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut_T. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut_T. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut_T. produces_IterMut_T b bc c
                /\ produces_IterMut_T a ab b
              -> produces_IterMut_T b bc c
              /\ produces_IterMut_T a ab b
              /\ (forall result: (). produces_IterMut_T a (Seq.(++) ab bc) c -> produces_IterMut_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_IterMut_T__produces_refl__refines (* <std::option::IterMut<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut_T
  
  type t_T
  
  type t_Option_ref_T = None | Some (MutBorrow.t t_T)
  
  function view_IterMut_T (self: t_IterMut_T) : t_Option_ref_T
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut_T) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view_IterMut_T self = Some e /\ visited = Seq.singleton e /\ view_IterMut_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IterMut_T. forall result: (). produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
        -> produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_std__slice__impl_IteratorSpec_for_Iter_T__produces_refl__refines (* <std::slice::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter_T. forall result: (). produces_Iter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__slice__impl_IteratorSpec_for_Iter_T__produces_trans__refines (* <std::slice::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_T. forall ab: Seq.seq t_T. forall b: t_Iter_T. forall bc: Seq.seq t_T. forall c: t_Iter_T. produces_Iter_T b bc c
                /\ produces_Iter_T a ab b
              -> produces_Iter_T b bc c
              /\ produces_Iter_T a ab b
              /\ (forall result: (). produces_Iter_T a (Seq.(++) ab bc) c -> produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__slice__impl_IteratorSpec_for_IterMut_T__produces_refl__refines (* <std::slice::IterMut<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_IterMut_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_mut_seq_slice_T (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_slice_T_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq_slice_T self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_slice_T_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq_slice_T self)
        -> Seq.get (to_mut_seq_slice_T self) i
        = MutBorrow.borrow_logic (index_slice_T self.current i) (index_slice_T self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut_T) =
    to_mut_seq_slice_T (view_IterMut_T self) = Seq.(++) visited (to_mut_seq_slice_T (view_IterMut_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IterMut_T. forall result: (). produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
        -> produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_std__slice__impl_IteratorSpec_for_IterMut_T__produces_trans__refines (* <std::slice::IterMut<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use mach.int.Int
  
  type t_IterMut_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_mut_seq_slice_T (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_slice_T_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq_slice_T self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_slice_T_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq_slice_T self)
        -> Seq.get (to_mut_seq_slice_T self) i
        = MutBorrow.borrow_logic (index_slice_T self.current i) (index_slice_T self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut_T) =
    to_mut_seq_slice_T (view_IterMut_T self) = Seq.(++) visited (to_mut_seq_slice_T (view_IterMut_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut_T. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut_T. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut_T. produces_IterMut_T b bc c
                /\ produces_IterMut_T a ab b
              -> produces_IterMut_T b bc c
              /\ produces_IterMut_T a ab b
              /\ (forall result: (). produces_IterMut_T a (Seq.(++) ab bc) c -> produces_IterMut_T a (Seq.(++) ab bc) c)
end
module M_std__vec__impl_IteratorSpec_for_IntoIter_T_A__produces_trans__refines (* <std::vec::IntoIter<T, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T_A
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate produces_IntoIter_T_A (self: t_IntoIter_T_A) (visited: Seq.seq t_T) (rhs: t_IntoIter_T_A) =
    view_IntoIter_T_A self = Seq.(++) visited (view_IntoIter_T_A rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_T_A. forall ab: Seq.seq t_T. forall b: t_IntoIter_T_A. forall bc: Seq.seq t_T. forall c: t_IntoIter_T_A. produces_IntoIter_T_A b bc c
                /\ produces_IntoIter_T_A a ab b
              -> produces_IntoIter_T_A b bc c
              /\ produces_IntoIter_T_A a ab b
              /\ (forall result: (). produces_IntoIter_T_A a (Seq.(++) ab bc) c
                -> produces_IntoIter_T_A a (Seq.(++) ab bc) c)
end
module M_std__vec__impl_IteratorSpec_for_IntoIter_T_A__produces_refl__refines (* <std::vec::IntoIter<T, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T_A
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate produces_IntoIter_T_A (self: t_IntoIter_T_A) (visited: Seq.seq t_T) (rhs: t_IntoIter_T_A) =
    view_IntoIter_T_A self = Seq.(++) visited (view_IntoIter_T_A rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T_A. forall result: (). produces_IntoIter_T_A self (Seq.empty: Seq.seq t_T) self
        -> produces_IntoIter_T_A self (Seq.empty: Seq.seq t_T) self
end
module M_logic__int__impl_PartialOrd_for_Int__gt__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ > other)
          -> result = (deep_model_ref_Int self_ > deep_model_ref_Int other)
end
module M_logic__int__impl_PartialOrd_for_Int__ge__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ >= other)
          -> result = (deep_model_ref_Int self_ >= deep_model_ref_Int other)
end
module M_logic__int__impl_PartialOrd_for_Int__le__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ <= other)
          -> result = (deep_model_ref_Int self_ <= deep_model_ref_Int other)
end
module M_logic__int__impl_PartialOrd_for_Int__partial_cmp__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall rhs: int. forall result: t_Option_Ordering. result
            = Some (cmp_log_Int self_ rhs) -> result = Some (cmp_log_Int (deep_model_Int self_) (deep_model_Int rhs))
end
module M_logic__int__impl_PartialOrd_for_Int__lt__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ < other)
          -> result = (deep_model_ref_Int self_ < deep_model_ref_Int other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__partial_cmp__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: t_Option_Ordering. result
            = Some (cmp_log_PeanoInt self_ rhs)
          -> result = Some (cmp_log_u64 (deep_model_PeanoInt self_) (deep_model_PeanoInt rhs))
end
module M_peano__impl_PartialOrd_for_PeanoInt__le__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.le (view_PeanoInt self_) (view_PeanoInt other)
          -> result = UInt64.le (deep_model_ref_PeanoInt self_) (deep_model_ref_PeanoInt other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__lt__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.lt (view_PeanoInt self_) (view_PeanoInt other)
          -> result = UInt64.lt (deep_model_ref_PeanoInt self_) (deep_model_ref_PeanoInt other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__gt__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.gt (view_PeanoInt self_) (view_PeanoInt other)
          -> result = UInt64.gt (deep_model_ref_PeanoInt self_) (deep_model_ref_PeanoInt other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__ge__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.ge (view_PeanoInt self_) (view_PeanoInt other)
          -> result = UInt64.ge (deep_model_ref_PeanoInt self_) (deep_model_ref_PeanoInt other)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_ge_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate ge_log_ref_T (self: t_T) (other: t_T) = ge_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). ge_log_ref_T x y = (cmp_log_ref_T x y <> Less)
          -> ge_log_ref_T x y = (cmp_log_ref_T x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__refl__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall result: (). cmp_log_ref_T x x = Equal -> cmp_log_ref_T x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_ref_T__antisym1__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. cmp_log_ref_T x y = Less
        -> cmp_log_ref_T x y = Less /\ (forall result: (). cmp_log_ref_T y x = Greater -> cmp_log_ref_T y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_gt_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate gt_log_ref_T (self: t_T) (other: t_T) = gt_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). gt_log_ref_T x y = (cmp_log_ref_T x y = Greater)
          -> gt_log_ref_T x y = (cmp_log_ref_T x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_le_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate le_log_ref_T (self: t_T) (other: t_T) = le_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). le_log_ref_T x y = (cmp_log_ref_T x y <> Greater)
          -> le_log_ref_T x y = (cmp_log_ref_T x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_lt_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate lt_log_ref_T (self: t_T) (other: t_T) = lt_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). lt_log_ref_T x y = (cmp_log_ref_T x y = Less)
          -> lt_log_ref_T x y = (cmp_log_ref_T x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__eq_cmp__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). (x = y) = (cmp_log_ref_T x y = Equal)
          -> (x = y) = (cmp_log_ref_T x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__antisym2__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. cmp_log_ref_T x y = Greater
        -> cmp_log_ref_T x y = Greater /\ (forall result: (). cmp_log_ref_T y x = Less -> cmp_log_ref_T y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__trans__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall z: t_T. forall o: t_Ordering. cmp_log_ref_T y z = o
              /\ cmp_log_ref_T x y = o
            -> cmp_log_ref_T y z = o
            /\ cmp_log_ref_T x y = o /\ (forall result: (). cmp_log_ref_T x z = o -> cmp_log_ref_T x z = o)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_gt_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x > y) = (cmp_log_Int x y = Greater)
          -> (x > y) = (cmp_log_Int x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_ge_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x >= y) = (cmp_log_Int x y <> Less)
          -> (x >= y) = (cmp_log_Int x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__antisym2__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. cmp_log_Int x y = Greater
        -> cmp_log_Int x y = Greater /\ (forall result: (). cmp_log_Int y x = Less -> cmp_log_Int y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__eq_cmp__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x = y) = (cmp_log_Int x y = Equal)
          -> (x = y) = (cmp_log_Int x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_le_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x <= y) = (cmp_log_Int x y <> Greater)
          -> (x <= y) = (cmp_log_Int x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__refl__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall result: (). cmp_log_Int x x = Equal -> cmp_log_Int x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_Int__trans__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall z: int. forall o: t_Ordering. cmp_log_Int y z = o
              /\ cmp_log_Int x y = o
            -> cmp_log_Int y z = o
            /\ cmp_log_Int x y = o /\ (forall result: (). cmp_log_Int x z = o -> cmp_log_Int x z = o)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_lt_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x < y) = (cmp_log_Int x y = Less)
          -> (x < y) = (cmp_log_Int x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__antisym1__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. cmp_log_Int x y = Less
        -> cmp_log_Int x y = Less /\ (forall result: (). cmp_log_Int y x = Greater -> cmp_log_Int y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__eq_cmp__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). (x = y) = (cmp_log_u8 x y = Equal)
          -> (x = y) = (cmp_log_u8 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_gt_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.gt x y = (cmp_log_u8 x y = Greater)
          -> UInt8.gt x y = (cmp_log_u8 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__trans__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall z: UInt8.t. forall o: t_Ordering. cmp_log_u8 y z = o
              /\ cmp_log_u8 x y = o
            -> cmp_log_u8 y z = o /\ cmp_log_u8 x y = o /\ (forall result: (). cmp_log_u8 x z = o -> cmp_log_u8 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u8__antisym2__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. cmp_log_u8 x y = Greater
        -> cmp_log_u8 x y = Greater /\ (forall result: (). cmp_log_u8 y x = Less -> cmp_log_u8 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_le_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.le x y = (cmp_log_u8 x y <> Greater)
          -> UInt8.le x y = (cmp_log_u8 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_lt_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.lt x y = (cmp_log_u8 x y = Less)
          -> UInt8.lt x y = (cmp_log_u8 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_ge_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.ge x y = (cmp_log_u8 x y <> Less)
          -> UInt8.ge x y = (cmp_log_u8 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__antisym1__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. cmp_log_u8 x y = Less
        -> cmp_log_u8 x y = Less /\ (forall result: (). cmp_log_u8 y x = Greater -> cmp_log_u8 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__refl__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall result: (). cmp_log_u8 x x = Equal -> cmp_log_u8 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u16__antisym2__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. cmp_log_u16 x y = Greater
        -> cmp_log_u16 x y = Greater /\ (forall result: (). cmp_log_u16 y x = Less -> cmp_log_u16 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_ge_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.ge x y = (cmp_log_u16 x y <> Less)
          -> UInt16.ge x y = (cmp_log_u16 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__refl__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall result: (). cmp_log_u16 x x = Equal -> cmp_log_u16 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_lt_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.lt x y = (cmp_log_u16 x y = Less)
          -> UInt16.lt x y = (cmp_log_u16 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_le_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.le x y = (cmp_log_u16 x y <> Greater)
          -> UInt16.le x y = (cmp_log_u16 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__antisym1__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. cmp_log_u16 x y = Less
        -> cmp_log_u16 x y = Less /\ (forall result: (). cmp_log_u16 y x = Greater -> cmp_log_u16 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__trans__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall z: UInt16.t. forall o: t_Ordering. cmp_log_u16 y z = o
              /\ cmp_log_u16 x y = o
            -> cmp_log_u16 y z = o
            /\ cmp_log_u16 x y = o /\ (forall result: (). cmp_log_u16 x z = o -> cmp_log_u16 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u16__eq_cmp__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). (x = y) = (cmp_log_u16 x y = Equal)
          -> (x = y) = (cmp_log_u16 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_gt_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.gt x y = (cmp_log_u16 x y = Greater)
          -> UInt16.gt x y = (cmp_log_u16 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_gt_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.gt x y = (cmp_log_u32 x y = Greater)
          -> UInt32.gt x y = (cmp_log_u32 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__trans__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall z: UInt32.t. forall o: t_Ordering. cmp_log_u32 y z = o
              /\ cmp_log_u32 x y = o
            -> cmp_log_u32 y z = o
            /\ cmp_log_u32 x y = o /\ (forall result: (). cmp_log_u32 x z = o -> cmp_log_u32 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_lt_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.lt x y = (cmp_log_u32 x y = Less)
          -> UInt32.lt x y = (cmp_log_u32 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_ge_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.ge x y = (cmp_log_u32 x y <> Less)
          -> UInt32.ge x y = (cmp_log_u32 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_le_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.le x y = (cmp_log_u32 x y <> Greater)
          -> UInt32.le x y = (cmp_log_u32 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__antisym2__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. cmp_log_u32 x y = Greater
        -> cmp_log_u32 x y = Greater /\ (forall result: (). cmp_log_u32 y x = Less -> cmp_log_u32 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__refl__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall result: (). cmp_log_u32 x x = Equal -> cmp_log_u32 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u32__eq_cmp__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). (x = y) = (cmp_log_u32 x y = Equal)
          -> (x = y) = (cmp_log_u32 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u32__antisym1__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. cmp_log_u32 x y = Less
        -> cmp_log_u32 x y = Less /\ (forall result: (). cmp_log_u32 y x = Greater -> cmp_log_u32 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__trans__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log_u64 y z = o
              /\ cmp_log_u64 x y = o
            -> cmp_log_u64 y z = o
            /\ cmp_log_u64 x y = o /\ (forall result: (). cmp_log_u64 x z = o -> cmp_log_u64 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u64__eq_cmp__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log_u64 x y = Equal)
          -> (x = y) = (cmp_log_u64 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u64__antisym1__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log_u64 x y = Less
        -> cmp_log_u64 x y = Less /\ (forall result: (). cmp_log_u64 y x = Greater -> cmp_log_u64 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__refl__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall result: (). cmp_log_u64 x x = Equal -> cmp_log_u64 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_le_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y = (cmp_log_u64 x y <> Greater)
          -> UInt64.le x y = (cmp_log_u64 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_ge_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y = (cmp_log_u64 x y <> Less)
          -> UInt64.ge x y = (cmp_log_u64 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__antisym2__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log_u64 x y = Greater
        -> cmp_log_u64 x y = Greater /\ (forall result: (). cmp_log_u64 y x = Less -> cmp_log_u64 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_gt_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y = (cmp_log_u64 x y = Greater)
          -> UInt64.gt x y = (cmp_log_u64 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_lt_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y = (cmp_log_u64 x y = Less)
          -> UInt64.lt x y = (cmp_log_u64 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__antisym2__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. cmp_log_u128 x y = Greater
        -> cmp_log_u128 x y = Greater /\ (forall result: (). cmp_log_u128 y x = Less -> cmp_log_u128 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_le_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.le x y
            = (cmp_log_u128 x y <> Greater) -> UInt128.le x y = (cmp_log_u128 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__antisym1__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. cmp_log_u128 x y = Less
        -> cmp_log_u128 x y = Less /\ (forall result: (). cmp_log_u128 y x = Greater -> cmp_log_u128 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__trans__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall z: UInt128.t. forall o: t_Ordering. cmp_log_u128 y z
                = o
              /\ cmp_log_u128 x y = o
            -> cmp_log_u128 y z = o
            /\ cmp_log_u128 x y = o /\ (forall result: (). cmp_log_u128 x z = o -> cmp_log_u128 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u128__refl__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall result: (). cmp_log_u128 x x = Equal -> cmp_log_u128 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_ge_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.ge x y = (cmp_log_u128 x y <> Less)
          -> UInt128.ge x y = (cmp_log_u128 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__eq_cmp__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). (x = y) = (cmp_log_u128 x y = Equal)
          -> (x = y) = (cmp_log_u128 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_gt_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.gt x y
            = (cmp_log_u128 x y = Greater) -> UInt128.gt x y = (cmp_log_u128 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_lt_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.lt x y = (cmp_log_u128 x y = Less)
          -> UInt128.lt x y = (cmp_log_u128 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__antisym1__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log_usize x y = Less
        -> cmp_log_usize x y = Less /\ (forall result: (). cmp_log_usize y x = Greater -> cmp_log_usize y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_ge_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y = (cmp_log_usize x y <> Less)
          -> UInt64.ge x y = (cmp_log_usize x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_le_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y
            = (cmp_log_usize x y <> Greater) -> UInt64.le x y = (cmp_log_usize x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_lt_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y = (cmp_log_usize x y = Less)
          -> UInt64.lt x y = (cmp_log_usize x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_gt_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y = (cmp_log_usize x y = Greater)
          -> UInt64.gt x y = (cmp_log_usize x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__trans__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log_usize y z = o
              /\ cmp_log_usize x y = o
            -> cmp_log_usize y z = o
            /\ cmp_log_usize x y = o /\ (forall result: (). cmp_log_usize x z = o -> cmp_log_usize x z = o)
end
module M_logic__ord__impl_OrdLogic_for_usize__eq_cmp__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log_usize x y = Equal)
          -> (x = y) = (cmp_log_usize x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_usize__antisym2__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log_usize x y = Greater
        -> cmp_log_usize x y = Greater /\ (forall result: (). cmp_log_usize y x = Less -> cmp_log_usize y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__refl__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall result: (). cmp_log_usize x x = Equal -> cmp_log_usize x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_lt_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.lt x y = (cmp_log_i8 x y = Less)
          -> Int8.lt x y = (cmp_log_i8 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_ge_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.ge x y = (cmp_log_i8 x y <> Less)
          -> Int8.ge x y = (cmp_log_i8 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__trans__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall z: Int8.t. forall o: t_Ordering. cmp_log_i8 y z = o
              /\ cmp_log_i8 x y = o
            -> cmp_log_i8 y z = o /\ cmp_log_i8 x y = o /\ (forall result: (). cmp_log_i8 x z = o -> cmp_log_i8 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i8__refl__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall result: (). cmp_log_i8 x x = Equal -> cmp_log_i8 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i8__antisym1__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. cmp_log_i8 x y = Less
        -> cmp_log_i8 x y = Less /\ (forall result: (). cmp_log_i8 y x = Greater -> cmp_log_i8 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_gt_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.gt x y = (cmp_log_i8 x y = Greater)
          -> Int8.gt x y = (cmp_log_i8 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__eq_cmp__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). (x = y) = (cmp_log_i8 x y = Equal)
          -> (x = y) = (cmp_log_i8 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i8__antisym2__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. cmp_log_i8 x y = Greater
        -> cmp_log_i8 x y = Greater /\ (forall result: (). cmp_log_i8 y x = Less -> cmp_log_i8 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_le_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.le x y = (cmp_log_i8 x y <> Greater)
          -> Int8.le x y = (cmp_log_i8 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_ge_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.ge x y = (cmp_log_i16 x y <> Less)
          -> Int16.ge x y = (cmp_log_i16 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__trans__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall z: Int16.t. forall o: t_Ordering. cmp_log_i16 y z = o
              /\ cmp_log_i16 x y = o
            -> cmp_log_i16 y z = o
            /\ cmp_log_i16 x y = o /\ (forall result: (). cmp_log_i16 x z = o -> cmp_log_i16 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_le_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.le x y = (cmp_log_i16 x y <> Greater)
          -> Int16.le x y = (cmp_log_i16 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__refl__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall result: (). cmp_log_i16 x x = Equal -> cmp_log_i16 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i16__eq_cmp__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). (x = y) = (cmp_log_i16 x y = Equal)
          -> (x = y) = (cmp_log_i16 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_lt_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.lt x y = (cmp_log_i16 x y = Less)
          -> Int16.lt x y = (cmp_log_i16 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__antisym2__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. cmp_log_i16 x y = Greater
        -> cmp_log_i16 x y = Greater /\ (forall result: (). cmp_log_i16 y x = Less -> cmp_log_i16 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_gt_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.gt x y = (cmp_log_i16 x y = Greater)
          -> Int16.gt x y = (cmp_log_i16 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__antisym1__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. cmp_log_i16 x y = Less
        -> cmp_log_i16 x y = Less /\ (forall result: (). cmp_log_i16 y x = Greater -> cmp_log_i16 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_le_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.le x y = (cmp_log_i32 x y <> Greater)
          -> Int32.le x y = (cmp_log_i32 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__trans__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall z: Int32.t. forall o: t_Ordering. cmp_log_i32 y z = o
              /\ cmp_log_i32 x y = o
            -> cmp_log_i32 y z = o
            /\ cmp_log_i32 x y = o /\ (forall result: (). cmp_log_i32 x z = o -> cmp_log_i32 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_gt_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.gt x y = (cmp_log_i32 x y = Greater)
          -> Int32.gt x y = (cmp_log_i32 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_lt_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.lt x y = (cmp_log_i32 x y = Less)
          -> Int32.lt x y = (cmp_log_i32 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_ge_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.ge x y = (cmp_log_i32 x y <> Less)
          -> Int32.ge x y = (cmp_log_i32 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__antisym1__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. cmp_log_i32 x y = Less
        -> cmp_log_i32 x y = Less /\ (forall result: (). cmp_log_i32 y x = Greater -> cmp_log_i32 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__antisym2__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. cmp_log_i32 x y = Greater
        -> cmp_log_i32 x y = Greater /\ (forall result: (). cmp_log_i32 y x = Less -> cmp_log_i32 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__refl__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall result: (). cmp_log_i32 x x = Equal -> cmp_log_i32 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i32__eq_cmp__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). (x = y) = (cmp_log_i32 x y = Equal)
          -> (x = y) = (cmp_log_i32 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i64__refl__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall result: (). cmp_log_i64 x x = Equal -> cmp_log_i64 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_lt_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log_i64 x y = Less)
          -> Int64.lt x y = (cmp_log_i64 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__antisym1__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log_i64 x y = Less
        -> cmp_log_i64 x y = Less /\ (forall result: (). cmp_log_i64 y x = Greater -> cmp_log_i64 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__trans__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log_i64 y z = o
              /\ cmp_log_i64 x y = o
            -> cmp_log_i64 y z = o
            /\ cmp_log_i64 x y = o /\ (forall result: (). cmp_log_i64 x z = o -> cmp_log_i64 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i64__eq_cmp__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log_i64 x y = Equal)
          -> (x = y) = (cmp_log_i64 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i64__antisym2__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log_i64 x y = Greater
        -> cmp_log_i64 x y = Greater /\ (forall result: (). cmp_log_i64 y x = Less -> cmp_log_i64 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_gt_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y = (cmp_log_i64 x y = Greater)
          -> Int64.gt x y = (cmp_log_i64 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_le_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y = (cmp_log_i64 x y <> Greater)
          -> Int64.le x y = (cmp_log_i64 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_ge_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log_i64 x y <> Less)
          -> Int64.ge x y = (cmp_log_i64 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__antisym1__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. cmp_log_i128 x y = Less
        -> cmp_log_i128 x y = Less /\ (forall result: (). cmp_log_i128 y x = Greater -> cmp_log_i128 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__eq_cmp__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). (x = y) = (cmp_log_i128 x y = Equal)
          -> (x = y) = (cmp_log_i128 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i128__antisym2__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. cmp_log_i128 x y = Greater
        -> cmp_log_i128 x y = Greater /\ (forall result: (). cmp_log_i128 y x = Less -> cmp_log_i128 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_gt_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.gt x y = (cmp_log_i128 x y = Greater)
          -> Int128.gt x y = (cmp_log_i128 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__refl__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall result: (). cmp_log_i128 x x = Equal -> cmp_log_i128 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_ge_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.ge x y = (cmp_log_i128 x y <> Less)
          -> Int128.ge x y = (cmp_log_i128 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_lt_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.lt x y = (cmp_log_i128 x y = Less)
          -> Int128.lt x y = (cmp_log_i128 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_le_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.le x y = (cmp_log_i128 x y <> Greater)
          -> Int128.le x y = (cmp_log_i128 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__trans__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall z: Int128.t. forall o: t_Ordering. cmp_log_i128 y z = o
              /\ cmp_log_i128 x y = o
            -> cmp_log_i128 y z = o
            /\ cmp_log_i128 x y = o /\ (forall result: (). cmp_log_i128 x z = o -> cmp_log_i128 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_isize__antisym1__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log_isize x y = Less
        -> cmp_log_isize x y = Less /\ (forall result: (). cmp_log_isize y x = Greater -> cmp_log_isize y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__antisym2__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log_isize x y = Greater
        -> cmp_log_isize x y = Greater /\ (forall result: (). cmp_log_isize y x = Less -> cmp_log_isize y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_ge_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log_isize x y <> Less)
          -> Int64.ge x y = (cmp_log_isize x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_lt_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log_isize x y = Less)
          -> Int64.lt x y = (cmp_log_isize x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__trans__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log_isize y z = o
              /\ cmp_log_isize x y = o
            -> cmp_log_isize y z = o
            /\ cmp_log_isize x y = o /\ (forall result: (). cmp_log_isize x z = o -> cmp_log_isize x z = o)
end
module M_logic__ord__impl_OrdLogic_for_isize__eq_cmp__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log_isize x y = Equal)
          -> (x = y) = (cmp_log_isize x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_isize__refl__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall result: (). cmp_log_isize x x = Equal -> cmp_log_isize x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_gt_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y = (cmp_log_isize x y = Greater)
          -> Int64.gt x y = (cmp_log_isize x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_le_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y = (cmp_log_isize x y <> Greater)
          -> Int64.le x y = (cmp_log_isize x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_le_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.le x y = (cmp_log_char x y <> Greater)
          -> Char.le x y = (cmp_log_char x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__antisym2__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. cmp_log_char x y = Greater
        -> cmp_log_char x y = Greater /\ (forall result: (). cmp_log_char y x = Less -> cmp_log_char y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_char__antisym1__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. cmp_log_char x y = Less
        -> cmp_log_char x y = Less /\ (forall result: (). cmp_log_char y x = Greater -> cmp_log_char y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_ge_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.ge x y = (cmp_log_char x y <> Less)
          -> Char.ge x y = (cmp_log_char x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_lt_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.lt x y = (cmp_log_char x y = Less)
          -> Char.lt x y = (cmp_log_char x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_char__refl__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall result: (). cmp_log_char x x = Equal -> cmp_log_char x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_char__trans__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall z: Char.t. forall o: t_Ordering. cmp_log_char y z = o
              /\ cmp_log_char x y = o
            -> cmp_log_char y z = o
            /\ cmp_log_char x y = o /\ (forall result: (). cmp_log_char x z = o -> cmp_log_char x z = o)
end
module M_logic__ord__impl_OrdLogic_for_char__eq_cmp__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). (x = y) = (cmp_log_char x y = Equal)
          -> (x = y) = (cmp_log_char x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_gt_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.gt x y = (cmp_log_char x y = Greater)
          -> Char.gt x y = (cmp_log_char x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_le_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.le x y = (cmp_log_bool x y <> Greater)
          -> Bool.le x y = (cmp_log_bool x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_ge_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.ge x y = (cmp_log_bool x y <> Less)
          -> Bool.ge x y = (cmp_log_bool x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__antisym2__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. cmp_log_bool x y = Greater
        -> cmp_log_bool x y = Greater /\ (forall result: (). cmp_log_bool y x = Less -> cmp_log_bool y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__eq_cmp__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). (x = y) = (cmp_log_bool x y = Equal)
          -> (x = y) = (cmp_log_bool x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_bool__antisym1__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. cmp_log_bool x y = Less
        -> cmp_log_bool x y = Less /\ (forall result: (). cmp_log_bool y x = Greater -> cmp_log_bool y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__refl__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall result: (). cmp_log_bool x x = Equal -> cmp_log_bool x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_gt_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.gt x y = (cmp_log_bool x y = Greater)
          -> Bool.gt x y = (cmp_log_bool x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__trans__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall z: bool. forall o: t_Ordering. cmp_log_bool y z = o
              /\ cmp_log_bool x y = o
            -> cmp_log_bool y z = o
            /\ cmp_log_bool x y = o /\ (forall result: (). cmp_log_bool x z = o -> cmp_log_bool x z = o)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_lt_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.lt x y = (cmp_log_bool x y = Less)
          -> Bool.lt x y = (cmp_log_bool x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_ge_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate ge_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ ge_log_B self.f1 o.f1 \/ gt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). ge_log_tup2_A_B x y
            = (cmp_log_tup2_A_B x y <> Less) -> ge_log_tup2_A_B x y = (cmp_log_tup2_A_B x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__refl__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall result: (). cmp_log_tup2_A_B x x = Equal -> cmp_log_tup2_A_B x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_gt_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate gt_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ gt_log_B self.f1 o.f1 \/ gt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). gt_log_tup2_A_B x y
            = (cmp_log_tup2_A_B x y = Greater) -> gt_log_tup2_A_B x y = (cmp_log_tup2_A_B x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_lt_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate lt_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ lt_log_B self.f1 o.f1 \/ lt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). lt_log_tup2_A_B x y
            = (cmp_log_tup2_A_B x y = Less) -> lt_log_tup2_A_B x y = (cmp_log_tup2_A_B x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__eq_cmp__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). (x = y) = (cmp_log_tup2_A_B x y = Equal)
          -> (x = y) = (cmp_log_tup2_A_B x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__antisym1__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. cmp_log_tup2_A_B x y = Less
        -> cmp_log_tup2_A_B x y = Less
        /\ (forall result: (). cmp_log_tup2_A_B y x = Greater -> cmp_log_tup2_A_B y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__antisym2__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. cmp_log_tup2_A_B x y = Greater
        -> cmp_log_tup2_A_B x y = Greater
        /\ (forall result: (). cmp_log_tup2_A_B y x = Less -> cmp_log_tup2_A_B y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_le_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate le_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ le_log_B self.f1 o.f1 \/ lt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). le_log_tup2_A_B x y
            = (cmp_log_tup2_A_B x y <> Greater) -> le_log_tup2_A_B x y = (cmp_log_tup2_A_B x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__trans__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall z: tup2_A_B. forall o: t_Ordering. cmp_log_tup2_A_B y z
                = o
              /\ cmp_log_tup2_A_B x y = o
            -> cmp_log_tup2_A_B y z = o
            /\ cmp_log_tup2_A_B x y = o /\ (forall result: (). cmp_log_tup2_A_B x z = o -> cmp_log_tup2_A_B x z = o)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_le_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(<=) x y
            = (cmp_log_Real x y <> Greater) -> Real.(<=) x y = (cmp_log_Real x y <> Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__antisym2__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. cmp_log_Real x y = Greater
        -> cmp_log_Real x y = Greater /\ (forall result: (). cmp_log_Real y x = Less -> cmp_log_Real y x = Less)
end
module M_logic__real__impl_OrdLogic_for_Real__antisym1__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. cmp_log_Real x y = Less
        -> cmp_log_Real x y = Less /\ (forall result: (). cmp_log_Real y x = Greater -> cmp_log_Real y x = Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_lt_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(<) x y = (cmp_log_Real x y = Less)
          -> Real.(<) x y = (cmp_log_Real x y = Less)
end
module M_logic__real__impl_OrdLogic_for_Real__trans__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall z: Real.real. forall o: t_Ordering. cmp_log_Real y z
                = o
              /\ cmp_log_Real x y = o
            -> cmp_log_Real y z = o
            /\ cmp_log_Real x y = o /\ (forall result: (). cmp_log_Real x z = o -> cmp_log_Real x z = o)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_ge_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(>=) x y = (cmp_log_Real x y <> Less)
          -> Real.(>=) x y = (cmp_log_Real x y <> Less)
end
module M_logic__real__impl_OrdLogic_for_Real__refl__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall result: (). cmp_log_Real x x = Equal -> cmp_log_Real x x = Equal
end
module M_logic__real__impl_OrdLogic_for_Real__eq_cmp__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). (x = y) = (cmp_log_Real x y = Equal)
          -> (x = y) = (cmp_log_Real x y = Equal)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_gt_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(>) x y = (cmp_log_Real x y = Greater)
          -> Real.(>) x y = (cmp_log_Real x y = Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__antisym2__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
        -> cmp_log_PeanoInt x y = Greater
        /\ (forall result: (). cmp_log_PeanoInt y x = Less -> cmp_log_PeanoInt y x = Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__trans__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall x: t_PeanoInt. forall y: t_PeanoInt. forall z: t_PeanoInt. forall o: t_Ordering. cmp_log_PeanoInt y z = o
              /\ cmp_log_PeanoInt x y = o
            -> cmp_log_PeanoInt y z = o
            /\ cmp_log_PeanoInt x y = o /\ (forall result: (). cmp_log_PeanoInt x z = o -> cmp_log_PeanoInt x z = o)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_ge_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). ge_log_PeanoInt x y
            = (cmp_log_PeanoInt x y <> Less) -> ge_log_PeanoInt x y = (cmp_log_PeanoInt x y <> Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__antisym1__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. cmp_log_PeanoInt x y = Less
        -> cmp_log_PeanoInt x y = Less
        /\ (forall result: (). cmp_log_PeanoInt y x = Greater -> cmp_log_PeanoInt y x = Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_lt_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). lt_log_PeanoInt x y
            = (cmp_log_PeanoInt x y = Less) -> lt_log_PeanoInt x y = (cmp_log_PeanoInt x y = Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_le_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). le_log_PeanoInt x y
            = (cmp_log_PeanoInt x y <> Greater) -> le_log_PeanoInt x y = (cmp_log_PeanoInt x y <> Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__refl__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall result: (). cmp_log_PeanoInt x x = Equal -> cmp_log_PeanoInt x x = Equal
end
module M_peano__impl_OrdLogic_for_PeanoInt__eq_cmp__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). (x = y) = (cmp_log_PeanoInt x y = Equal)
          -> (x = y) = (cmp_log_PeanoInt x y = Equal)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_gt_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). gt_log_PeanoInt x y
            = (cmp_log_PeanoInt x y = Greater) -> gt_log_PeanoInt x y = (cmp_log_PeanoInt x y = Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_lt_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate lt_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o = Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). lt_log_Reverse_T x y
            = (cmp_log_Reverse_T x y = Less) -> lt_log_Reverse_T x y = (cmp_log_Reverse_T x y = Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__antisym1__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. cmp_log_Reverse_T x y = Less
        -> cmp_log_Reverse_T x y = Less
        /\ (forall result: (). cmp_log_Reverse_T y x = Greater -> cmp_log_Reverse_T y x = Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__eq_cmp__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). (x = y)
            = (cmp_log_Reverse_T x y = Equal) -> (x = y) = (cmp_log_Reverse_T x y = Equal)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__refl__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall result: (). cmp_log_Reverse_T x x = Equal -> cmp_log_Reverse_T x x = Equal
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__trans__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall x: t_Reverse_T. forall y: t_Reverse_T. forall z: t_Reverse_T. forall o: t_Ordering. cmp_log_Reverse_T y z = o
              /\ cmp_log_Reverse_T x y = o
            -> cmp_log_Reverse_T y z = o
            /\ cmp_log_Reverse_T x y = o /\ (forall result: (). cmp_log_Reverse_T x z = o -> cmp_log_Reverse_T x z = o)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__antisym2__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. cmp_log_Reverse_T x y = Greater
        -> cmp_log_Reverse_T x y = Greater
        /\ (forall result: (). cmp_log_Reverse_T y x = Less -> cmp_log_Reverse_T y x = Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_le_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate le_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o <> Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). le_log_Reverse_T x y
            = (cmp_log_Reverse_T x y <> Greater) -> le_log_Reverse_T x y = (cmp_log_Reverse_T x y <> Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_ge_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate ge_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o <> Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). ge_log_Reverse_T x y
            = (cmp_log_Reverse_T x y <> Less) -> ge_log_Reverse_T x y = (cmp_log_Reverse_T x y <> Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_gt_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate gt_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o = Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). gt_log_Reverse_T x y
            = (cmp_log_Reverse_T x y = Greater) -> gt_log_Reverse_T x y = (cmp_log_Reverse_T x y = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__eq_cmp__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). (x = y) = (cmp_log_Option_T x y = Equal)
          -> (x = y) = (cmp_log_Option_T x y = Equal)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_lt_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate lt_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o = Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). lt_log_Option_T x y
            = (cmp_log_Option_T x y = Less) -> lt_log_Option_T x y = (cmp_log_Option_T x y = Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__antisym1__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. cmp_log_Option_T x y = Less
        -> cmp_log_Option_T x y = Less
        /\ (forall result: (). cmp_log_Option_T y x = Greater -> cmp_log_Option_T y x = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_ge_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate ge_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o <> Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). ge_log_Option_T x y
            = (cmp_log_Option_T x y <> Less) -> ge_log_Option_T x y = (cmp_log_Option_T x y <> Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_gt_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate gt_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o = Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). gt_log_Option_T x y
            = (cmp_log_Option_T x y = Greater) -> gt_log_Option_T x y = (cmp_log_Option_T x y = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__trans__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall x: t_Option_T. forall y: t_Option_T. forall z: t_Option_T. forall o: t_Ordering. cmp_log_Option_T y z = o
              /\ cmp_log_Option_T x y = o
            -> cmp_log_Option_T y z = o
            /\ cmp_log_Option_T x y = o /\ (forall result: (). cmp_log_Option_T x z = o -> cmp_log_Option_T x z = o)
end
module M_std__option__impl_OrdLogic_for_Option_T__refl__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall result: (). cmp_log_Option_T x x = Equal -> cmp_log_Option_T x x = Equal
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_le_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate le_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o <> Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). le_log_Option_T x y
            = (cmp_log_Option_T x y <> Greater) -> le_log_Option_T x y = (cmp_log_Option_T x y <> Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__antisym2__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. cmp_log_Option_T x y = Greater
        -> cmp_log_Option_T x y = Greater
        /\ (forall result: (). cmp_log_Option_T y x = Less -> cmp_log_Option_T y x = Less)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__associative__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function and_then_Option_Ag_T (self: t_Option_Ag_T) (f: Map.map t_Ag_T t_Option_Ag_T) : t_Option_Ag_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Ag_T. forall b: t_Ag_T. forall c: t_Ag_T. forall result: (). and_then_Option_Ag_T (op_Ag_T a b) (fun (ab: t_Ag_T) -> op_Ag_T ab c)
              = and_then_Option_Ag_T (op_Ag_T b c) (fun (bc: t_Ag_T) -> op_Ag_T a bc)
            -> and_then_Option_Ag_T (op_Ag_T a b) (fun (ab: t_Ag_T) -> op_Ag_T ab c)
            = and_then_Option_Ag_T (op_Ag_T b c) (fun (bc: t_Ag_T) -> op_Ag_T a bc)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__factor__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag_T. forall factor: t_Ag_T. forall result: t_Option_Ag_T. match result with
              | Some c -> op_Ag_T factor c = Some self
              | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
              end
          -> match result with
            | Some c -> op_Ag_T factor c = Some self
            | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
            end
end
module M_logic__ra__agree__impl_RA_for_Ag_T__core_is_maximal_idemp__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  function core_Ag_T (self: t_Ag_T) : t_Option_Ag_T = Some self
  
  axiom core_Ag_T_spec: forall self: t_Ag_T. match core_Ag_T self with
        | Some c -> op_Ag_T c c = Some c /\ op_Ag_T c self = Some self
        | None -> true
        end
  
  function factor_Ag_T (self: t_Ag_T) (factor: t_Ag_T) : t_Option_Ag_T = op_Ag_T self factor
  
  axiom factor_Ag_T_spec: forall self: t_Ag_T, factor: t_Ag_T. match factor_Ag_T self factor with
        | Some c -> op_Ag_T factor c = Some self
        | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
        end
  
  predicate incl_Ag_T (self: t_Ag_T) (other: t_Ag_T) = factor_Ag_T other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag_T. forall i: t_Ag_T. op_Ag_T i self = Some self /\ op_Ag_T i i = Some i
        -> op_Ag_T i self = Some self
        /\ op_Ag_T i i = Some i
        /\ (forall result: (). match core_Ag_T self with
              | Some c -> incl_Ag_T i c
              | None -> false
              end
          -> match core_Ag_T self with
            | Some c -> incl_Ag_T i c
            | None -> false
            end)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__core__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag_T. forall result: t_Option_Ag_T. match result with
            | Some c -> op_Ag_T c c = Some c /\ op_Ag_T c self = Some self
            | None -> true
            end
        -> match result with
          | Some c -> op_Ag_T c c = Some c /\ op_Ag_T c self = Some self
          | None -> true
          end
end
module M_logic__ra__agree__impl_RA_for_Ag_T__commutative__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Ag_T. forall b: t_Ag_T. forall result: (). op_Ag_T a b = op_Ag_T b a
          -> op_Ag_T a b = op_Ag_T b a
end
module M_logic__ra__excl__impl_RA_for_Excl_T__commutative__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Excl_T. forall b: t_Excl_T. forall result: (). op_Excl_T a b = op_Excl_T b a
          -> op_Excl_T a b = op_Excl_T b a
end
module M_logic__ra__excl__impl_RA_for_Excl_T__associative__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function and_then_Option_Excl_T (self: t_Option_Excl_T) (f: Map.map t_Excl_T t_Option_Excl_T) : t_Option_Excl_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Excl_T. forall b: t_Excl_T. forall c: t_Excl_T. forall result: (). and_then_Option_Excl_T (op_Excl_T a b) (fun (ab: t_Excl_T) -> op_Excl_T ab c)
              = and_then_Option_Excl_T (op_Excl_T b c) (fun (bc: t_Excl_T) -> op_Excl_T a bc)
            -> and_then_Option_Excl_T (op_Excl_T a b) (fun (ab: t_Excl_T) -> op_Excl_T ab c)
            = and_then_Option_Excl_T (op_Excl_T b c) (fun (bc: t_Excl_T) -> op_Excl_T a bc)
end
module M_logic__ra__excl__impl_RA_for_Excl_T__core_is_maximal_idemp__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  function core_Excl_T (self: t_Excl_T) : t_Option_Excl_T = None
  
  axiom core_Excl_T_spec: forall self: t_Excl_T. match core_Excl_T self with
        | Some c -> op_Excl_T c c = Some c /\ op_Excl_T c self = Some self
        | None -> true
        end
  
  function factor_Excl_T (self: t_Excl_T) (factor: t_Excl_T) : t_Option_Excl_T = None
  
  axiom factor_Excl_T_spec: forall self: t_Excl_T, factor: t_Excl_T. match factor_Excl_T self factor with
        | Some c -> op_Excl_T factor c = Some self
        | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
        end
  
  predicate incl_Excl_T (self: t_Excl_T) (other: t_Excl_T) = factor_Excl_T other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl_T. forall i: t_Excl_T. op_Excl_T i self = Some self /\ op_Excl_T i i = Some i
        -> op_Excl_T i self = Some self
        /\ op_Excl_T i i = Some i
        /\ (forall result: (). match core_Excl_T self with
              | Some c -> incl_Excl_T i c
              | None -> false
              end
          -> match core_Excl_T self with
            | Some c -> incl_Excl_T i c
            | None -> false
            end)
end
module M_logic__ra__excl__impl_RA_for_Excl_T__core__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl_T. forall result: t_Option_Excl_T. match result with
            | Some c -> op_Excl_T c c = Some c /\ op_Excl_T c self = Some self
            | None -> true
            end
        -> match result with
          | Some c -> op_Excl_T c c = Some c /\ op_Excl_T c self = Some self
          | None -> true
          end
end
module M_logic__ra__excl__impl_RA_for_Excl_T__factor__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl_T. forall factor: t_Excl_T. forall result: t_Option_Excl_T. match result with
              | Some c -> op_Excl_T factor c = Some self
              | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
              end
          -> match result with
            | Some c -> op_Excl_T factor c = Some self
            | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
            end
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__factor__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall factor: t_FMap_K_V. forall result: t_Option_FMap_K_V. match result with
              | Some c -> op_FMap_K_V factor c = Some self
              | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
              end
          -> match result with
            | Some c -> op_FMap_K_V factor c = Some self
            | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
            end
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__core__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall result: t_Option_FMap_K_V. match result with
            | Some c -> op_FMap_K_V c c = Some c /\ op_FMap_K_V c self = Some self
            | None -> true
            end
        -> match result with
          | Some c -> op_FMap_K_V c c = Some c /\ op_FMap_K_V c self = Some self
          | None -> true
          end
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__core_is_maximal_idemp__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  axiom core_V_spec: forall self: t_V. match core_V self with
        | Some'0 c -> op_V c c = Some'0 c /\ op_V c self = Some'0 self
        | None'0 -> true
        end
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V =
    let r = filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v) in r
  
  axiom core_total_FMap_K_V_spec:
    forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
      = Some (core_total_FMap_K_V self)
  
  axiom core_total_FMap_K_V_spec'0: forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) self = Some self
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V = Some (core_total_FMap_K_V self)
  
  axiom core_FMap_K_V_spec: forall self: t_FMap_K_V. match core_FMap_K_V self with
        | Some c -> op_FMap_K_V c c = Some c /\ op_FMap_K_V c self = Some self
        | None -> true
        end
  
  function factor_Option_V (self: t_Option_V) (factor: t_Option_V) : t_Option_Option_V = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None'0} -> Some'1 x
      | {f0 = None'0} -> None'1
      | {f0 = Some'0 x; f1 = Some'0 y} -> match factor_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_V_spec: forall self: t_Option_V, factor: t_Option_V. match factor_Option_V self factor with
        | Some'1 c -> op_Option_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_V. op_Option_V factor c <> Some'1 self
        end
  
  predicate incl_Option_V (self: t_Option_V) (other: t_Option_V) = factor_Option_V other self <> None'1
  
  function incl_transitive_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : () = ()
  
  axiom incl_transitive_Option_V_spec: forall a: t_Option_V, b: t_Option_V, c: t_Option_V. incl_Option_V a b
      -> incl_Option_V b c -> incl_Option_V a c
  
  function incl_op_Option_V (self: t_Option_V) (other: t_Option_V) (comb: t_Option_V) : () = ()
  
  axiom incl_op_Option_V_spec: forall self: t_Option_V, other: t_Option_V, comb: t_Option_V. op_Option_V self other
        = Some'1 comb -> incl_Option_V self comb
  
  function factor_FMap_K_V (self: t_FMap_K_V) (factor: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. incl_Option_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in Some res
    else
      None
  
  
  axiom factor_FMap_K_V_spec: forall self: t_FMap_K_V, factor: t_FMap_K_V. match factor_FMap_K_V self factor with
        | Some c -> op_FMap_K_V factor c = Some self
        | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
        end
  
  predicate incl_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) = factor_FMap_K_V other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall i: t_FMap_K_V. op_FMap_K_V i self = Some self
          /\ op_FMap_K_V i i = Some i
        -> op_FMap_K_V i self = Some self
        /\ op_FMap_K_V i i = Some i
        /\ (forall result: (). match core_FMap_K_V self with
              | Some c -> incl_FMap_K_V i c
              | None -> false
              end
          -> match core_FMap_K_V self with
            | Some c -> incl_FMap_K_V i c
            | None -> false
            end)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__commutative__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_FMap_K_V. forall b: t_FMap_K_V. forall result: (). op_FMap_K_V a b = op_FMap_K_V b a
          -> op_FMap_K_V a b = op_FMap_K_V b a
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__associative__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FMap_K_V. forall b: t_FMap_K_V. forall c: t_FMap_K_V. forall result: (). and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
              = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
            -> and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
            = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
end
module M_logic__ra__option__impl_RA_for_Option_T__commutative__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_T. forall b: t_Option_T. forall result: (). op_Option_T a b = op_Option_T b a
          -> op_Option_T a b = op_Option_T b a
end
module M_logic__ra__option__impl_RA_for_Option_T__core__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall result: t_Option_Option_T. match result with
            | Some'0 c -> op_Option_T c c = Some'0 c /\ op_Option_T c self = Some'0 self
            | None'0 -> true
            end
        -> match result with
          | Some'0 c -> op_Option_T c c = Some'0 c /\ op_Option_T c self = Some'0 self
          | None'0 -> true
          end
end
module M_logic__ra__option__impl_RA_for_Option_T__core_is_maximal_idemp__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some c -> op_T c c = Some c /\ op_T c self = Some self
        | None -> true
        end
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> core_T x
      end
  
  axiom core_total_Option_T_spec:
    forall self: t_Option_T. op_Option_T (core_total_Option_T self) (core_total_Option_T self)
      = Some'0 (core_total_Option_T self)
  
  axiom core_total_Option_T_spec'0: forall self: t_Option_T. op_Option_T (core_total_Option_T self) self = Some'0 self
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = Some'0 (core_total_Option_T self)
  
  axiom core_Option_T_spec: forall self: t_Option_T. match core_Option_T self with
        | Some'0 c -> op_Option_T c c = Some'0 c /\ op_Option_T c self = Some'0 self
        | None'0 -> true
        end
  
  function factor_Option_T (self: t_Option_T) (factor: t_Option_T) : t_Option_Option_T = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None} -> Some'0 x
      | {f0 = None} -> None'0
      | {f0 = Some x; f1 = Some y} -> match factor_T x y with
        | Some z -> Some'0 (Some z)
        | None -> if x = y then Some'0 (None) else None'0
        end
      end
  
  axiom factor_Option_T_spec: forall self: t_Option_T, factor: t_Option_T. match factor_Option_T self factor with
        | Some'0 c -> op_Option_T factor c = Some'0 self
        | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
        end
  
  predicate incl_Option_T (self: t_Option_T) (other: t_Option_T) = factor_Option_T other self <> None'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall i: t_Option_T. op_Option_T i self = Some'0 self
          /\ op_Option_T i i = Some'0 i
        -> op_Option_T i self = Some'0 self
        /\ op_Option_T i i = Some'0 i
        /\ (forall result: (). match core_Option_T self with
              | Some'0 c -> incl_Option_T i c
              | None'0 -> false
              end
          -> match core_Option_T self with
            | Some'0 c -> incl_Option_T i c
            | None'0 -> false
            end)
end
module M_logic__ra__option__impl_RA_for_Option_T__associative__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Option_T. forall b: t_Option_T. forall c: t_Option_T. forall result: (). and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
              = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
            -> and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
            = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
end
module M_logic__ra__option__impl_RA_for_Option_T__factor__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall factor: t_Option_T. forall result: t_Option_Option_T. match result with
              | Some'0 c -> op_Option_T factor c = Some'0 self
              | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
              end
          -> match result with
            | Some'0 c -> op_Option_T factor c = Some'0 self
            | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
            end
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__commutative__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: tup2_T_U. forall b: tup2_T_U. forall result: (). op_tup2_T_U a b = op_tup2_T_U b a
          -> op_tup2_T_U a b = op_tup2_T_U b a
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__factor__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall factor: tup2_T_U. forall result: t_Option_tup2_T_U. match result with
              | Some c -> op_tup2_T_U factor c = Some self
              | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
              end
          -> match result with
            | Some c -> op_tup2_T_U factor c = Some self
            | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
            end
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__core_is_maximal_idemp__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some'0 c -> op_T c c = Some'0 c /\ op_T c self = Some'0 self
        | None'0 -> true
        end
  
  function core_U (self: t_U) : t_Option_U
  
  axiom core_U_spec: forall self: t_U. match core_U self with
        | Some'1 c -> op_U c c = Some'1 c /\ op_U c self = Some'1 self
        | None'1 -> true
        end
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  axiom core_tup2_T_U_spec: forall self: tup2_T_U. match core_tup2_T_U self with
        | Some c -> op_tup2_T_U c c = Some c /\ op_tup2_T_U c self = Some self
        | None -> true
        end
  
  function factor_tup2_T_U (self: tup2_T_U) (factor: tup2_T_U) : t_Option_tup2_T_U =
    match { f0'0 = factor_T self.f0 factor.f0; f1'0 = factor_U self.f1 factor.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  axiom factor_tup2_T_U_spec: forall self: tup2_T_U, factor: tup2_T_U. match factor_tup2_T_U self factor with
        | Some c -> op_tup2_T_U factor c = Some self
        | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
        end
  
  predicate incl_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) = factor_tup2_T_U other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall i: tup2_T_U. op_tup2_T_U i self = Some self /\ op_tup2_T_U i i = Some i
        -> op_tup2_T_U i self = Some self
        /\ op_tup2_T_U i i = Some i
        /\ (forall result: (). match core_tup2_T_U self with
              | Some c -> incl_tup2_T_U i c
              | None -> false
              end
          -> match core_tup2_T_U self with
            | Some c -> incl_tup2_T_U i c
            | None -> false
            end)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__core__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall result: t_Option_tup2_T_U. match result with
            | Some c -> op_tup2_T_U c c = Some c /\ op_tup2_T_U c self = Some self
            | None -> true
            end
        -> match result with
          | Some c -> op_tup2_T_U c c = Some c /\ op_tup2_T_U c self = Some self
          | None -> true
          end
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__associative__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: tup2_T_U. forall b: tup2_T_U. forall c: tup2_T_U. forall result: (). and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
              = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
            -> and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
            = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__associative__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Sum_R1_R2. forall b: t_Sum_R1_R2. forall c: t_Sum_R1_R2. forall result: (). and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
              = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
            -> and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
            = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__core_is_maximal_idemp__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function core_R1 (self: t_R1) : t_Option_R1
  
  axiom core_R1_spec: forall self: t_R1. match core_R1 self with
        | Some'0 c -> op_R1 c c = Some'0 c /\ op_R1 c self = Some'0 self
        | None'0 -> true
        end
  
  function core_R2 (self: t_R2) : t_Option_R2
  
  axiom core_R2_spec: forall self: t_R2. match core_R2 self with
        | Some'1 c -> op_R2 c c = Some'1 c /\ op_R2 c self = Some'1 self
        | None'1 -> true
        end
  
  function core_Sum_R1_R2 (self: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | Left x -> map_Option_R1 (core_R1 x) (fun (l: t_R1) -> Left l)
      | Right x -> map_Option_R2 (core_R2 x) (fun (r: t_R2) -> Right r)
      end
  
  axiom core_Sum_R1_R2_spec: forall self: t_Sum_R1_R2. match core_Sum_R1_R2 self with
        | Some c -> op_Sum_R1_R2 c c = Some c /\ op_Sum_R1_R2 c self = Some self
        | None -> true
        end
  
  function factor_Sum_R1_R2 (self: t_Sum_R1_R2) (factor: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                     f1 = factor } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (factor_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (factor_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  axiom factor_Sum_R1_R2_spec: forall self: t_Sum_R1_R2, factor: t_Sum_R1_R2. match factor_Sum_R1_R2 self factor with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end
  
  predicate incl_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) = factor_Sum_R1_R2 other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum_R1_R2. forall i: t_Sum_R1_R2. op_Sum_R1_R2 i self = Some self
          /\ op_Sum_R1_R2 i i = Some i
        -> op_Sum_R1_R2 i self = Some self
        /\ op_Sum_R1_R2 i i = Some i
        /\ (forall result: (). match core_Sum_R1_R2 self with
              | Some c -> incl_Sum_R1_R2 i c
              | None -> false
              end
          -> match core_Sum_R1_R2 self with
            | Some c -> incl_Sum_R1_R2 i c
            | None -> false
            end)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__commutative__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Sum_R1_R2. forall b: t_Sum_R1_R2. forall result: (). op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
          -> op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__factor__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Sum_R1_R2. forall factor: t_Sum_R1_R2. forall result: t_Option_Sum_R1_R2. match result with
              | Some c -> op_Sum_R1_R2 factor c = Some self
              | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
              end
          -> match result with
            | Some c -> op_Sum_R1_R2 factor c = Some self
            | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
            end
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__core__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum_R1_R2. forall result: t_Option_Sum_R1_R2. match result with
            | Some c -> op_Sum_R1_R2 c c = Some c /\ op_Sum_R1_R2 c self = Some self
            | None -> true
            end
        -> match result with
          | Some c -> op_Sum_R1_R2 c c = Some c /\ op_Sum_R1_R2 c self = Some self
          | None -> true
          end
end
module M_logic__ra__view__impl_RA_for_View_R__commutative__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_View_R. forall b: t_View_R. forall result: (). op_View_R a b = op_View_R b a
          -> op_View_R a b = op_View_R b a
end
module M_logic__ra__view__impl_RA_for_View_R__core_is_maximal_idemp__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_total_View_R (self: t_View_R) : t_View_R = new_frag_R (core_total_Frag (frag_R self))
  
  axiom core_total_View_R_spec: forall self: t_View_R. op_View_R (core_total_View_R self) (core_total_View_R self)
      = Some (core_total_View_R self)
  
  axiom core_total_View_R_spec'0: forall self: t_View_R. op_View_R (core_total_View_R self) self = Some self
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (core_total_View_R self)
  
  axiom core_View_R_spec: forall self: t_View_R. match core_View_R self with
        | Some c -> op_View_R c c = Some c /\ op_View_R c self = Some self
        | None -> true
        end
  
  function factor_View_R (self: t_View_R) (factor: t_View_R) : t_Option_View_R =
    match factor_Frag (frag_R self) (frag_R factor) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R factor } with
        | {f0'0 = Some'1 a; f1'0 = None'1} -> Some (new_R (Some'1 a) f)
        | {f0'0 = a1; f1'0 = a2} -> if a1 = a2 then Some (new_frag_R f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_R_spec: forall self: t_View_R, factor: t_View_R. match factor_View_R self factor with
        | Some c -> op_View_R factor c = Some self
        | None -> forall c: t_View_R. op_View_R factor c <> Some self
        end
  
  predicate incl_View_R (self: t_View_R) (other: t_View_R) = factor_View_R other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall i: t_View_R. op_View_R i self = Some self /\ op_View_R i i = Some i
        -> op_View_R i self = Some self
        /\ op_View_R i i = Some i
        /\ (forall result: (). match core_View_R self with
              | Some c -> incl_View_R i c
              | None -> false
              end
          -> match core_View_R self with
            | Some c -> incl_View_R i c
            | None -> false
            end)
end
module M_logic__ra__view__impl_RA_for_View_R__factor__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall factor: t_View_R. forall result: t_Option_View_R. match result with
              | Some c -> op_View_R factor c = Some self
              | None -> forall c: t_View_R. op_View_R factor c <> Some self
              end
          -> match result with
            | Some c -> op_View_R factor c = Some self
            | None -> forall c: t_View_R. op_View_R factor c <> Some self
            end
end
module M_logic__ra__view__impl_RA_for_View_R__core__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall result: t_Option_View_R. match result with
            | Some c -> op_View_R c c = Some c /\ op_View_R c self = Some self
            | None -> true
            end
        -> match result with
          | Some c -> op_View_R c c = Some c /\ op_View_R c self = Some self
          | None -> true
          end
end
module M_logic__ra__view__impl_RA_for_View_R__associative__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_View_R. forall b: t_View_R. forall c: t_View_R. forall result: (). and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
              = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
            -> and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
            = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_mono__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_T. forall f1: t_T. forall f2: t_T. incl_T f2 f1 /\ rel_AuthViewRel_T a f1
          -> incl_T f2 f1
          /\ rel_AuthViewRel_T a f1 /\ (forall result: (). rel_AuthViewRel_T a f2 -> rel_AuthViewRel_T a f2)
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_unit__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. op_T (core_total_T self) (core_total_T self) = Some (core_total_T self)
  
  axiom core_total_T_spec'0: forall self: t_T. op_T (core_total_T self) self = Some self
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some x
  
  constant unit_core_T: () = ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T: () = let _ = unit_T in ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_T. forall result: (). rel_AuthViewRel_T a unit_T -> rel_AuthViewRel_T a unit_T
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_none__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_T. forall f: t_T. rel_AuthViewRel_T a f
        -> (forall result: (). rel_AuthViewRel_T (None) f -> rel_AuthViewRel_T (None) f)
end
module M_logic__ra__auth__impl_Update_for_AuthUpdate_U__update__refines (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate_U = { f0: t_U }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. op_R (core_total_R self) (core_total_R self) = Some (core_total_R self)
  
  axiom core_total_R_spec'0: forall self: t_R. op_R (core_total_R self) self = Some self
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R: () = ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R: () = let _ = unit_R in ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : () = ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : () = ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  predicate premise_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some auth -> premise_U self.f0 auth (frag_AuthViewRel_R from)
      | None -> false
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_AuthUpdate_U. forall from: t_View_AuthViewRel_R. forall ch: (). premise_AuthUpdate_U self from
          -> premise_AuthUpdate_U self from
end
module M_logic__ra__auth__impl_Update_for_AuthUpdate_U__frame_preserving__refines (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_View_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None | Some t_View_AuthViewRel_R
  
  function and_then_Option_View_AuthViewRel_R (self: t_Option_View_AuthViewRel_R) (f: Map.map t_View_AuthViewRel_R t_Option_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_R
  
  type t_Option_R = None'0 | Some'0 t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'0 c -> op_R factor c = Some'0 self
        | None'0 -> forall c: t_R. op_R factor c <> Some'0 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'0
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'0 comb -> incl_R self comb
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. op_R (core_total_R self) (core_total_R self) = Some'0 (core_total_R self)
  
  axiom core_total_R_spec'0: forall self: t_R. op_R (core_total_R self) self = Some'0 self
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some'0 x
  
  constant unit_core_R: () = ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R: () = let _ = unit_R in ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some'0 a'0 -> incl_R f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : () = ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : () = ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None'0) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  type tup2_Option_R_Option_R = { f0: t_Option_R; f1: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some'0 f -> match { f0 = auth_AuthViewRel_R self; f1 = auth_AuthViewRel_R other } with
        | {f0 = None'0; f1 = a} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | {f0 = a; f1 = None'0} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) : ()
  
  axiom associative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R. and_then_Option_View_AuthViewRel_R (op_View_AuthViewRel_R a b) (fun (ab: t_View_AuthViewRel_R) -> op_View_AuthViewRel_R ab c)
      = and_then_Option_View_AuthViewRel_R (op_View_AuthViewRel_R b c) (fun (bc: t_View_AuthViewRel_R) -> op_View_AuthViewRel_R a bc)
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  type t_U
  
  type t_AuthUpdate_U = { f0'0: t_U }
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  predicate premise_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some'0 auth -> premise_U self.f0'0 auth (frag_AuthViewRel_R from)
      | None'0 -> false
      end
  
  type tup2_R_R = { f0'1: t_R; f1'1: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some'0 x -> x
      | None'0 -> such_that_R (fun (__0: t_R) -> true)
      end
  
  type t_Option_Option_R = None'1 | Some'1 t_Option_R
  
  function and_then_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_R
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some'0 z)
      end
  
  function associative_Option_R (a: t_Option_R) (b: t_Option_R) (c: t_Option_R) : ()
  
  axiom associative_Option_R_spec:
    forall a: t_Option_R, b: t_Option_R, c: t_Option_R. and_then_Option_Option_R (op_Option_R a b) (fun (ab: t_Option_R) -> op_Option_R ab c)
      = and_then_Option_Option_R (op_Option_R b c) (fun (bc: t_Option_R) -> op_Option_R a bc)
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option_R. premise_U self from_auth from_frag
      -> op_Option_R (Some'0 from_frag) frame = Some'1 (Some'0 from_auth)
      -> (let {f0'1 = to_auth; f1'1 = to_frag} = update_U self from_auth from_frag in op_Option_R (Some'0 to_frag) frame
      = Some'1 (Some'0 to_auth))
  
  function update_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (_3: ()) : t_View_AuthViewRel_R =
    let from_auth = unwrap_Option_R (auth_AuthViewRel_R from) in let {f0'1 = auth; f1'1 = frag} = update_U self.f0'0 from_auth (frag_AuthViewRel_R from) in let _ = frame_preserving_U self.f0'0 from_auth (frag_AuthViewRel_R from) (factor_R from_auth (frag_AuthViewRel_R from)) in new_AuthViewRel_R (Some'0 auth) frag
  
  axiom update_AuthUpdate_U_spec:
    forall self: t_AuthUpdate_U, from: t_View_AuthViewRel_R, _3: (). premise_AuthUpdate_U self from
      -> (let {f0'1 = auth; f1'1 = frag} = update_U self.f0'0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from) in rel_AuthViewRel_R (Some'0 auth) frag)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_AuthUpdate_U. forall from: t_View_AuthViewRel_R. forall frame: t_View_AuthViewRel_R. op_View_AuthViewRel_R from frame
              <> None
            /\ premise_AuthUpdate_U self from
          -> op_View_AuthViewRel_R from frame <> None
          /\ premise_AuthUpdate_U self from
          /\ (forall result: (). op_View_AuthViewRel_R (update_AuthUpdate_U self from result) frame <> None
            -> op_View_AuthViewRel_R (update_AuthUpdate_U self from result) frame <> None)
end
module M_logic__ra__excl__impl_Update_for_ExclUpdate_T__frame_preserving__refines (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function and_then_Option_Excl_T (self: t_Option_Excl_T) (f: Map.map t_Excl_T t_Option_Excl_T) : t_Option_Excl_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  function associative_Excl_T (a: t_Excl_T) (b: t_Excl_T) (c: t_Excl_T) : () = ()
  
  axiom associative_Excl_T_spec:
    forall a: t_Excl_T, b: t_Excl_T, c: t_Excl_T. and_then_Option_Excl_T (op_Excl_T a b) (fun (ab: t_Excl_T) -> op_Excl_T ab c)
      = and_then_Option_Excl_T (op_Excl_T b c) (fun (bc: t_Excl_T) -> op_Excl_T a bc)
  
  function commutative_Excl_T (a: t_Excl_T) (b: t_Excl_T) : () = ()
  
  axiom commutative_Excl_T_spec: forall a: t_Excl_T, b: t_Excl_T. op_Excl_T a b = op_Excl_T b a
  
  type t_ExclUpdate_T = { f0'0: t_T }
  
  predicate premise_ExclUpdate_T (self: t_ExclUpdate_T) (_2: t_Excl_T) = true
  
  function update_ExclUpdate_T (self: t_ExclUpdate_T) (from: t_Excl_T) (_3: ()) : t_Excl_T = { f0 = self.f0'0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ExclUpdate_T. forall from: t_Excl_T. forall frame: t_Excl_T. op_Excl_T from frame <> None
            /\ premise_ExclUpdate_T self from
          -> op_Excl_T from frame <> None
          /\ premise_ExclUpdate_T self from
          /\ (forall result: (). op_Excl_T (update_ExclUpdate_T self from result) frame <> None
            -> op_Excl_T (update_ExclUpdate_T self from result) frame <> None)
end
module M_logic__ra__excl__impl_Update_for_ExclUpdate_T__update__refines (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_ExclUpdate_T = { f0: t_T }
  
  type t_Excl_T = { f0'0: t_T }
  
  predicate premise_ExclUpdate_T (self: t_ExclUpdate_T) (_2: t_Excl_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ExclUpdate_T. forall from: t_Excl_T. forall ch: (). premise_ExclUpdate_T self from
          -> premise_ExclUpdate_T self from
end
module M_logic__ra__option__impl_Update_for_OptionUpdate_U__update__refines (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_OptionUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) =
    match from with
      | Some from'0 -> premise_U self.f0 from'0
      | None -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_OptionUpdate_U. forall from: t_Option_R. forall ch: t_Choice. premise_OptionUpdate_U self from
          -> premise_OptionUpdate_U self from
end
module M_logic__ra__option__impl_Update_for_OptionUpdate_U__frame_preserving__refines (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  function and_then_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_R
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup3_Option_R_Option_R_Option_R = { f0: t_Option_R; f1: t_Option_R; f2: t_Option_R }
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function associative_Option_R (a: t_Option_R) (b: t_Option_R) (c: t_Option_R) : () = match { f0 = a;
                                                                                               f1 = b;
                                                                                               f2 = c } with
      | {f0 = None} -> ()
      | {f1 = None} -> ()
      | {f2 = None} -> ()
      | {f0 = Some aa; f1 = Some bb; f2 = Some cc} -> associative_R aa bb cc
      end
  
  axiom associative_Option_R_spec:
    forall a: t_Option_R, b: t_Option_R, c: t_Option_R. and_then_Option_Option_R (op_Option_R a b) (fun (ab: t_Option_R) -> op_Option_R ab c)
      = and_then_Option_Option_R (op_Option_R b c) (fun (bc: t_Option_R) -> op_Option_R a bc)
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : () = ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  type t_U
  
  type t_OptionUpdate_U = { f0'1: t_U }
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) =
    match from with
      | Some from'0 -> premise_U self.f0'1 from'0
      | None -> false
      end
  
  type t_Choice
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) (ch: t_Choice) : t_Option_R =
    match from with
      | Some from'0 -> Some (update_U self.f0'1 from'0 ch)
      | None -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_OptionUpdate_U. forall from: t_Option_R. forall frame: t_Option_R. op_Option_R from frame
              <> None'0
            /\ premise_OptionUpdate_U self from
          -> op_Option_R from frame <> None'0
          /\ premise_OptionUpdate_U self from
          /\ (forall result: t_Choice. op_Option_R (update_OptionUpdate_U self from result) frame <> None'0
            -> op_Option_R (update_OptionUpdate_U self from result) frame <> None'0)
end
module M_logic__ra__prod__impl_Update_for_ProdUpdate_U1_U2__update__refines (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  predicate premise_U1 (self: t_U1) (from: t_R1)
  
  predicate premise_U2 (self: t_U2) (from: t_R2)
  
  predicate premise_ProdUpdate_U1_U2 (self: t_ProdUpdate_U1_U2) (from: tup2_R1_R2) =
    premise_U1 self.f0 from.f0'0 /\ premise_U2 self.f1 from.f1'0
  
  type t_Choice
  
  type t_Choice'0
  
  type tup2_Choice_Choice = { f0'1: t_Choice; f1'1: t_Choice'0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ProdUpdate_U1_U2. forall from: tup2_R1_R2. forall ch: tup2_Choice_Choice. premise_ProdUpdate_U1_U2 self from
          -> premise_ProdUpdate_U1_U2 self from
end
module M_logic__ra__prod__impl_Update_for_ProdUpdate_U1_U2__frame_preserving__refines (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0: t_R1; f1: t_R2 }
  
  type t_Option_tup2_R1_R2 = None | Some tup2_R1_R2
  
  function and_then_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_Option_tup2_R1_R2) : t_Option_tup2_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_tup2_R1_R2) : t_Option_tup2_R1_R2 =
    match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_R1'0 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1'0 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1'0 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 tup2_R1_R2) : t_Option_tup2_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_tup2_R1_R2 (self: tup2_R1_R2) (other: tup2_R1_R2) : t_Option_tup2_R1_R2 =
    and_then_Option_R1 (op_R1 self.f0 other.f0) (fun (x: t_R1) -> map_Option_R2 (op_R2 self.f1 other.f1) (fun (y: t_R2) -> { f0 = x;
                                                                                                                             f1 = y }))
  
  function associative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) (c: tup2_R1_R2) : () = ()
  
  axiom associative_tup2_R1_R2_spec:
    forall a: tup2_R1_R2, b: tup2_R1_R2, c: tup2_R1_R2. and_then_Option_tup2_R1_R2 (op_tup2_R1_R2 a b) (fun (ab: tup2_R1_R2) -> op_tup2_R1_R2 ab c)
      = and_then_Option_tup2_R1_R2 (op_tup2_R1_R2 b c) (fun (bc: tup2_R1_R2) -> op_tup2_R1_R2 a bc)
  
  function commutative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) : () = ()
  
  axiom commutative_tup2_R1_R2_spec: forall a: tup2_R1_R2, b: tup2_R1_R2. op_tup2_R1_R2 a b = op_tup2_R1_R2 b a
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate_U1_U2 = { f0'0: t_U1; f1'0: t_U2 }
  
  predicate premise_U1 (self: t_U1) (from: t_R1)
  
  predicate premise_U2 (self: t_U2) (from: t_R2)
  
  predicate premise_ProdUpdate_U1_U2 (self: t_ProdUpdate_U1_U2) (from: tup2_R1_R2) =
    premise_U1 self.f0'0 from.f0 /\ premise_U2 self.f1'0 from.f1
  
  type t_Choice
  
  type t_Choice'0
  
  type tup2_Choice_Choice = { f0'1: t_Choice; f1'1: t_Choice'0 }
  
  function update_U1 (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_U2 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  function update_ProdUpdate_U1_U2 (self: t_ProdUpdate_U1_U2) (from: tup2_R1_R2) (ch: tup2_Choice_Choice) : tup2_R1_R2 =
    { f0 = update_U1 self.f0'0 from.f0 ch.f0'1; f1 = update_U2 self.f1'0 from.f1 ch.f1'1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ProdUpdate_U1_U2. forall from: tup2_R1_R2. forall frame: tup2_R1_R2. op_tup2_R1_R2 from frame <> None
            /\ premise_ProdUpdate_U1_U2 self from
          -> op_tup2_R1_R2 from frame <> None
          /\ premise_ProdUpdate_U1_U2 self from
          /\ (forall result: tup2_Choice_Choice. op_tup2_R1_R2 (update_ProdUpdate_U1_U2 self from result) frame <> None
            -> op_tup2_R1_R2 (update_ProdUpdate_U1_U2 self from result) frame <> None)
end
module M_logic__ra__sum__impl_Update_for_SumUpdateL_U__update__refines (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  predicate premise_U (self: t_U) (from: t_R1)
  
  predicate premise_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) =
    match from with
      | Left from'0 -> premise_U self.f0 from'0
      | Right _ -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumUpdateL_U. forall from: t_Sum_R1_R2. forall ch: t_Choice. premise_SumUpdateL_U self from
          -> premise_SumUpdateL_U self from
end
module M_logic__ra__sum__impl_Update_for_SumUpdateL_U__frame_preserving__refines (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function associative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) (c: t_Sum_R1_R2) : () = ()
  
  axiom associative_Sum_R1_R2_spec:
    forall a: t_Sum_R1_R2, b: t_Sum_R1_R2, c: t_Sum_R1_R2. and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
      = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  type t_U
  
  type t_SumUpdateL_U = { f0'0: t_U }
  
  predicate premise_U (self: t_U) (from: t_R1)
  
  predicate premise_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) =
    match from with
      | Left from'0 -> premise_U self.f0'0 from'0
      | Right _ -> false
      end
  
  type t_Choice
  
  function update_U (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) (ch: t_Choice) : t_Sum_R1_R2 = match from with
      | Left from'0 -> Left (update_U self.f0'0 from'0 ch)
      | x -> x
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumUpdateL_U. forall from: t_Sum_R1_R2. forall frame: t_Sum_R1_R2. op_Sum_R1_R2 from frame <> None
            /\ premise_SumUpdateL_U self from
          -> op_Sum_R1_R2 from frame <> None
          /\ premise_SumUpdateL_U self from
          /\ (forall result: t_Choice. op_Sum_R1_R2 (update_SumUpdateL_U self from result) frame <> None
            -> op_Sum_R1_R2 (update_SumUpdateL_U self from result) frame <> None)
end
module M_logic__ra__sum__impl_Update_for_SumUpdateR_U__update__refines (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateR_U = { f0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum_V_R = Left t_V | Right t_R
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) =
    match from with
      | Right from'0 -> premise_U self.f0 from'0
      | Left _ -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SumUpdateR_U. forall from: t_Sum_V_R. forall ch: t_Choice. premise_SumUpdateR_U self from
          -> premise_SumUpdateR_U self from
end
module M_logic__ra__sum__impl_Update_for_SumUpdateR_U__frame_preserving__refines (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_V
  
  type t_R
  
  type t_Sum_V_R = Left t_V | Right t_R
  
  type t_Option_Sum_V_R = None | Some t_Sum_V_R
  
  function and_then_Option_Sum_V_R (self: t_Option_Sum_V_R) (f: Map.map t_Sum_V_R t_Option_Sum_V_R) : t_Option_Sum_V_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_V_R_Sum_V_R = { f0: t_Sum_V_R; f1: t_Sum_V_R }
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Sum_V_R) : t_Option_Sum_V_R = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  type t_Option_R = None'1 | Some'1 t_R
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Sum_V_R) : t_Option_Sum_V_R = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'1 c -> op_R factor c = Some'1 self
        | None'1 -> forall c: t_R. op_R factor c <> Some'1 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'1
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'1 comb -> incl_R self comb
  
  function op_Sum_V_R (self: t_Sum_V_R) (other: t_Sum_V_R) : t_Option_Sum_V_R = match { f0 = self; f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_V (op_V x y) (fun (l: t_V) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R (op_R x y) (fun (r: t_R) -> Right r)
      | _ -> None
      end
  
  function associative_Sum_V_R (a: t_Sum_V_R) (b: t_Sum_V_R) (c: t_Sum_V_R) : () = ()
  
  axiom associative_Sum_V_R_spec:
    forall a: t_Sum_V_R, b: t_Sum_V_R, c: t_Sum_V_R. and_then_Option_Sum_V_R (op_Sum_V_R a b) (fun (ab: t_Sum_V_R) -> op_Sum_V_R ab c)
      = and_then_Option_Sum_V_R (op_Sum_V_R b c) (fun (bc: t_Sum_V_R) -> op_Sum_V_R a bc)
  
  function commutative_Sum_V_R (a: t_Sum_V_R) (b: t_Sum_V_R) : () = ()
  
  axiom commutative_Sum_V_R_spec: forall a: t_Sum_V_R, b: t_Sum_V_R. op_Sum_V_R a b = op_Sum_V_R b a
  
  type t_U
  
  type t_SumUpdateR_U = { f0'0: t_U }
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) =
    match from with
      | Right from'0 -> premise_U self.f0'0 from'0
      | Left _ -> false
      end
  
  type t_Choice
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) (ch: t_Choice) : t_Sum_V_R = match from with
      | Right from'0 -> Right (update_U self.f0'0 from'0 ch)
      | x -> x
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SumUpdateR_U. forall from: t_Sum_V_R. forall frame: t_Sum_V_R. op_Sum_V_R from frame
              <> None
            /\ premise_SumUpdateR_U self from
          -> op_Sum_V_R from frame <> None
          /\ premise_SumUpdateR_U self from
          /\ (forall result: t_Choice. op_Sum_V_R (update_SumUpdateR_U self from result) frame <> None
            -> op_Sum_V_R (update_SumUpdateR_U self from result) frame <> None)
end
module M_logic__ra__update__impl_Update_for_Snapshot_R__update__refines (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate premise_Snapshot_R (self: t_R) (from: t_R) = forall y: t_R. op_R from y <> None -> op_R self y <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_R. forall from: t_R. forall ch: (). premise_Snapshot_R self from
          -> premise_Snapshot_R self from
end
module M_logic__ra__update__impl_Update_for_Snapshot_R__frame_preserving__refines (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate premise_Snapshot_R (self: t_R) (from: t_R) = forall y: t_R. op_R from y <> None -> op_R self y <> None
  
  function update_Snapshot_R (self: t_R) (from: t_R) (_3: ()) : t_R = self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_R. forall from: t_R. forall frame: t_R. op_R from frame <> None
            /\ premise_Snapshot_R self from
          -> op_R from frame <> None
          /\ premise_Snapshot_R self from
          /\ (forall result: (). op_R (update_Snapshot_R self from result) frame <> None
            -> op_R (update_Snapshot_R self from result) frame <> None)
end
module M_logic__ra__update__impl_Update_for_Snapshot_Mapping_Choice_R__update__refines (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function index_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_R
  
  predicate premise_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> (exists ch: t_Choice. op_R (index_Mapping_Choice_R self ch) y <> None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Map.map t_Choice t_R. forall from: t_R. forall ch: t_Choice. premise_Snapshot_Mapping_Choice_R self from
          -> premise_Snapshot_Mapping_Choice_R self from
end
module M_logic__ra__update__impl_Update_for_Snapshot_Mapping_Choice_R__frame_preserving__refines (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  type t_Choice
  
  function index_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_R
  
  predicate premise_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> (exists ch: t_Choice. op_R (index_Mapping_Choice_R self ch) y <> None)
  
  function update_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R =
    index_Mapping_Choice_R self ch
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Map.map t_Choice t_R. forall from: t_R. forall frame: t_R. op_R from frame <> None
            /\ premise_Snapshot_Mapping_Choice_R self from
          -> op_R from frame <> None
          /\ premise_Snapshot_Mapping_Choice_R self from
          /\ (forall result: t_Choice. op_R (update_Snapshot_Mapping_Choice_R self from result) frame <> None
            -> op_R (update_Snapshot_Mapping_Choice_R self from result) frame <> None)
end
module M_logic__ra__view__impl_Update_for_ViewUpdate_R_Choice__update__refines (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Auth_Frag = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate_R_Choice = { f0'0: Map.map t_Choice tup2_Auth_Frag }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'1: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'1).auth
  
  function index_Mapping_Choice_tup2_Auth_Frag [@inline:trivial] (self: Map.map t_Choice tup2_Auth_Frag) (a: t_Choice) : tup2_Auth_Frag
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_tup2_Auth_Frag
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0'1).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) =
    auth_R from <> None
    /\ (forall ch: t_Choice. rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
    /\ (forall frame: t_Frag. match op_Frag (frag_R from) frame with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end
      -> (exists ch: t_Choice. match op_Frag (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1 frame with
          | Some'0 ff -> rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) ff
          | None'0 -> false
          end))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdate_R_Choice. forall from: t_View_R. forall ch: t_Choice. premise_ViewUpdate_R_Choice self from
          -> premise_ViewUpdate_R_Choice self from
end
module M_logic__ra__view__impl_Update_for_ViewUpdate_R_Choice__frame_preserving__refines (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Option_Frag_Option_Frag = { f0'0: t_Option_Frag; f1'0: t_Option_Frag }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth; f2'1: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None'1; f1'2 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'2 = a; f1'2 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'0 = op_Frag (frag_R a) (frag_R b); f1'0 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'0 = Some'0 fab; f1'0 = Some'0 fbc} -> match { f0'0 = op_Frag fab (frag_R c);
                                                          f1'0 = op_Frag (frag_R a) fbc } with
        | {f0'0 = Some'0 fabc1; f1'0 = Some'0 fabc2} -> match { f0'1 = auth_R a; f1'1 = auth_R b; f2'1 = auth_R c } with
          | {f0'1 = Some'1 _; f1'1 = None'1; f2'1 = None'1} | {f0'1 = None'1; f1'1 = Some'1 _; f2'1 = None'1} | {f0'1 = None'1; f1'1 = None'1; f2'1 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  type t_Choice
  
  type tup2_Auth_Frag = { f0'3: t_Auth; f1'3: t_Frag }
  
  type t_ViewUpdate_R_Choice = { f0'4: Map.map t_Choice tup2_Auth_Frag }
  
  function index_Mapping_Choice_tup2_Auth_Frag [@inline:trivial] (self: Map.map t_Choice tup2_Auth_Frag) (a: t_Choice) : tup2_Auth_Frag
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_tup2_Auth_Frag
  
  predicate premise_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) =
    auth_R from <> None'1
    /\ (forall ch: t_Choice. rel_R (Some'1 ((index_Mapping_Choice_tup2_Auth_Frag self.f0'4 ch).f0'3)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'4 ch).f1'3)
    /\ (forall frame: t_Frag. match op_Frag (frag_R from) frame with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end
      -> (exists ch: t_Choice. match op_Frag (index_Mapping_Choice_tup2_Auth_Frag self.f0'4 ch).f1'3 frame with
          | Some'0 ff -> rel_R (Some'1 ((index_Mapping_Choice_tup2_Auth_Frag self.f0'4 ch).f0'3)) ff
          | None'0 -> false
          end))
  
  function update_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) (ch: t_Choice) : t_View_R =
    new_R (Some'1 ((index_Mapping_Choice_tup2_Auth_Frag self.f0'4 ch).f0'3)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'4 ch).f1'3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdate_R_Choice. forall from: t_View_R. forall frame: t_View_R. op_View_R from frame
              <> None
            /\ premise_ViewUpdate_R_Choice self from
          -> op_View_R from frame <> None
          /\ premise_ViewUpdate_R_Choice self from
          /\ (forall result: t_Choice. op_View_R (update_ViewUpdate_R_Choice self from result) frame <> None
            -> op_View_R (update_ViewUpdate_R_Choice self from result) frame <> None)
end
module M_logic__ra__view__impl_Update_for_ViewUpdateInsert_R__update__refines (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateInsert_R = { f0: t_Auth; f1: t_Frag }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'0: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'0).auth
  
  predicate premise_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. rel_R (auth_R from) f
      -> match op_Frag self.f1 f with
        | Some'0 ff -> rel_R (Some (self.f0)) ff
        | None'0 -> false
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdateInsert_R. forall from: t_View_R. forall ch: (). premise_ViewUpdateInsert_R self from
          -> premise_ViewUpdateInsert_R self from
end
module M_logic__ra__view__impl_Update_for_ViewUpdateInsert_R__frame_preserving__refines (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Option_Frag_Option_Frag = { f0'0: t_Option_Frag; f1'0: t_Option_Frag }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth; f2'1: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None'1; f1'2 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'2 = a; f1'2 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'0 = op_Frag (frag_R a) (frag_R b); f1'0 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'0 = Some'0 fab; f1'0 = Some'0 fbc} -> match { f0'0 = op_Frag fab (frag_R c);
                                                          f1'0 = op_Frag (frag_R a) fbc } with
        | {f0'0 = Some'0 fabc1; f1'0 = Some'0 fabc2} -> match { f0'1 = auth_R a; f1'1 = auth_R b; f2'1 = auth_R c } with
          | {f0'1 = Some'1 _; f1'1 = None'1; f2'1 = None'1} | {f0'1 = None'1; f1'1 = Some'1 _; f2'1 = None'1} | {f0'1 = None'1; f1'1 = None'1; f2'1 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  type t_ViewUpdateInsert_R = { f0'3: t_Auth; f1'3: t_Frag }
  
  predicate premise_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) =
    auth_R from <> None'1
    /\ (forall f: t_Frag. rel_R (auth_R from) f
      -> match op_Frag self.f1'3 f with
        | Some'0 ff -> rel_R (Some'1 (self.f0'3)) ff
        | None'0 -> false
        end)
  
  function update_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) (_3: ()) : t_View_R =
    new_R (Some'1 (self.f0'3)) self.f1'3
  
  axiom update_ViewUpdateInsert_R_spec:
    forall self: t_ViewUpdateInsert_R, from: t_View_R, _3: (). premise_ViewUpdateInsert_R self from
      -> rel_R (Some'1 (self.f0'3)) self.f1'3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdateInsert_R. forall from: t_View_R. forall frame: t_View_R. op_View_R from frame
              <> None
            /\ premise_ViewUpdateInsert_R self from
          -> op_View_R from frame <> None
          /\ premise_ViewUpdateInsert_R self from
          /\ (forall result: (). op_View_R (update_ViewUpdateInsert_R self from result) frame <> None
            -> op_View_R (update_ViewUpdateInsert_R self from result) frame <> None)
end
module M_logic__ra__view__impl_Update_for_ViewUpdateRemove_R__update__refines (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateRemove_R = { f0: t_Auth }
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0'0: t_Subset_InnerView_R }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0'0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. match op_Frag (frag_R from) f with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end -> rel_R (Some (self.f0)) f)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdateRemove_R. forall from: t_View_R. forall ch: (). premise_ViewUpdateRemove_R self from
          -> premise_ViewUpdateRemove_R self from
end
module M_logic__ra__view__impl_Update_for_ViewUpdateRemove_R__frame_preserving__refines (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Option_Frag_Option_Frag = { f0'0: t_Option_Frag; f1'0: t_Option_Frag }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth; f2'1: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None'1; f1'2 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'2 = a; f1'2 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'0 = op_Frag (frag_R a) (frag_R b); f1'0 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'0 = Some'0 fab; f1'0 = Some'0 fbc} -> match { f0'0 = op_Frag fab (frag_R c);
                                                          f1'0 = op_Frag (frag_R a) fbc } with
        | {f0'0 = Some'0 fabc1; f1'0 = Some'0 fabc2} -> match { f0'1 = auth_R a; f1'1 = auth_R b; f2'1 = auth_R c } with
          | {f0'1 = Some'1 _; f1'1 = None'1; f2'1 = None'1} | {f0'1 = None'1; f1'1 = Some'1 _; f2'1 = None'1} | {f0'1 = None'1; f1'1 = None'1; f2'1 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  type t_ViewUpdateRemove_R = { f0'3: t_Auth }
  
  predicate premise_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) =
    auth_R from <> None'1
    /\ (forall f: t_Frag. match op_Frag (frag_R from) f with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end -> rel_R (Some'1 (self.f0'3)) f)
  
  function new_auth_R [@inline:trivial] (auth'0: t_Auth) : t_View_R = new_R (Some'1 auth'0) unit_Frag
  
  meta "rewrite_def" function new_auth_R
  
  function update_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) (_3: ()) : t_View_R =
    new_auth_R self.f0'3
  
  axiom update_ViewUpdateRemove_R_spec:
    forall self: t_ViewUpdateRemove_R, from: t_View_R, _3: (). premise_ViewUpdateRemove_R self from
      -> rel_R (Some'1 (self.f0'3)) unit_Frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ViewUpdateRemove_R. forall from: t_View_R. forall frame: t_View_R. op_View_R from frame
              <> None
            /\ premise_ViewUpdateRemove_R self from
          -> op_View_R from frame <> None
          /\ premise_ViewUpdateRemove_R self from
          /\ (forall result: (). op_View_R (update_ViewUpdateRemove_R self from result) frame <> None
            -> op_View_R (update_ViewUpdateRemove_R self from result) frame <> None)
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__core_is_total__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'1: t_Option_FMap_K_V; f1'1: t_Option_FMap_K_V }
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : () = match { f0'1 = op_FMap_K_V a b;
                                                                                               f1'1 = op_FMap_K_V b c } with
      | {f0'1 = Some ab; f1'1 = Some bc} -> match { f0'1 = op_FMap_K_V ab c; f1'1 = op_FMap_K_V a bc } with
        | {f0'1 = Some x; f1'1 = Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_FMap_K_V_spec:
    forall a: t_FMap_K_V, b: t_FMap_K_V, c: t_FMap_K_V. and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  type tup2_K_V = { f0'2: t_K; f1'2: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'2 = k; f1'2 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  axiom core_V_spec: forall self: t_V. match core_V self with
        | Some'0 c -> op_V c c = Some'0 c /\ op_V c self = Some'0 self
        | None'0 -> true
        end
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V =
    let r = filter_map_K self (fun (__0: tup2_K_V) -> let {f1'2 = v} = __0 in core_V v) in r
  
  axiom core_total_FMap_K_V_spec:
    forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
      = Some (core_total_FMap_K_V self)
  
  axiom core_total_FMap_K_V_spec'0: forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) self = Some self
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V = Some (core_total_FMap_K_V self)
  
  axiom core_FMap_K_V_spec: forall self: t_FMap_K_V. match core_FMap_K_V self with
        | Some c -> op_FMap_K_V c c = Some c /\ op_FMap_K_V c self = Some self
        | None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall result: (). core_FMap_K_V self = Some (core_total_FMap_K_V self)
        -> core_FMap_K_V self = Some (core_total_FMap_K_V self)
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__unit__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0: t_Option_FMap_K_V; f1: t_Option_FMap_K_V }
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'1: t_V; f1'1: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None'0; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None'0} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'1 = x; f1'1 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : () = match { f0 = op_FMap_K_V a b;
                                                                                               f1 = op_FMap_K_V b c } with
      | {f0 = Some ab; f1 = Some bc} -> match { f0 = op_FMap_K_V ab c; f1 = op_FMap_K_V a bc } with
        | {f0 = Some x; f1 = Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_FMap_K_V_spec:
    forall a: t_FMap_K_V, b: t_FMap_K_V, c: t_FMap_K_V. and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_FMap_K_V. (forall x: t_FMap_K_V [op_FMap_K_V x result]. op_FMap_K_V x result = Some x)
      -> (forall x: t_FMap_K_V [op_FMap_K_V x result]. op_FMap_K_V x result = Some x)
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__core_total__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0: t_Option_FMap_K_V; f1: t_Option_FMap_K_V }
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'1: t_V; f1'1: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None'0; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None'0} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'1 = x; f1'1 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : () = match { f0 = op_FMap_K_V a b;
                                                                                               f1 = op_FMap_K_V b c } with
      | {f0 = Some ab; f1 = Some bc} -> match { f0 = op_FMap_K_V ab c; f1 = op_FMap_K_V a bc } with
        | {f0 = Some x; f1 = Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_FMap_K_V_spec:
    forall a: t_FMap_K_V, b: t_FMap_K_V, c: t_FMap_K_V. and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall result: t_FMap_K_V. op_FMap_K_V result self = Some self
          /\ op_FMap_K_V result result = Some result
        -> op_FMap_K_V result self = Some self /\ op_FMap_K_V result result = Some result
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__core_is_total__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  type tup3_Option_T_Option_T_Option_T = { f0'0: t_Option_T; f1'0: t_Option_T; f2'0: t_Option_T }
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function associative_Option_T (a: t_Option_T) (b: t_Option_T) (c: t_Option_T) : () = match { f0'0 = a;
                                                                                               f1'0 = b;
                                                                                               f2'0 = c } with
      | {f0'0 = None} -> ()
      | {f1'0 = None} -> ()
      | {f2'0 = None} -> ()
      | {f0'0 = Some aa; f1'0 = Some bb; f2'0 = Some cc} -> associative_T aa bb cc
      end
  
  axiom associative_Option_T_spec:
    forall a: t_Option_T, b: t_Option_T, c: t_Option_T. and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some c -> op_T c c = Some c /\ op_T c self = Some self
        | None -> true
        end
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> core_T x
      end
  
  axiom core_total_Option_T_spec:
    forall self: t_Option_T. op_Option_T (core_total_Option_T self) (core_total_Option_T self)
      = Some'0 (core_total_Option_T self)
  
  axiom core_total_Option_T_spec'0: forall self: t_Option_T. op_Option_T (core_total_Option_T self) self = Some'0 self
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = Some'0 (core_total_Option_T self)
  
  axiom core_Option_T_spec: forall self: t_Option_T. match core_Option_T self with
        | Some'0 c -> op_Option_T c c = Some'0 c /\ op_Option_T c self = Some'0 self
        | None'0 -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall result: (). core_Option_T self = Some'0 (core_total_Option_T self)
        -> core_Option_T self = Some'0 (core_total_Option_T self)
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__core_total__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup3_Option_T_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T; f2: t_Option_T }
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  type tup2_Option_T_Option_T = { f0'0: t_Option_T; f1'0: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function associative_Option_T (a: t_Option_T) (b: t_Option_T) (c: t_Option_T) : () = match { f0 = a;
                                                                                               f1 = b;
                                                                                               f2 = c } with
      | {f0 = None} -> ()
      | {f1 = None} -> ()
      | {f2 = None} -> ()
      | {f0 = Some aa; f1 = Some bb; f2 = Some cc} -> associative_T aa bb cc
      end
  
  axiom associative_Option_T_spec:
    forall a: t_Option_T, b: t_Option_T, c: t_Option_T. and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall result: t_Option_T. op_Option_T result self = Some'0 self
          /\ op_Option_T result result = Some'0 result
        -> op_Option_T result self = Some'0 self /\ op_Option_T result result = Some'0 result
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__unit__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup3_Option_T_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T; f2: t_Option_T }
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  type tup2_Option_T_Option_T = { f0'0: t_Option_T; f1'0: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function associative_Option_T (a: t_Option_T) (b: t_Option_T) (c: t_Option_T) : () = match { f0 = a;
                                                                                               f1 = b;
                                                                                               f2 = c } with
      | {f0 = None} -> ()
      | {f1 = None} -> ()
      | {f2 = None} -> ()
      | {f0 = Some aa; f1 = Some bb; f2 = Some cc} -> associative_T aa bb cc
      end
  
  axiom associative_Option_T_spec:
    forall a: t_Option_T, b: t_Option_T, c: t_Option_T. and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
      = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_Option_T. (forall x: t_Option_T [op_Option_T x result]. op_Option_T x result
          = Some'0 x) -> (forall x: t_Option_T [op_Option_T x result]. op_Option_T x result = Some'0 x)
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__unit__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  function associative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) (c: tup2_T_U) : () = ()
  
  axiom associative_tup2_T_U_spec:
    forall a: tup2_T_U, b: tup2_T_U, c: tup2_T_U. and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
      = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: tup2_T_U. (forall x: tup2_T_U [op_tup2_T_U x result]. op_tup2_T_U x result = Some x)
      -> (forall x: tup2_T_U [op_tup2_T_U x result]. op_tup2_T_U x result = Some x)
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__core_total__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  function associative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) (c: tup2_T_U) : () = ()
  
  axiom associative_tup2_T_U_spec:
    forall a: tup2_T_U, b: tup2_T_U, c: tup2_T_U. and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
      = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall result: tup2_T_U. op_tup2_T_U result self = Some self
          /\ op_tup2_T_U result result = Some result
        -> op_tup2_T_U result self = Some self /\ op_tup2_T_U result result = Some result
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__core_is_total__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function and_then_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'0 -> None
      | Some'0 x -> Map.get f x
      end
  
  function and_then_Option_T'0 (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_T = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : () = ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_T_spec: forall a: t_T, b: t_T, c: t_T. and_then_Option_T'0 (op_T a b) (fun (ab: t_T) -> op_T ab c)
      = and_then_Option_T'0 (op_T b c) (fun (bc: t_T) -> op_T a bc)
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : () = ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  type t_Option_U = None'1 | Some'1 t_U
  
  function map_Option_U (self: t_Option_U) (f: Map.map t_U tup2_T_U) : t_Option_tup2_T_U = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_U (self: t_Option_U) (f: Map.map t_U t_Option_U) : t_Option_U = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : () = ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_U_spec: forall a: t_U, b: t_U, c: t_U. and_then_Option_U (op_U a b) (fun (ab: t_U) -> op_U ab c)
      = and_then_Option_U (op_U b c) (fun (bc: t_U) -> op_U a bc)
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : () = ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U =
    and_then_Option_T (op_T self.f0 other.f0) (fun (x: t_T) -> map_Option_U (op_U self.f1 other.f1) (fun (y: t_U) -> { f0 = x;
                                                                                                                       f1 = y }))
  
  function associative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) (c: tup2_T_U) : () = ()
  
  axiom associative_tup2_T_U_spec:
    forall a: tup2_T_U, b: tup2_T_U, c: tup2_T_U. and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
      = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function core_T (self: t_T) : t_Option_T
  
  axiom core_T_spec: forall self: t_T. match core_T self with
        | Some'0 c -> op_T c c = Some'0 c /\ op_T c self = Some'0 self
        | None'0 -> true
        end
  
  function core_U (self: t_U) : t_Option_U
  
  axiom core_U_spec: forall self: t_U. match core_U self with
        | Some'1 c -> op_U c c = Some'1 c /\ op_U c self = Some'1 self
        | None'1 -> true
        end
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  axiom core_tup2_T_U_spec: forall self: tup2_T_U. match core_tup2_T_U self with
        | Some c -> op_tup2_T_U c c = Some c /\ op_tup2_T_U c self = Some self
        | None -> true
        end
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. op_T (core_total_T self) (core_total_T self) = Some'0 (core_total_T self)
  
  axiom core_total_T_spec'0: forall self: t_T. op_T (core_total_T self) self = Some'0 self
  
  constant unit_core_T: () = ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T: () = let _ = unit_T in ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  constant unit_U : t_U
  
  axiom unit_U_spec: forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x
  
  function core_total_U (self: t_U) : t_U
  
  axiom core_total_U_spec: forall self: t_U. op_U (core_total_U self) (core_total_U self) = Some'1 (core_total_U self)
  
  axiom core_total_U_spec'0: forall self: t_U. op_U (core_total_U self) self = Some'1 self
  
  constant unit_core_U: () = ()
  
  axiom unit_core_U_spec: core_total_U unit_U = unit_U
  
  constant incl_refl_U: () = let _ = unit_U in ()
  
  axiom incl_refl_U_spec: forall x: t_U. incl_U x x
  
  function core_total_tup2_T_U (self: tup2_T_U) : tup2_T_U = { f0 = core_total_T self.f0; f1 = core_total_U self.f1 }
  
  axiom core_total_tup2_T_U_spec:
    forall self: tup2_T_U. op_tup2_T_U (core_total_tup2_T_U self) (core_total_tup2_T_U self)
      = Some (core_total_tup2_T_U self)
  
  axiom core_total_tup2_T_U_spec'0: forall self: tup2_T_U. op_tup2_T_U (core_total_tup2_T_U self) self = Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall result: (). core_tup2_T_U self = Some (core_total_tup2_T_U self)
        -> core_tup2_T_U self = Some (core_total_tup2_T_U self)
end
module M_logic__ra__view__impl_UnitRA_for_View_R__core_total__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Option_Frag_Option_Frag = { f0'0: t_Option_Frag; f1'0: t_Option_Frag }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth; f2'1: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None'1; f1'2 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'2 = a; f1'2 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'0 = op_Frag (frag_R a) (frag_R b); f1'0 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'0 = Some'0 fab; f1'0 = Some'0 fbc} -> match { f0'0 = op_Frag fab (frag_R c);
                                                          f1'0 = op_Frag (frag_R a) fbc } with
        | {f0'0 = Some'0 fabc1; f1'0 = Some'0 fabc2} -> match { f0'1 = auth_R a; f1'1 = auth_R b; f2'1 = auth_R c } with
          | {f0'1 = Some'1 _; f1'1 = None'1; f2'1 = None'1} | {f0'1 = None'1; f1'1 = Some'1 _; f2'1 = None'1} | {f0'1 = None'1; f1'1 = None'1; f2'1 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall result: t_View_R. op_View_R result self = Some self
          /\ op_View_R result result = Some result
        -> op_View_R result self = Some self /\ op_View_R result result = Some result
end
module M_logic__ra__view__impl_UnitRA_for_View_R__unit__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Option_Frag_Option_Frag = { f0'0: t_Option_Frag; f1'0: t_Option_Frag }
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth; f2'1: t_Option_Auth }
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None'1; f1'2 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'2 = a; f1'2 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'0 = op_Frag (frag_R a) (frag_R b); f1'0 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'0 = Some'0 fab; f1'0 = Some'0 fbc} -> match { f0'0 = op_Frag fab (frag_R c);
                                                          f1'0 = op_Frag (frag_R a) fbc } with
        | {f0'0 = Some'0 fabc1; f1'0 = Some'0 fabc2} -> match { f0'1 = auth_R a; f1'1 = auth_R b; f2'1 = auth_R c } with
          | {f0'1 = Some'1 _; f1'1 = None'1; f2'1 = None'1} | {f0'1 = None'1; f1'1 = Some'1 _; f2'1 = None'1} | {f0'1 = None'1; f1'1 = None'1; f2'1 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_View_R. (forall x: t_View_R [op_View_R x result]. op_View_R x result = Some x)
      -> (forall x: t_View_R [op_View_R x result]. op_View_R x result = Some x)
end
module M_logic__ra__view__impl_UnitRA_for_View_R__core_is_total__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_InnerView_R
  
  type t_View_R = { f0: t_Subset_InnerView_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  function view_Subset_InnerView_R (self: t_Subset_InnerView_R) : t_InnerView_R
  
  axiom view_Subset_InnerView_R_spec:
    forall self: t_Subset_InnerView_R. invariant_InnerView_R (view_Subset_InnerView_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (view_Subset_InnerView_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (view_Subset_InnerView_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_InnerView_R (x: t_InnerView_R) : t_Subset_InnerView_R
  
  axiom new_InnerView_R_spec: forall x: t_InnerView_R. invariant_InnerView_R x
      -> view_Subset_InnerView_R (new_InnerView_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_InnerView_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  type tup2_Option_Frag_Option_Frag = { f0'1: t_Option_Frag; f1'1: t_Option_Frag }
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth; f2'2: t_Option_Auth }
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : () =
    let _ = match { f0'1 = op_Frag (frag_R a) (frag_R b); f1'1 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'1 = Some'0 fab; f1'1 = Some'0 fbc} -> match { f0'1 = op_Frag fab (frag_R c);
                                                          f1'1 = op_Frag (frag_R a) fbc } with
        | {f0'1 = Some'0 fabc1; f1'1 = Some'0 fabc2} -> match { f0'2 = auth_R a; f1'2 = auth_R b; f2'2 = auth_R c } with
          | {f0'2 = Some'1 _; f1'2 = None'1; f2'2 = None'1} | {f0'2 = None'1; f1'2 = Some'1 _; f2'2 = None'1} | {f0'2 = None'1; f1'2 = None'1; f2'2 = Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in ()
  
  axiom associative_View_R_spec:
    forall a: t_View_R, b: t_View_R, c: t_View_R. and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_total_View_R (self: t_View_R) : t_View_R = new_frag_R (core_total_Frag (frag_R self))
  
  axiom core_total_View_R_spec: forall self: t_View_R. op_View_R (core_total_View_R self) (core_total_View_R self)
      = Some (core_total_View_R self)
  
  axiom core_total_View_R_spec'0: forall self: t_View_R. op_View_R (core_total_View_R self) self = Some self
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (core_total_View_R self)
  
  axiom core_View_R_spec: forall self: t_View_R. match core_View_R self with
        | Some c -> op_View_R c c = Some c /\ op_View_R c self = Some self
        | None -> true
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall result: (). core_View_R self = Some (core_total_View_R self)
        -> core_View_R self = Some (core_total_View_R self)
end
module M_logic__ra__fmap__impl_LocalUpdate_for_FMapInsertLocalUpdate_K_V__frame_preserving__refines (* <logic::ra::fmap::FMapInsertLocalUpdate<K, V> as logic::ra::update::LocalUpdate<logic::fmap::FMap<K, V>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_Option_Option_FMap_K_V = None'0 | Some'0 t_Option_FMap_K_V
  
  function and_then_Option_Option_FMap_K_V (self: t_Option_Option_FMap_K_V) (f: Map.map t_Option_FMap_K_V t_Option_Option_FMap_K_V) : t_Option_Option_FMap_K_V
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0: t_Option_FMap_K_V; f1: t_Option_FMap_K_V }
  
  function map_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_Option_FMap_K_V
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option_V = None'1 | Some'1 t_V
  
  type t_Option_Option_V = None'2 | Some'2 t_Option_V
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'1 -> None'2
      | Some'1 x -> Some'2 (Map.get f x)
      end
  
  function and_then_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_V = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'1 c -> op_V factor c = Some'1 self
        | None'1 -> forall c: t_V. op_V factor c <> Some'1 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'1
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : () = ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_V_spec: forall a: t_V, b: t_V, c: t_V. and_then_Option_V (op_V a b) (fun (ab: t_V) -> op_V ab c)
      = and_then_Option_V (op_V b c) (fun (bc: t_V) -> op_V a bc)
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : () = ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'1 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None'1} -> Some'2 other
      | {f1'0 = None'1} -> Some'2 self
      | {f0'0 = Some'1 x; f1'0 = Some'1 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'1 z)
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'1: t_V; f1'1: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None'1; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None'1} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some'1 x; f1'0 = Some'1 y} -> get_K (merge_K self m f) k
          = Some'1 (index_Mapping_tup2_V_V_V f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'1 = x; f1'1 = y} = __0 in match op_V x y with
      | Some'1 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'2 then Some (total_op_K self other) else None
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : () = match { f0 = op_FMap_K_V a b;
                                                                                               f1 = op_FMap_K_V b c } with
      | {f0 = Some ab; f1 = Some bc} -> match { f0 = op_FMap_K_V ab c; f1 = op_FMap_K_V a bc } with
        | {f0 = Some x; f1 = Some y} -> ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_FMap_K_V_spec:
    forall a: t_FMap_K_V, b: t_FMap_K_V, c: t_FMap_K_V. and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  function op_Option_FMap_K_V (self: t_Option_FMap_K_V) (other: t_Option_FMap_K_V) : t_Option_Option_FMap_K_V =
    match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_FMap_K_V (op_FMap_K_V x y) (fun (z: t_FMap_K_V) -> Some z)
      end
  
  function associative_Option_FMap_K_V (a: t_Option_FMap_K_V) (b: t_Option_FMap_K_V) (c: t_Option_FMap_K_V) : ()
  
  axiom associative_Option_FMap_K_V_spec:
    forall a: t_Option_FMap_K_V, b: t_Option_FMap_K_V, c: t_Option_FMap_K_V. and_then_Option_Option_FMap_K_V (op_Option_FMap_K_V a b) (fun (ab: t_Option_FMap_K_V) -> op_Option_FMap_K_V ab c)
      = and_then_Option_Option_FMap_K_V (op_Option_FMap_K_V b c) (fun (bc: t_Option_FMap_K_V) -> op_Option_FMap_K_V a bc)
  
  function commutative_Option_FMap_K_V (a: t_Option_FMap_K_V) (b: t_Option_FMap_K_V) : ()
  
  axiom commutative_Option_FMap_K_V_spec: forall a: t_Option_FMap_K_V, b: t_Option_FMap_K_V. op_Option_FMap_K_V a b
      = op_Option_FMap_K_V b a
  
  type t_FMapInsertLocalUpdate_K_V = { f0'2: t_K; f1'2: t_V }
  
  predicate premise_FMapInsertLocalUpdate_K_V (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (_3: t_FMap_K_V) =
    get_K from_auth self.f0'2 = None'1
  
  type tup2_FMap_K_V_FMap_K_V = { f0'3: t_FMap_K_V; f1'3: t_FMap_K_V }
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'1
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some'1 v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  function update_FMapInsertLocalUpdate_K_V (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (from_frag: t_FMap_K_V) : tup2_FMap_K_V_FMap_K_V
   = { f0'3 = insert_K from_auth self.f0'2 self.f1'2; f1'3 = insert_K from_frag self.f0'2 self.f1'2 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_FMapInsertLocalUpdate_K_V. forall from_auth: t_FMap_K_V. forall from_frag: t_FMap_K_V. forall frame: t_Option_FMap_K_V. op_Option_FMap_K_V (Some from_frag) frame
                = Some'0 (Some from_auth)
              /\ premise_FMapInsertLocalUpdate_K_V self from_auth from_frag
            -> op_Option_FMap_K_V (Some from_frag) frame = Some'0 (Some from_auth)
            /\ premise_FMapInsertLocalUpdate_K_V self from_auth from_frag
            /\ (forall result: (). (let {f0'3 = to_auth; f1'3 = to_frag} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in op_Option_FMap_K_V (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'3 = to_auth; f1'3 = to_frag} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in op_Option_FMap_K_V (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__prod__impl_LocalUpdate_for_ProdLocalUpdate_U1_U2__frame_preserving__refines (* <logic::ra::prod::ProdLocalUpdate<U1, U2> as logic::ra::update::LocalUpdate<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0: t_R1; f1: t_R2 }
  
  type t_Option_tup2_R1_R2 = None | Some tup2_R1_R2
  
  type t_Option_Option_tup2_R1_R2 = None'0 | Some'0 t_Option_tup2_R1_R2
  
  function and_then_Option_Option_tup2_R1_R2 (self: t_Option_Option_tup2_R1_R2) (f: Map.map t_Option_tup2_R1_R2 t_Option_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_tup2_R1_R2_Option_tup2_R1_R2 = { f0'0: t_Option_tup2_R1_R2; f1'0: t_Option_tup2_R1_R2 }
  
  function map_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_Option_tup2_R1_R2) : t_Option_tup2_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_tup2_R1_R2) : t_Option_tup2_R1_R2 =
    match self with
      | None'1 -> None
      | Some'1 x -> Map.get f x
      end
  
  function and_then_Option_R1'0 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1'0 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1'0 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 tup2_R1_R2) : t_Option_tup2_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_tup2_R1_R2 (self: tup2_R1_R2) (other: tup2_R1_R2) : t_Option_tup2_R1_R2 =
    and_then_Option_R1 (op_R1 self.f0 other.f0) (fun (x: t_R1) -> map_Option_R2 (op_R2 self.f1 other.f1) (fun (y: t_R2) -> { f0 = x;
                                                                                                                             f1 = y }))
  
  function associative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) (c: tup2_R1_R2) : () = ()
  
  axiom associative_tup2_R1_R2_spec:
    forall a: tup2_R1_R2, b: tup2_R1_R2, c: tup2_R1_R2. and_then_Option_tup2_R1_R2 (op_tup2_R1_R2 a b) (fun (ab: tup2_R1_R2) -> op_tup2_R1_R2 ab c)
      = and_then_Option_tup2_R1_R2 (op_tup2_R1_R2 b c) (fun (bc: tup2_R1_R2) -> op_tup2_R1_R2 a bc)
  
  function commutative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) : () = ()
  
  axiom commutative_tup2_R1_R2_spec: forall a: tup2_R1_R2, b: tup2_R1_R2. op_tup2_R1_R2 a b = op_tup2_R1_R2 b a
  
  function op_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (other: t_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2 =
    match { f0'0 = self; f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_tup2_R1_R2 (op_tup2_R1_R2 x y) (fun (z: tup2_R1_R2) -> Some z)
      end
  
  function associative_Option_tup2_R1_R2 (a: t_Option_tup2_R1_R2) (b: t_Option_tup2_R1_R2) (c: t_Option_tup2_R1_R2) : ()
  
  axiom associative_Option_tup2_R1_R2_spec:
    forall a: t_Option_tup2_R1_R2, b: t_Option_tup2_R1_R2, c: t_Option_tup2_R1_R2. and_then_Option_Option_tup2_R1_R2 (op_Option_tup2_R1_R2 a b) (fun (ab: t_Option_tup2_R1_R2) -> op_Option_tup2_R1_R2 ab c)
      = and_then_Option_Option_tup2_R1_R2 (op_Option_tup2_R1_R2 b c) (fun (bc: t_Option_tup2_R1_R2) -> op_Option_tup2_R1_R2 a bc)
  
  function commutative_Option_tup2_R1_R2 (a: t_Option_tup2_R1_R2) (b: t_Option_tup2_R1_R2) : ()
  
  axiom commutative_Option_tup2_R1_R2_spec:
    forall a: t_Option_tup2_R1_R2, b: t_Option_tup2_R1_R2. op_Option_tup2_R1_R2 a b = op_Option_tup2_R1_R2 b a
  
  type t_U1
  
  type t_U2
  
  type t_ProdLocalUpdate_U1_U2 = { f0'1: t_U1; f1'1: t_U2 }
  
  predicate premise_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise_ProdLocalUpdate_U1_U2 (self: t_ProdLocalUpdate_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) =
    premise_U1 self.f0'1 from_auth.f0 from_frag.f0 /\ premise_U2 self.f1'1 from_auth.f1 from_frag.f1
  
  type tup2_tup2_R1_R2_tup2_R1_R2 = { f0'2: tup2_R1_R2; f1'2: tup2_R1_R2 }
  
  type tup2_R1_R1 = { f0'3: t_R1; f1'3: t_R1 }
  
  function update_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) : tup2_R1_R1
  
  type tup2_R2_R2 = { f0'4: t_R2; f1'4: t_R2 }
  
  function update_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) : tup2_R2_R2
  
  function update_ProdLocalUpdate_U1_U2 (self: t_ProdLocalUpdate_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) : tup2_tup2_R1_R2_tup2_R1_R2
   =
    let {f0'3 = to_auth0; f1'3 = to_frag0} = update_U1 self.f0'1 from_auth.f0 from_frag.f0 in let {f0'4 = to_auth1; f1'4 = to_frag1} = update_U2 self.f1'1 from_auth.f1 from_frag.f1 in { f0'2 = { f0 = to_auth0;
                                                                                                                                                                                                   f1 = to_auth1 };
                                                                                                                                                                                          f1'2 = { f0 = to_frag0;
                                                                                                                                                                                                   f1 = to_frag1 } }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ProdLocalUpdate_U1_U2. forall from_auth: tup2_R1_R2. forall from_frag: tup2_R1_R2. forall frame: t_Option_tup2_R1_R2. op_Option_tup2_R1_R2 (Some from_frag) frame
                = Some'0 (Some from_auth)
              /\ premise_ProdLocalUpdate_U1_U2 self from_auth from_frag
            -> op_Option_tup2_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            /\ premise_ProdLocalUpdate_U1_U2 self from_auth from_frag
            /\ (forall result: (). (let {f0'2 = to_auth; f1'2 = to_frag} = update_ProdLocalUpdate_U1_U2 self from_auth from_frag in op_Option_tup2_R1_R2 (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'2 = to_auth; f1'2 = to_frag} = update_ProdLocalUpdate_U1_U2 self from_auth from_frag in op_Option_tup2_R1_R2 (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__sum__impl_LocalUpdate_for_SumLocalUpdateL_U__frame_preserving__refines (* <logic::ra::sum::SumLocalUpdateL<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type t_Option_Option_Sum_R1_R2 = None'0 | Some'0 t_Option_Sum_R1_R2
  
  function and_then_Option_Option_Sum_R1_R2 (self: t_Option_Option_Sum_R1_R2) (f: Map.map t_Option_Sum_R1_R2 t_Option_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_Sum_R1_R2_Option_Sum_R1_R2 = { f0: t_Option_Sum_R1_R2; f1: t_Option_Sum_R1_R2 }
  
  function map_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function associative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) (c: t_Sum_R1_R2) : () = ()
  
  axiom associative_Sum_R1_R2_spec:
    forall a: t_Sum_R1_R2, b: t_Sum_R1_R2, c: t_Sum_R1_R2. and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
      = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function op_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (other: t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2 =
    match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_Sum_R1_R2 (op_Sum_R1_R2 x y) (fun (z: t_Sum_R1_R2) -> Some z)
      end
  
  function associative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) (c: t_Option_Sum_R1_R2) : ()
  
  axiom associative_Option_Sum_R1_R2_spec:
    forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2, c: t_Option_Sum_R1_R2. and_then_Option_Option_Sum_R1_R2 (op_Option_Sum_R1_R2 a b) (fun (ab: t_Option_Sum_R1_R2) -> op_Option_Sum_R1_R2 ab c)
      = and_then_Option_Option_Sum_R1_R2 (op_Option_Sum_R1_R2 b c) (fun (bc: t_Option_Sum_R1_R2) -> op_Option_Sum_R1_R2 a bc)
  
  function commutative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) : ()
  
  axiom commutative_Option_Sum_R1_R2_spec: forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 a b
      = op_Option_Sum_R1_R2 b a
  
  type t_U
  
  type t_SumLocalUpdateL_U = { f0'1: t_U }
  
  predicate premise_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise_SumLocalUpdateL_U (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Left from_auth'0; f1'0 = Left from_frag'0} -> premise_U self.f0'1 from_auth'0 from_frag'0
      | {f0'0 = Right _; f1'0 = Right _} -> false
      | _ -> true
      end
  
  type tup2_R1_R1 = { f0'2: t_R1; f1'2: t_R1 }
  
  function update_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1) : tup2_R1_R1
  
  predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool [@inline:trivial] (self: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) (a: tup2_Sum_R1_R2_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool
  
  function such_that_tup2_Sum_R1_R2_Sum_R1_R2 (p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) : tup2_Sum_R1_R2_Sum_R1_R2
  
  axiom such_that_tup2_Sum_R1_R2_Sum_R1_R2_spec:
    forall p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool. (exists x: tup2_Sum_R1_R2_Sum_R1_R2. index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p x)
      -> index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p (such_that_tup2_Sum_R1_R2_Sum_R1_R2 p)
  
  function update_SumLocalUpdateL_U (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) : tup2_Sum_R1_R2_Sum_R1_R2
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Left from_auth'0; f1'0 = Left from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0'1 from_auth'0 from_frag'0 in { f0'0 = Left to_auth;
                                                                                                                                                     f1'0 = Left to_frag }
      | _ -> such_that_tup2_Sum_R1_R2_Sum_R1_R2 (fun (__0: tup2_Sum_R1_R2_Sum_R1_R2) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumLocalUpdateL_U. forall from_auth: t_Sum_R1_R2. forall from_frag: t_Sum_R1_R2. forall frame: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 (Some from_frag) frame
                = Some'0 (Some from_auth)
              /\ premise_SumLocalUpdateL_U self from_auth from_frag
            -> op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            /\ premise_SumLocalUpdateL_U self from_auth from_frag
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__sum__impl_LocalUpdate_for_SumLocalUpdateR_U__frame_preserving__refines (* <logic::ra::sum::SumLocalUpdateR<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type t_Option_Option_Sum_R1_R2 = None'0 | Some'0 t_Option_Sum_R1_R2
  
  function and_then_Option_Option_Sum_R1_R2 (self: t_Option_Option_Sum_R1_R2) (f: Map.map t_Option_Sum_R1_R2 t_Option_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_Sum_R1_R2_Option_Sum_R1_R2 = { f0: t_Option_Sum_R1_R2; f1: t_Option_Sum_R1_R2 }
  
  function map_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_R1 = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : () = ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_R1_spec:
    forall a: t_R1, b: t_R1, c: t_R1. and_then_Option_R1 (op_R1 a b) (fun (ab: t_R1) -> op_R1 ab c)
      = and_then_Option_R1 (op_R1 b c) (fun (bc: t_R1) -> op_R1 a bc)
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : () = ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function and_then_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_R2 = match self with
      | None'2 -> None'2
      | Some'2 x -> Map.get f x
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : () = ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_R2_spec:
    forall a: t_R2, b: t_R2, c: t_R2. and_then_Option_R2 (op_R2 a b) (fun (ab: t_R2) -> op_R2 ab c)
      = and_then_Option_R2 (op_R2 b c) (fun (bc: t_R2) -> op_R2 a bc)
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : () = ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function associative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) (c: t_Sum_R1_R2) : () = ()
  
  axiom associative_Sum_R1_R2_spec:
    forall a: t_Sum_R1_R2, b: t_Sum_R1_R2, c: t_Sum_R1_R2. and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
      = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function op_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (other: t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2 =
    match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_Sum_R1_R2 (op_Sum_R1_R2 x y) (fun (z: t_Sum_R1_R2) -> Some z)
      end
  
  function associative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) (c: t_Option_Sum_R1_R2) : ()
  
  axiom associative_Option_Sum_R1_R2_spec:
    forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2, c: t_Option_Sum_R1_R2. and_then_Option_Option_Sum_R1_R2 (op_Option_Sum_R1_R2 a b) (fun (ab: t_Option_Sum_R1_R2) -> op_Option_Sum_R1_R2 ab c)
      = and_then_Option_Option_Sum_R1_R2 (op_Option_Sum_R1_R2 b c) (fun (bc: t_Option_Sum_R1_R2) -> op_Option_Sum_R1_R2 a bc)
  
  function commutative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) : ()
  
  axiom commutative_Option_Sum_R1_R2_spec: forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 a b
      = op_Option_Sum_R1_R2 b a
  
  type t_U
  
  type t_SumLocalUpdateR_U = { f0'1: t_U }
  
  predicate premise_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise_SumLocalUpdateR_U (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Right from_auth'0; f1'0 = Right from_frag'0} -> premise_U self.f0'1 from_auth'0 from_frag'0
      | {f0'0 = Left _; f1'0 = Left _} -> false
      | _ -> true
      end
  
  type tup2_R2_R2 = { f0'2: t_R2; f1'2: t_R2 }
  
  function update_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2) : tup2_R2_R2
  
  predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool [@inline:trivial] (self: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) (a: tup2_Sum_R1_R2_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool
  
  function such_that_tup2_Sum_R1_R2_Sum_R1_R2 (p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) : tup2_Sum_R1_R2_Sum_R1_R2
  
  axiom such_that_tup2_Sum_R1_R2_Sum_R1_R2_spec:
    forall p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool. (exists x: tup2_Sum_R1_R2_Sum_R1_R2. index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p x)
      -> index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p (such_that_tup2_Sum_R1_R2_Sum_R1_R2 p)
  
  function update_SumLocalUpdateR_U (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) : tup2_Sum_R1_R2_Sum_R1_R2
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Right from_auth'0; f1'0 = Right from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0'1 from_auth'0 from_frag'0 in { f0'0 = Right to_auth;
                                                                                                                                                       f1'0 = Right to_frag }
      | _ -> such_that_tup2_Sum_R1_R2_Sum_R1_R2 (fun (__0: tup2_Sum_R1_R2_Sum_R1_R2) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumLocalUpdateR_U. forall from_auth: t_Sum_R1_R2. forall from_frag: t_Sum_R1_R2. forall frame: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 (Some from_frag) frame
                = Some'0 (Some from_auth)
              /\ premise_SumLocalUpdateR_U self from_auth from_frag
            -> op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            /\ premise_SumLocalUpdateR_U self from_auth from_frag
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__update__impl_LocalUpdate_for_Snapshot_tup2_R_R__frame_preserving__refines (* <snapshot::Snapshot<(R, R)> as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  function and_then_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_R
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_R_Option_R = { f0: t_Option_R; f1: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function and_then_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_R = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : () = ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_R_spec: forall a: t_R, b: t_R, c: t_R. and_then_Option_R (op_R a b) (fun (ab: t_R) -> op_R ab c)
      = and_then_Option_R (op_R b c) (fun (bc: t_R) -> op_R a bc)
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : () = ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function associative_Option_R (a: t_Option_R) (b: t_Option_R) (c: t_Option_R) : ()
  
  axiom associative_Option_R_spec:
    forall a: t_Option_R, b: t_Option_R, c: t_Option_R. and_then_Option_Option_R (op_Option_R a b) (fun (ab: t_Option_R) -> op_Option_R ab c)
      = and_then_Option_Option_R (op_Option_R b c) (fun (bc: t_Option_R) -> op_Option_R a bc)
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  type tup2_R_R = { f0'0: t_R; f1'0: t_R }
  
  predicate premise_Snapshot_tup2_R_R (self: tup2_R_R) (from_auth: t_R) (from_frag: t_R) =
    forall f: t_Option_R. op_Option_R (Some from_frag) f = Some'0 (Some from_auth)
      -> op_Option_R (Some (self.f1'0)) f = Some'0 (Some (self.f0'0))
  
  function update_Snapshot_tup2_R_R (self: tup2_R_R) (_2: t_R) (_3: t_R) : tup2_R_R = self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: tup2_R_R. forall from_auth: t_R. forall from_frag: t_R. forall frame: t_Option_R. op_Option_R (Some from_frag) frame
                = Some'0 (Some from_auth)
              /\ premise_Snapshot_tup2_R_R self from_auth from_frag
            -> op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
            /\ premise_Snapshot_tup2_R_R self from_auth from_frag
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update_Snapshot_tup2_R_R self from_auth from_frag in op_Option_R (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_Snapshot_tup2_R_R self from_auth from_frag in op_Option_R (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__view__impl_InhabitedInvariant_for_InnerView_R__inhabits__refines (* <logic::ra::view::InnerView<R> as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : () = ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function and_then_Option_Frag (self: t_Option_Frag) (f: Map.map t_Frag t_Option_Frag) : t_Option_Frag =
    match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  function associative_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_Frag_spec:
    forall a: t_Frag, b: t_Frag, c: t_Frag. and_then_Option_Frag (op_Frag a b) (fun (ab: t_Frag) -> op_Frag ab c)
      = and_then_Option_Frag (op_Frag b c) (fun (bc: t_Frag) -> op_Frag a bc)
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : () = ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag: () = ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag: () = let _ = unit_Frag in ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_InnerView_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_InnerView_R (self: t_InnerView_R) = rel_R self.auth self.frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_InnerView_R. invariant_InnerView_R result -> invariant_InnerView_R result
end
module M_logic__well_founded__impl_WellFounded_for_Int__no_infinite_decreasing_sequence__refines (* <logic::int::Int as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use mach.int.Int
  use map.Map
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int int. forall result: int. not well_founded_relation_Int (index_Mapping_Int_Int s result) (index_Mapping_Int_Int s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_Int (index_Mapping_Int_Int s result) (index_Mapping_Int_Int s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_u8__no_infinite_decreasing_sequence__refines (* <u8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom eq_cmp_u8_spec: forall x: UInt8.t, y: UInt8.t. (x = y) = (cmp_log_u8 x y = Equal)
  
  function antisym2_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym2_u8_spec: forall x: UInt8.t, y: UInt8.t. cmp_log_u8 x y = Greater -> cmp_log_u8 y x = Less
  
  function antisym1_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym1_u8_spec: forall x: UInt8.t, y: UInt8.t. cmp_log_u8 x y = Less -> cmp_log_u8 y x = Greater
  
  function trans_u8 (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  axiom trans_u8_spec: forall x: UInt8.t, y: UInt8.t, z: UInt8.t, o: t_Ordering. cmp_log_u8 x y = o
      -> cmp_log_u8 y z = o -> cmp_log_u8 x z = o
  
  function refl_u8 (x: UInt8.t) : ()
  
  axiom refl_u8_spec: forall x: UInt8.t. cmp_log_u8 x x = Equal
  
  function cmp_gt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_gt_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.gt x y = (cmp_log_u8 x y = Greater)
  
  function cmp_ge_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_ge_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.ge x y = (cmp_log_u8 x y <> Less)
  
  function cmp_lt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_lt_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.lt x y = (cmp_log_u8 x y = Less)
  
  function cmp_le_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_le_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.le x y = (cmp_log_u8 x y <> Greater)
  
  predicate well_founded_relation_u8 [@inline:trivial] (self: UInt8.t) (other: UInt8.t) = UInt8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u8
  
  function index_Mapping_Int_u8 [@inline:trivial] (self: Map.map int UInt8.t) (a: int) : UInt8.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt8.t. forall result: int. not well_founded_relation_u8 (index_Mapping_Int_u8 s result) (index_Mapping_Int_u8 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_u8 (index_Mapping_Int_u8 s result) (index_Mapping_Int_u8 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_u16__no_infinite_decreasing_sequence__refines (* <u16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom eq_cmp_u16_spec: forall x: UInt16.t, y: UInt16.t. (x = y) = (cmp_log_u16 x y = Equal)
  
  function antisym2_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym2_u16_spec: forall x: UInt16.t, y: UInt16.t. cmp_log_u16 x y = Greater -> cmp_log_u16 y x = Less
  
  function antisym1_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym1_u16_spec: forall x: UInt16.t, y: UInt16.t. cmp_log_u16 x y = Less -> cmp_log_u16 y x = Greater
  
  function trans_u16 (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  axiom trans_u16_spec: forall x: UInt16.t, y: UInt16.t, z: UInt16.t, o: t_Ordering. cmp_log_u16 x y = o
      -> cmp_log_u16 y z = o -> cmp_log_u16 x z = o
  
  function refl_u16 (x: UInt16.t) : ()
  
  axiom refl_u16_spec: forall x: UInt16.t. cmp_log_u16 x x = Equal
  
  function cmp_gt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_gt_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.gt x y = (cmp_log_u16 x y = Greater)
  
  function cmp_ge_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_ge_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.ge x y = (cmp_log_u16 x y <> Less)
  
  function cmp_lt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_lt_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.lt x y = (cmp_log_u16 x y = Less)
  
  function cmp_le_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_le_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.le x y = (cmp_log_u16 x y <> Greater)
  
  predicate well_founded_relation_u16 [@inline:trivial] (self: UInt16.t) (other: UInt16.t) = UInt16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u16
  
  function index_Mapping_Int_u16 [@inline:trivial] (self: Map.map int UInt16.t) (a: int) : UInt16.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt16.t. forall result: int. not well_founded_relation_u16 (index_Mapping_Int_u16 s result) (index_Mapping_Int_u16 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_u16 (index_Mapping_Int_u16 s result) (index_Mapping_Int_u16 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_u32__no_infinite_decreasing_sequence__refines (* <u32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom eq_cmp_u32_spec: forall x: UInt32.t, y: UInt32.t. (x = y) = (cmp_log_u32 x y = Equal)
  
  function antisym2_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym2_u32_spec: forall x: UInt32.t, y: UInt32.t. cmp_log_u32 x y = Greater -> cmp_log_u32 y x = Less
  
  function antisym1_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym1_u32_spec: forall x: UInt32.t, y: UInt32.t. cmp_log_u32 x y = Less -> cmp_log_u32 y x = Greater
  
  function trans_u32 (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  axiom trans_u32_spec: forall x: UInt32.t, y: UInt32.t, z: UInt32.t, o: t_Ordering. cmp_log_u32 x y = o
      -> cmp_log_u32 y z = o -> cmp_log_u32 x z = o
  
  function refl_u32 (x: UInt32.t) : ()
  
  axiom refl_u32_spec: forall x: UInt32.t. cmp_log_u32 x x = Equal
  
  function cmp_gt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_gt_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.gt x y = (cmp_log_u32 x y = Greater)
  
  function cmp_ge_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_ge_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.ge x y = (cmp_log_u32 x y <> Less)
  
  function cmp_lt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_lt_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.lt x y = (cmp_log_u32 x y = Less)
  
  function cmp_le_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_le_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.le x y = (cmp_log_u32 x y <> Greater)
  
  predicate well_founded_relation_u32 [@inline:trivial] (self: UInt32.t) (other: UInt32.t) = UInt32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u32
  
  function index_Mapping_Int_u32 [@inline:trivial] (self: Map.map int UInt32.t) (a: int) : UInt32.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt32.t. forall result: int. not well_founded_relation_u32 (index_Mapping_Int_u32 s result) (index_Mapping_Int_u32 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_u32 (index_Mapping_Int_u32 s result) (index_Mapping_Int_u32 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_u64__no_infinite_decreasing_sequence__refines (* <u64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate well_founded_relation_u64 [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u64
  
  function index_Mapping_Int_u64 [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt64.t. forall result: int. not well_founded_relation_u64 (index_Mapping_Int_u64 s result) (index_Mapping_Int_u64 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_u64 (index_Mapping_Int_u64 s result) (index_Mapping_Int_u64 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_u128__no_infinite_decreasing_sequence__refines (* <u128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom eq_cmp_u128_spec: forall x: UInt128.t, y: UInt128.t. (x = y) = (cmp_log_u128 x y = Equal)
  
  function antisym2_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym2_u128_spec: forall x: UInt128.t, y: UInt128.t. cmp_log_u128 x y = Greater -> cmp_log_u128 y x = Less
  
  function antisym1_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym1_u128_spec: forall x: UInt128.t, y: UInt128.t. cmp_log_u128 x y = Less -> cmp_log_u128 y x = Greater
  
  function trans_u128 (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  axiom trans_u128_spec: forall x: UInt128.t, y: UInt128.t, z: UInt128.t, o: t_Ordering. cmp_log_u128 x y = o
      -> cmp_log_u128 y z = o -> cmp_log_u128 x z = o
  
  function refl_u128 (x: UInt128.t) : ()
  
  axiom refl_u128_spec: forall x: UInt128.t. cmp_log_u128 x x = Equal
  
  function cmp_gt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_gt_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.gt x y = (cmp_log_u128 x y = Greater)
  
  function cmp_ge_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_ge_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.ge x y = (cmp_log_u128 x y <> Less)
  
  function cmp_lt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_lt_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.lt x y = (cmp_log_u128 x y = Less)
  
  function cmp_le_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_le_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.le x y = (cmp_log_u128 x y <> Greater)
  
  predicate well_founded_relation_u128 [@inline:trivial] (self: UInt128.t) (other: UInt128.t) = UInt128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u128
  
  function index_Mapping_Int_u128 [@inline:trivial] (self: Map.map int UInt128.t) (a: int) : UInt128.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt128.t. forall result: int. not well_founded_relation_u128 (index_Mapping_Int_u128 s result) (index_Mapping_Int_u128 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_u128 (index_Mapping_Int_u128 s result) (index_Mapping_Int_u128 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_usize__no_infinite_decreasing_sequence__refines (* <usize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  predicate well_founded_relation_usize [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_usize
  
  function index_Mapping_Int_usize [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int UInt64.t. forall result: int. not well_founded_relation_usize (index_Mapping_Int_usize s result) (index_Mapping_Int_usize s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_usize (index_Mapping_Int_usize s result) (index_Mapping_Int_usize s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_i8__no_infinite_decreasing_sequence__refines (* <i8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom eq_cmp_i8_spec: forall x: Int8.t, y: Int8.t. (x = y) = (cmp_log_i8 x y = Equal)
  
  function antisym2_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym2_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Greater -> cmp_log_i8 y x = Less
  
  function antisym1_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym1_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Less -> cmp_log_i8 y x = Greater
  
  function trans_i8 (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  axiom trans_i8_spec: forall x: Int8.t, y: Int8.t, z: Int8.t, o: t_Ordering. cmp_log_i8 x y = o
      -> cmp_log_i8 y z = o -> cmp_log_i8 x z = o
  
  function refl_i8 (x: Int8.t) : ()
  
  axiom refl_i8_spec: forall x: Int8.t. cmp_log_i8 x x = Equal
  
  function cmp_gt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_gt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.gt x y = (cmp_log_i8 x y = Greater)
  
  function cmp_ge_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_ge_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.ge x y = (cmp_log_i8 x y <> Less)
  
  function cmp_lt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_lt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.lt x y = (cmp_log_i8 x y = Less)
  
  function cmp_le_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_le_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.le x y = (cmp_log_i8 x y <> Greater)
  
  predicate well_founded_relation_i8 [@inline:trivial] (self: Int8.t) (other: Int8.t) = Int8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i8
  
  function index_Mapping_Int_i8 [@inline:trivial] (self: Map.map int Int8.t) (a: int) : Int8.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int8.t. forall result: int. not well_founded_relation_i8 (index_Mapping_Int_i8 s result) (index_Mapping_Int_i8 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_i8 (index_Mapping_Int_i8 s result) (index_Mapping_Int_i8 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_i16__no_infinite_decreasing_sequence__refines (* <i16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom eq_cmp_i16_spec: forall x: Int16.t, y: Int16.t. (x = y) = (cmp_log_i16 x y = Equal)
  
  function antisym2_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym2_i16_spec: forall x: Int16.t, y: Int16.t. cmp_log_i16 x y = Greater -> cmp_log_i16 y x = Less
  
  function antisym1_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym1_i16_spec: forall x: Int16.t, y: Int16.t. cmp_log_i16 x y = Less -> cmp_log_i16 y x = Greater
  
  function trans_i16 (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  axiom trans_i16_spec: forall x: Int16.t, y: Int16.t, z: Int16.t, o: t_Ordering. cmp_log_i16 x y = o
      -> cmp_log_i16 y z = o -> cmp_log_i16 x z = o
  
  function refl_i16 (x: Int16.t) : ()
  
  axiom refl_i16_spec: forall x: Int16.t. cmp_log_i16 x x = Equal
  
  function cmp_gt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_gt_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.gt x y = (cmp_log_i16 x y = Greater)
  
  function cmp_ge_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_ge_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.ge x y = (cmp_log_i16 x y <> Less)
  
  function cmp_lt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_lt_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.lt x y = (cmp_log_i16 x y = Less)
  
  function cmp_le_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_le_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.le x y = (cmp_log_i16 x y <> Greater)
  
  predicate well_founded_relation_i16 [@inline:trivial] (self: Int16.t) (other: Int16.t) = Int16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i16
  
  function index_Mapping_Int_i16 [@inline:trivial] (self: Map.map int Int16.t) (a: int) : Int16.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int16.t. forall result: int. not well_founded_relation_i16 (index_Mapping_Int_i16 s result) (index_Mapping_Int_i16 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_i16 (index_Mapping_Int_i16 s result) (index_Mapping_Int_i16 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_i32__no_infinite_decreasing_sequence__refines (* <i32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_i32_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log_i32 x y = Equal)
  
  function antisym2_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Greater -> cmp_log_i32 y x = Less
  
  function antisym1_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Less -> cmp_log_i32 y x = Greater
  
  function trans_i32 (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_i32_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log_i32 x y = o
      -> cmp_log_i32 y z = o -> cmp_log_i32 x z = o
  
  function refl_i32 (x: Int32.t) : ()
  
  axiom refl_i32_spec: forall x: Int32.t. cmp_log_i32 x x = Equal
  
  function cmp_gt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log_i32 x y = Greater)
  
  function cmp_ge_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log_i32 x y <> Less)
  
  function cmp_lt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log_i32 x y = Less)
  
  function cmp_le_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log_i32 x y <> Greater)
  
  predicate well_founded_relation_i32 [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i32
  
  function index_Mapping_Int_i32 [@inline:trivial] (self: Map.map int Int32.t) (a: int) : Int32.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int32.t. forall result: int. not well_founded_relation_i32 (index_Mapping_Int_i32 s result) (index_Mapping_Int_i32 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_i32 (index_Mapping_Int_i32 s result) (index_Mapping_Int_i32 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_i64__no_infinite_decreasing_sequence__refines (* <i64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_i64_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_i64 x y = Equal)
  
  function antisym2_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_i64_spec: forall x: Int64.t, y: Int64.t. cmp_log_i64 x y = Greater -> cmp_log_i64 y x = Less
  
  function antisym1_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_i64_spec: forall x: Int64.t, y: Int64.t. cmp_log_i64 x y = Less -> cmp_log_i64 y x = Greater
  
  function trans_i64 (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_i64_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_i64 x y = o
      -> cmp_log_i64 y z = o -> cmp_log_i64 x z = o
  
  function refl_i64 (x: Int64.t) : ()
  
  axiom refl_i64_spec: forall x: Int64.t. cmp_log_i64 x x = Equal
  
  function cmp_gt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_i64 x y = Greater)
  
  function cmp_ge_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_i64 x y <> Less)
  
  function cmp_lt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_i64 x y = Less)
  
  function cmp_le_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_i64 x y <> Greater)
  
  predicate well_founded_relation_i64 [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i64
  
  function index_Mapping_Int_i64 [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int64.t. forall result: int. not well_founded_relation_i64 (index_Mapping_Int_i64 s result) (index_Mapping_Int_i64 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_i64 (index_Mapping_Int_i64 s result) (index_Mapping_Int_i64 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_i128__no_infinite_decreasing_sequence__refines (* <i128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom eq_cmp_i128_spec: forall x: Int128.t, y: Int128.t. (x = y) = (cmp_log_i128 x y = Equal)
  
  function antisym2_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym2_i128_spec: forall x: Int128.t, y: Int128.t. cmp_log_i128 x y = Greater -> cmp_log_i128 y x = Less
  
  function antisym1_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym1_i128_spec: forall x: Int128.t, y: Int128.t. cmp_log_i128 x y = Less -> cmp_log_i128 y x = Greater
  
  function trans_i128 (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  axiom trans_i128_spec: forall x: Int128.t, y: Int128.t, z: Int128.t, o: t_Ordering. cmp_log_i128 x y = o
      -> cmp_log_i128 y z = o -> cmp_log_i128 x z = o
  
  function refl_i128 (x: Int128.t) : ()
  
  axiom refl_i128_spec: forall x: Int128.t. cmp_log_i128 x x = Equal
  
  function cmp_gt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_gt_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.gt x y = (cmp_log_i128 x y = Greater)
  
  function cmp_ge_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_ge_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.ge x y = (cmp_log_i128 x y <> Less)
  
  function cmp_lt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_lt_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.lt x y = (cmp_log_i128 x y = Less)
  
  function cmp_le_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_le_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.le x y = (cmp_log_i128 x y <> Greater)
  
  predicate well_founded_relation_i128 [@inline:trivial] (self: Int128.t) (other: Int128.t) = Int128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i128
  
  function index_Mapping_Int_i128 [@inline:trivial] (self: Map.map int Int128.t) (a: int) : Int128.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int128.t. forall result: int. not well_founded_relation_i128 (index_Mapping_Int_i128 s result) (index_Mapping_Int_i128 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_i128 (index_Mapping_Int_i128 s result) (index_Mapping_Int_i128 s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_isize__no_infinite_decreasing_sequence__refines (* <isize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use mach.int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate well_founded_relation_isize [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_isize
  
  function index_Mapping_Int_isize [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int Int64.t. forall result: int. not well_founded_relation_isize (index_Mapping_Int_isize s result) (index_Mapping_Int_isize s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_isize (index_Mapping_Int_isize s result) (index_Mapping_Int_isize s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_ref_T__no_infinite_decreasing_sequence__refines (* <&T as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation_T (self: t_T) (other: t_T)
  
  predicate well_founded_relation_ref_T [@inline:trivial] (self: t_T) (other: t_T) = well_founded_relation_T self other
  
  meta "rewrite_def" predicate well_founded_relation_ref_T
  
  function index_Mapping_Int_ref_T [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_ref_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int t_T. forall result: int. not well_founded_relation_ref_T (index_Mapping_Int_ref_T s result) (index_Mapping_Int_ref_T s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_ref_T (index_Mapping_Int_ref_T s result) (index_Mapping_Int_ref_T s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_Box_T_Global__no_infinite_decreasing_sequence__refines (* <std::boxed::Box<T> as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T
  
  predicate well_founded_relation_T (self: t_T) (other: t_T)
  
  predicate well_founded_relation_Box_T_Global [@inline:trivial] (self: t_T) (other: t_T) =
    well_founded_relation_T self other
  
  meta "rewrite_def" predicate well_founded_relation_Box_T_Global
  
  function index_Mapping_Int_Box_T_Global [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Box_T_Global
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int t_T. forall result: int. not well_founded_relation_Box_T_Global (index_Mapping_Int_Box_T_Global s result) (index_Mapping_Int_Box_T_Global s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_Box_T_Global (index_Mapping_Int_Box_T_Global s result) (index_Mapping_Int_Box_T_Global s (result
          + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_unit__no_infinite_decreasing_sequence__refines (* <() as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  predicate well_founded_relation_unit [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation_unit
  
  function index_Mapping_Int_unit [@inline:trivial] (self: Map.map int ()) (a: int) : () = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_unit
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int (). forall result: int. not well_founded_relation_unit (index_Mapping_Int_unit s result) (index_Mapping_Int_unit s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_unit (index_Mapping_Int_unit s result) (index_Mapping_Int_unit s (result + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_tup8_T0_T1_T2_T3_T4_T5_T6_T7__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5, T6, T7) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type t_T7
  
  type tup8_T0_T1_T2_T3_T4_T5_T6_T7 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6; f7: t_T7 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_T6 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation_T7 (self: t_T7) (other: t_T7)
  
  predicate well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: tup8_T0_T1_T2_T3_T4_T5_T6_T7) (other: tup8_T0_T1_T2_T3_T4_T5_T6_T7) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2
      /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation_T6 self.f6 other.f6
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3
    /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ self.f6 = other.f6 /\ well_founded_relation_T7 self.f7 other.f7
  
  meta "rewrite_def" predicate well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  function index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7) (a: int) : tup8_T0_T1_T2_T3_T4_T5_T6_T7
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7. forall result: int. not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s result) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s result) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (result
          + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_tup7_T0_T1_T2_T3_T4_T5_T6__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5, T6) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type tup7_T0_T1_T2_T3_T4_T5_T6 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_T6 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: tup7_T0_T1_T2_T3_T4_T5_T6) (other: tup7_T0_T1_T2_T3_T4_T5_T6) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation_T6 self.f6 other.f6
  
  meta "rewrite_def" predicate well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6
  
  function index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: Map.map int tup7_T0_T1_T2_T3_T4_T5_T6) (a: int) : tup7_T0_T1_T2_T3_T4_T5_T6
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tup7_T0_T1_T2_T3_T4_T5_T6. forall result: int. not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s result) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s result) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (result
          + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_tup6_T0_T1_T2_T3_T4_T5__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type tup6_T0_T1_T2_T3_T4_T5 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 [@inline:trivial] (self: tup6_T0_T1_T2_T3_T4_T5) (other: tup6_T0_T1_T2_T3_T4_T5) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
  
  meta "rewrite_def" predicate well_founded_relation_tup6_T0_T1_T2_T3_T4_T5
  
  function index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 [@inline:trivial] (self: Map.map int tup6_T0_T1_T2_T3_T4_T5) (a: int) : tup6_T0_T1_T2_T3_T4_T5
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tup6_T0_T1_T2_T3_T4_T5. forall result: int. not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s result) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s result) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (result
          + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_tup5_T0_T1_T2_T3_T4__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type tup5_T0_T1_T2_T3_T4 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_tup5_T0_T1_T2_T3_T4 [@inline:trivial] (self: tup5_T0_T1_T2_T3_T4) (other: tup5_T0_T1_T2_T3_T4) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
  
  meta "rewrite_def" predicate well_founded_relation_tup5_T0_T1_T2_T3_T4
  
  function index_Mapping_Int_tup5_T0_T1_T2_T3_T4 [@inline:trivial] (self: Map.map int tup5_T0_T1_T2_T3_T4) (a: int) : tup5_T0_T1_T2_T3_T4
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup5_T0_T1_T2_T3_T4
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tup5_T0_T1_T2_T3_T4. forall result: int. not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s result) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s result) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (result
          + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_tup4_T0_T1_T2_T3__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type tup4_T0_T1_T2_T3 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_tup4_T0_T1_T2_T3 [@inline:trivial] (self: tup4_T0_T1_T2_T3) (other: tup4_T0_T1_T2_T3) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
  
  meta "rewrite_def" predicate well_founded_relation_tup4_T0_T1_T2_T3
  
  function index_Mapping_Int_tup4_T0_T1_T2_T3 [@inline:trivial] (self: Map.map int tup4_T0_T1_T2_T3) (a: int) : tup4_T0_T1_T2_T3
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup4_T0_T1_T2_T3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tup4_T0_T1_T2_T3. forall result: int. not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s result) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s result) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (result
          + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_tup3_T0_T1_T2__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type tup3_T0_T1_T2 = { f0: t_T0; f1: t_T1; f2: t_T2 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup3_T0_T1_T2 [@inline:trivial] (self: tup3_T0_T1_T2) (other: tup3_T0_T1_T2) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
  
  meta "rewrite_def" predicate well_founded_relation_tup3_T0_T1_T2
  
  function index_Mapping_Int_tup3_T0_T1_T2 [@inline:trivial] (self: Map.map int tup3_T0_T1_T2) (a: int) : tup3_T0_T1_T2
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup3_T0_T1_T2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tup3_T0_T1_T2. forall result: int. not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s result) (index_Mapping_Int_tup3_T0_T1_T2 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s result) (index_Mapping_Int_tup3_T0_T1_T2 s (result
          + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_tup2_T0_T1__no_infinite_decreasing_sequence__refines (* <(T0, T1) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  type t_T1
  
  type tup2_T0_T1 = { f0: t_T0; f1: t_T1 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_tup2_T0_T1 [@inline:trivial] (self: tup2_T0_T1) (other: tup2_T0_T1) =
    well_founded_relation_T0 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_T1
  
  function index_Mapping_Int_tup2_T0_T1 [@inline:trivial] (self: Map.map int tup2_T0_T1) (a: int) : tup2_T0_T1 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_T1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int tup2_T0_T1. forall result: int. not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s result) (index_Mapping_Int_tup2_T0_T1 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s result) (index_Mapping_Int_tup2_T0_T1 s (result
          + 1))
        /\ result >= 0
end
module M_logic__well_founded__impl_WellFounded_for_tup1_T0__no_infinite_decreasing_sequence__refines (* <(T0,) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use mach.int.Int
  
  type t_T0
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_tup1_T0 [@inline:trivial] (self: t_T0) (other: t_T0) =
    well_founded_relation_T0 self other
  
  meta "rewrite_def" predicate well_founded_relation_tup1_T0
  
  function index_Mapping_Int_tup1_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup1_T0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall s: Map.map int t_T0. forall result: int. not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s result) (index_Mapping_Int_tup1_T0 s (result
            + 1))
          /\ result >= 0
        -> not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s result) (index_Mapping_Int_tup1_T0 s (result
          + 1))
        /\ result >= 0
end
module M_peano__impl_Ord_for_PeanoInt__cmp__refines (* <peano::PeanoInt as std::cmp::Ord> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: t_Ordering. result
            = cmp_log_PeanoInt self_ rhs -> result = cmp_log_u64 (deep_model_PeanoInt self_) (deep_model_PeanoInt rhs)
end
module M_std__iter__fuse__impl_FusedIterator_for_Fuse_I__is_fused__refines (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  function produces_trans_Fuse_I (a: t_Fuse_I) (ab: Seq.seq t_Item) (b: t_Fuse_I) (bc: Seq.seq t_Item) (c: t_Fuse_I) : ()
   = ()
  
  axiom produces_trans_Fuse_I_spec:
    forall a: t_Fuse_I, ab: Seq.seq t_Item, b: t_Fuse_I, bc: Seq.seq t_Item, c: t_Fuse_I. produces_Fuse_I a ab b
      -> produces_Fuse_I b bc c -> produces_Fuse_I a (Seq.(++) ab bc) c
  
  function produces_refl_Fuse_I (self: t_Fuse_I) : () = ()
  
  axiom produces_refl_Fuse_I_spec: forall self: t_Fuse_I. produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate completed_Fuse_I (self: MutBorrow.t t_Fuse_I) =
    (view_Fuse_I self.current = None
      \/ (exists it: MutBorrow.t t_I. completed_I it /\ view_Fuse_I self.current = Some (it.current)))
    /\ view_Fuse_I self.final = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: MutBorrow.t t_Fuse_I. forall steps: Seq.seq t_Item. forall next: t_Fuse_I. produces_Fuse_I self.final steps next
            /\ completed_Fuse_I self
          -> produces_Fuse_I self.final steps next
          /\ completed_Fuse_I self
          /\ (forall result: (). steps = (Seq.empty: Seq.seq t_Item) -> steps = (Seq.empty: Seq.seq t_Item))
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_Range_Idx__produces_back_refl__refines (* <std::ops::Range<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_back_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.start = o.start
    /\ deep_model_Idx self.end' >= deep_model_Idx o.end'
    /\ (Seq.length visited > 0 -> deep_model_Idx o.end' >= deep_model_Idx o.start)
    /\ Seq.length visited = deep_model_Idx o.end' - deep_model_Idx self.end'
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.end' - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Range_Idx. forall result: (). produces_back_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
        -> produces_back_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_Range_Idx__produces_back_trans__refines (* <std::ops::Range<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_back_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.start = o.start
    /\ deep_model_Idx self.end' >= deep_model_Idx o.end'
    /\ (Seq.length visited > 0 -> deep_model_Idx o.end' >= deep_model_Idx o.start)
    /\ Seq.length visited = deep_model_Idx o.end' - deep_model_Idx self.end'
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.end' - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Range_Idx. forall ab: Seq.seq t_Idx. forall b: t_Range_Idx. forall bc: Seq.seq t_Idx. forall c: t_Range_Idx. produces_back_Range_Idx b bc c
                /\ produces_back_Range_Idx a ab b
              -> produces_back_Range_Idx b bc c
              /\ produces_back_Range_Idx a ab b
              /\ (forall result: (). produces_back_Range_Idx a (Seq.(++) ab bc) c
                -> produces_back_Range_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_RangeInclusive_Idx__produces_back_refl__refines (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_back_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ start_log_RangeInclusive_Idx self = start_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (end_log_RangeInclusive_Idx self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_RangeInclusive_Idx. forall result: (). produces_back_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
        -> produces_back_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_RangeInclusive_Idx__produces_back_trans__refines (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use mach.int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_back_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ start_log_RangeInclusive_Idx self = start_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (end_log_RangeInclusive_Idx self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_RangeInclusive_Idx. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive_Idx. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive_Idx. produces_back_RangeInclusive_Idx b bc c
                /\ produces_back_RangeInclusive_Idx a ab b
              -> produces_back_RangeInclusive_Idx b bc c
              /\ produces_back_RangeInclusive_Idx a ab b
              /\ (forall result: (). produces_back_RangeInclusive_Idx a (Seq.(++) ab bc) c
                -> produces_back_RangeInclusive_Idx a (Seq.(++) ab bc) c)
end
module M_std__ops__impl_FnMutExt_for_F__hist_inv_trans__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall b: t_F. forall c: t_F. hist_inv_F b c /\ hist_inv_F self b
          -> hist_inv_F b c /\ hist_inv_F self b /\ (forall result: (). hist_inv_F self c -> hist_inv_F self c)
end
module M_std__ops__impl_FnMutExt_for_F__fn_mut_once__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once_F (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate resolve_F (_1: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once_F self args res
              = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
            -> postcondition_once_F self args res
            = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
end
module M_std__ops__impl_FnMutExt_for_F__postcondition_mut_hist_inv__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut_F (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. postcondition_mut_F self args res_state res
            -> postcondition_mut_F self args res_state res
            /\ (forall result: (). hist_inv_F self res_state -> hist_inv_F self res_state)
end
module M_std__ops__impl_FnMutExt_for_F__hist_inv_refl__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall result: (). hist_inv_F self self -> hist_inv_F self self
end
module M_std__ops__impl_FnExt_for_F__fn_mut__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut_F (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate postcondition_F (self: t_F) (args: t_Args) (result: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. forall result: (). postcondition_mut_F self args res_state res
                = (postcondition_F self args res /\ self = res_state)
              -> postcondition_mut_F self args res_state res = (postcondition_F self args res /\ self = res_state)
end
module M_std__ops__impl_FnExt_for_F__fn_once__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once_F (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate postcondition_F (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate resolve_F (_1: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once_F self args res
              = (postcondition_F self args res /\ resolve_F self)
            -> postcondition_once_F self args res = (postcondition_F self args res /\ resolve_F self)
end
module M_std__ops__impl_FnExt_for_F__fn_hist_inv__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall res_state: t_F. forall result: (). hist_inv_F self res_state
            = (self = res_state) -> hist_inv_F self res_state = (self = res_state)
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__sub_offset_logic__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  
  function sub_ptr_T (self: Opaque.ptr) (rhs: Opaque.ptr) : int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_ptr_T (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_ptr_T_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_ptr_T self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Opaque.ptr. forall offset: int. forall result: (). sub_ptr_T (offset_ptr_T self offset) self = offset
          -> sub_ptr_T (offset_ptr_T self offset) self = offset
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__offset_logic_zero__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_ptr_T (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_ptr_T_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_ptr_T self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall result: (). offset_ptr_T self 0 = self -> offset_ptr_T self 0 = self
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__offset_logic__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.prelude.Opaque
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall offset: int. UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
          < UInt64.t'int const_MAX
        -> UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T < UInt64.t'int const_MAX
        /\ (forall result: Opaque.ptr. UInt64.t'int (Ptr.addr_logic_u64 result)
            = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
          -> UInt64.t'int (Ptr.addr_logic_u64 result) = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T)
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__offset_logic_assoc__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_ptr_T (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_ptr_T_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_ptr_T self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Opaque.ptr. forall offset1: int. forall offset2: int. forall result: (). offset_ptr_T (offset_ptr_T self offset1) offset2
              = offset_ptr_T self (offset1 + offset2)
            -> offset_ptr_T (offset_ptr_T self offset1) offset2 = offset_ptr_T self (offset1 + offset2)
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__sub_logic_refl__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  
  function sub_ptr_T (self: Opaque.ptr) (rhs: Opaque.ptr) : int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall result: (). sub_ptr_T self self = 0 -> sub_ptr_T self self = 0
end
module M_std__ptr__impl_SlicePointerExt_for_ptr_slice_T__slice_ptr_ext__refines (* <*const [T] as std::ptr::SlicePointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function thin_ptr_slice_T [@inline:trivial] (self: Opaque.ptr) : Opaque.ptr = Opaque.thin self
  
  meta "rewrite_def" function thin_ptr_slice_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  function len_ptr_slice_T [@inline:trivial] (self: Opaque.ptr) : UInt64.t = metadata_slice_T self
  
  meta "rewrite_def" function len_ptr_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall other: Opaque.ptr. forall result: (). thin_ptr_slice_T self
                = thin_ptr_slice_T other
              /\ len_ptr_slice_T self = len_ptr_slice_T other -> self = other
          -> thin_ptr_slice_T self = thin_ptr_slice_T other /\ len_ptr_slice_T self = len_ptr_slice_T other
          -> self = other
end
module M_std__slice__impl_SliceExt_for_slice_T__as_mut_ptr_own__refines (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv_slice_T self.current /\ inv_slice_T self.final
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  type t_PtrOwn_slice_T
  
  function val_slice_T (self: t_PtrOwn_slice_T) : Slice64.slice t_T
  
  function fin_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_slice_T) : t_PtrOwn_slice_T =
    self.final
  
  meta "rewrite_def" function fin_Ghost_ref_PtrOwn_slice_T
  
  type tup2_ptr_T_Ghost_ref_PtrOwn_slice_T = { f0: Opaque.ptr; f1: MutBorrow.t t_PtrOwn_slice_T }
  
  function ptr_slice_T (self: t_PtrOwn_slice_T) : Opaque.ptr
  
  predicate is_null_ptr_slice_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_slice_T (self: t_PtrOwn_slice_T)
  
  predicate metadata_matches_slice_T [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches_slice_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_slice_T [@inline:trivial] (val': Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val')
  
  meta "rewrite_def" function size_of_val_slice_T
  
  axiom size_of_val_slice_T_spec: forall val': Slice64.slice t_T. 0 <= size_of_val_slice_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_ref_slice_T'0 [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T'0
  
  predicate inv_ref_slice_T'0 [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_slice_T'0
  
  predicate invariant_PtrOwn_slice_T (self: t_PtrOwn_slice_T) =
    not is_null_ptr_slice_T (ptr_slice_T self)
    /\ ptr_is_aligned_opaque_slice_T self
    /\ metadata_matches_slice_T (val_slice_T self) (metadata_slice_T (ptr_slice_T self))
    /\ size_of_val_slice_T (val_slice_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_slice_T self)) + size_of_val_slice_T (val_slice_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_slice_T'0 (val_slice_T self)
  
  predicate inv_PtrOwn_slice_T (_1: t_PtrOwn_slice_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_slice_T [inv_PtrOwn_slice_T x]. inv_PtrOwn_slice_T x
      = invariant_PtrOwn_slice_T x
  
  predicate invariant_ref_PtrOwn_slice_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_slice_T) =
    inv_PtrOwn_slice_T self.current /\ inv_PtrOwn_slice_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_slice_T
  
  predicate inv_ref_PtrOwn_slice_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_slice_T) =
    invariant_ref_PtrOwn_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_slice_T
  
  predicate invariant_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_slice_T) =
    inv_ref_PtrOwn_slice_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_slice_T
  
  predicate inv_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_slice_T) =
    invariant_Ghost_ref_PtrOwn_slice_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_slice_T
  
  predicate inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T) =
    inv_Ghost_ref_PtrOwn_slice_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t (Slice64.slice t_T). inv_ref_slice_T self
      -> inv_ref_slice_T self
      /\ (forall result: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T. self.final
            = val_slice_T (fin_Ghost_ref_PtrOwn_slice_T result.f1)
          /\ self.current = val_slice_T result.f1.current
          /\ result.f0 = Opaque.thin (ptr_slice_T result.f1.current) /\ inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T result
        -> inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T result)
end
module M_std__slice__impl_SliceExt_for_slice_T__as_ptr_own__refines (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_T_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  type t_PtrOwn_slice_T
  
  function val_slice_T (self: t_PtrOwn_slice_T) : Slice64.slice t_T
  
  type tup2_ptr_T_Ghost_ref_PtrOwn_slice_T = { f0: Opaque.ptr; f1: t_PtrOwn_slice_T }
  
  function ptr_slice_T (self: t_PtrOwn_slice_T) : Opaque.ptr
  
  predicate is_null_ptr_slice_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_slice_T (self: t_PtrOwn_slice_T)
  
  predicate metadata_matches_slice_T [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches_slice_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_slice_T [@inline:trivial] (val': Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val')
  
  meta "rewrite_def" function size_of_val_slice_T
  
  axiom size_of_val_slice_T_spec: forall val': Slice64.slice t_T. 0 <= size_of_val_slice_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_PtrOwn_slice_T (self: t_PtrOwn_slice_T) =
    not is_null_ptr_slice_T (ptr_slice_T self)
    /\ ptr_is_aligned_opaque_slice_T self
    /\ metadata_matches_slice_T (val_slice_T self) (metadata_slice_T (ptr_slice_T self))
    /\ size_of_val_slice_T (val_slice_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_slice_T self)) + size_of_val_slice_T (val_slice_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_slice_T (val_slice_T self)
  
  predicate inv_PtrOwn_slice_T (_1: t_PtrOwn_slice_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_slice_T [inv_PtrOwn_slice_T x]. inv_PtrOwn_slice_T x
      = invariant_PtrOwn_slice_T x
  
  predicate invariant_ref_PtrOwn_slice_T [@inline:trivial] (self: t_PtrOwn_slice_T) = inv_PtrOwn_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_slice_T
  
  predicate inv_ref_PtrOwn_slice_T [@inline:trivial] (_1: t_PtrOwn_slice_T) = invariant_ref_PtrOwn_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_slice_T
  
  predicate invariant_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (self: t_PtrOwn_slice_T) = inv_ref_PtrOwn_slice_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_slice_T
  
  predicate inv_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: t_PtrOwn_slice_T) =
    invariant_Ghost_ref_PtrOwn_slice_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_slice_T
  
  predicate inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T) =
    inv_Ghost_ref_PtrOwn_slice_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.slice t_T. inv_ref_slice_T self
      -> inv_ref_slice_T self
      /\ (forall result: tup2_ptr_T_Ghost_ref_PtrOwn_slice_T. self = val_slice_T result.f1
          /\ result.f0 = Opaque.thin (ptr_slice_T result.f1) /\ inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T result
        -> inv_tup2_ptr_T_Ghost_ref_PtrOwn_slice_T result)
end
