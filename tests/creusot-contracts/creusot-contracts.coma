module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 70 14 70 47
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 71 27 71 29
  let%span sarray'1 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#sarray'1] view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (self'0: t_IntoIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sarray] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 75 15 75 32
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 76 15 76 32
  let%span sarray'1 = "../../creusot-contracts/src/std/array.rs" 77 14 77 42
  let%span sarray'2 = "../../creusot-contracts/src/std/array.rs" 78 91 78 93
  let%span sarray'3 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#sarray'3] view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (a'0: t_IntoIter) (ab'0: Seq.seq t_T) (b'0: t_IntoIter) (bc'0: Seq.seq t_T) (c'0: t_IntoIter) : ()
  
  
  goal vc_produces_trans: ([%#sarray] produces a ab b)
   -> ([%#sarray'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#sarray'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__clone__extern_spec_Clone_bool_clone_body [#"../../creusot-contracts/src/std/clone.rs" 19 8 19 31]
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 18 18 18 33
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_bool_clone_body[#"../../creusot-contracts/src/std/clone.rs" 19 8 19 31] (self_:bool) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: bool = Any.any_l () | & self_'0: bool = self_ ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_Clone_bool_clone_body ensures] [%#sclone] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__clone__extern_spec_Clone_f32_clone_body [#"../../creusot-contracts/src/std/clone.rs" 26 8 26 30]
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 25 18 25 33
  
  use creusot.float.Float32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_f32_clone_body[#"../../creusot-contracts/src/std/clone.rs" 26 8 26 30] (self_:Float32.t) (return'  (x:Float32.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Float32.t = Any.any_l () | & self_'0: Float32.t = self_ ] 
    [ return''0 (result:Float32.t)-> {[@expl:extern_spec_Clone_f32_clone_body ensures] [%#sclone] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__clone__extern_spec_Clone_f64_clone_body [#"../../creusot-contracts/src/std/clone.rs" 33 8 33 30]
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 32 18 32 33
  
  use creusot.float.Float64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_f64_clone_body[#"../../creusot-contracts/src/std/clone.rs" 33 8 33 30] (self_:Float64.t) (return'  (x:Float64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Float64.t = Any.any_l () | & self_'0: Float64.t = self_ ] 
    [ return''0 (result:Float64.t)-> {[@expl:extern_spec_Clone_f64_clone_body ensures] [%#sclone] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__clone__extern_spec_T_Cloneqy95z_ref_T_clone_body [#"../../creusot-contracts/src/std/clone.rs" 40 8 40 32]
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 39 8 39 9
  let%span sclone'0 = "../../creusot-contracts/src/std/clone.rs" 40 27 40 32
  let%span sclone'1 = "../../creusot-contracts/src/std/clone.rs" 39 18 39 33
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Cloneqy95z_ref_T_clone_body[#"../../creusot-contracts/src/std/clone.rs" 40 8 40 32] (self_:t_T) (return'  (x:t_T))= {[@expl:extern_spec_T_Clone__ref_T_clone_body 'self_' type invariant] [%#sclone] inv'1 self_}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ] )
    [ & _0: t_T = Any.any_l () | & self_'0: t_T = self_ ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_T_Clone__ref_T_clone_body result type invariant] [%#sclone'0] inv'0 result}
      {[@expl:extern_spec_T_Clone__ref_T_clone_body ensures] [%#sclone'1] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 97 14 97 47
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 98 27 98 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self: t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_IntoIter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (self'0: t_IntoIter'0) : ()
  
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#shash_map] produces self (Seq.empty: Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 102 15 102 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 103 15 103 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 104 14 104 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 106 24 106 97
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 106 8 106 99
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self: t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq tuple'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq tuple'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (a'0: t_IntoIter'0) (ab'0: Seq.seq tuple'0) (b'0: t_IntoIter'0) (bc'0: Seq.seq tuple'0) (c'0: t_IntoIter'0) : ()
  
  
  goal vc_produces_trans: ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i: int. 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [@expl:produces_trans ensures] [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 149 14 149 47
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 150 27 150 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self: t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Iter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (self'0: t_Iter'0) : ()
  
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#shash_map] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 154 15 154 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 155 15 155 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 156 14 156 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 158 24 158 97
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 158 8 158 99
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self: t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Iter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (a'0: t_Iter'0) (ab'0: Seq.seq tuple) (b'0: t_Iter'0) (bc'0: Seq.seq tuple) (c'0: t_Iter'0) : ()
  
  
  goal vc_produces_trans: ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i: int. 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [@expl:produces_trans ensures] [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 201 14 201 47
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 202 27 202 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self: t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_IterMut'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (self'0: t_IterMut'0) : ()
  
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#shash_map] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 206 15 206 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 207 15 207 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 208 14 208 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 210 24 210 97
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 210 8 210 99
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self: t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_IterMut'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (a'0: t_IterMut'0) (ab'0: Seq.seq tuple) (b'0: t_IterMut'0) (bc'0: Seq.seq tuple) (c'0: t_IterMut'0) : ()
  
  
  goal vc_produces_trans: ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i: int. 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [@expl:produces_trans ensures] [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 379 14 380 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 381 29 381 31
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 79 8 79 82
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 101 20 101 103
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 102 20 102 93
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_I
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/model.rs" 15 4 15 34] (self: t_I) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_I) (visited: Seq.seq t_T) (end': t_I)
  
   =
    [%#shash_set'5] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function get [#"../../creusot-contracts/src/logic/seq.rs" 78 4 78 42] (self: Seq.seq t_T) (ix: int) : t_Option =
    [%#sseq'2] if 0 <= ix /\ ix < Seq.length self then C_Some (Seq.get self ix) else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_I
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_I
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_I
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a'0: t_I) (ab'0: Seq.seq t_T) (b'0: t_I) (bc'0: Seq.seq t_T) (c'0: t_I) : ()
  
  
  goal vc_set_produces_trans: ([%#shash_set] set_produces a ab b)
   -> ([%#shash_set'0] set_produces b bc c)
   -> ([%#sseq] forall a'0: Seq.seq t_T, b'0: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a'0 b'0) x = contains'0 a'0 x
  \/ contains'0 b'0 x)
   -> (let _ = concat_contains in ([%#shash_set'2] forall i: int, x: t_T. Seq.length ab <= i
  /\ get (Seq.(++) ab bc) i = C_Some x  -> contains'0 bc x)
  && (let _ = () in let _ = () in ([%#shash_set'3] forall i: int. 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in let _ = () in [@expl:set_produces_trans ensures] [%#shash_set'1] set_produces a (Seq.(++) ab bc) c)))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 120 14 120 47
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 121 27 121 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_IntoIter'1
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (self'0: t_IntoIter'1) : ()
  
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#shash_set] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 379 14 380 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 381 29 381 31
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 125 15 125 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 126 15 126 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 127 14 127 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 129 8 129 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a: t_IntoIter'1) (ab: Seq.seq t_T) (b: t_IntoIter'1) (bc: Seq.seq t_T) (c: t_IntoIter'1) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_IntoIter'1, ab: Seq.seq t_T, b: t_IntoIter'1, bc: Seq.seq t_T, c: t_IntoIter'1. ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_IntoIter'1
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter'1
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter'1
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (a'0: t_IntoIter'1) (ab'0: Seq.seq t_T) (b'0: t_IntoIter'1) (bc'0: Seq.seq t_T) (c'0: t_IntoIter'1) : ()
  
  
  goal vc_produces_trans: ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [@expl:produces_trans ensures] [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 159 14 159 47
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 160 27 160 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Iter'1
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (self'0: t_Iter'1) : ()
  
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#shash_set] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 379 14 380 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 381 29 381 31
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 164 15 164 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 165 15 165 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 166 14 166 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 168 8 168 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a: t_Iter'1) (ab: Seq.seq t_T) (b: t_Iter'1) (bc: Seq.seq t_T) (c: t_Iter'1) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Iter'1, ab: Seq.seq t_T, b: t_Iter'1, bc: Seq.seq t_T, c: t_Iter'1. ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Iter'1
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter'1
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter'1
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (a'0: t_Iter'1) (ab'0: Seq.seq t_T) (b'0: t_Iter'1) (bc'0: Seq.seq t_T) (c'0: t_Iter'1) : ()
  
  
  goal vc_produces_trans: ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [@expl:produces_trans ensures] [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 217 14 217 47
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 218 27 218 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Intersection
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (self'0: t_Intersection) : ()
  
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#shash_set] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 379 14 380 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 381 29 381 31
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 222 15 222 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 223 15 223 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 224 14 224 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 226 8 226 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Intersection
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Intersection
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Intersection
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (a'0: t_Intersection) (ab'0: Seq.seq t_T) (b'0: t_Intersection) (bc'0: Seq.seq t_T) (c'0: t_Intersection) : ()
  
  
  goal vc_produces_trans: ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [@expl:produces_trans ensures] [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 245 14 245 47
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 246 27 246 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self: t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Difference
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (self'0: t_Difference) : ()
  
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#shash_set] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 379 14 380 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 381 29 381 31
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 250 15 250 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 251 15 251 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 252 14 252 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 254 8 254 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self: t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Difference
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Difference
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Difference
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (a'0: t_Difference) (ab'0: Seq.seq t_T) (b'0: t_Difference) (bc'0: Seq.seq t_T) (c'0: t_Difference) : ()
  
  
  goal vc_produces_trans: ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [@expl:produces_trans ensures] [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialEq_Rhs_ne_body [#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 17 16 17 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 18 29 18 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 17 26 17 75
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 11 16 11 17
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 12 29 12 32
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom [@rewrite]: forall x: t_Self_ [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Rhs [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Rhs [inv'4 x]. inv'4 x = invariant''2 x
  
  type t_DeepModelTy
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'2 self
  
  function deep_model'4 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'3 self
  
  let rec eq (self_:t_Self_) (rhs:t_Rhs) (return'  (x:bool))= {[@expl:eq 'self_' type invariant] [%#scmp'2] inv'1 self_}
    {[@expl:eq 'rhs' type invariant] [%#scmp'3] inv'4 rhs}
    any
    [ return''0 (result:bool)-> {[%#scmp'4] result = (deep_model'1 self_ = deep_model'4 rhs)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialEq_Rhs_ne_body[#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18] (self_:t_Self_) (rhs:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'self_' type invariant] [%#scmp] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'rhs' type invariant] [%#scmp'0] inv'3 rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq {self_'0} {rhs'0} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- not _4 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: bool = Any.any_l () | & self_'0: t_Self_ = self_ | & rhs'0: t_Rhs = rhs | & _4: bool = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <> deep_model'3 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 39 29 39 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 38 48 38 52
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 35 16 35 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 36 29 36 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 1320 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rhs [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: t_Option)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & other'0: t_Rhs = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body ensures] [%#scmp'3] result
      = lt_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_le_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 47 29 47 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 46 66 46 70
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 43 16 43 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 44 29 44 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 43 26 43 77
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 1320 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rhs [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: t_Option)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_le_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & other'0: t_Rhs = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body ensures] [%#scmp'3] result
      = le_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 55 29 55 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 54 51 54 55
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 51 16 51 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 52 29 52 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 51 26 51 76
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 1320 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rhs [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: t_Option)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & other'0: t_Rhs = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body ensures] [%#scmp'3] result
      = gt_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 63 29 63 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 62 69 62 73
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 59 16 59 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 60 29 60 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 59 26 59 77
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 1320 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rhs [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: t_Option)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & other'0: t_Rhs = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body ensures] [%#scmp'3] result
      = ge_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_max_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 75 16 75 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 80 29 80 30
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 80 41 80 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 75 26 75 66
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 76 26 76 63
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 77 26 77 55
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 78 26 78 77
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 79 26 79 79
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 1353 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom [@rewrite]: forall x: t_Self_ [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: bool)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = le_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec le (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:le requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_max_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18] (self_:t_Self_) (o:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_max_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_max_body 'o' type invariant] [%#scmp'0] inv o}
    (! bb0
    [ bb0 = s0 [ s0 = le {self_'0} {o'0} (fun (_ret:bool) ->  [ &_8 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_8 = false} (! bb3) | br1 -> {_8} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- o'0 ] s3
      | s3 = bb6 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv o'0} s1 | s1 = -{resolve o'0}- s2 | s2 =  [ &_0 <- self_'0 ] s3 | s3 = bb6 ]
    
    | bb6 = return''0 {_0} ]
    ) [ & _0: t_Self_ = Any.any_l () | & self_'0: t_Self_ = self_ | & o'0: t_Self_ = o | & _8: bool = Any.any_l () ] 
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_max_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #0] [%#scmp'2] ge_log (deep_model result) (deep_model self_)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #1] [%#scmp'3] ge_log (deep_model result) (deep_model o)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #2] [%#scmp'4] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #3] [%#scmp'5] le_log (deep_model self_) (deep_model o)
       -> result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #4] [%#scmp'6] lt_log (deep_model o) (deep_model self_)
       -> result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_min_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 84 16 84 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 89 29 89 30
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 89 41 89 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 84 26 84 66
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 85 26 85 63
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 86 26 86 55
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 87 26 87 79
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 88 26 88 77
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 1335 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom [@rewrite]: forall x: t_Self_ [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: bool)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = lt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec lt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:lt requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_min_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18] (self_:t_Self_) (o:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_min_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_min_body 'o' type invariant] [%#scmp'0] inv o}
    (! bb0
    [ bb0 = s0 [ s0 = lt {self_'0} {o'0} (fun (_ret:bool) ->  [ &_8 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_8 = false} (! bb3) | br1 -> {_8} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv o'0} s1 | s1 = -{resolve o'0}- s2 | s2 =  [ &_0 <- self_'0 ] s3 | s3 = bb6 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- o'0 ] s3
      | s3 = bb6 ]
    
    | bb6 = return''0 {_0} ]
    ) [ & _0: t_Self_ = Any.any_l () | & self_'0: t_Self_ = self_ | & o'0: t_Self_ = o | & _8: bool = Any.any_l () ] 
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_min_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #0] [%#scmp'2] le_log (deep_model result) (deep_model self_)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #1] [%#scmp'3] le_log (deep_model result) (deep_model o)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #2] [%#scmp'4] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #3] [%#scmp'5] lt_log (deep_model self_) (deep_model o)
       -> result = self_}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #4] [%#scmp'6] le_log (deep_model o) (deep_model self_)
       -> result = o}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_clamp_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 93 16 93 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 102 31 102 34
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 102 42 102 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 93 27 93 63
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 102 56 102 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 94 26 94 65
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 95 26 95 65
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 96 26 96 74
  let%span scmp'7 = "../../creusot-contracts/src/std/cmp.rs" 97 26 101 41
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 1371 4
  let%span slib'0 = "../../creusot-contracts/src/lib.rs" 1 0 1335 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom [@rewrite]: forall x: t_Self_ [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: bool)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = gt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec gt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:gt requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Self_)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef'0: [%#slib'0] forall args: tuple [precondition'0 () args]. (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition'0 () args
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: bool)
  
  
  axiom postcondition_fndef'0: [%#slib'0] forall args: tuple, res: bool [postcondition_once'0 () args res]. postcondition_once'0 () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = lt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec lt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:lt requires] precondition'0 () { _p0 = self_;
                                                                                                           _p1 = other }}
    any
    [ return''0 (result:bool)-> {postcondition_once'0 () { _p0 = self_; _p1 = other } result} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_Ord_clamp_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18] (self_:t_Self_) (min:t_Self_) (max:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_clamp_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'min' type invariant] [%#scmp'0] inv min}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'max' type invariant] [%#scmp'1] inv max}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body requires] [%#scmp'2] le_log (deep_model min) (deep_model max)}
    (! bb0
    [ bb0 = s0 [ s0 = gt {self_'0} {max'0} (fun (_ret:bool) ->  [ &_9 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_9 = false} (! bb3) | br1 -> {_9} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv min'0} s1
      | s1 = -{resolve min'0}- s2
      | s2 = {[@expl:type invariant] inv self_'0} s3
      | s3 = -{resolve self_'0}- s4
      | s4 =  [ &_0 <- max'0 ] s5
      | s5 = bb11 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv max'0} s1
      | s1 = -{resolve max'0}- s2
      | s2 = lt {self_'0} {min'0} (fun (_ret:bool) ->  [ &_12 <- _ret ] s3)
      | s3 = bb4 ]
    
    | bb4 = any [ br0 -> {_12 = false} (! bb6) | br1 -> {_12} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- min'0 ] s3
      | s3 = bb11 ]
    
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv min'0} s1
      | s1 = -{resolve min'0}- s2
      | s2 =  [ &_0 <- self_'0 ] s3
      | s3 = bb11 ]
    
    | bb11 = return''0 {_0} ]
    )
    [ & _0: t_Self_ = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & min'0: t_Self_ = min
    | & max'0: t_Self_ = max
    | & _9: bool = Any.any_l ()
    | & _12: bool = Any.any_l () ]
    
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_clamp_body result type invariant] [%#scmp'3] inv result}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #0] [%#scmp'4] ge_log (deep_model result) (deep_model min)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #1] [%#scmp'5] le_log (deep_model result) (deep_model max)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #2] [%#scmp'6] result = self_ \/ result = min \/ result = max}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #3] [%#scmp'7] if gt_log (deep_model self_) (deep_model max) then
        result = max
      else
        if lt_log (deep_model self_) (deep_model min) then result = min else result = self_
      }
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_max_body [#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66]
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 112 22 112 24
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 112 29 112 31
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 112 39 112 40
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 107 22 107 60
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 108 22 108 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 109 22 109 50
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 110 22 110 73
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 111 22 111 72
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 980 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_T
  
  type tuple  =
    { _p0: t_T; _p1: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = o} = args in inv o
  /\ inv self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = o} = args in (lt_log (deep_model o) (deep_model self_)  -> res = self_)
  /\ (le_log (deep_model self_) (deep_model o)  -> res = o)
  /\ (res = self_ \/ res = o)
  /\ ge_log (deep_model res) (deep_model o) /\ ge_log (deep_model res) (deep_model self_) /\ inv res)
  
  let rec max (self_:t_T) (o:t_T) (return'  (x:t_T))= {[@expl:max requires] precondition () { _p0 = self_; _p1 = o }}
    any [ return''0 (result:t_T)-> {postcondition_once () { _p0 = self_; _p1 = o } result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_max_body[#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66] (v1:t_T) (v2:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_cmp_max_body 'v1' type invariant] [%#scmp] inv v1}
    {[@expl:extern_spec_std_cmp_max_body 'v2' type invariant] [%#scmp'0] inv v2}
    (! bb0
    [ bb0 = s0 [ s0 = max {v1'0} {v2'0} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ]  | bb3 = return''0 {_0} ]
    ) [ & _0: t_T = Any.any_l () | & v1'0: t_T = v1 | & v2'0: t_T = v2 ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_cmp_max_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_max_body ensures #0] [%#scmp'2] ge_log (deep_model result) (deep_model v1)}
      {[@expl:extern_spec_std_cmp_max_body ensures #1] [%#scmp'3] ge_log (deep_model result) (deep_model v2)}
      {[@expl:extern_spec_std_cmp_max_body ensures #2] [%#scmp'4] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #3] [%#scmp'5] le_log (deep_model v1) (deep_model v2)
       -> result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #4] [%#scmp'6] lt_log (deep_model v2) (deep_model v1)
       -> result = v1}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_min_body [#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66]
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 123 22 123 24
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 123 29 123 31
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 123 39 123 40
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 118 22 118 60
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 119 22 119 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 120 22 120 50
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 121 22 121 72
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 122 22 122 73
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 1001 4
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_T
  
  type tuple  =
    { _p0: t_T; _p1: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: [%#slib] forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = o} = args in inv o
  /\ inv self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = o} = args in (le_log (deep_model o) (deep_model self_)  -> res = o)
  /\ (lt_log (deep_model self_) (deep_model o)  -> res = self_)
  /\ (res = self_ \/ res = o)
  /\ le_log (deep_model res) (deep_model o) /\ le_log (deep_model res) (deep_model self_) /\ inv res)
  
  let rec min (self_:t_T) (o:t_T) (return'  (x:t_T))= {[@expl:min requires] precondition () { _p0 = self_; _p1 = o }}
    any [ return''0 (result:t_T)-> {postcondition_once () { _p0 = self_; _p1 = o } result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_cmp_min_body[#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66] (v1:t_T) (v2:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_cmp_min_body 'v1' type invariant] [%#scmp] inv v1}
    {[@expl:extern_spec_std_cmp_min_body 'v2' type invariant] [%#scmp'0] inv v2}
    (! bb0
    [ bb0 = s0 [ s0 = min {v1'0} {v2'0} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ]  | bb3 = return''0 {_0} ]
    ) [ & _0: t_T = Any.any_l () | & v1'0: t_T = v1 | & v2'0: t_T = v2 ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_cmp_min_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_min_body ensures #0] [%#scmp'2] le_log (deep_model result) (deep_model v1)}
      {[@expl:extern_spec_std_cmp_min_body ensures #1] [%#scmp'3] le_log (deep_model result) (deep_model v2)}
      {[@expl:extern_spec_std_cmp_min_body ensures #2] [%#scmp'4] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_min_body ensures #3] [%#scmp'5] lt_log (deep_model v1) (deep_model v2)
       -> result = v1}
      {[@expl:extern_spec_std_cmp_min_body ensures #4] [%#scmp'6] le_log (deep_model v2) (deep_model v1)
       -> result = v2}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i8_i8_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int8.t) : int =
    [%#snum] Int8.to_int self
  
  let rec partial_cmp (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int8.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:Int8.t) (other:Int8.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int8.t = self_
    | & other'0: Int8.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i8_i8_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i8_i8_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int8.t) : int =
    [%#snum] Int8.to_int self
  
  let rec partial_cmp (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int8.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:Int8.t) (other:Int8.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int8.t = self_
    | & other'0: Int8.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i8_i8_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i8_i8_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int8.t) : int =
    [%#snum] Int8.to_int self
  
  let rec partial_cmp (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int8.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:Int8.t) (other:Int8.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int8.t = self_
    | & other'0: Int8.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i8_i8_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i8_i8_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int8.t) : int =
    [%#snum] Int8.to_int self
  
  let rec partial_cmp (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int8.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:Int8.t) (other:Int8.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int8.t = self_
    | & other'0: Int8.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i8_i8_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i16_i16_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int16.t) : int =
    [%#snum] Int16.to_int self
  
  let rec partial_cmp (self_:Int16.t) (rhs:Int16.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int16.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:Int16.t) (other:Int16.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int16.t = self_
    | & other'0: Int16.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i16_i16_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i16_i16_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int16.t) : int =
    [%#snum] Int16.to_int self
  
  let rec partial_cmp (self_:Int16.t) (rhs:Int16.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int16.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:Int16.t) (other:Int16.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int16.t = self_
    | & other'0: Int16.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i16_i16_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i16_i16_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int16.t) : int =
    [%#snum] Int16.to_int self
  
  let rec partial_cmp (self_:Int16.t) (rhs:Int16.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int16.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:Int16.t) (other:Int16.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int16.t = self_
    | & other'0: Int16.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i16_i16_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i16_i16_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int16.t) : int =
    [%#snum] Int16.to_int self
  
  let rec partial_cmp (self_:Int16.t) (rhs:Int16.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int16.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:Int16.t) (other:Int16.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int16.t = self_
    | & other'0: Int16.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i16_i16_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i32_i32_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int32.t) : int =
    [%#snum] Int32.to_int self
  
  let rec partial_cmp (self_:Int32.t) (rhs:Int32.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int32.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:Int32.t) (other:Int32.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int32.t = self_
    | & other'0: Int32.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i32_i32_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i32_i32_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int32.t) : int =
    [%#snum] Int32.to_int self
  
  let rec partial_cmp (self_:Int32.t) (rhs:Int32.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int32.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:Int32.t) (other:Int32.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int32.t = self_
    | & other'0: Int32.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i32_i32_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i32_i32_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int32.t) : int =
    [%#snum] Int32.to_int self
  
  let rec partial_cmp (self_:Int32.t) (rhs:Int32.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int32.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:Int32.t) (other:Int32.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int32.t = self_
    | & other'0: Int32.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i32_i32_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i32_i32_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int32.t) : int =
    [%#snum] Int32.to_int self
  
  let rec partial_cmp (self_:Int32.t) (rhs:Int32.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int32.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:Int32.t) (other:Int32.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int32.t = self_
    | & other'0: Int32.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i32_i32_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i64_i64_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int64.t) : int =
    [%#snum] Int64.to_int self
  
  let rec partial_cmp (self_:Int64.t) (rhs:Int64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:Int64.t) (other:Int64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int64.t = self_
    | & other'0: Int64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i64_i64_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i64_i64_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int64.t) : int =
    [%#snum] Int64.to_int self
  
  let rec partial_cmp (self_:Int64.t) (rhs:Int64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:Int64.t) (other:Int64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int64.t = self_
    | & other'0: Int64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i64_i64_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i64_i64_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int64.t) : int =
    [%#snum] Int64.to_int self
  
  let rec partial_cmp (self_:Int64.t) (rhs:Int64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:Int64.t) (other:Int64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int64.t = self_
    | & other'0: Int64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i64_i64_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i64_i64_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int64.t) : int =
    [%#snum] Int64.to_int self
  
  let rec partial_cmp (self_:Int64.t) (rhs:Int64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:Int64.t) (other:Int64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int64.t = self_
    | & other'0: Int64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i64_i64_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i128_i128_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int128.t) : int =
    [%#snum] Int128.to_int self
  
  let rec partial_cmp (self_:Int128.t) (rhs:Int128.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int128.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:Int128.t) (other:Int128.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int128.t = self_
    | & other'0: Int128.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i128_i128_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i128_i128_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int128.t) : int =
    [%#snum] Int128.to_int self
  
  let rec partial_cmp (self_:Int128.t) (rhs:Int128.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int128.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:Int128.t) (other:Int128.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int128.t = self_
    | & other'0: Int128.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i128_i128_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i128_i128_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int128.t) : int =
    [%#snum] Int128.to_int self
  
  let rec partial_cmp (self_:Int128.t) (rhs:Int128.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int128.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:Int128.t) (other:Int128.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int128.t = self_
    | & other'0: Int128.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i128_i128_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_i128_i128_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int128.t) : int =
    [%#snum] Int128.to_int self
  
  let rec partial_cmp (self_:Int128.t) (rhs:Int128.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int128.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:Int128.t) (other:Int128.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int128.t = self_
    | & other'0: Int128.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_i128_i128_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_isize_isize_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int64.t) : int =
    [%#snum] Int64.to_int self
  
  let rec partial_cmp (self_:Int64.t) (rhs:Int64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:Int64.t) (other:Int64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int64.t = self_
    | & other'0: Int64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_isize_isize_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_isize_isize_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int64.t) : int =
    [%#snum] Int64.to_int self
  
  let rec partial_cmp (self_:Int64.t) (rhs:Int64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:Int64.t) (other:Int64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int64.t = self_
    | & other'0: Int64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_isize_isize_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_isize_isize_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int64.t) : int =
    [%#snum] Int64.to_int self
  
  let rec partial_cmp (self_:Int64.t) (rhs:Int64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:Int64.t) (other:Int64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int64.t = self_
    | & other'0: Int64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_isize_isize_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_isize_isize_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.Int64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: Int64.t) : int =
    [%#snum] Int64.to_int self
  
  let rec partial_cmp (self_:Int64.t) (rhs:Int64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: Int64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:Int64.t) (other:Int64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: Int64.t = self_
    | & other'0: Int64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_isize_isize_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u8_u8_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt8.t) : int =
    [%#snum] UInt8.t'int self
  
  let rec partial_cmp (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt8.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:UInt8.t) (other:UInt8.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt8.t = self_
    | & other'0: UInt8.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u8_u8_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u8_u8_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt8.t) : int =
    [%#snum] UInt8.t'int self
  
  let rec partial_cmp (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt8.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:UInt8.t) (other:UInt8.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt8.t = self_
    | & other'0: UInt8.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u8_u8_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u8_u8_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt8.t) : int =
    [%#snum] UInt8.t'int self
  
  let rec partial_cmp (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt8.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:UInt8.t) (other:UInt8.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt8.t = self_
    | & other'0: UInt8.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u8_u8_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u8_u8_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt8.t) : int =
    [%#snum] UInt8.t'int self
  
  let rec partial_cmp (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt8.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:UInt8.t) (other:UInt8.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt8.t = self_
    | & other'0: UInt8.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u8_u8_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u16_u16_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt16.t) : int =
    [%#snum] UInt16.t'int self
  
  let rec partial_cmp (self_:UInt16.t) (rhs:UInt16.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt16.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:UInt16.t) (other:UInt16.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt16.t = self_
    | & other'0: UInt16.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u16_u16_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u16_u16_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt16.t) : int =
    [%#snum] UInt16.t'int self
  
  let rec partial_cmp (self_:UInt16.t) (rhs:UInt16.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt16.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:UInt16.t) (other:UInt16.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt16.t = self_
    | & other'0: UInt16.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u16_u16_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u16_u16_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt16.t) : int =
    [%#snum] UInt16.t'int self
  
  let rec partial_cmp (self_:UInt16.t) (rhs:UInt16.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt16.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:UInt16.t) (other:UInt16.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt16.t = self_
    | & other'0: UInt16.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u16_u16_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u16_u16_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt16
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt16.t) : int =
    [%#snum] UInt16.t'int self
  
  let rec partial_cmp (self_:UInt16.t) (rhs:UInt16.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt16.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:UInt16.t) (other:UInt16.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt16.t = self_
    | & other'0: UInt16.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u16_u16_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u32_u32_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt32.t) : int =
    [%#snum] UInt32.t'int self
  
  let rec partial_cmp (self_:UInt32.t) (rhs:UInt32.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt32.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:UInt32.t) (other:UInt32.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt32.t = self_
    | & other'0: UInt32.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u32_u32_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u32_u32_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt32.t) : int =
    [%#snum] UInt32.t'int self
  
  let rec partial_cmp (self_:UInt32.t) (rhs:UInt32.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt32.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:UInt32.t) (other:UInt32.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt32.t = self_
    | & other'0: UInt32.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u32_u32_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u32_u32_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt32.t) : int =
    [%#snum] UInt32.t'int self
  
  let rec partial_cmp (self_:UInt32.t) (rhs:UInt32.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt32.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:UInt32.t) (other:UInt32.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt32.t = self_
    | & other'0: UInt32.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u32_u32_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u32_u32_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt32
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt32.t) : int =
    [%#snum] UInt32.t'int self
  
  let rec partial_cmp (self_:UInt32.t) (rhs:UInt32.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt32.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:UInt32.t) (other:UInt32.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt32.t = self_
    | & other'0: UInt32.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u32_u32_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u64_u64_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec partial_cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:UInt64.t) (other:UInt64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt64.t = self_
    | & other'0: UInt64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u64_u64_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u64_u64_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec partial_cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:UInt64.t) (other:UInt64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt64.t = self_
    | & other'0: UInt64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u64_u64_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u64_u64_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec partial_cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:UInt64.t) (other:UInt64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt64.t = self_
    | & other'0: UInt64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u64_u64_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u64_u64_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec partial_cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:UInt64.t) (other:UInt64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt64.t = self_
    | & other'0: UInt64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u64_u64_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u128_u128_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt128.t) : int =
    [%#snum] UInt128.t'int self
  
  let rec partial_cmp (self_:UInt128.t) (rhs:UInt128.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt128.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:UInt128.t) (other:UInt128.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt128.t = self_
    | & other'0: UInt128.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u128_u128_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u128_u128_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt128.t) : int =
    [%#snum] UInt128.t'int self
  
  let rec partial_cmp (self_:UInt128.t) (rhs:UInt128.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt128.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:UInt128.t) (other:UInt128.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt128.t = self_
    | & other'0: UInt128.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u128_u128_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u128_u128_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt128.t) : int =
    [%#snum] UInt128.t'int self
  
  let rec partial_cmp (self_:UInt128.t) (rhs:UInt128.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt128.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:UInt128.t) (other:UInt128.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt128.t = self_
    | & other'0: UInt128.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u128_u128_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_u128_u128_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt128
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt128.t) : int =
    [%#snum] UInt128.t'int self
  
  let rec partial_cmp (self_:UInt128.t) (rhs:UInt128.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt128.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:UInt128.t) (other:UInt128.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt128.t = self_
    | & other'0: UInt128.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_u128_u128_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_usize_usize_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 159 21 159 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 158 40 158 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 155 18 155 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec partial_cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 156 8 156 40] (self_:UInt64.t) (other:UInt64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt64.t = self_
    | & other'0: UInt64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_usize_usize_lt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ < deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_usize_usize_le_body [#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 168 21 168 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 167 58 167 62
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 164 18 164 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec partial_cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_le_body[#"../../creusot-contracts/src/std/cmp.rs" 165 8 165 40] (self_:UInt64.t) (other:UInt64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb5) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt64.t = self_
    | & other'0: UInt64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_usize_usize_le_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_usize_usize_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 177 21 177 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 43 176 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 173 18 173 68
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec partial_cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 174 8 174 40] (self_:UInt64.t) (other:UInt64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt64.t = self_
    | & other'0: UInt64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_usize_usize_gt_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ > deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_PartialOrd_usize_usize_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40]
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 186 21 186 26
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 185 61 185 65
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 18 182 69
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 151 18 151 83
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'4] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec partial_cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#scmp'2] result = C_Some (cmp_log (deep_model self_) (deep_model rhs))}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: UInt64.t) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 183 8 183 40] (self_:UInt64.t) (other:UInt64.t) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb2) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb5) | br2 -> {r0 = C_Greater} (! bb5) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: UInt64.t = self_
    | & other'0: UInt64.t = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_PartialOrd_usize_usize_ge_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ >= deep_model'0 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log [#"../../creusot-contracts/src/std/cmp.rs" 262 4 262 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 261 14 261 64
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 262 36 262 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 262 4 262 35] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#scmp] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log [#"../../creusot-contracts/src/std/cmp.rs" 267 4 267 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 266 14 266 61
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 267 36 267 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 267 4 267 35] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#scmp] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log [#"../../creusot-contracts/src/std/cmp.rs" 272 4 272 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 271 14 271 61
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 272 36 272 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 272 4 272 35] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#scmp] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log [#"../../creusot-contracts/src/std/cmp.rs" 277 4 277 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 276 14 276 64
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 277 36 277 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 277 4 277 35] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#scmp] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl [#"../../creusot-contracts/src/std/cmp.rs" 282 4 282 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 281 14 281 45
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 282 21 282 23
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  function refl'0 [#"../../creusot-contracts/src/std/cmp.rs" 282 4 282 20] (x'0: t_Reverse) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#scmp] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans [#"../../creusot-contracts/src/std/cmp.rs" 289 4 289 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 286 15 286 32
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 287 15 287 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 288 14 288 31
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 289 53 289 55
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'3] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  constant z  : t_Reverse
  
  constant o  : t_Ordering
  
  function trans'0 [#"../../creusot-contracts/src/std/cmp.rs" 289 4 289 52] (x'0: t_Reverse) (y'0: t_Reverse) (z'0: t_Reverse) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#scmp] cmp_log'0 x y = o)
   -> ([%#scmp'0] cmp_log'0 y z = o)  -> ([@expl:trans ensures] [%#scmp'1] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1 [#"../../creusot-contracts/src/std/cmp.rs" 295 4 295 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 293 15 293 45
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 294 14 294 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 295 34 295 36
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'2] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function antisym1'0 [#"../../creusot-contracts/src/std/cmp.rs" 295 4 295 33] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_antisym1: ([%#scmp] cmp_log'0 x y = C_Less)
   -> ([@expl:antisym1 ensures] [%#scmp'0] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2 [#"../../creusot-contracts/src/std/cmp.rs" 301 4 301 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 299 15 299 48
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 300 14 300 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 301 34 301 36
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'2] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function antisym2'0 [#"../../creusot-contracts/src/std/cmp.rs" 301 4 301 33] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_antisym2: ([%#scmp] cmp_log'0 x y = C_Greater)
   -> ([@expl:antisym2 ensures] [%#scmp'0] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp [#"../../creusot-contracts/src/std/cmp.rs" 306 4 306 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 305 14 305 59
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 306 32 306 34
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function eq_cmp'0 [#"../../creusot-contracts/src/std/cmp.rs" 306 4 306 31] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#scmp] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl [#"../../creusot-contracts/src/std/deque.rs" 177 4 177 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 176 14 176 47
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 177 27 177 29
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 170 12 170 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 84 14 84 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 85 14 85 76
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'1] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'2] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 86 4 86 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. [%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. [%#sslice'0] forall i: int. 0 <= i
  /\ i < Seq.length (to_ref_seq self)  -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 154 4 154 33] (self: t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 168 4 168 65] (self: t_Iter'0) (visited: Seq.seq t_T) (tl: t_Iter'0)
  
   =
    [%#sdeque'1] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Iter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/deque.rs" 177 4 177 26] (self'0: t_Iter'0) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sdeque] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans [#"../../creusot-contracts/src/std/deque.rs" 184 4 184 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 181 15 181 32
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 182 15 182 32
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 183 14 183 42
  let%span sdeque'2 = "../../creusot-contracts/src/std/deque.rs" 184 91 184 93
  let%span sdeque'3 = "../../creusot-contracts/src/std/deque.rs" 170 12 170 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 84 14 84 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 85 14 85 76
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'1] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'2] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 86 4 86 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. [%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. [%#sslice'0] forall i: int. 0 <= i
  /\ i < Seq.length (to_ref_seq self)  -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 154 4 154 33] (self: t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 168 4 168 65] (self: t_Iter'0) (visited: Seq.seq t_T) (tl: t_Iter'0)
  
   =
    [%#sdeque'3] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/deque.rs" 184 4 184 90] (a'0: t_Iter'0) (ab'0: Seq.seq t_T) (b'0: t_Iter'0) (bc'0: Seq.seq t_T) (c'0: t_Iter'0) : ()
  
  
  goal vc_produces_trans: ([%#sdeque] produces a ab b)
   -> ([%#sdeque'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#sdeque'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_assert_unchecked_body [#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 7 23 7 27
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_assert_unchecked_body[#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1] (cond:bool) (return'  (x:()))= {[@expl:extern_spec_std_hint_assert_unchecked_body requires] [%#shint] cond}
    (! bb0 [ bb0 = return''0 {_0} ] ) [ & _0: () = Any.any_l () ]  [ return''0 (result:())-> (! return' {result}) ] 
end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_black_box_body [#"../../creusot-contracts/src/std/hint.rs" 12 12 12 42]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 12 28 12 33
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 12 41 12 42
  let%span shint'1 = "../../creusot-contracts/src/std/hint.rs" 11 22 11 37
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_black_box_body[#"../../creusot-contracts/src/std/hint.rs" 12 12 12 42] (dummy:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_hint_black_box_body 'dummy' type invariant] [%#shint] inv dummy}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- dummy'0 ] s1 | s1 = bb1 ]  | bb1 = return''0 {_0} ] )
    [ & _0: t_T = Any.any_l () | & dummy'0: t_T = dummy ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_hint_black_box_body result type invariant] [%#shint'0] inv result}
      {[@expl:extern_spec_std_hint_black_box_body ensures] [%#shint'1] result = dummy}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_spin_loop_body [#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 17 23 17 27
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 18 22 18 26
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_spin_loop_body[#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1] (return'  (x:()))= {[@expl:extern_spec_std_hint_spin_loop_body requires] [%#shint] true}
    (! bb0 [ bb0 = return''0 {_0} ] ) [ & _0: () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_hint_spin_loop_body ensures] [%#shint'0] true}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_unreachable_unchecked_body [#"../../creusot-contracts/src/std/hint.rs" 23 12 23 50]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 81 8 81 13
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 22 23 22 28
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 23 49 23 50
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 80 4 80 30] (self: ()) =
    [%#sinvariant] false
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom [@rewrite]: forall x: () [inv x]. inv x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_unreachable_unchecked_body[#"../../creusot-contracts/src/std/hint.rs" 23 12 23 50] (return'  (x:()))= {[@expl:extern_spec_std_hint_unreachable_unchecked_body requires] [%#shint] false}
    (! bb0 [ bb0 = {false} any ] )
    [ return''0 (result:())-> {[@expl:extern_spec_std_hint_unreachable_unchecked_body result type invariant] [%#shint'0] inv result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_must_use_body [#"../../creusot-contracts/src/std/hint.rs" 30 12 30 41]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 30 27 30 32
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 30 40 30 41
  let%span shint'1 = "../../creusot-contracts/src/std/hint.rs" 29 22 29 37
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_hint_must_use_body[#"../../creusot-contracts/src/std/hint.rs" 30 12 30 41] (value:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_hint_must_use_body 'value' type invariant] [%#shint] inv value}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- value'0 ] s1 | s1 = bb1 ]  | bb1 = return''0 {_0} ] )
    [ & _0: t_T = Any.any_l () | & value'0: t_T = value ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_hint_must_use_body result type invariant] [%#shint'0] inv result}
      {[@expl:extern_spec_std_hint_must_use_body ensures] [%#shint'1] result = value}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__io__extern_spec_std_ioqy95z_print_body [#"../../creusot-contracts/src/std/io.rs" 4 0 18 1]
  let%span sio = "../../creusot-contracts/src/std/io.rs" 9 22 9 26
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use creusot.prelude.Char
  use creusot.int.UInt32
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Alignment  =
    | C_Left
    | C_Right
    | C_Center
    | C_Unknown
  
  type t_Count  =
    | C_Is UInt64.t
    | C_Param UInt64.t
    | C_Implied
  
  type t_Placeholder  =
    { t_Placeholder__position: UInt64.t;
      t_Placeholder__fill: Char.t;
      t_Placeholder__align: t_Alignment;
      t_Placeholder__flags: UInt32.t;
      t_Placeholder__precision: t_Count;
      t_Placeholder__width: t_Count }
  
  type t_Option  =
    | C_None
    | C_Some (Slice64.slice t_Placeholder)
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_ArgumentType  =
    | C_Placeholder t_NonNull Opaque.ptr ()
    | C_Count UInt64.t
  
  type t_Argument  =
    { t_Argument__ty: t_ArgumentType }
  
  type t_Arguments  =
    { t_Arguments__pieces: Slice64.slice string;
      t_Arguments__fmt: t_Option;
      t_Arguments__args: Slice64.slice t_Argument }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_ioqy95z_print_body[#"../../creusot-contracts/src/std/io.rs" 4 0 18 1] (args:t_Arguments) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_io__print_body ensures] [%#sio] true} (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__io__extern_spec_std_ioqy95z_eprint_body [#"../../creusot-contracts/src/std/io.rs" 4 0 18 1]
  let%span sio = "../../creusot-contracts/src/std/io.rs" 14 22 14 26
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use creusot.prelude.Char
  use creusot.int.UInt32
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Alignment  =
    | C_Left
    | C_Right
    | C_Center
    | C_Unknown
  
  type t_Count  =
    | C_Is UInt64.t
    | C_Param UInt64.t
    | C_Implied
  
  type t_Placeholder  =
    { t_Placeholder__position: UInt64.t;
      t_Placeholder__fill: Char.t;
      t_Placeholder__align: t_Alignment;
      t_Placeholder__flags: UInt32.t;
      t_Placeholder__precision: t_Count;
      t_Placeholder__width: t_Count }
  
  type t_Option  =
    | C_None
    | C_Some (Slice64.slice t_Placeholder)
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_ArgumentType  =
    | C_Placeholder t_NonNull Opaque.ptr ()
    | C_Count UInt64.t
  
  type t_Argument  =
    { t_Argument__ty: t_ArgumentType }
  
  type t_Arguments  =
    { t_Arguments__pieces: Slice64.slice string;
      t_Arguments__fmt: t_Option;
      t_Arguments__args: Slice64.slice t_Argument }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_ioqy95z_eprint_body[#"../../creusot-contracts/src/std/io.rs" 4 0 18 1] (args:t_Arguments) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_io__eprint_body ensures] [%#sio] true} (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl [#"../../creusot-contracts/src/std/iter/cloned.rs" 59 4 59 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 58 14 58 47
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 59 27 59 29
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 50 12 53 98
  let%span scloned'2 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'2] inv'0 self  -> inv (iter self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv'1 res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv'1 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv'1 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 48 4 48 55] (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned)
  
   =
    [%#scloned'1] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Cloned
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 59 4 59 26] (self'0: t_Cloned) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#scloned] produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 72] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 62 15 62 32
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 63 15 63 32
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 64 14 64 42
  let%span scloned'2 = "../../creusot-contracts/src/std/iter/cloned.rs" 65 73 65 75
  let%span scloned'3 = "../../creusot-contracts/src/std/iter/cloned.rs" 50 12 53 98
  let%span scloned'4 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'4] inv'0 self  -> inv (iter self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv'1 res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv'1 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv'1 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 48 4 48 55] (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned)
  
   =
    [%#scloned'3] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Cloned
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Cloned
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Cloned
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 72] (a'0: t_Cloned) (ab'0: Seq.seq t_T) (b'0: t_Cloned) (bc'0: Seq.seq t_T) (c'0: t_Cloned) : ()
  
  
  goal vc_produces_trans: ([%#scloned] produces'0 a ab b)
   -> ([%#scloned'0] produces'0 b bc c)
   -> ([@expl:produces_trans ensures] [%#scloned'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl [#"../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 58 14 58 47
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 59 27 59 29
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'2 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 48 4 48 64] (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied)
  
   =
    [%#scopied'1] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Copied
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 26] (self'0: t_Copied) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#scopied] produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  let%span scopied'2 = "../../creusot-contracts/src/std/iter/copied.rs" 65 91 65 93
  let%span scopied'3 = "../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'4 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'4] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 48 4 48 64] (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied)
  
   =
    [%#scopied'3] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Copied
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Copied
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Copied
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (a'0: t_Copied) (ab'0: Seq.seq t_T) (b'0: t_Copied) (bc'0: Seq.seq t_T) (c'0: t_Copied) : ()
  
  
  goal vc_produces_trans: ([%#scopied] produces'0 a ab b)
   -> ([%#scopied'0] produces'0 b bc c)
   -> ([@expl:produces_trans ensures] [%#scopied'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 17 14 17 47
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 18 27 18 29
  let%span sempty'1 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 56
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty)
  
   =
    [%#sempty'1] visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Empty
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (self'0: t_Empty) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sempty] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 21 15 21 32
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 22 15 22 32
  let%span sempty'1 = "../../creusot-contracts/src/std/iter/empty.rs" 23 14 23 42
  let%span sempty'2 = "../../creusot-contracts/src/std/iter/empty.rs" 24 91 24 93
  let%span sempty'3 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 56
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty)
  
   =
    [%#sempty'3] visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Empty
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Empty
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Empty
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (a'0: t_Empty) (ab'0: Seq.seq t_T) (b'0: t_Empty) (bc'0: Seq.seq t_T) (c'0: t_Empty) : ()
  
  
  goal vc_produces_trans: ([%#sempty] produces a ab b)
   -> ([%#sempty'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#sempty'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 82 14 82 47
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 83 27 83 29
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 73 12 77 108
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  let%span senumerate'3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 46 12 50 87
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self: t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'2] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 44 4 44 30] (self: t_Enumerate) =
    [%#senumerate'3] (forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i: MutBorrow.t t_I. completed i  -> produces i.current (Seq.empty: Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv'0 x]. inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 71 4 71 64] (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate)
  
   =
    [%#senumerate'1] Seq.length visited = n o - n self
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Enumerate
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (self'0: t_Enumerate) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#senumerate] produces'0 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans [#"../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 86 15 86 32
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 87 15 87 32
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 88 14 88 42
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 89 91 89 93
  let%span senumerate'3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 73 12 77 108
  let%span senumerate'4 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  let%span senumerate'5 = "../../creusot-contracts/src/std/iter/enumerate.rs" 46 12 50 87
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self: t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'4] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 44 4 44 30] (self: t_Enumerate) =
    [%#senumerate'5] (forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i: MutBorrow.t t_I. completed i  -> produces i.current (Seq.empty: Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv'0 x]. inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 71 4 71 64] (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate)
  
   =
    [%#senumerate'3] Seq.length visited = n o - n self
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Enumerate
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Enumerate
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Enumerate
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 90] (a'0: t_Enumerate) (ab'0: Seq.seq tuple) (b'0: t_Enumerate) (bc'0: Seq.seq tuple) (c'0: t_Enumerate) : ()
  
  
  goal vc_produces_trans: ([%#senumerate] produces'0 a ab b)
   -> ([%#senumerate'0] produces'0 b bc c)
   -> ([@expl:produces_trans ensures] [%#senumerate'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 102 14 102 47
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 103 27 103 29
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 139
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 118
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'4 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: bool) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: bool. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self: t_Filter) =
    [%#sfilter'2] forall f: t_F, i: t_Item. precondition f i
    /\ (forall f'0: t_F, g: t_F. hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1: t_F, f2: t_F, i'0: t_Item. not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Filter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Filter [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self: t_Filter) : t_F
  
  axiom func_spec: forall self: t_Filter. [%#sfilter'3] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self: t_Filter) : t_I
  
  axiom iter_spec: forall self: t_Filter. [%#sfilter'4] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter)
  
   =
    [%#sfilter'1] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Filter
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (self'0: t_Filter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sfilter] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 106 15 106 32
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 107 15 107 32
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 108 14 108 42
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 109 91 109 93
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 139
  let%span sfilter'4 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 118
  let%span sfilter'5 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'6 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: bool) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: bool. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self: t_Filter) =
    [%#sfilter'4] forall f: t_F, i: t_Item. precondition f i
    /\ (forall f'0: t_F, g: t_F. hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1: t_F, f2: t_F, i'0: t_Item. not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Filter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Filter [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self: t_Filter) : t_F
  
  axiom func_spec: forall self: t_Filter. [%#sfilter'5] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self: t_Filter) : t_I
  
  axiom iter_spec: forall self: t_Filter. [%#sfilter'6] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter)
  
   =
    [%#sfilter'3] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Filter
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Filter
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Filter
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (a'0: t_Filter) (ab'0: Seq.seq t_Item) (b'0: t_Filter) (bc'0: Seq.seq t_Item) (c'0: t_Filter) : ()
  
  
  goal vc_produces_trans: ([%#sfilter] produces'0 a ab b)
   -> ([%#sfilter'0] produces'0 b bc c)
   -> ([@expl:produces_trans ensures] [%#sfilter'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 102 14 102 47
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 103 27 103 29
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 143
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 49
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 53
  let%span sfilter_map'7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 130
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f: t_F) =
    [%#sfilter_map'5] forall i: t_Item. precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f: t_F) =
    [%#sfilter_map'6] forall g: t_F. hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1: t_F) =
    [%#sfilter_map'7] forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self: t_FilterMap) : t_F
  
  axiom func_spec: forall self: t_FilterMap. [%#sfilter_map'3] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self: t_FilterMap) =
    [%#sfilter_map'2] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite]: forall x: t_FilterMap [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self: t_FilterMap) : t_I
  
  axiom iter_spec: forall self: t_FilterMap. [%#sfilter_map'4] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap)
  
   =
    [%#sfilter_map'1] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j: int. 0 <= j /\ j < Seq.length s
     -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FilterMap
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (self'0: t_FilterMap) : ()
  
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sfilter_map] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 106 15 106 32
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 107 15 107 32
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 108 14 108 42
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 109 91 109 93
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 143
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 49
  let%span sfilter_map'8 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 53
  let%span sfilter_map'9 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 130
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f: t_F) =
    [%#sfilter_map'7] forall i: t_Item. precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f: t_F) =
    [%#sfilter_map'8] forall g: t_F. hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1: t_F) =
    [%#sfilter_map'9] forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self: t_FilterMap) : t_F
  
  axiom func_spec: forall self: t_FilterMap. [%#sfilter_map'5] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self: t_FilterMap) =
    [%#sfilter_map'4] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite]: forall x: t_FilterMap [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self: t_FilterMap) : t_I
  
  axiom iter_spec: forall self: t_FilterMap. [%#sfilter_map'6] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap)
  
   =
    [%#sfilter_map'3] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j: int. 0 <= j /\ j < Seq.length s
     -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_FilterMap
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_FilterMap
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_FilterMap
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (a'0: t_FilterMap) (ab'0: Seq.seq t_B) (b'0: t_FilterMap) (bc'0: Seq.seq t_B) (c'0: t_FilterMap) : ()
  
  
  goal vc_produces_trans: ([%#sfilter_map] produces'0 a ab b)
   -> ([%#sfilter_map'0] produces'0 b bc c)
   -> ([@expl:produces_trans ensures] [%#sfilter_map'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 47
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. [%#sfuse'2] inv'1 self  -> inv'0 (view self)
  
  axiom view_spec'0: forall self: t_Fuse. [%#sfuse'3] forall other: t_Fuse. view self = view other  -> self = other
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'1] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Fuse
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self'0: t_Fuse) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sfuse] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. [%#sfuse'4] inv'1 self  -> inv'0 (view self)
  
  axiom view_spec'0: forall self: t_Fuse. [%#sfuse'5] forall other: t_Fuse. view self = view other  -> self = other
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'3] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Fuse
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Fuse
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Fuse
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a'0: t_Fuse) (ab'0: Seq.seq t_Item) (b'0: t_Fuse) (bc'0: Seq.seq t_Item) (c'0: t_Fuse) : ()
  
  
  goal vc_produces_trans: ([%#sfuse] produces'0 a ab b)
   -> ([%#sfuse'0] produces'0 b bc c)  -> ([@expl:produces_trans ensures] [%#sfuse'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 63 15 63 31
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 64 15 64 44
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 65 14 65 52
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 66 63 66 65
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 47
  let%span sfuse'6 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'7 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'8 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'9 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'10 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'11 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'12 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. [%#sfuse'11] inv'1 self  -> inv'0 (view self)
  
  axiom view_spec'0: forall self: t_Fuse. [%#sfuse'12] forall other: t_Fuse. view self = view other  -> self = other
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'4] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a: t_Fuse) (ab: Seq.seq t_Item) (b: t_Fuse) (bc: Seq.seq t_Item) (c: t_Fuse) : ()
  
   =
    [%#sfuse'10] ()
  
  axiom produces_trans_spec'0: forall a: t_Fuse, ab: Seq.seq t_Item, b: t_Fuse, bc: Seq.seq t_Item, c: t_Fuse. ([%#sfuse'7] produces'0 a ab b)
   -> ([%#sfuse'8] produces'0 b bc c)  -> ([%#sfuse'9] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self: t_Fuse) : () =
    [%#sfuse'6] ()
  
  axiom produces_refl_spec'0: forall self: t_Fuse. [%#sfuse'5] produces'0 self (Seq.empty: Seq.seq t_Item) self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Fuse) : t_Option =
    [%#smodel] view self.current
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self: MutBorrow.t t_Fuse) =
    [%#sfuse'3] (view'0 self = C_None
    \/ (exists it: MutBorrow.t t_I. completed it /\ view'0 self = C_Some (it.current)))
    /\ view self.final = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : MutBorrow.t t_Fuse
  
  constant steps  : Seq.seq t_Item
  
  constant next  : t_Fuse
  
  function is_fused [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (self'0: MutBorrow.t t_Fuse) (steps'0: Seq.seq t_Item) (next'0: t_Fuse) : ()
  
  
  goal vc_is_fused: ([%#sfuse] completed'0 self)
   -> ([%#sfuse'0] produces'0 self.final steps next)
   -> ([@expl:is_fused ensures] [%#sfuse'1] steps = (Seq.empty: Seq.seq t_Item) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi306403796899090344__produces_refl [#"../../creusot-contracts/src/std/iter/map.rs" 76 4 76 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 75 14 75 47
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 76 27 76 29
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 59 12 70 75
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap'3 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'3] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 57 4 57 67] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map)
  
   =
    [%#smap'1] hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Map
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map.rs" 76 4 76 26] (self'0: t_Map) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#smap] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi306403796899090344__produces_trans [#"../../creusot-contracts/src/std/iter/map.rs" 82 4 82 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 79 15 79 32
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 80 15 80 32
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 81 14 81 42
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 82 91 82 93
  let%span smap'3 = "../../creusot-contracts/src/std/iter/map.rs" 59 12 70 75
  let%span smap'4 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap'5 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'4] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'5] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 57 4 57 67] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map)
  
   =
    [%#smap'3] hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Map
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_Map
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_Map
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map.rs" 82 4 82 90] (a'0: t_Map) (ab'0: Seq.seq t_B) (b'0: t_Map) (bc'0: Seq.seq t_B) (c'0: t_Map) : ()
  
  
  goal vc_produces_trans: ([%#smap] produces'0 a ab b)
   -> ([%#smap'0] produces'0 b bc c)  -> ([@expl:produces_trans ensures] [%#smap'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 47
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 27 25 29
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'1] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_MapInv
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self'0: t_MapInv) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#smap_inv] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'3] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_MapInv
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_MapInv
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_MapInv
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a'0: t_MapInv) (ab'0: Seq.seq t_B) (b'0: t_MapInv) (bc'0: Seq.seq t_B) (c'0: t_MapInv) : ()
  
  
  goal vc_produces_trans: ([%#smap_inv] produces'0 a ab b)
   -> ([%#smap_inv'0] produces'0 b bc c)
   -> ([@expl:produces_trans ensures] [%#smap_inv'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence [#"../../creusot-contracts/src/std/iter/map_inv.rs" 63 4 63 30] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 61 15 61 39
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 62 14 62 28
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 63 31 63 33
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 48
  
  use seq.Seq
  
  type t_I
  
  type t_F
  
  type t_B
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_B }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_MapInv) =
    match _0 with
      | {t_MapInv__iter = x0 ; t_MapInv__func = x1 ; t_MapInv__produced = x2} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 56 4 56 28] (self: t_MapInv) =
    [%#smap_inv'2] resolve'0 self.t_MapInv__iter /\ resolve self.t_MapInv__func
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_MapInv
  
  function resolve_coherence [#"../../creusot-contracts/src/std/iter/map_inv.rs" 63 4 63 30] (self'0: t_MapInv) : ()
  
  goal vc_resolve_coherence: ([%#smap_inv] structural_resolve self)
   -> ([@expl:resolve_coherence ensures] [%#smap_inv'0] resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next [#"../../creusot-contracts/src/std/iter/map_inv.rs" 89 4 89 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 75 4
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 193 16 193 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 195 39 195 42
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 193 27 193 52
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 194 26 194 71
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'9 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 90 39 90 58
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 93 16 93 76
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 94 31 94 71
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 98 24 98 66
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 99 32 99 63
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 104 32 104 58
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 89 17 89 21
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 89 26 89 44
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 85 14 88 5
  let%span smap_inv'8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 160 15 160 31
  let%span smap_inv'9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 161 4 161 60
  let%span smap_inv'10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 162 15 162 30
  let%span smap_inv'11 = "../../creusot-contracts/src/std/iter/map_inv.rs" 163 15 163 64
  let%span smap_inv'12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 164 14 164 74
  let%span smap_inv'13 = "../../creusot-contracts/src/std/iter/map_inv.rs" 165 14 165 75
  let%span smap_inv'14 = "../../creusot-contracts/src/std/iter/map_inv.rs" 167 8 171 9
  let%span smap_inv'15 = "../../creusot-contracts/src/std/iter/map_inv.rs" 176 14 176 68
  let%span smap_inv'16 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 12 184 74
  let%span smap_inv'17 = "../../creusot-contracts/src/std/iter/map_inv.rs" 17 8 20 9
  let%span smap_inv'18 = "../../creusot-contracts/src/std/iter/map_inv.rs" 73 12 75 73
  let%span smap_inv'19 = "../../creusot-contracts/src/std/iter/map_inv.rs" 123 14 123 83
  let%span smap_inv'20 = "../../creusot-contracts/src/std/iter/map_inv.rs" 126 12 131 88
  let%span smap_inv'21 = "../../creusot-contracts/src/std/iter/map_inv.rs" 116 12 118 63
  let%span smap_inv'22 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv'23 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 47
  let%span smap_inv'24 = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 27 25 29
  let%span smap_inv'25 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv'26 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv'27 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv'28 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span smap_inv'29 = "../../creusot-contracts/src/std/iter/map_inv.rs" 152 12 155 47
  let%span smap_inv'30 = "../../creusot-contracts/src/std/iter/map_inv.rs" 139 12 144 71
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_I
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_Option  =
    | C_None
    | C_Some t_Item
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_I) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_I)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_I [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: MutBorrow.t t_I)
  
  axiom precondition_fndef: [%#slib] forall args: MutBorrow.t t_I [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Item)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: MutBorrow.t t_I) (result: t_Option)
  
  
  axiom postcondition_fndef: [%#slib] forall args: MutBorrow.t t_I, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in match res with
    | C_None -> completed self_
    | C_Some v -> produces self_.current (Seq.singleton v) self_.final
    end
  /\ inv'2 res)
  
  let rec next (self_:MutBorrow.t t_I) (return'  (x:t_Option))= {[@expl:next requires] precondition () self_}
    any [ return''0 (result:t_Option)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Item))= any
    [ good (field_0:t_Item)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Item [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_B
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_F) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_F)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_F [inv'4 x]. inv'4 x = invariant''0 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple [inv'5 x]. inv'5 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'1 x0)
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'9] postcondition_once'0 self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'6] hist_inv self b)
   -> ([%#sops'7] hist_inv b c)  -> ([%#sops'8] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'5] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops'3] postcondition_mut self args res_state res)
   -> ([%#sops'4] hist_inv self res_state)
  
  let rec call_mut (self_:MutBorrow.t t_F) (arg:tuple) (return'  (x:t_B))= {[@expl:call_mut 'self_' type invariant] [%#sops] inv'4 self_}
    {[@expl:call_mut 'arg' type invariant] [%#sops'0] inv'5 arg}
    {[@expl:call_mut requires] [%#sops'1] precondition'0 self_.current arg}
    any
    [ return''0 (result:t_B)-> {inv'6 result}
      {[%#sops'2] postcondition_mut self_.current arg self_.final result}
      (! return' {result}) ]
  
  
  predicate next_precondition [#"../../creusot-contracts/src/std/iter/map_inv.rs" 114 4 114 78] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'21] forall e: t_Item, i: t_I. produces iter (Seq.singleton e) i
     -> precondition'0 func { _p0 = e; _p1 = produced }
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 137 4 137 49] (iter: t_I) (func: t_F) =
    [%#smap_inv'30] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition'0 f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  predicate reinitialize [#"../../creusot-contracts/src/std/iter/map_inv.rs" 150 4 150 33]  =
    [%#smap_inv'29] forall iter: MutBorrow.t t_I, func: t_F. completed iter
     -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 124 4 124 77] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'20] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _p0 = e1; _p1 = Seq.(++) produced s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
     -> precondition'0 f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec: forall iter: t_I, func: t_F, produced: Seq.seq t_Item. [%#smap_inv'19] produced
  = (Seq.empty: Seq.seq t_Item)  -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant''1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 71 4 71 30] (self: t_MapInv) =
    [%#smap_inv'18] reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  function produces_one_invariant [#"../../creusot-contracts/src/std/iter/map_inv.rs" 166 4 166 73] (self: t_MapInv) (e: t_Item) (r: t_B) (f: MutBorrow.t t_F) (iter: t_I) : ()
  
   =
    [%#smap_inv'14] let _ = () in ()
  
  axiom produces_one_invariant_spec: forall self: t_MapInv, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter: t_I. ([%#smap_inv'8] invariant''1 self)
   -> ([%#smap_inv'9] produces self.t_MapInv__iter (Seq.singleton e) iter)
   -> ([%#smap_inv'10] f.current = self.t_MapInv__func)
   -> ([%#smap_inv'11] postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final r)
   -> ([%#smap_inv'12] preservation_inv iter f.final (Seq.snoc self.t_MapInv__produced e))
  
  axiom produces_one_invariant_spec'0: forall self: t_MapInv, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter: t_I. ([%#smap_inv'8] invariant''1 self)
   -> ([%#smap_inv'9] produces self.t_MapInv__iter (Seq.singleton e) iter)
   -> ([%#smap_inv'10] f.current = self.t_MapInv__func)
   -> ([%#smap_inv'11] postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final r)
   -> ([%#smap_inv'13] next_precondition iter f.final (Seq.snoc self.t_MapInv__produced e))
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'22] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _p0 = Seq.get s i;
                                               _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : ()
  
   =
    [%#smap_inv'28] ()
  
  axiom produces_trans_spec'0: forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. ([%#smap_inv'25] produces'0 a ab b)
   -> ([%#smap_inv'26] produces'0 b bc c)  -> ([%#smap_inv'27] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self: t_MapInv) : () =
    [%#smap_inv'24] ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. [%#smap_inv'23] produces'0 self (Seq.empty: Seq.seq t_B) self
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 177 4 177 57] (self: t_MapInv) (visited: t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'16] exists f: MutBorrow.t t_F, e: t_Item. f.current = self.t_MapInv__func
    /\ f.final = succ.t_MapInv__func
    /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
    /\ precondition'0 f.current { _p0 = e; _p1 = self.t_MapInv__produced }
    /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited
  
  axiom produces_one_spec: forall self: t_MapInv, visited: t_B, succ: t_MapInv. [%#smap_inv'15] produces_one self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_MapInv)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_MapInv [inv'7 x]. inv'7 x
  = (invariant''1 x
  /\ match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'3 func
    end)
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_MapInv) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_MapInv)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_MapInv [inv'8 x]. inv'8 x = invariant''2 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_MapInv) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_MapInv) =
    resolve'0 _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B
  
  predicate inv'9 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'9 x]. inv'9 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 16 4 16 35] (self: MutBorrow.t t_MapInv) =
    [%#smap_inv'17] (self.final).t_MapInv__produced = (Seq.empty: Seq.seq t_Item)
    /\ completed (MutBorrow.borrow_logic (self.current).t_MapInv__iter (self.final).t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func = (self.final).t_MapInv__func
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next'0[#"../../creusot-contracts/src/std/iter/map_inv.rs" 89 4 89 44] (self:MutBorrow.t t_MapInv) (return'  (x:t_Option'0))= {[@expl:next 'self' type invariant] [%#smap_inv'5] inv'8 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#smap_inv] self'0.current ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv (self'0.current).t_MapInv__iter}
        MutBorrow.borrow_final
          <t_I>
          {(self'0.current).t_MapInv__iter}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_I) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__iter = _ret.final } } ] 
            s1)
      | s1 = next {_6} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_5 = C_None} (! bb5) | br1 (x0:t_Item)-> {_5 = C_Some x0} (! bb6) ] 
    | bb6 = s0
      [ s0 = v_Some {_5} (fun (r0:t_Item) ->  [ &v <- r0 ] s1)
      | s1 = {[@expl:assertion] [%#smap_inv'0] precondition'0 (self'0.current).t_MapInv__func { _p0 = v;
                                                                                                _p1 = (self'0.current).t_MapInv__produced }}
        s2
      | s2 =  [ &produced <- [%#smap_inv'1] Seq.snoc (self'0.current).t_MapInv__produced v ] s3
      | s3 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'3 (self'0.current).t_MapInv__func}
        MutBorrow.borrow_final
          <t_F>
          {(self'0.current).t_MapInv__func}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t t_F) ->
             [ &_14 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__func = _ret.final } } ] 
            s1)
      | s1 =  [ &_15 <- { _p0 = v; _p1 = (self'0.current).t_MapInv__produced } ] s2
      | s2 = call_mut {_14} {_15} (fun (_ret:t_B) ->  [ &r <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__produced = produced } } ] s1
      | s1 =  [ &_19 <- [%#smap_inv'2] () ] s2
      | s2 = bb10 ]
    
    | bb10 = s0
      [ s0 = {[@expl:assertion] [%#smap_inv'3] produces_one old_self r self'0.current} s1
      | s1 = {[@expl:type invariant] inv'8 self'0} s2
      | s2 = -{resolve'1 self'0}- s3
      | s3 =  [ &_0 <- C_Some'0 r ] s4
      | s4 = bb16 ]
    
    | bb5 = s0 [ s0 =  [ &_24 <- [%#smap_inv'4] Seq.empty: Seq.seq t_Item ] s1 | s1 = bb14 ] 
    | bb14 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__produced = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv'8 self'0} s2
      | s2 = -{resolve'1 self'0}- s3
      | s3 =  [ &_0 <- C_None'0 ] s4
      | s4 = bb16 ]
    
    | bb16 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self'0: MutBorrow.t t_MapInv = self
    | & old_self: t_MapInv = Any.any_l ()
    | & _5: t_Option = Any.any_l ()
    | & _6: MutBorrow.t t_I = Any.any_l ()
    | & v: t_Item = Any.any_l ()
    | & produced: Seq.seq t_Item = Any.any_l ()
    | & r: t_B = Any.any_l ()
    | & _14: MutBorrow.t t_F = Any.any_l ()
    | & _15: tuple = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _24: Seq.seq t_Item = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:next result type invariant] [%#smap_inv'6] inv'9 result}
      {[@expl:next ensures] [%#smap_inv'7] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces_one self.current v self.final
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 124 4 124 77] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 123 14 123 83
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 126 12 131 88
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 139 12 144 71
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  type t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 137 4 137 49] (iter: t_I) (func: t_F) =
    [%#smap_inv'1] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant iter  : t_I
  
  constant func  : t_F
  
  constant produced  : Seq.seq t_Item
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 124 4 124 77] (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item)
  
  
  goal vc_preservation_inv: [@expl:preservation_inv ensures] [%#smap_inv] produced = (Seq.empty: Seq.seq t_Item)
   -> ([%#smap_inv'0] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
   -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
   -> precondition f.current { _p0 = e1; _p1 = Seq.(++) produced s }
   -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
   -> precondition f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 })
  = preservation iter func
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__produces_one_invariant [#"../../creusot-contracts/src/std/iter/map_inv.rs" 166 4 166 73] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 240 8 240 27
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 160 15 160 31
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 161 4 161 60
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 162 15 162 30
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 163 15 163 64
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 164 14 164 74
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 165 14 165 75
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 168 12 170 82
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 167 8 171 9
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 73 12 75 73
  let%span smap_inv'8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 123 14 123 83
  let%span smap_inv'9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 126 12 131 88
  let%span smap_inv'10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 116 12 118 63
  let%span smap_inv'11 = "../../creusot-contracts/src/std/iter/map_inv.rs" 152 12 155 47
  let%span smap_inv'12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 139 12 144 71
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate next_precondition [#"../../creusot-contracts/src/std/iter/map_inv.rs" 114 4 114 78] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'10] forall e: t_Item, i: t_I. produces iter (Seq.singleton e) i
     -> precondition func { _p0 = e; _p1 = produced }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 137 4 137 49] (iter: t_I) (func: t_F) =
    [%#smap_inv'12] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  predicate reinitialize [#"../../creusot-contracts/src/std/iter/map_inv.rs" 150 4 150 33]  =
    [%#smap_inv'11] forall iter: MutBorrow.t t_I, func: t_F. completed iter
     -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 124 4 124 77] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'9] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = Seq.(++) produced s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec: forall iter: t_I, func: t_F, produced: Seq.seq t_Item. [%#smap_inv'8] produced
  = (Seq.empty: Seq.seq t_Item)  -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/map_inv.rs" 71 4 71 30] (self: t_MapInv) =
    [%#smap_inv'7] reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  function push_front [@inline:trivial] [#"../../creusot-contracts/src/logic/seq.rs" 239 4 239 41] (self: Seq.seq t_Item) (x: t_Item) : Seq.seq t_Item
  
   =
    [%#sseq] Seq.cons x self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_MapInv
  
  constant e  : t_Item
  
  constant r  : t_B
  
  constant f  : MutBorrow.t t_F
  
  constant iter  : t_I
  
  function produces_one_invariant [#"../../creusot-contracts/src/std/iter/map_inv.rs" 166 4 166 73] (self'0: t_MapInv) (e'0: t_Item) (r'0: t_B) (f'0: MutBorrow.t t_F) (iter'0: t_I) : ()
  
  
  goal vc_produces_one_invariant: ([%#smap_inv] invariant' self)
   -> ([%#smap_inv'0] produces self.t_MapInv__iter (Seq.singleton e) iter)
   -> ([%#smap_inv'1] f.current = self.t_MapInv__func)
   -> ([%#smap_inv'2] postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final r)
   -> ([%#smap_inv'5] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, i: t_I. produces iter (Seq.snoc (Seq.snoc s e1) e2) i
   -> produces self.t_MapInv__iter (Seq.snoc (Seq.snoc (push_front s e) e1) e2) i)
  && (let _ = () in ([@expl:produces_one_invariant ensures #0] [%#smap_inv'3] preservation_inv iter f.final (Seq.snoc self.t_MapInv__produced e))
  && ([@expl:produces_one_invariant ensures #1] [%#smap_inv'4] next_precondition iter f.final (Seq.snoc self.t_MapInv__produced e)))
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 177 4 177 57] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 176 14 176 68
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 12 184 74
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 47
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 27 25 29
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'1] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : ()
  
   =
    [%#smap_inv'7] ()
  
  axiom produces_trans_spec'0: forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. ([%#smap_inv'4] produces'0 a ab b)
   -> ([%#smap_inv'5] produces'0 b bc c)  -> ([%#smap_inv'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self: t_MapInv) : () =
    [%#smap_inv'3] ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. [%#smap_inv'2] produces'0 self (Seq.empty: Seq.seq t_B) self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_MapInv
  
  constant visited  : t_B
  
  constant succ  : t_MapInv
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 177 4 177 57] (self'0: t_MapInv) (visited'0: t_B) (succ'0: t_MapInv)
  
  
  goal vc_produces_one: [@expl:produces_one ensures] [%#smap_inv] ([%#smap_inv'0] exists f: MutBorrow.t t_F, e: t_Item. f.current
  = self.t_MapInv__func
  /\ f.final = succ.t_MapInv__func
  /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
  /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
  /\ precondition f.current { _p0 = e; _p1 = self.t_MapInv__produced }
  /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited)
  = produces'0 self (Seq.singleton visited) succ
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 30 14 30 47
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 31 27 31 29
  let%span sonce'1 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self: t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self: t_Once) (visited: Seq.seq t_T) (o: t_Once)
  
   =
    [%#sonce'1] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Once
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (self'0: t_Once) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sonce] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 34 15 34 32
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 35 15 35 32
  let%span sonce'1 = "../../creusot-contracts/src/std/iter/once.rs" 36 14 36 42
  let%span sonce'2 = "../../creusot-contracts/src/std/iter/once.rs" 37 91 37 93
  let%span sonce'3 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self: t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self: t_Once) (visited: Seq.seq t_T) (o: t_Once)
  
   =
    [%#sonce'3] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Once
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Once
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Once
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (a'0: t_Once) (ab'0: Seq.seq t_T) (b'0: t_Once) (bc'0: Seq.seq t_T) (c'0: t_Once) : ()
  
  
  goal vc_produces_trans: ([%#sonce] produces a ab b)
   -> ([%#sonce'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#sonce'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 34 14 34 47
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 35 27 35 29
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'1] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Range
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (self'0: t_Range) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#srange] produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 38 15 38 32
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 39 15 39 32
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 40 14 40 42
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 41 91 41 93
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'3] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Range
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_Range
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_Range
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (a'0: t_Range) (ab'0: Seq.seq t_Idx) (b'0: t_Range) (bc'0: Seq.seq t_Idx) (c'0: t_Range) : ()
  
  
  goal vc_produces_trans: ([%#srange] produces a ab b)
   -> ([%#srange'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#srange'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 59 14 59 52
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 60 32 60 34
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'1] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Range
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (self'0: t_Range) : ()
  
  goal vc_produces_back_refl: [@expl:produces_back_refl ensures] [%#srange] produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 63 15 63 37
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 64 15 64 37
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 65 14 65 47
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 66 96 66 98
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'3] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Range
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_Range
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_Range
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (a'0: t_Range) (ab'0: Seq.seq t_Idx) (b'0: t_Range) (bc'0: Seq.seq t_Idx) (c'0: t_Range) : ()
  
  
  goal vc_produces_back_trans: ([%#srange] produces_back a ab b)
   -> ([%#srange'0] produces_back b bc c)
   -> ([@expl:produces_back_trans ensures] [%#srange'1] produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant r  : t_RangeInclusive
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r'0: t_RangeInclusive) : int
  
  
  goal vc_range_inclusive_len: ([%#sops] not is_empty_log r  -> deep_model (start_log r) <= deep_model (end_log r))
   -> (if is_empty_log r then
    [@expl:range_inclusive_len ensures] [%#srange] is_empty_log r = (0 = 0)
  else
    [@expl:range_inclusive_len ensures] [%#srange] is_empty_log r
    = (deep_model (end_log r) - deep_model (start_log r) + 1 = 0)
  )
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 103 14 103 47
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 104 27 104 29
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'3] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'2] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'1] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_RangeInclusive
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (self'0: t_RangeInclusive) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#srange] produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 108 15 108 32
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 109 15 109 32
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 110 14 110 42
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 111 91 111 93
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'4 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'5 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'5] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'4] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'3] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_RangeInclusive
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_RangeInclusive
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_RangeInclusive
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (a'0: t_RangeInclusive) (ab'0: Seq.seq t_Idx) (b'0: t_RangeInclusive) (bc'0: Seq.seq t_Idx) (c'0: t_RangeInclusive) : ()
  
  
  goal vc_produces_trans: ([%#srange] produces a ab b)
   -> ([%#srange'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#srange'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 130 14 130 52
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 131 32 131 34
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'3] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'2] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'1] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_RangeInclusive
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (self'0: t_RangeInclusive) : ()
  
  
  goal vc_produces_back_refl: [@expl:produces_back_refl ensures] [%#srange] produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 135 15 135 37
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 136 15 136 37
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 137 14 137 47
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 138 96 138 98
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'4 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'5 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'5] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'4] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'3] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_RangeInclusive
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_RangeInclusive
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_RangeInclusive
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (a'0: t_RangeInclusive) (ab'0: Seq.seq t_Idx) (b'0: t_RangeInclusive) (bc'0: Seq.seq t_Idx) (c'0: t_RangeInclusive) : ()
  
  
  goal vc_produces_back_trans: ([%#srange] produces_back a ab b)
   -> ([%#srange'0] produces_back b bc c)
   -> ([@expl:produces_back_trans ensures] [%#srange'1] produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 30 14 30 47
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 31 27 31 29
  let%span srepeat'1 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 99
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self: t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat)
  
   =
    [%#srepeat'1] self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> postcondition () (view self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Repeat
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (self'0: t_Repeat) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#srepeat] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 34 15 34 32
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 35 15 35 32
  let%span srepeat'1 = "../../creusot-contracts/src/std/iter/repeat.rs" 36 14 36 42
  let%span srepeat'2 = "../../creusot-contracts/src/std/iter/repeat.rs" 37 91 37 93
  let%span srepeat'3 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 99
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self: t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat)
  
   =
    [%#srepeat'3] self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> postcondition () (view self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Repeat
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Repeat
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Repeat
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (a'0: t_Repeat) (ab'0: Seq.seq t_T) (b'0: t_Repeat) (bc'0: Seq.seq t_T) (c'0: t_Repeat) : ()
  
  
  goal vc_produces_trans: ([%#srepeat] produces a ab b)
   -> ([%#srepeat'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#srepeat'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 76 14 76 52
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 80 15 80 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 81 15 81 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 82 14 82 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 46 14 46 47
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 47 27 47 29
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'2 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 73 4 73 70] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 83 4 83 96] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_back_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 77 4 77 32] (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. [%#siter] produces_back self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rev)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rev [inv'0 x]. inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self: t_Rev) : t_I
  
  axiom iter_spec: forall self: t_Rev. [%#srev'2] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev)
  
   =
    [%#srev'1] produces_back (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Rev
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (self'0: t_Rev) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#srev] produces self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 76 14 76 52
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 80 15 80 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 81 15 81 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 82 14 82 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 50 15 50 32
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 51 15 51 32
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 52 14 52 42
  let%span srev'2 = "../../creusot-contracts/src/std/iter/rev.rs" 53 91 53 93
  let%span srev'3 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'4 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 73 4 73 70] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 83 4 83 96] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_back_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 77 4 77 32] (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. [%#siter] produces_back self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rev)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rev [inv'0 x]. inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self: t_Rev) : t_I
  
  axiom iter_spec: forall self: t_Rev. [%#srev'4] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev)
  
   =
    [%#srev'3] produces_back (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Rev
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Rev
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Rev
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (a'0: t_Rev) (ab'0: Seq.seq t_Item) (b'0: t_Rev) (bc'0: Seq.seq t_Item) (c'0: t_Rev) : ()
  
  
  goal vc_produces_trans: ([%#srev] produces a ab b)
   -> ([%#srev'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#srev'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl [#"../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 74 14 74 47
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 75 27 75 29
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 64 12 69 68
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip'3 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self: t_Skip) : int
  
  axiom n_spec: forall self: t_Skip. [%#sskip'2] n self >= 0 /\ n self <= UInt64.t'int v_MAX
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'3] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 62 4 62 64] (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip)
  
   =
    [%#sskip'1] visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Skip
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (self'0: t_Skip) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sskip] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 78 15 78 32
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 79 15 79 32
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 80 14 80 42
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 81 91 81 93
  let%span sskip'3 = "../../creusot-contracts/src/std/iter/skip.rs" 64 12 69 68
  let%span sskip'4 = "../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip'5 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self: t_Skip) : int
  
  axiom n_spec: forall self: t_Skip. [%#sskip'4] n self >= 0 /\ n self <= UInt64.t'int v_MAX
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'5] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 62 4 62 64] (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip)
  
   =
    [%#sskip'3] visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Skip
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Skip
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Skip
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (a'0: t_Skip) (ab'0: Seq.seq t_Item) (b'0: t_Skip) (bc'0: Seq.seq t_Item) (c'0: t_Skip) : ()
  
  
  goal vc_produces_trans: ([%#sskip] produces'0 a ab b)
   -> ([%#sskip'0] produces'0 b bc c)  -> ([@expl:produces_trans ensures] [%#sskip'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl [#"../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 72 14 72 47
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 73 27 73 29
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 67 12 67 88
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 33 14 33 50
  let%span stake'3 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 34 4 34 21] (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. [%#stake'2] n self >= 0 /\ n self <= UInt64.t'int v_MAX
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'3] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 65 4 65 64] (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take)
  
   =
    [%#stake'1] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Take
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (self'0: t_Take) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#stake] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 76 15 76 32
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 77 15 77 32
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 78 14 78 42
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 79 91 79 93
  let%span stake'3 = "../../creusot-contracts/src/std/iter/take.rs" 67 12 67 88
  let%span stake'4 = "../../creusot-contracts/src/std/iter/take.rs" 33 14 33 50
  let%span stake'5 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 34 4 34 21] (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. [%#stake'4] n self >= 0 /\ n self <= UInt64.t'int v_MAX
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'5] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 65 4 65 64] (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take)
  
   =
    [%#stake'3] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Take
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Take
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Take
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (a'0: t_Take) (ab'0: Seq.seq t_Item) (b'0: t_Take) (bc'0: Seq.seq t_Item) (c'0: t_Take) : ()
  
  
  goal vc_produces_trans: ([%#stake] produces'0 a ab b)
   -> ([%#stake'0] produces'0 b bc c)  -> ([@expl:produces_trans ensures] [%#stake'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 54 14 54 47
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 55 27 55 29
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'3 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Zip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip [inv'1 x]. inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self: t_Zip) : t_A
  
  axiom itera_spec: forall self: t_Zip. [%#szip'2] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  
  axiom produces_trans_spec'0: forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self: t_Zip) : t_B
  
  axiom iterb_spec: forall self: t_Zip. [%#szip'3] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip)
  
   =
    [%#szip'1] exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Zip
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (self'0: t_Zip) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#szip] produces'1 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 58 15 58 32
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 59 15 59 32
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 60 14 60 42
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 61 91 61 93
  let%span szip'3 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'4 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'5 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Zip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip [inv'1 x]. inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self: t_Zip) : t_A
  
  axiom itera_spec: forall self: t_Zip. [%#szip'4] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  
  axiom produces_trans_spec'0: forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self: t_Zip) : t_B
  
  axiom iterb_spec: forall self: t_Zip. [%#szip'5] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip)
  
   =
    [%#szip'3] exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Zip
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Zip
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Zip
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (a'0: t_Zip) (ab'0: Seq.seq tuple) (b'0: t_Zip) (bc'0: Seq.seq tuple) (c'0: t_Zip) : ()
  
  
  goal vc_produces_trans: ([%#szip] produces'1 a ab b)
   -> ([%#szip'0] produces'1 b bc c)  -> ([@expl:produces_trans ensures] [%#szip'1] produces'1 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__Iterator__map_inv [#"../../creusot-contracts/src/std/iter.rs" 57 4 60 61]
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 57 4
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 62 45 62 69
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 57 21 57 25
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 57 27 57 31
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 51 15 53 71
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 54 15 54 51
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 55 15 55 70
  let%span siter'5 = "../../creusot-contracts/src/std/iter.rs" 57 39 57 66
  let%span siter'6 = "../../creusot-contracts/src/std/iter.rs" 56 14 56 89
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 152 12 155 47
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 139 12 144 71
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 116 12 118 63
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 73 12 75 73
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 123 14 123 83
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Item
  
  type t_Self
  
  type t_F
  
  type t_MapInv  =
    { t_MapInv__iter: t_Self; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_Self) (visited: Seq.seq t_Item) (o: t_Self)
  
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_Self)
  
  predicate next_precondition [#"../../creusot-contracts/src/std/iter/map_inv.rs" 114 4 114 78] (iter: t_Self) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'1] forall e: t_Item, i: t_Self. produces iter (Seq.singleton e) i
     -> precondition func { _p0 = e; _p1 = produced }
  
  type t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 137 4 137 49] (iter: t_Self) (func: t_F) =
    [%#smap_inv'0] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_Self. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  predicate reinitialize [#"../../creusot-contracts/src/std/iter/map_inv.rs" 150 4 150 33]  =
    [%#smap_inv] forall iter: MutBorrow.t t_Self, func: t_F. completed iter
     -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 124 4 124 77] (iter: t_Self) (func: t_F) (produced: Seq.seq t_Item)
  
  
  axiom preservation_inv_spec: forall iter: t_Self, func: t_F, produced: Seq.seq t_Item. [%#smap_inv'3] produced
  = (Seq.empty: Seq.seq t_Item)  -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/map_inv.rs" 71 4 71 30] (self: t_MapInv) =
    [%#smap_inv'2] reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_MapInv)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'0 func
    end)
  
  type tuple'0  =
    { _p0'0: t_Self; _p1'0: t_F }
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: tuple'0)
  
  axiom precondition_fndef: [%#slib] forall args: tuple'0 [precondition'0 () args]. (let {_p0'0 = self ; _p1'0 = func} = args in preservation self func
  /\ reinitialize
  /\ (forall e: t_Item, i2: t_Self. produces self (Seq.singleton e) i2
   -> precondition func { _p0 = e; _p1 = Seq.empty: Seq.seq t_Item })
  /\ inv'0 func /\ inv self)  -> precondition'0 () args
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: tuple'0) (result: t_MapInv)
  
  
  axiom postcondition_fndef: [%#slib] forall args: tuple'0, res: t_MapInv [postcondition_once'0 () args res]. postcondition_once'0 () args res
   -> (let {_p0'0 = self ; _p1'0 = func} = args in res
  = { t_MapInv__iter = self; t_MapInv__func = func; t_MapInv__produced = Seq.empty: Seq.seq t_Item }
  /\ inv'1 res)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec map_inv[#"../../creusot-contracts/src/std/iter.rs" 57 4 60 61] (self:t_Self) (func:t_F) (return'  (x:t_MapInv))= {[@expl:map_inv 'self' type invariant] [%#siter'0] inv self}
    {[@expl:map_inv 'func' type invariant] [%#siter'1] inv'0 func}
    {[@expl:map_inv requires #0] [%#siter'2] forall e: t_Item, i2: t_Self. produces self (Seq.singleton e) i2
     -> precondition func { _p0 = e; _p1 = Seq.empty: Seq.seq t_Item }}
    {[@expl:map_inv requires #1] [%#siter'3] reinitialize}
    {[@expl:map_inv requires #2] [%#siter'4] preservation self func}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_9 <- [%#siter] Seq.empty: Seq.seq t_Item ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_0 <- { t_MapInv__iter = self'0; t_MapInv__func = func'0; t_MapInv__produced = _9 } ] s1 | s1 = bb6 ]
    
    | bb6 = return''0 {_0} ]
    )
    [ & _0: t_MapInv = Any.any_l ()
    | & self'0: t_Self = self
    | & func'0: t_F = func
    | & _9: Seq.seq t_Item = Any.any_l () ]
    
    [ return''0 (result:t_MapInv)-> {[@expl:map_inv result type invariant] [%#siter'5] inv'1 result}
      {[@expl:map_inv ensures] [%#siter'6] result
      = { t_MapInv__iter = self; t_MapInv__func = func; t_MapInv__produced = Seq.empty: Seq.seq t_Item }}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl [#"../../creusot-contracts/src/std/iter.rs" 233 4 233 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 232 14 232 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 233 27 233 29
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 221 20 221 64
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'5 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'3] produces a ab b)
   -> ([%#siter'4] produces b bc c)  -> ([%#siter'5] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter'2] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 220 4 220 64] (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I)
  
   =
    [%#siter'1] produces self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : MutBorrow.t t_I
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 233 4 233 26] (self'0: MutBorrow.t t_I) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans [#"../../creusot-contracts/src/std/iter.rs" 240 4 240 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 237 15 237 32
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 238 15 238 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 239 14 239 42
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 240 91 240 93
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 221 20 221 64
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'5] produces a ab b)
   -> ([%#siter'6] produces b bc c)  -> ([%#siter'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter'4] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 220 4 220 64] (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I)
  
   =
    [%#siter'3] produces self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : MutBorrow.t t_I
  
  constant ab  : Seq.seq t_Item
  
  constant b  : MutBorrow.t t_I
  
  constant bc  : Seq.seq t_Item
  
  constant c  : MutBorrow.t t_I
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 240 4 240 90] (a'0: MutBorrow.t t_I) (ab'0: Seq.seq t_Item) (b'0: MutBorrow.t t_I) (bc'0: Seq.seq t_Item) (c'0: MutBorrow.t t_I) : ()
  
  
  goal vc_produces_trans: ([%#siter] produces'0 a ab b)
   -> ([%#siter'0] produces'0 b bc c)  -> ([@expl:produces_trans ensures] [%#siter'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_replace_body [#"../../creusot-contracts/src/std/mem.rs" 10 12 10 52]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 10 51 10 52
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'6 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'7 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  let rec swap (x:MutBorrow.t t_T) (y:MutBorrow.t t_T) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'4] inv'0 x}
    {[@expl:swap 'y' type invariant] [%#smem'5] inv'0 y}
    any
    [ return''0 (result:())-> {[%#smem'6] x.final = y.current} {[%#smem'7] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_replace_body[#"../../creusot-contracts/src/std/mem.rs" 10 12 10 52] (dest:MutBorrow.t t_T) (src:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_mem_replace_body 'dest' type invariant] [%#smem] inv'0 dest}
    {[@expl:extern_spec_std_mem_replace_body 'src' type invariant] [%#smem'0] inv src}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &src'1 <- src'0 ] s1
      | s1 = {inv src'1}
        MutBorrow.borrow_mut <t_T> {src'1}
          (fun (_ret:MutBorrow.t t_T) ->  [ &_9 <- _ret ] -{inv _ret.final}-  [ &src'1 <- _ret.final ] s2)
      | s2 = {inv dest'0.current}
        MutBorrow.borrow_final <t_T> {dest'0.current} {MutBorrow.get_id dest'0}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_7 <- _ret ] 
            -{inv _ret.final}-
             [ &dest'0 <- { dest'0 with current = _ret.final } ] 
            s3)
      | s3 = {inv _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv _ret.final}-
             [ &_9 <- { _9 with current = _ret.final } ] 
            s4)
      | s4 = swap {_7} {_8} (fun (_ret:()) ->  [ &_6 <- _ret ] s5)
      | s5 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 _9} s1
      | s1 = -{resolve'0 _9}- s2
      | s2 = {[@expl:type invariant] inv'0 dest'0} s3
      | s3 = -{resolve'0 dest'0}- s4
      | s4 =  [ &_0 <- src'1 ] s5
      | s5 = bb3 ]
    
    | bb3 = return''0 {_0} ]
    )
    [ & _0: t_T = Any.any_l ()
    | & dest'0: MutBorrow.t t_T = dest
    | & src'0: t_T = src
    | & src'1: t_T = Any.any_l ()
    | & _6: () = Any.any_l ()
    | & _7: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_mem_replace_body result type invariant] [%#smem'1] inv result}
      {[@expl:extern_spec_std_mem_replace_body ensures #0] [%#smem'2] dest.final = src}
      {[@expl:extern_spec_std_mem_replace_body ensures #1] [%#smem'3] result = dest.current}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_take_body [#"../../creusot-contracts/src/std/mem.rs" 23 12 23 50]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 139 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 23 49 23 50
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'6 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: ())
  
  axiom precondition_fndef: [%#slib] forall args: () [precondition () args]. (let () = args in true)
   -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: ()) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_T) (src:t_T) (return'  (x:t_T))= {[@expl:replace 'dest' type invariant] [%#smem'3] inv'0 dest}
    {[@expl:replace 'src' type invariant] [%#smem'4] inv src}
    any
    [ return''0 (result:t_T)-> {inv result}
      {[%#smem'5] dest.final = src}
      {[%#smem'6] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve _0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: (), res: t_T [postcondition () args res]. postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'1 self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_take_body[#"../../creusot-contracts/src/std/mem.rs" 23 12 23 50] (dest:MutBorrow.t t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_mem_take_body 'dest' type invariant] [%#smem] inv'0 dest}
    (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv dest'0.current}
        MutBorrow.borrow_final <t_T> {dest'0.current} {MutBorrow.get_id dest'0}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_4 <- _ret ] 
            -{inv _ret.final}-
             [ &dest'0 <- { dest'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_4} {_5} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 dest'0} s1 | s1 = -{resolve'0 dest'0}- s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: t_T = Any.any_l ()
    | & dest'0: MutBorrow.t t_T = dest
    | & _4: MutBorrow.t t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_mem_take_body result type invariant] [%#smem'0] inv result}
      {[@expl:extern_spec_std_mem_take_body ensures #0] [%#smem'1] result = dest.current}
      {[@expl:extern_spec_std_mem_take_body ensures #1] [%#smem'2] postcondition () () dest.final}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_drop_body [#"../../creusot-contracts/src/std/mem.rs" 4 0 40 1]
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 29 23 29 24
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 28 22 28 32
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_drop_body[#"../../creusot-contracts/src/std/mem.rs" 4 0 40 1] (t:t_T) (return'  (x:()))= {[@expl:extern_spec_std_mem_drop_body 't' type invariant] [%#smem] inv t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv t'0} s1 | s1 = -{resolve t'0}- s2 | s2 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () | & t'0: t_T = t ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_mem_drop_body ensures] [%#smem'0] resolve t}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_forget_body [#"../../creusot-contracts/src/std/mem.rs" 4 0 40 1]
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 33 25 33 26
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 32 22 32 32
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_mem_forget_body[#"../../creusot-contracts/src/std/mem.rs" 4 0 40 1] (t:t_T) (return'  (x:()))= {[@expl:extern_spec_std_mem_forget_body 't' type invariant] [%#smem] inv t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv t'0} s1 | s1 = -{resolve t'0}- s2 | s2 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () | & t'0: t_T = t ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_mem_forget_body ensures] [%#smem'0] resolve t}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u8_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u8_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt8.t) (return'  (x:UInt8.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt8.t = Any.any_l () | & self_'0: UInt8.t = self_ ] 
    [ return''0 (result:UInt8.t)-> {[@expl:extern_spec_Clone_u8_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u16_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u16_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt16.t) (return'  (x:UInt16.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt16.t = Any.any_l () | & self_'0: UInt16.t = self_ ] 
    [ return''0 (result:UInt16.t)-> {[@expl:extern_spec_Clone_u16_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u32_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u32_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt32.t) (return'  (x:UInt32.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt32.t = Any.any_l () | & self_'0: UInt32.t = self_ ] 
    [ return''0 (result:UInt32.t)-> {[@expl:extern_spec_Clone_u32_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u64_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u64_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt64.t) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & self_'0: UInt64.t = self_ ] 
    [ return''0 (result:UInt64.t)-> {[@expl:extern_spec_Clone_u64_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u128_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u128_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt128.t) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt128.t = Any.any_l () | & self_'0: UInt128.t = self_ ] 
    [ return''0 (result:UInt128.t)-> {[@expl:extern_spec_Clone_u128_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_usize_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_usize_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt64.t) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & self_'0: UInt64.t = self_ ] 
    [ return''0 (result:UInt64.t)-> {[@expl:extern_spec_Clone_usize_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i8_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i8_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int8.t) (return'  (x:Int8.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int8.t = Any.any_l () | & self_'0: Int8.t = self_ ] 
    [ return''0 (result:Int8.t)-> {[@expl:extern_spec_Clone_i8_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i16_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i16_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int16.t) (return'  (x:Int16.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int16.t = Any.any_l () | & self_'0: Int16.t = self_ ] 
    [ return''0 (result:Int16.t)-> {[@expl:extern_spec_Clone_i16_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i32_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i32_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int32.t) (return'  (x:Int32.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int32.t = Any.any_l () | & self_'0: Int32.t = self_ ] 
    [ return''0 (result:Int32.t)-> {[@expl:extern_spec_Clone_i32_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i64_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i64_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int64.t) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & self_'0: Int64.t = self_ ] 
    [ return''0 (result:Int64.t)-> {[@expl:extern_spec_Clone_i64_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i128_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i128_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int128.t) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int128.t = Any.any_l () | & self_'0: Int128.t = self_ ] 
    [ return''0 (result:Int128.t)-> {[@expl:extern_spec_Clone_i128_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_isize_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_isize_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int64.t) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & self_'0: Int64.t = self_ ] 
    [ return''0 (result:Int64.t)-> {[@expl:extern_spec_Clone_isize_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_Try_Option_T_from_output_body [#"../../creusot-contracts/src/std/ops.rs" 276 36 278 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 278 31 278 37
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 276 28 276 37
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 277 26 277 48
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Try_Option_T_from_output_body[#"../../creusot-contracts/src/std/ops.rs" 276 36 278 18] (output:t_T) (return'  (x:t_Option))= {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body 'output' type invariant] [%#sops] inv output}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- C_Some output'0 ] s1 | s1 = bb2 ]  | bb2 = return''0 {_0} ] )
    [ & _0: t_Option = Any.any_l () | & output'0: t_T = output ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body result type invariant] [%#sops'0] inv'0 result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body ensures] [%#sops'1] result = C_Some output}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_Try_Option_T_branch_body [#"../../creusot-contracts/src/std/ops.rs" 286 16 286 69]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 282 16 282 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 286 35 286 69
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 282 26 285 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 ()
  
  type t_ControlFlow  =
    | C_Continue t_T
    | C_Break t_Option'0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom'0 [@rewrite]: forall x: () [inv'1 x]. inv'1 x = false
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_ControlFlow)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_ControlFlow [inv'3 x]. inv'3 x
  = match x with
    | C_Continue a_0 -> inv a_0
    | C_Break a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Try_Option_T_branch_body[#"../../creusot-contracts/src/std/ops.rs" 286 16 286 69] (self_:t_Option) (return'  (x:t_ControlFlow))= {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body 'self_' type invariant] [%#sops] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb3) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb4) ] 
    | bb4 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &v <- r0 ] s1) | s1 =  [ &_0 <- C_Continue v ] s2 | s2 = bb8 ]
    
    | bb3 = s0 [ s0 =  [ &_6 <- C_None'0 ] s1 | s1 =  [ &_0 <- C_Break _6 ] s2 | s2 = bb8 ] 
    | bb8 = return''0 {_0} ]
    )
    [ & _0: t_ControlFlow = Any.any_l ()
    | & self_'0: t_Option = self_
    | & v: t_T = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l () ]
    
    [ return''0 (result:t_ControlFlow)-> {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body result type invariant] [%#sops'0] inv'3 result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body ensures] [%#sops'1] match self_ with
        | C_Some v -> result = C_Continue v
        | C_None -> result = C_Break (C_None'0)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body [#"../../creusot-contracts/src/std/ops.rs" 294 65 296 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 296 33 296 41
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 294 57 294 66
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 295 26 295 40
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 ()
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom [@rewrite]: forall x: () [inv x]. inv x = false
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'0 x]. inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body[#"../../creusot-contracts/src/std/ops.rs" 294 65 296 18] (residual:t_Option'0) (return'  (x:t_Option))= {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body 'residual' type invariant] [%#sops] inv'0 residual}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = return''0 {_0} ]  ] ) [ & _0: t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body result type invariant] [%#sops'0] inv'2 result}
      {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body ensures] [%#sops'1] result
      = C_None}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_Try_Result_T_E_from_output_body [#"../../creusot-contracts/src/std/ops.rs" 306 42 308 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 308 31 308 37
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 306 31 306 43
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 307 26 307 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_from_output_body[#"../../creusot-contracts/src/std/ops.rs" 306 42 308 18] (output:t_T) (return'  (x:t_Result))= {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body 'output' type invariant] [%#sops] inv output}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- C_Ok output'0 ] s1 | s1 = bb2 ]  | bb2 = return''0 {_0} ] )
    [ & _0: t_Result = Any.any_l () | & output'0: t_T = output ]
    
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body result type invariant] [%#sops'0] inv'1 result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body ensures] [%#sops'1] result = C_Ok output}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_Try_Result_T_E_branch_body [#"../../creusot-contracts/src/std/ops.rs" 316 16 316 72]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 312 16 312 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 316 35 316 72
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 312 26 315 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_Result'0  =
    | C_Ok'0 ()
    | C_Err'0 t_E
  
  type t_ControlFlow  =
    | C_Continue t_T
    | C_Break t_Result'0
  
  let rec v_Ok (input:t_Result) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Ok field_0: t_Result]. C_Ok field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom'0 [@rewrite]: forall x: () [inv'2 x]. inv'2 x = false
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Result'0 [inv'3 x]. inv'3 x
  = match x with
    | C_Ok'0 a_0 -> inv'2 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_ControlFlow)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_ControlFlow [inv'4 x]. inv'4 x
  = match x with
    | C_Continue a_0 -> inv a_0
    | C_Break a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_branch_body[#"../../creusot-contracts/src/std/ops.rs" 316 16 316 72] (self_:t_Result) (return'  (x:t_ControlFlow))= {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body 'self_' type invariant] [%#sops] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 (x0:t_T)-> {self_'0 = C_Ok x0} (! bb4) | br1 (x0:t_E)-> {self_'0 = C_Err x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Err {self_'0} (fun (r0:t_E) ->  [ &e <- r0 ] s1) | s1 =  [ &_7 <- C_Err'0 e ] s2 | s2 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_Break _7 ] s1 | s1 = bb11 ] 
    | bb4 = s0
      [ s0 = v_Ok {self_'0} (fun (r0:t_T) ->  [ &v <- r0 ] s1) | s1 =  [ &_0 <- C_Continue v ] s2 | s2 = bb11 ]
    
    | bb11 = return''0 {_0} ]
    )
    [ & _0: t_ControlFlow = Any.any_l ()
    | & self_'0: t_Result = self_
    | & v: t_T = Any.any_l ()
    | & e: t_E = Any.any_l ()
    | & _7: t_Result'0 = Any.any_l () ]
    
    [ return''0 (result:t_ControlFlow)-> {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body result type invariant] [%#sops'0] inv'4 result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body ensures] [%#sops'1] match self_ with
        | C_Ok v -> result = C_Continue v
        | C_Err e -> result = C_Break (C_Err'0 e)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body [#"../../creusot-contracts/src/std/ops.rs" 324 86 329 18]
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 587 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 329 33 329 41
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 324 75 324 87
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 325 26 328 17
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'9 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'10 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'11 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use creusot.prelude.Any
  
  type t_E
  
  type t_Result  =
    | C_Ok ()
    | C_Err t_E
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: t_E)
  
  axiom precondition_fndef: [%#slib] forall args: t_E [precondition () args]. (let value = args in inv value)
   -> precondition () args
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_E) (result: t_F)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_E, res: t_F [postcondition_once () args res]. postcondition_once () args res
   -> (let value = args in inv'0 res)
  
  let rec from (value:t_E) (return'  (x:t_F))= {[@expl:from requires] precondition () value}
    any [ return''0 (result:t_F)-> {postcondition_once () value result} (! return' {result}) ] 
  
  type t_T
  
  type t_Result'0  =
    | C_Ok'0 t_T
    | C_Err'0 t_F
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom [@rewrite]: forall x: () [inv'1 x]. inv'1 x = false
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result [inv'2 x]. inv'2 x
  = match x with
    | C_Ok a_0 -> inv'1 a_0
    | C_Err a_0 -> inv a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Result'0 [inv'4 x]. inv'4 x
  = match x with
    | C_Ok'0 a_0 -> inv'3 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  type tuple  =
    { _p0: t_Result'0; _p1: t_Result }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_E) (result_state: ()) (result: t_F)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_E, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let value = args in inv'0 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_E) (res: t_F) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_E, res: t_F. [%#sops'11] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'8] hist_inv self b)
   -> ([%#sops'9] hist_inv b c)  -> ([%#sops'10] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'7] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_E) (res_state: ()) (res: t_F) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_E, res_state: (), res: t_F. ([%#sops'5] postcondition_mut self args res_state res)
   -> ([%#sops'6] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'4] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_E) (result: t_F)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_E, res: t_F [postcondition () args res]. postcondition () args res
   -> (let value = args in inv'0 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_E) (res: t_F) : ()
  
  axiom fn_once_spec: forall self: (), args: t_E, res: t_F. [%#sops'3] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_E) (res_state: ()) (res: t_F) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_E, res_state: (), res: t_F. [%#sops'2] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body[#"../../creusot-contracts/src/std/ops.rs" 324 86 329 18] (residual:t_Result) (return'  (x:t_Result'0))= {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body 'residual' type invariant] [%#sops] inv'2 residual}
    (! bb0
    [ bb0 = s0
      [ s0 = v_Err {residual'0} (fun (r0:t_E) ->  [ &e <- r0 ] s1)
      | s1 = from {e} (fun (_ret:t_F) ->  [ &_4 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- C_Err'0 _4 ] s1 | s1 = bb4 ] 
    | bb4 = return''0 {_0} ]
    )
    [ & _0: t_Result'0 = Any.any_l ()
    | & residual'0: t_Result = residual
    | & e: t_E = Any.any_l ()
    | & _4: t_F = Any.any_l () ]
    
    [ return''0 (result:t_Result'0)-> {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body result type invariant] [%#sops'0] inv'4 result}
      {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body ensures] [%#sops'1] match { _p0 = result;
                                                                                                                                       _p1 = residual } with
        | {_p0 = C_Err'0 result'0 ; _p1 = C_Err residual'0} -> postcondition () residual'0 result'0
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_PartialEq_Option_T_eq_body [#"../../creusot-contracts/src/std/option.rs" 26 16 26 48]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 11 16 11 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 12 29 12 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span soption = "../../creusot-contracts/src/std/option.rs" 30 29 30 34
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 28 40 28 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 24 16 24 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 26 29 26 32
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 25 26 25 75
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 13 8 16 9
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  let rec eq (self_:t_T) (rhs:t_T) (return'  (x:bool))= {[@expl:eq 'self_' type invariant] [%#scmp] inv'1 self_}
    {[@expl:eq 'rhs' type invariant] [%#scmp'0] inv'1 rhs}
    any
    [ return''0 (result:bool)-> {[%#scmp'1] result = (deep_model'1 self_ = deep_model'1 rhs)} (! return' {result}) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x = invariant''1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_DeepModelTy
  
  function deep_model'2 [#"../../creusot-contracts/src/std/option.rs" 12 4 12 44] (self: t_Option) : t_Option'0 =
    [%#soption'4] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Option) : t_Option'0 =
    [%#smodel] deep_model'2 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_PartialEq_Option_T_eq_body[#"../../creusot-contracts/src/std/option.rs" 26 16 26 48] (self_:t_Option) (rhs:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body 'self_' type invariant] [%#soption'1] inv'3 self_}
    {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body 'rhs' type invariant] [%#soption'2] inv'3 rhs}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = rhs'0 } ] s1
      | s1 = any [ br0 -> {_4._p0 = C_None} (! bb2) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb4) ]  ]
    
    | bb4 = any [ br0 -> {_4._p1 = C_None} (! bb1) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb6) ] 
    | bb6 = s0
      [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &x <- r0 ] s1)
      | s1 = v_Some {_4._p1} (fun (r0:t_T) ->  [ &y <- r0 ] s2)
      | s2 = eq {x} {y} (fun (_ret:bool) ->  [ &_0 <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb2 = any [ br0 -> {_4._p1 = C_None} (! bb7) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb1) ] 
    | bb1 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb9 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- [%#soption'0] true ] s1 | s1 = bb9 ] 
    | bb9 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Option = self_
    | & rhs'0: t_Option = rhs
    | & _4: tuple = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & y: t_T = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body ensures] [%#soption'3] result
      = (deep_model'3 self_ = deep_model'3 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_T_Clone_Option_T_clone_body [#"../../creusot-contracts/src/std/option.rs" 43 8 43 36]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span soption = "../../creusot-contracts/src/std/option.rs" 38 8 38 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 43 27 43 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 38 18 42 9
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: [%#slib] forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x = invariant''0 x
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone_Option_T_clone_body[#"../../creusot-contracts/src/std/option.rs" 43 8 43 36] (self_:t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_T_Clone_Option_T_clone_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &x <- r0 ] s1)
      | s1 = clone' {x} (fun (_ret:t_T) ->  [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_0 <- C_Some _5 ] s1 | s1 = bb7 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l () | & self_'0: t_Option = self_ | & x: t_T = Any.any_l () | & _5: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_T_Clone_Option_T_clone_body result type invariant] [%#soption'0] inv'1 result}
      {[@expl:extern_spec_T_Clone_Option_T_clone_body ensures] [%#soption'1] match { _p0 = self_; _p1 = result } with
        | {_p0 = C_None ; _p1 = C_None} -> true
        | {_p0 = C_Some s ; _p1 = C_Some r} -> postcondition () s r
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_some_body [#"../../creusot-contracts/src/std/option.rs" 59 16 59 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 62 35 62 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 61 32 61 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 57 16 57 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 58 26 58 51
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_some_body[#"../../creusot-contracts/src/std/option.rs" 59 16 59 41] (self_:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_some_body 'self_' type invariant] [%#soption'1] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [%#soption] true ] s1 | s1 = bb5 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption'0] false ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: bool = Any.any_l () | & self_'0: t_Option = self_ ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_some_body ensures] [%#soption'2] result
      = (self_ <> C_None)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_some_and_body [#"../../creusot-contracts/src/std/option.rs" 74 16 74 71]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 189 35 189 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 76 32 76 37
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 66 16 66 17
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 74 37 74 38
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 66 27 69 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 70 26 73 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type impl_FnOnce_T_____bool
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: impl_FnOnce_T_____bool)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: impl_FnOnce_T_____bool) (args: t_T)
  
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: impl_FnOnce_T_____bool) (args: t_T) (result: bool)
  
  
  let rec call_once (self_:impl_FnOnce_T_____bool) (arg:t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: impl_FnOnce_T_____bool)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_some_and_body[#"../../creusot-contracts/src/std/option.rs" 74 16 74 71] (self_:t_Option) (f:impl_FnOnce_T_____bool) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'self_' type invariant] [%#soption'0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'f' type invariant] [%#soption'1] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body requires] [%#soption'2] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_8 <- t ] s2
      | s2 = call_once {f'0} {_8} (fun (_ret:bool) ->  [ &_0 <- _ret ] s3)
      | s3 = bb10 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb10 ] 
    | bb10 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: impl_FnOnce_T_____bool = f
    | & t: t_T = Any.any_l ()
    | & _8: t_T = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body ensures] [%#soption'3] match self_ with
        | C_None -> result = false
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_none_body [#"../../creusot-contracts/src/std/option.rs" 83 16 83 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 86 35 86 40
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 85 32 85 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 81 16 81 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_is_none_body[#"../../creusot-contracts/src/std/option.rs" 83 16 83 41] (self_:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_none_body 'self_' type invariant] [%#soption'1] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb5 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption'0] true ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: bool = Any.any_l () | & self_'0: t_Option = self_ ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_none_body ensures] [%#soption'2] result
      = (self_ = C_None)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_ref_body [#"../../creusot-contracts/src/std/option.rs" 95 16 95 46]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 90 16 90 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 95 36 95 46
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 91 26 91 58
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 93 20 93 89
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_ref_body[#"../../creusot-contracts/src/std/option.rs" 95 16 95 46] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_as_ref_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- C_Some'0 t ] s2 | s2 = bb5 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: t_Option'0 = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_ref_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #0] [%#soption'1] self_ = C_None
       -> result = C_None'0}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #1] [%#soption'2] self_ = C_None
      \/ (exists r: t_T. result = C_Some'0 r /\ self_ = C_Some r)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_mut_body [#"../../creusot-contracts/src/std/option.rs" 108 16 108 54]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 108 40 108 54
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve _0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Option [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Option) =
    resolve'1 _0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_mut_body[#"../../creusot-contracts/src/std/option.rs" 108 16 108 54] (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_as_mut_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 =  [ &_0 <- C_Some'0 _6 ] s3
      | s3 = {[@expl:type invariant] inv'0 t} s4
      | s4 = -{resolve'0 t}- s5
      | s5 = bb5 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _6: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_mut_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #0] [%#soption'1] self_.current = C_None
       -> result = C_None'0 /\ self_.final = C_None}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #1] [%#soption'2] self_.current = C_None
      \/ (exists r: MutBorrow.t t_T. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_slice_body [#"../../creusot-contracts/src/std/option.rs" 120 16 120 42]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 424 27 424 28
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 422 22 422 40
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 423 22 423 38
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 20 20 20 30
  let%span soption = "../../creusot-contracts/src/std/option.rs" 115 16 115 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 120 38 120 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 116 26 119 17
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/logic/seq.rs" 682 4 682 30] (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'2] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'3] view self = Slice64.id self
  
  predicate invariant''2 [#"../../creusot-contracts/src/std/slice.rs" 19 4 19 30] (self: Slice64.slice t_T) =
    [%#sslice'4] inv'2 (view self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Slice64.slice t_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Slice64.slice t_T [inv'3 x]. inv'3 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: Slice64.slice t_T) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Slice64.slice t_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: Slice64.slice t_T [inv'4 x]. inv'4 x = invariant''3 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  let rec from_ref (s:t_T) (return'  (x:Slice64.slice t_T))= {[@expl:from_ref 's' type invariant] [%#sslice] inv'0 s}
    any
    [ return''0 (result:Slice64.slice t_T)-> {inv'4 result}
      {[%#sslice'0] Seq.length (view'0 result) = 1}
      {[%#sslice'1] Seq.get (view'0 result) 0 = s}
      (! return' {result}) ]
  
  
  let rec promoted0__extern_spec_std_option_T_Option_T_as_slice_body (return'  (x:Slice64.array t_T))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array t_T)-> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Slice64.array t_T = Any.any_l () | & _1: Slice64.array t_T = Any.any_l () ] 
    [ return''0 (result:Slice64.array t_T)-> return' {result} ]
  
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''4 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'5 self
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option [inv'6 x]. inv'6 x = invariant''4 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_slice_body[#"../../creusot-contracts/src/std/option.rs" 120 16 120 42] (self_:t_Option) (return'  (x:Slice64.slice t_T))= {[@expl:extern_spec_std_option_T_Option_T_as_slice_body 'self_' type invariant] [%#soption] inv'6 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = from_ref {t} (fun (_ret:Slice64.slice t_T) ->  [ &_9 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_3 <- _9 ] s1 | s1 = bb6 ] 
    | bb4 = s0
      [ s0 = promoted0__extern_spec_std_option_T_Option_T_as_slice_body 
          (fun (pr0:Slice64.array t_T) ->  [ &_11 <- pr0 ] s1)
      | s1 =  [ &_6 <- _11 ] s2
      | s2 =  [ &_3 <- _6 ] s3
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- _3 ] s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Slice64.slice t_T = Any.any_l ()
    | & self_'0: t_Option = self_
    | & _3: Slice64.slice t_T = Any.any_l ()
    | & _6: Slice64.array t_T = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _9: Slice64.slice t_T = Any.any_l ()
    | & _11: Slice64.array t_T = Any.any_l () ]
    
    [ return''0 (result:Slice64.slice t_T)-> {[@expl:extern_spec_std_option_T_Option_T_as_slice_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_slice_body ensures] [%#soption'1] match self_ with
        | C_None -> Seq.length (view'0 result) = 0
        | C_Some t -> Seq.length (view'0 result) = 1 /\ Seq.get (view'0 result) 0 = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_mut_slice_body [#"../../creusot-contracts/src/std/option.rs" 135 16 135 54]
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 10 20 10 30
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 431 27 431 28
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 427 22 427 40
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 428 22 428 38
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 429 22 429 43
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 430 22 430 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 20 20 20 30
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 127 16 127 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 135 46 135 54
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 128 26 134 17
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/logic/seq.rs" 682 4 682 30] (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'4] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'5] view self = Slice64.id self
  
  predicate invariant''2 [#"../../creusot-contracts/src/std/slice.rs" 19 4 19 30] (self: Slice64.slice t_T) =
    [%#sslice'6] inv'2 (view self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Slice64.slice t_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Slice64.slice t_T [inv'3 x]. inv'3 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t (Slice64.slice t_T))
  
   =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t (Slice64.slice t_T))
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t (Slice64.slice t_T) [inv'4 x]. inv'4 x = invariant''3 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  let rec from_mut (s:MutBorrow.t t_T) (return'  (x:MutBorrow.t (Slice64.slice t_T)))= {[@expl:from_mut 's' type invariant] [%#sslice] inv'0 s}
    any
    [ return''0 (result:MutBorrow.t (Slice64.slice t_T))-> {inv'4 result}
      {[%#sslice'0] Seq.length (view'0 result) = 1}
      {[%#sslice'1] Seq.get (view'0 result) 0 = s.current}
      {[%#sslice'2] Seq.length (view result.final) = 1}
      {[%#sslice'3] Seq.get (view result.final) 0 = s.final}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t (Slice64.slice t_T)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t (Slice64.slice t_T)) =
    resolve _0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve'1 _0
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''4 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Option) =
    resolve'3 _0
  
  predicate invariant''5 [#"../../creusot-contracts/src/std/array.rs" 9 4 9 30] (self: Slice64.array t_T) =
    [%#sarray] inv'2 (Slice64.id self)
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Slice64.array t_T)
  
  axiom inv_axiom'6 [@rewrite]: forall x: Slice64.array t_T [inv'7 x]. inv'7 x = invariant''5 x
  
  let rec promoted0__extern_spec_std_option_T_Option_T_as_mut_slice_body (return'  (x:MutBorrow.t (Slice64.array t_T)))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array t_T)-> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 = {inv'7 _1}
        MutBorrow.borrow_mut <Slice64.array t_T> {_1}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_0 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_1 <- _ret.final ] 
            s2)
      | s2 = return''0 {_0} ]
     ]
     [ & _0: MutBorrow.t (Slice64.array t_T) = Any.any_l () | & _1: Slice64.array t_T = Any.any_l () ] 
    [ return''0 (result:MutBorrow.t (Slice64.array t_T))-> return' {result} ]
  
  
  predicate invariant''6 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t (Slice64.array t_T))
  
   =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t (Slice64.array t_T))
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t (Slice64.array t_T) [inv'8 x]. inv'8 x = invariant''6 x
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t (Slice64.array t_T)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t (Slice64.array t_T)) =
    resolve'5 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_as_mut_slice_body[#"../../creusot-contracts/src/std/option.rs" 135 16 135 54] (self_:MutBorrow.t t_Option) (return'  (x:MutBorrow.t (Slice64.slice t_T)))= {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body 'self_' type invariant] [%#soption] inv'6 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_11 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 = from_mut {_11} (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->  [ &_10 <- _ret ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0
      [ s0 = {inv'3 _10.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_4 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_10 <- { _10 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'0 t} s4
      | s4 = -{resolve'2 t}- s5
      | s5 = bb6 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'6 self_'0} s1 | s1 = -{resolve'4 self_'0}- s2 | s2 = bb4 ] 
    | bb4 = s0
      [ s0 = promoted0__extern_spec_std_option_T_Option_T_as_mut_slice_body 
          (fun (pr0:MutBorrow.t (Slice64.array t_T)) ->  [ &_12 <- pr0 ] s1)
      | s1 = {inv'7 _12.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_7 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_12 <- { _12 with current = _ret.final } ] 
            s2)
      | s2 = {inv'7 _7.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_7.current} {MutBorrow.get_id _7}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_6 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_7 <- { _7 with current = _ret.final } ] 
            s3)
      | s3 =  [ &_4 <- _6 ] s4
      | s4 = {[@expl:type invariant] inv'8 _7} s5
      | s5 = -{resolve'6 _7}- s6
      | s6 = bb8 ]
    
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'8 _12} s1 | s1 = -{resolve'6 _12}- s2 | s2 = bb6 ] 
    | bb6 = s0
      [ s0 = {inv'3 _4.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_4.current} {MutBorrow.get_id _4}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_2 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_4 <- { _4 with current = _ret.final } ] 
            s1)
      | s1 = {inv'3 _2.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_0 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_2 <- { _2 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 _4} s3
      | s3 = -{resolve'0 _4}- s4
      | s4 = {[@expl:type invariant] inv'4 _2} s5
      | s5 = -{resolve'0 _2}- s6
      | s6 = {[@expl:type invariant] inv'6 self_'0} s7
      | s7 = -{resolve'4 self_'0}- s8
      | s8 = return''0 {_0} ]
     ]
    )
    [ & _0: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & _2: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _4: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _6: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & _7: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _11: MutBorrow.t t_T = Any.any_l ()
    | & _12: MutBorrow.t (Slice64.array t_T) = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t (Slice64.slice t_T))-> {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body ensures] [%#soption'1] match self_.current with
        | C_None -> Seq.length (view'0 result) = 0
        | C_Some _ -> exists b: MutBorrow.t t_T. self_.current = C_Some (b.current)
        /\ self_.final = C_Some (b.final)
        /\ Seq.get (view result.current) 0 = b.current
        /\ Seq.get (view result.final) 0 = b.final
        /\ Seq.length (view result.current) = 1 /\ Seq.length (view result.final) = 1
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_expect_body [#"../../creusot-contracts/src/std/option.rs" 145 16 145 47]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 142 16 142 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 143 27 143 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 145 46 145 47
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 144 26 144 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_expect_body[#"../../creusot-contracts/src/std/option.rs" 145 16 145 47] (self_:t_Option) (msg:string) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_expect_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_expect_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb6 ] 
    | bb6 = return''0 {_0}
    | bb4 = {false} any ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_expect_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_expect_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_body [#"../../creusot-contracts/src/std/option.rs" 155 16 155 36]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 155 35 155 36
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_body[#"../../creusot-contracts/src/std/option.rs" 155 16 155 36] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb6 ] 
    | bb6 = return''0 {_0}
    | bb4 = {false} any ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_body [#"../../creusot-contracts/src/std/option.rs" 165 16 165 51]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 162 16 162 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 165 35 165 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 165 50 165 51
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 163 26 163 60
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 164 26 164 84
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_body[#"../../creusot-contracts/src/std/option.rs" 165 16 165 51] (self_:t_Option) (default:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'default' type invariant] [%#soption'0] inv default}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb8 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- default'0 ] s1 | s1 = bb8 ] 
    | bb8 = return''0 {_0} ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & default'0: t_T = default | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #0] [%#soption'2] self_ = C_None
       -> result = default}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #1] [%#soption'3] self_ = C_None
      \/ self_ = C_Some result /\ resolve default}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body [#"../../creusot-contracts/src/std/option.rs" 177 16 179 36]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 172 16 172 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 177 43 177 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 172 27 172 62
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 177 52 177 53
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 173 26 176 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: ()) (result: t_T)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_T))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_T)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body[#"../../creusot-contracts/src/std/option.rs" 177 16 179 36] (self_:t_Option) (f:t_F) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body requires] [%#soption'1] self_ = C_None
     -> precondition f ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb9 ]
    
    | bb4 = s0 [ s0 = call_once {f'0} {_7} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb9 ] 
    | bb9 = return''0 {_0} ]
    )
    [ & _0: t_T = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & _7: () = Any.any_l ()
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body result type invariant] [%#soption'2] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_default_body [#"../../creusot-contracts/src/std/option.rs" 188 16 190 30]
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 139 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span soption = "../../creusot-contracts/src/std/option.rs" 186 16 186 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 188 46 188 47
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 186 26 186 79
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 187 26 187 62
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: ())
  
  axiom precondition_fndef: [%#slib] forall args: () [precondition () args]. (let () = args in true)
   -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: ()) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: (), res: t_T [postcondition () args res]. postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_default_body[#"../../creusot-contracts/src/std/option.rs" 188 16 190 30] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body 'self_' type invariant] [%#soption] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb4 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body result type invariant] [%#soption'0] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #0] [%#soption'1] self_ = C_None
       -> postcondition () () result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #1] [%#soption'2] self_ = C_None
      \/ self_ = C_Some result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_unchecked_body [#"../../creusot-contracts/src/std/option.rs" 200 16 200 53]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 197 16 197 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 198 27 198 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 200 52 200 53
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 199 26 199 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_unwrap_unchecked_body[#"../../creusot-contracts/src/std/option.rs" 200 16 200 53] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb6 ] 
    | bb6 = return''0 {_0}
    | bb4 = {false} any ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_body [#"../../creusot-contracts/src/std/option.rs" 215 16 217 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 189 35 189 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 207 16 207 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 215 35 215 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 207 27 210 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 215 44 215 53
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 211 26 214 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_T) (result: t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'2 result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'4 x]. inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_body[#"../../creusot-contracts/src/std/option.rs" 215 16 217 37] (self_:t_Option) (f:t_F) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_map_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_map_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_9 <- t ] s2
      | s2 = call_once {f'0} {_9} (fun (_ret:t_U) ->  [ &_7 <- _ret ] s3)
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- C_Some'0 _7 ] s1 | s1 = bb11 ] 
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb11 ] 
    | bb11 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & t: t_T = Any.any_l ()
    | & _7: t_U = Any.any_l ()
    | & _9: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_body result type invariant] [%#soption'2] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> exists r: t_U. result = C_Some'0 r /\ postcondition_once f t r
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_inspect_body [#"../../creusot-contracts/src/std/option.rs" 233 16 235 33]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 189 35 189 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 224 16 224 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 233 36 233 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 224 27 227 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 233 45 233 54
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 228 26 228 40
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 229 26 232 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_T) (result: ())
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:()))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:())-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_inspect_body[#"../../creusot-contracts/src/std/option.rs" 233 16 235 33] (self_:t_Option) (f:t_F) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_12 <- t ] s2
      | s2 =  [ &_10 <- _12 ] s3
      | s3 = call_once {f'0} {_10} (fun (_ret:()) ->  [ &_8 <- _ret ] s4)
      | s4 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb10 ] 
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb10 ] 
    | bb10 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _10: t_T = Any.any_l ()
    | & _12: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_inspect_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #0] [%#soption'3] result = self_}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #1] [%#soption'4] match self_ with
        | C_None -> true
        | C_Some t -> postcondition_once f t ()
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_body [#"../../creusot-contracts/src/std/option.rs" 250 16 252 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 189 35 189 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 242 16 242 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 250 38 250 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 250 50 250 51
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 242 27 245 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 250 59 250 60
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 246 26 249 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_U
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_U)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_T) (result: t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:t_U)-> {inv result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_or_body[#"../../creusot-contracts/src/std/option.rs" 250 16 252 37] (self_:t_Option) (default:t_U) (f:t_F) (return'  (x:t_U))= {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'default' type invariant] [%#soption'0] inv default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'f' type invariant] [%#soption'1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body requires] [%#soption'2] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_9 <- t ] s4
      | s4 = call_once {f'0} {_9} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s5)
      | s5 = bb11 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 f'0} s1 | s1 = -{resolve'0 f'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- default'0 ] s1 | s1 = bb11 ] 
    | bb11 = return''0 {_0} ]
    )
    [ & _0: t_U = Any.any_l ()
    | & self_'0: t_Option = self_
    | & default'0: t_U = default
    | & f'0: t_F = f
    | & t: t_T = Any.any_l ()
    | & _9: t_T = Any.any_l () ]
    
    [ return''0 (result:t_U)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_body result type invariant] [%#soption'3] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_body ensures] [%#soption'4] match self_ with
        | C_None -> result = default
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_else_body [#"../../creusot-contracts/src/std/option.rs" 267 16 270 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 189 35 189 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 259 16 259 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 267 46 267 53
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 267 58 267 59
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 259 27 262 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 267 67 267 68
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 263 26 266 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_D
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_D)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_D)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_F
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_T)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_T) (result: t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'3 result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_D) (args: ())
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_D) (args: ()) (result: t_U)
  
  
  let rec call_once'0 (self_:t_D) (arg:()) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'1] precondition'0 self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'3 result} {[%#sops'2] postcondition_once'0 self_ arg result} (! return' {result}) ]
  
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body[#"../../creusot-contracts/src/std/option.rs" 267 16 270 37] (self_:t_Option) (default:t_D) (f:t_F) (return'  (x:t_U))= {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'default' type invariant] [%#soption'0] inv default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'f' type invariant] [%#soption'1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body requires] [%#soption'2] match self_ with
      | C_None -> precondition'0 default ()
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_11 <- t ] s4
      | s4 = call_once {f'0} {_11} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s5)
      | s5 = bb12 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 f'0} s1 | s1 = -{resolve'0 f'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 = call_once'0 {default'0} {_8} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s1) | s1 = bb12 ] 
    | bb12 = return''0 {_0} ]
    )
    [ & _0: t_U = Any.any_l ()
    | & self_'0: t_Option = self_
    | & default'0: t_D = default
    | & f'0: t_F = f
    | & _8: () = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _11: t_T = Any.any_l () ]
    
    [ return''0 (result:t_U)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body result type invariant] [%#soption'3] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body ensures] [%#soption'4] match self_ with
        | C_None -> postcondition_once'0 default () result
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_body [#"../../creusot-contracts/src/std/option.rs" 282 16 282 57]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 277 16 277 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 282 34 282 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 282 45 282 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 278 26 281 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_E
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_E)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result [inv'2 x]. inv'2 x
  = match x with
    | C_Ok a_0 -> inv'0 a_0
    | C_Err a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_ok_or_body[#"../../creusot-contracts/src/std/option.rs" 282 16 282 57] (self_:t_Option) (err:t_E) (return'  (x:t_Result))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'err' type invariant] [%#soption'0] inv err}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv err'0} s1
      | s1 = -{resolve err'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Ok t ] s4
      | s4 = bb10 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_Err err'0 ] s1 | s1 = bb10 ] 
    | bb10 = return''0 {_0} ]
    ) [ & _0: t_Result = Any.any_l () | & self_'0: t_Option = self_ | & err'0: t_E = err | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_body result type invariant] [%#soption'1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_body ensures] [%#soption'2] match self_ with
        | C_None -> result = C_Err err
        | C_Some t -> result = C_Ok t /\ resolve err
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_else_body [#"../../creusot-contracts/src/std/option.rs" 294 16 296 36]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 289 16 289 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 294 42 294 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 289 27 289 64
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 294 53 294 65
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 290 26 293 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: ()) (result: t_E)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_E))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_E)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result [inv'3 x]. inv'3 x
  = match x with
    | C_Ok a_0 -> inv'1 a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body[#"../../creusot-contracts/src/std/option.rs" 294 16 296 36] (self_:t_Option) (err:t_F) (return'  (x:t_Result))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'err' type invariant] [%#soption'0] inv err}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body requires] [%#soption'1] self_ = C_None
     -> precondition err ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv err'0} s1
      | s1 = -{resolve err'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Ok t ] s4
      | s4 = bb11 ]
    
    | bb4 = s0 [ s0 = call_once {err'0} {_8} (fun (_ret:t_E) ->  [ &_6 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- C_Err _6 ] s1 | s1 = bb11 ] 
    | bb11 = return''0 {_0} ]
    )
    [ & _0: t_Result = Any.any_l ()
    | & self_'0: t_Option = self_
    | & err'0: t_F = err
    | & _6: t_E = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> exists r: t_E. result = C_Err r /\ postcondition_once err () r
        | C_Some t -> result = C_Ok t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_body [#"../../creusot-contracts/src/std/option.rs" 306 16 306 61]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 303 16 303 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 306 32 306 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 306 52 306 61
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 304 26 304 75
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 305 26 305 76
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Option) =
    resolve'0 _0
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_U)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option'0) =
    [%#sresolve] match self with
      | C_Some'0 x -> resolve'2 x
      | C_None'0 -> true
      end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Option'0) =
    resolve'3 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_and_body[#"../../creusot-contracts/src/std/option.rs" 306 16 306 61] (self_:t_Option) (optb:t_Option'0) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_body 'optb' type invariant] [%#soption'0] inv'2 optb}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_'0} s1
      | s1 = -{resolve'1 self_'0}- s2
      | s2 =  [ &_0 <- optb'0 ] s3
      | s3 = bb7 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'2 optb'0} s1
      | s1 = -{resolve'4 optb'0}- s2
      | s2 = {[@expl:type invariant] inv'0 self_'0} s3
      | s3 = -{resolve'1 self_'0}- s4
      | s4 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    ) [ & _0: t_Option'0 = Any.any_l () | & self_'0: t_Option = self_ | & optb'0: t_Option'0 = optb ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_body result type invariant] [%#soption'1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #0] [%#soption'2] self_ = C_None
       -> result = C_None'0 /\ resolve'3 optb}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #1] [%#soption'3] self_ = C_None
      \/ result = optb /\ resolve'0 self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_then_body [#"../../creusot-contracts/src/std/option.rs" 321 16 323 45]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 189 35 189 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 313 16 313 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 321 40 321 41
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 313 27 316 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 321 49 321 58
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 317 26 320 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_T) (result: t_Option'0)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_Option'0))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_Option'0)-> {inv'3 result}
      {[%#sops'2] postcondition_once self_ arg result}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_and_then_body[#"../../creusot-contracts/src/std/option.rs" 321 16 323 45] (self_:t_Option) (f:t_F) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_8 <- t ] s2
      | s2 = call_once {f'0} {_8} (fun (_ret:t_Option'0) ->  [ &_0 <- _ret ] s3)
      | s3 = bb10 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb10 ] 
    | bb10 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_then_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_then_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_filter_body [#"../../creusot-contracts/src/std/option.rs" 341 16 343 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 189 35 189 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 330 16 330 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 341 35 341 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 330 27 333 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 341 52 341 61
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 334 26 340 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_P
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_P)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_P) (args: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_P) (args: t_T) (result: bool)
  
  
  let rec call_once (self_:t_P) (arg:t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_P)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_filter_body[#"../../creusot-contracts/src/std/option.rs" 341 16 343 41] (self_:t_Option) (predicate':t_P) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_filter_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'predicate' type invariant] [%#soption'0] inv predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition predicate' t
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_11 <- t ] s2
      | s2 =  [ &_9 <- _11 ] s3
      | s3 = call_once {predicate''0} {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s4)
      | s4 = bb5 ]
    
    | bb5 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb6) ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb14 ] 
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve t}- s2 | s2 = bb9 ] 
    | bb9 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb14 ] 
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv predicate''0} s1 | s1 = -{resolve'0 predicate''0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb14 ] 
    | bb14 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & predicate''0: t_P = predicate'
    | & t: t_T = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_T = Any.any_l ()
    | & _11: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_filter_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_filter_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None
        | C_Some t -> match result with
          | C_None -> postcondition_once predicate' t false /\ resolve t
          | C_Some r -> postcondition_once predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_body [#"../../creusot-contracts/src/std/option.rs" 353 16 353 57]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 350 16 350 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 353 28 353 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 353 48 353 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 351 26 351 57
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 352 26 352 76
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_or_body[#"../../creusot-contracts/src/std/option.rs" 353 16 353 57] (self_:t_Option) (optb:t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_or_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_body 'optb' type invariant] [%#soption'0] inv'0 optb}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'0 optb'0} s1
      | s1 = -{resolve'1 optb'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Some t ] s4
      | s4 = bb9 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- optb'0 ] s1 | s1 = bb9 ] 
    | bb9 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & optb'0: t_Option = optb
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_or_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #0] [%#soption'2] self_ = C_None  -> result = optb}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #1] [%#soption'3] self_ = C_None
      \/ result = self_ /\ resolve'0 optb}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_else_body [#"../../creusot-contracts/src/std/option.rs" 365 16 367 44]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 360 16 360 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 365 36 365 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 360 27 360 62
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 365 45 365 54
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 361 26 364 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: ()) (result: t_Option)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_Option))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_Option)-> {inv'1 result}
      {[%#sops'1] postcondition_once self_ arg result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_or_else_body[#"../../creusot-contracts/src/std/option.rs" 365 16 367 44] (self_:t_Option) (f:t_F) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body requires] [%#soption'1] self_ = C_None  -> precondition f ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Some t ] s4
      | s4 = bb10 ]
    
    | bb4 = s0 [ s0 = call_once {f'0} {_7} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & _7: () = Any.any_l ()
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_or_else_body result type invariant] [%#soption'2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = C_Some t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_xor_body [#"../../creusot-contracts/src/std/option.rs" 381 16 381 58]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 374 16 374 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 381 29 381 33
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 381 49 381 58
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 375 26 380 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_xor_body[#"../../creusot-contracts/src/std/option.rs" 381 16 381 58] (self_:t_Option) (optb:t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_xor_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_xor_body 'optb' type invariant] [%#soption'0] inv'0 optb}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = optb'0 } ] s1 | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4._p0 = C_None} (! bb6) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb4) ] 
    | bb4 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 = any [ br0 -> {_4._p1 = C_None} (! bb9) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb24) ]  ]
    
    | bb24 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p0 = C_Some x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = bb3 ]
    
    | bb9 = s0 [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 = bb10 ] 
    | bb6 = any [ br0 -> {_4._p1 = C_None} (! bb23) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb8) ] 
    | bb23 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = C_Some x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = C_Some x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb16 ] 
    | bb8 = s0 [ s0 = v_Some {_4._p1} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb16 ] 
    | bb16 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & optb'0: t_Option = optb
    | & _4: tuple = Any.any_l ()
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_xor_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_xor_body ensures] [%#soption'2] match { _p0 = self_; _p1 = optb } with
        | {_p0 = C_None ; _p1 = C_None} -> result = C_None
        | {_p0 = C_Some t1 ; _p1 = C_Some t2} -> result = C_None /\ resolve t1 /\ resolve t2
        | {_p0 = C_Some t ; _p1 = C_None} -> result = C_Some t
        | {_p0 = C_None ; _p1 = C_Some t} -> result = C_Some t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_insert_body [#"../../creusot-contracts/src/std/option.rs" 394 16 394 56]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 388 16 388 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 394 37 394 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 394 50 394 56
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 389 26 392 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 393 26 393 68
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve'2 _0
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Option [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Option) =
    resolve'4 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_insert_body[#"../../creusot-contracts/src/std/option.rs" 394 16 394 56] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_insert_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_insert_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_6 <- C_Some value'0 ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _6 } ] s3
      | s3 = bb4 ]
    
    | bb4 = any [ br0 -> {self_'0.current = C_None} (! bb6) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb7) ] 
    | bb7 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &v <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv _ret.final}-
             [ &v <- { v with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 v} s3
      | s3 = -{resolve'3 v}- s4
      | s4 = {inv _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv _ret.final}-
             [ &_8 <- { _8 with current = _ret.final } ] 
            s5)
      | s5 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s6)
      | s6 = {[@expl:type invariant] inv'1 _8} s7
      | s7 = -{resolve'3 _8}- s8
      | s8 = {[@expl:type invariant] inv'1 _3} s9
      | s9 = -{resolve'3 _3}- s10
      | s10 = bb9 ]
    
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = return''0 {_0} ] 
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = bb8 ] 
    | bb8 = {false} any ]
    )
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & value'0: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_insert_body result type invariant] [%#soption'1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #0] [%#soption'2] match self_.current with
        | C_Some t -> resolve t
        | C_None -> true
        end}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #1] [%#soption'3] result.current = value
      /\ self_.final = C_Some (result.final)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_body [#"../../creusot-contracts/src/std/option.rs" 407 16 407 63]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 402 16 402 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 407 44 407 49
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 407 57 407 63
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 403 26 406 17
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve'2 _0
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Option [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Option) =
    resolve'4 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_body[#"../../creusot-contracts/src/std/option.rs" 407 16 407 63] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv value'0} s1 | s1 = -{resolve value'0}- s2 | s2 = bb9 ] 
    | bb4 = s0 [ s0 =  [ &_7 <- C_Some value'0 ] s1 | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _7 } ] s3
      | s3 = bb9 ]
    
    | bb9 = any [ br0 -> {self_'0.current = C_None} (! bb11) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb12) ] 
    | bb12 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &v <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_9 <- _ret ] 
            -{inv _ret.final}-
             [ &v <- { v with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 v} s3
      | s3 = -{resolve'3 v}- s4
      | s4 = {inv _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv _ret.final}-
             [ &_9 <- { _9 with current = _ret.final } ] 
            s5)
      | s5 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s6)
      | s6 = {[@expl:type invariant] inv'1 _9} s7
      | s7 = -{resolve'3 _9}- s8
      | s8 = {[@expl:type invariant] inv'1 _3} s9
      | s9 = -{resolve'3 _3}- s10
      | s10 = bb14 ]
    
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = return''0 {_0} ]
    
    | bb11 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = bb13 ] 
    | bb13 = {false} any ]
    )
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & value'0: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _7: t_Option = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body result type invariant] [%#soption'1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body ensures] [%#soption'2] match self_.current with
        | C_None -> result.current = value /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final) /\ resolve value
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body [#"../../creusot-contracts/src/std/option.rs" 423 16 425 36]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 418 16 418 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 423 52 423 53
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 418 27 418 63
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 423 61 423 67
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 419 26 422 17
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve'0 _0
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: ())
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: ()) (result: t_T)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_T))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_T)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve'2 x
      | C_None -> true
      end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Option) =
    resolve'3 _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Option [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'0 [inv'4 x]. inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption'4] inv'3 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'4 result}
      {[%#soption'5] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'6] self_.current = C_None
      \/ (exists r: MutBorrow.t t_T. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_T))= {[@expl:unwrap 'self_' type invariant] [%#soption'7] inv'4 self_}
    {[@expl:unwrap requires] [%#soption'8] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_T)-> {inv'1 result} {[%#soption'9] C_Some'0 result = self_} (! return' {result}) ]
  
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Option) =
    resolve'5 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body[#"../../creusot-contracts/src/std/option.rs" 423 16 425 36] (self_:MutBorrow.t t_Option) (f:t_F) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body requires] [%#soption'1] self_.current = C_None
     -> precondition f ()}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv'0 r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv'0 _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s3))
      | s3 = {inv'0 t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'1 t} s5
      | s5 = -{resolve'1 t}- s6
      | s6 = bb12 ]
    
    | bb4 = s0 [ s0 = call_once {f'0} {_12} (fun (_ret:t_T) ->  [ &_10 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 =  [ &_9 <- C_Some _10 ] s1 | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'2 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'4 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _9 } ] s3
      | s3 = bb9 ]
    
    | bb9 = s0
      [ s0 = {inv'2 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_15 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = as_mut {_15} (fun (_ret:t_Option'0) ->  [ &_14 <- _ret ] s2)
      | s2 = bb10 ]
    
    | bb10 = s0 [ s0 = unwrap {_14} (fun (_ret:MutBorrow.t t_T) ->  [ &_13 <- _ret ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 = {inv'0 _13.current}
        MutBorrow.borrow_final <t_T> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_13 <- { _13 with current = _ret.final } ] 
            s1)
      | s1 = {inv'0 _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_8 <- { _8 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 _13} s3
      | s3 = -{resolve'1 _13}- s4
      | s4 = {[@expl:type invariant] inv'1 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 = bb12 ]
    
    | bb12 = s0
      [ s0 = {inv'0 _6.current}
        MutBorrow.borrow_final <t_T> {_6.current} {MutBorrow.get_id _6}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_6 <- { _6 with current = _ret.final } ] 
            s1)
      | s1 = {inv'0 _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'1 _6}- s4
      | s4 = {[@expl:type invariant] inv'1 _3} s5
      | s5 = -{resolve'1 _3}- s6
      | s6 = bb13 ]
    
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'3 self_'0} s1 | s1 = -{resolve'6 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & f'0: t_F = f
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _6: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _10: t_T = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & _13: MutBorrow.t t_T = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body result type invariant] [%#soption'2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body ensures] [%#soption'3] match self_.current with
        | C_None -> postcondition_once f () result.current /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_body [#"../../creusot-contracts/src/std/option.rs" 434 16 434 47]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span soption = "../../creusot-contracts/src/std/option.rs" 432 16 432 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 434 38 434 47
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 433 26 433 58
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Option [inv'1 x]. inv'1 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_Option) (src:t_Option) (return'  (x:t_Option))= {[@expl:replace 'dest' type invariant] [%#smem] inv'1 dest}
    {[@expl:replace 'src' type invariant] [%#smem'0] inv'0 src}
    any
    [ return''0 (result:t_Option)-> {inv'0 result}
      {[%#smem'1] dest.final = src}
      {[%#smem'2] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Option) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_take_body[#"../../creusot-contracts/src/std/option.rs" 434 16 434 47] (self_:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_take_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- C_None ] s1
      | s1 = {inv'0 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_3 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s2)
      | s2 = replace {_3} {_4} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'1 self_'0} s1 | s1 = -{resolve'0 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & _3: MutBorrow.t t_Option = Any.any_l ()
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_take_body result type invariant] [%#soption'0] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_body ensures] [%#soption'1] result = self_.current
      /\ self_.final = C_None}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_if_body [#"../../creusot-contracts/src/std/option.rs" 452 16 454 45]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 187 16 187 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 189 35 189 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 187 27 187 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 188 26 188 62
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 438 16 438 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 452 41 452 50
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 438 27 441 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 452 58 452 67
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 442 26 451 17
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 432 16 432 17
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 433 26 433 58
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_P
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_P)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_P) (args: MutBorrow.t t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_P) (args: MutBorrow.t t_T) (result: bool)
  
  
  let rec call_once (self_:t_P) (arg:MutBorrow.t t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve _0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'2 [@rewrite]: forall x: MutBorrow.t t_Option [inv'4 x]. inv'4 x = invariant''0 x
  
  let rec take (self_:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:take 'self_' type invariant] [%#soption'4] inv'4 self_}
    any
    [ return''0 (result:t_Option)-> {inv'3 result}
      {[%#soption'5] result = self_.current /\ self_.final = C_None}
      (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Option) =
    resolve'1 _0
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_P)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_take_if_body[#"../../creusot-contracts/src/std/option.rs" 452 16 454 45] (self_:MutBorrow.t t_Option) (predicate':t_P) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'predicate' type invariant] [%#soption'0] inv'0 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body requires] [%#soption'1] match self_.current with
      | C_None -> true
      | C_Some t -> forall b: MutBorrow.t t_T. inv'1 b /\ b.current = t  -> precondition predicate' b
      end}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_mut <t_T> {r0}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_10 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 =  [ &_9 <- _10 ] s3
      | s3 = call_once {predicate''0} {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s4)
      | s4 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = {inv'3 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_11 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = take {_11} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0 [ s0 = {[@expl:type invariant] inv'4 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb12 ] 
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'4 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb9 ] 
    | bb9 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb12 ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 predicate''0} s1
      | s1 = -{resolve'3 predicate''0}- s2
      | s2 = {[@expl:type invariant] inv'4 self_'0} s3
      | s3 = -{resolve'2 self_'0}- s4
      | s4 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb12 ] 
    | bb12 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & predicate''0: t_P = predicate'
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l ()
    | & _11: MutBorrow.t t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_take_if_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_if_body ensures] [%#soption'3] match self_.current with
        | C_None -> result = C_None /\ self_.final = C_None
        | C_Some cur -> exists b: MutBorrow.t t_T, res: bool. inv'1 b
        /\ cur = b.current
        /\ postcondition_once predicate' b res
        /\ (if res then
          self_.final = C_None /\ result = C_Some (b.final)
        else
          self_.final = C_Some (b.final) /\ result = C_None
        )
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_replace_body [#"../../creusot-contracts/src/std/option.rs" 463 16 463 60]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span soption = "../../creusot-contracts/src/std/option.rs" 461 16 461 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 463 38 463 43
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 463 51 463 60
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 462 26 462 65
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Option [inv'1 x]. inv'1 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_Option) (src:t_Option) (return'  (x:t_Option))= {[@expl:replace 'dest' type invariant] [%#smem] inv'1 dest}
    {[@expl:replace 'src' type invariant] [%#smem'0] inv'0 src}
    any
    [ return''0 (result:t_Option)-> {inv'0 result}
      {[%#smem'1] dest.final = src}
      {[%#smem'2] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Option) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_replace_body[#"../../creusot-contracts/src/std/option.rs" 463 16 463 60] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_replace_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_replace_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- C_Some value'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_4 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_4} {_5} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'1 self_'0} s1 | s1 = -{resolve'0 self_'0}- s2 | s2 = bb3 ] 
    | bb3 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & value'0: t_T = value
    | & _4: MutBorrow.t t_Option = Any.any_l ()
    | & _5: t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_replace_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_replace_body ensures] [%#soption'2] result = self_.current
      /\ self_.final = C_Some value}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_zip_body [#"../../creusot-contracts/src/std/option.rs" 473 16 473 67]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 467 16 467 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 473 32 473 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 473 53 473 67
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 468 26 472 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option'0 [inv'0 x]. inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_U)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option'0) =
    [%#sresolve] match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Option'0) =
    resolve'0 _0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  type tuple'0  =
    { _p0'0: t_T; _p1'0: t_U }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 tuple'0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_U))= any
    [ good (field_0:t_U)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_U [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: tuple'0 [inv'3 x]. inv'3 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv'1 x0 /\ inv x1)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'1)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'1 [inv'4 x]. inv'4 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'3 a_0
    end
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve'2 x
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_T_zip_body[#"../../creusot-contracts/src/std/option.rs" 473 16 473 67] (self_:t_Option) (other:t_Option'0) (return'  (x:t_Option'1))= {[@expl:extern_spec_std_option_T_Option_T_zip_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_zip_body 'other' type invariant] [%#soption'0] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = other'0 } ] s1 | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4._p0 = C_None} (! bb25) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb4) ] 
    | bb25 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {_p0 = C_Some x} -> resolve'2 x
          | _ -> true
          end}-
        s4
      | s4 = bb3 ]
    
    | bb4 = any [ br0 -> {_4._p1 = C_None'0} (! bb26) | br1 (x0:t_U)-> {_4._p1 = C_Some'0 x0} (! bb6) ] 
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = C_Some'0 x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = C_Some'0 x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {_p0 = C_Some x} -> resolve'2 x
          | _ -> true
          end}-
        s4
      | s4 = bb3 ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb15 ] 
    | bb6 = s0
      [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = v_Some'0 {_4._p1} (fun (r0:t_U) ->  [ &u <- r0 ] s2)
      | s2 =  [ &_11 <- { _p0'0 = t; _p1'0 = u } ] s3
      | s3 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'1 _11 ] s1 | s1 = bb15 ] 
    | bb15 = return''0 {_0} ]
    )
    [ & _0: t_Option'1 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & other'0: t_Option'0 = other
    | & _4: tuple = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _11: tuple'0 = Any.any_l () ]
    
    [ return''0 (result:t_Option'1)-> {[@expl:extern_spec_std_option_T_Option_T_zip_body result type invariant] [%#soption'1] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_zip_body ensures] [%#soption'2] match { _p0 = self_; _p1 = other } with
        | {_p0 = C_None} -> result = C_None'1 /\ resolve'0 other
        | {_p1 = C_None'0} -> result = C_None'1 /\ resolve'3 self_
        | {_p0 = C_Some t ; _p1 = C_Some'0 u} -> result = C_Some'1 { _p0'0 = t; _p1'0 = u }
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body [#"../../creusot-contracts/src/std/option.rs" 487 16 487 56]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 482 16 482 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 487 34 487 56
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 483 26 486 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  let rec v_Some (input:t_Option) (ret  (field_0:tuple))= any
    [ good (field_0:tuple)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom [@rewrite]: forall x: tuple [inv'1 x]. inv'1 x = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'1)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'1 [inv'4 x]. inv'4 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'0 a_0
    end
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple'0)
  
  axiom inv_axiom'3 [@rewrite]: forall x: tuple'0 [inv'5 x]. inv'5 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv'3 x0 /\ inv'4 x1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body[#"../../creusot-contracts/src/std/option.rs" 487 16 487 56] (self_:t_Option) (return'  (x:tuple'0))= {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb3) | br1 (x0:tuple)-> {self_'0 = C_Some x0} (! bb4) ] 
    | bb4 = s0
      [ s0 = v_Some {self_'0} (fun (r0:tuple) ->  [ &t <- r0._p0 ] s1)
      | s1 = v_Some {self_'0} (fun (r0:tuple) ->  [ &u <- r0._p1 ] s2)
      | s2 =  [ &_6 <- C_Some'0 t ] s3
      | s3 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_8 <- C_Some'1 u ] s1 | s1 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- { _p0'0 = _6; _p1'0 = _8 } ] s1 | s1 = bb14 ] 
    | bb3 = s0
      [ s0 =  [ &_10 <- C_None'0 ] s1
      | s1 =  [ &_11 <- C_None'1 ] s2
      | s2 =  [ &_0 <- { _p0'0 = _10; _p1'0 = _11 } ] s3
      | s3 = bb14 ]
    
    | bb14 = return''0 {_0} ]
    )
    [ & _0: tuple'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l ()
    | & _8: t_Option'1 = Any.any_l ()
    | & _10: t_Option'0 = Any.any_l ()
    | & _11: t_Option'1 = Any.any_l () ]
    
    [ return''0 (result:tuple'0)-> {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body result type invariant] [%#soption'0] inv'5 result}
      {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body ensures] [%#soption'1] match self_ with
        | C_None -> result = { _p0'0 = C_None'0; _p1'0 = C_None'1 }
        | C_Some {_p0 = t ; _p1 = u} -> result = { _p0'0 = C_Some'0 t; _p1'0 = C_Some'1 u }
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_ref_T_copied_body [#"../../creusot-contracts/src/std/option.rs" 501 16 503 27]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 496 16 496 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 501 35 501 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 497 26 500 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_copied_body[#"../../creusot-contracts/src/std/option.rs" 501 16 503 27] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- C_Some'0 t ] s2 | s2 = bb5 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: t_Option'0 = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body ensures] [%#soption'1] match self_ with
        | C_None -> result = C_None'0
        | C_Some s -> result = C_Some'0 s
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body [#"../../creusot-contracts/src/std/option.rs" 515 16 517 28]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span soption = "../../creusot-contracts/src/std/option.rs" 510 16 510 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 515 35 515 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 510 26 514 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: [%#slib] forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body[#"../../creusot-contracts/src/std/option.rs" 515 16 517 28] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = clone' {t} (fun (_ret:t_T) ->  [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_0 <- C_Some'0 _5 ] s1 | s1 = bb7 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & t: t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body ensures] [%#soption'1] match { _p0 = self_;
                                                                                                _p1 = result } with
        | {_p0 = C_None ; _p1 = C_None'0} -> true
        | {_p0 = C_Some s ; _p1 = C_Some'0 r} -> postcondition () s r
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body [#"../../creusot-contracts/src/std/option.rs" 531 16 533 27]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 526 16 526 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 531 35 531 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 527 26 530 17
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:MutBorrow.t t_T))= any
    [ good (field_0:MutBorrow.t t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body[#"../../creusot-contracts/src/std/option.rs" 531 16 533 27] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:MutBorrow.t t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:MutBorrow.t t_T) ->  [ &t <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 t} s2
      | s2 = -{resolve'0 t}- s3
      | s3 =  [ &_0 <- C_Some'0 (t.current) ] s4
      | s4 = bb5 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: t_Option'0 = Any.any_l () | & self_'0: t_Option = self_ | & t: MutBorrow.t t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body ensures] [%#soption'1] match self_ with
        | C_None -> result = C_None'0
        | C_Some s -> result = C_Some'0 (s.current) /\ s.final = s.current
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body [#"../../creusot-contracts/src/std/option.rs" 545 16 547 28]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 540 16 540 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 545 35 545 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 540 26 544 17
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:MutBorrow.t t_T))= any
    [ good (field_0:MutBorrow.t t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant'0] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: [%#slib] forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_T) =
    resolve _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'1 self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body[#"../../creusot-contracts/src/std/option.rs" 545 16 547 28] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:MutBorrow.t t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:MutBorrow.t t_T) ->  [ &t <- r0 ] s1)
      | s1 = clone' {t.current} (fun (_ret:t_T) ->  [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 =  [ &_0 <- C_Some'0 _5 ] s3
      | s3 = bb7 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body ensures] [%#soption'1] match { _p0 = self_;
                                                                                                   _p1 = result } with
        | {_p0 = C_None ; _p1 = C_None'0} -> true
        | {_p0 = C_Some s ; _p1 = C_Some'0 r} -> postcondition () s.current r /\ s.final = s.current
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_E_Option_Result_T_E_transpose_body [#"../../creusot-contracts/src/std/option.rs" 562 16 562 58]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 556 16 556 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 562 38 562 58
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 557 26 561 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  type t_Option  =
    | C_None
    | C_Some t_Result
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Result))= any
    [ good (field_0:t_Result)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Result [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_Result'0  =
    | C_Ok'0 t_Option'0
    | C_Err'0 t_E
  
  let rec v_Ok (input:t_Result) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Ok field_0: t_Result]. C_Ok field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Result'0 [inv'4 x]. inv'4 x
  = match x with
    | C_Ok'0 a_0 -> inv'3 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_E_Option_Result_T_E_transpose_body[#"../../creusot-contracts/src/std/option.rs" 562 16 562 58] (self_:t_Option) (return'  (x:t_Result'0))= {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb7) | br1 (x0:t_Result)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = v_Some {self_'0}
        (fun (r0:t_Result) -> any [ br0 (x0:t_T)-> {r0 = C_Ok x0} (! bb6) | br1 (x0:t_E)-> {r0 = C_Err x0} (! bb5) ] )
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_Result) -> v_Err {r0} (fun (r0'0:t_E) ->  [ &err <- r0'0 ] s1))
      | s1 =  [ &_0 <- C_Err'0 err ] s2
      | s2 = bb15 ]
    
    | bb6 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_Result) -> v_Ok {r0} (fun (r0'0:t_T) ->  [ &ok <- r0'0 ] s1))
      | s1 =  [ &_7 <- C_Some'0 ok ] s2
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 =  [ &_0 <- C_Ok'0 _7 ] s1 | s1 = bb15 ] 
    | bb7 = s0 [ s0 =  [ &_5 <- C_None'0 ] s1 | s1 =  [ &_0 <- C_Ok'0 _5 ] s2 | s2 = bb15 ] 
    | bb15 = return''0 {_0} ]
    )
    [ & _0: t_Result'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & _5: t_Option'0 = Any.any_l ()
    | & ok: t_T = Any.any_l ()
    | & _7: t_Option'0 = Any.any_l ()
    | & err: t_E = Any.any_l () ]
    
    [ return''0 (result:t_Result'0)-> {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body ensures] [%#soption'1] match self_ with
        | C_None -> result = C_Ok'0 (C_None'0)
        | C_Some (C_Ok ok) -> result = C_Ok'0 (C_Some'0 ok)
        | C_Some (C_Err err) -> result = C_Err'0 err
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_Option_T_flatten_body [#"../../creusot-contracts/src/std/option.rs" 575 16 575 45]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 572 16 572 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 575 36 575 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 573 26 573 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 574 26 574 62
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  let rec v_Some (input:t_Option'0) (ret  (field_0:t_Option))= any
    [ good (field_0:t_Option)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Option [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'1 x]. inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_option_T_Option_Option_T_flatten_body[#"../../creusot-contracts/src/std/option.rs" 575 16 575 45] (self_:t_Option'0) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None'0} (! bb4) | br1 (x0:t_Option)-> {self_'0 = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_Option) ->  [ &opt <- r0 ] s1) | s1 =  [ &_0 <- opt ] s2 | s2 = bb7 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    ) [ & _0: t_Option = Any.any_l () | & self_'0: t_Option'0 = self_ | & opt: t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body result type invariant] [%#soption'0] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #0] [%#soption'1] self_ = C_None'0
       -> result = C_None}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #1] [%#soption'2] self_ = C_None'0
      \/ self_ = C_Some'0 result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_Option) (o: t_Option) =
    [%#sord'1] cmp_log'0 self o <> C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_Option) (o: t_Option) =
    [%#sord'1] cmp_log'0 self o = C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_Option) (o: t_Option) =
    [%#sord'1] cmp_log'0 self o <> C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_Option) (o: t_Option) =
    [%#sord'1] cmp_log'0 self o = C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: t_Option) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  constant z  : t_Option
  
  constant o  : t_Ordering
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: t_Option) (y'0: t_Option) (z'0: t_Option) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log'0 x y = o)
   -> ([%#sord'0] cmp_log'0 y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log'0 x y = C_Less)
   -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log'0 x y = C_Greater)
   -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl [#"../../creusot-contracts/src/std/option.rs" 650 4 650 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 649 14 649 47
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 650 27 650 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 643 12 644 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 627 4 627 30] (self: t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 641 4 641 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#soption'1] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 650 4 650 26] (self'0: t_IntoIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#soption] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans [#"../../creusot-contracts/src/std/option.rs" 656 4 656 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 653 15 653 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 654 15 654 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 655 14 655 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 656 91 656 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 643 12 644 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 627 4 627 30] (self: t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 641 4 641 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#soption'3] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 656 4 656 90] (a'0: t_IntoIter) (ab'0: Seq.seq t_T) (b'0: t_IntoIter) (bc'0: Seq.seq t_T) (c'0: t_IntoIter) : ()
  
  
  goal vc_produces_trans: ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_refl [#"../../creusot-contracts/src/std/option.rs" 687 4 687 26] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 686 14 686 47
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 687 27 687 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 680 12 681 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 664 4 664 34] (self: t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 678 4 678 64] (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter)
  
   =
    [%#soption'1] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Iter
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 687 4 687 26] (self'0: t_Iter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#soption] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_trans [#"../../creusot-contracts/src/std/option.rs" 693 4 693 90] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 690 15 690 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 691 15 691 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 692 14 692 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 693 91 693 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 680 12 681 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 664 4 664 34] (self: t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 678 4 678 64] (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter)
  
   =
    [%#soption'3] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Iter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 693 4 693 90] (a'0: t_Iter) (ab'0: Seq.seq t_T) (b'0: t_Iter) (bc'0: Seq.seq t_T) (c'0: t_Iter) : ()
  
  
  goal vc_produces_trans: ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_refl [#"../../creusot-contracts/src/std/option.rs" 724 4 724 26] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 723 14 723 47
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 724 27 724 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 717 12 718 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 701 4 701 38] (self: t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 715 4 715 64] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut)
  
   =
    [%#soption'1] visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_IterMut
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 724 4 724 26] (self'0: t_IterMut) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#soption] produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_trans [#"../../creusot-contracts/src/std/option.rs" 730 4 730 90] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 727 15 727 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 728 15 728 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 729 14 729 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 730 91 730 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 717 12 718 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 701 4 701 38] (self: t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 715 4 715 64] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut)
  
   =
    [%#soption'3] visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_IterMut
  
  constant ab  : Seq.seq (MutBorrow.t t_T)
  
  constant b  : t_IterMut
  
  constant bc  : Seq.seq (MutBorrow.t t_T)
  
  constant c  : t_IterMut
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 730 4 730 90] (a'0: t_IterMut) (ab'0: Seq.seq (MutBorrow.t t_T)) (b'0: t_IterMut) (bc'0: Seq.seq (MutBorrow.t t_T)) (c'0: t_IterMut) : ()
  
  
  goal vc_produces_trans: ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi748817807773504354__unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (* <std::option::Option<T> as std::option::OptionExt<T>> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 755 30 755 38
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_T bool) (a: t_T) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_T bool) : t_T
  
  axiom such_that_spec: forall p: Map.map t_T bool. ([%#sutil] exists x: t_T. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Option
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self'0: t_Option) : t_T
  
  goal vc_unwrap_logic: ([%#soption] self <> C_None)
   -> match self with
    | C_Some x -> true
    | C_None -> [@expl:such_that requires] [%#sutil] exists x: t_T. index_logic ([%#soption'0] fun (__0: t_T) -> true) x
    end
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self: Opaque.ptr) : UInt64.t
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Opaque.ptr
  
  predicate is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self'0: Opaque.ptr)
  
  goal vc_is_null_logic: [@expl:is_null_logic ensures] [%#sptr] (addr_logic self = (0: UInt64.t))
  = (addr_logic self = (0: UInt64.t))
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 74 14 74 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 76 8 76 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 68 4 68 32] (self: Opaque.ptr) : UInt64.t
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Opaque.ptr
  
  predicate is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (self'0: Opaque.ptr)
  
  goal vc_is_null_logic: [@expl:is_null_logic ensures] [%#sptr] (addr_logic self = (0: UInt64.t))
  = (addr_logic self = (0: UInt64.t))
end
module M_creusot_contracts__stdqy35z1__ptr__extern_spec_T_Cloneqy95z_ptrmut_T_clone_body [#"../../creusot-contracts/src/std/ptr.rs" 118 8 118 33]
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 117 18 117 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Cloneqy95z_ptrmut_T_clone_body[#"../../creusot-contracts/src/std/ptr.rs" 118 8 118 33] (self_:Opaque.ptr) (return'  (x:Opaque.ptr))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Opaque.ptr = Any.any_l () | & self_'0: Opaque.ptr = self_ ] 
    [ return''0 (result:Opaque.ptr)-> {[@expl:extern_spec_T_Clone__ptrmut_T_clone_body ensures] [%#sptr] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ptr__extern_spec_T_Cloneqy95z_ptrconst_T_clone_body [#"../../creusot-contracts/src/std/ptr.rs" 125 8 125 35]
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 124 18 124 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Cloneqy95z_ptrconst_T_clone_body[#"../../creusot-contracts/src/std/ptr.rs" 125 8 125 35] (self_:Opaque.ptr) (return'  (x:Opaque.ptr))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Opaque.ptr = Any.any_l () | & self_'0: Opaque.ptr = self_ ] 
    [ return''0 (result:Opaque.ptr)-> {[@expl:extern_spec_T_Clone__ptrconst_T_clone_body ensures] [%#sptr] result
      = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 464 4 464 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 463 14 463 47
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 464 27 464 29
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 457 12 457 66
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 84 14 84 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 85 14 85 76
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'4] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'5] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 86 4 86 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. [%#sslice'2] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. [%#sslice'3] forall i: int. 0 <= i
  /\ i < Seq.length (to_ref_seq self)  -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 441 4 441 33] (self: t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 455 4 455 65] (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter)
  
   =
    [%#sslice'1] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Iter
  
  function produces_refl [#"../../creusot-contracts/src/std/slice.rs" 464 4 464 26] (self'0: t_Iter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sslice] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 471 4 471 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 468 15 468 32
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 469 15 469 32
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 470 14 470 42
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 471 91 471 93
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 457 12 457 66
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 84 14 84 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 85 14 85 76
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'7 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'6] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'7] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 86 4 86 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. [%#sslice'4] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. [%#sslice'5] forall i: int. 0 <= i
  /\ i < Seq.length (to_ref_seq self)  -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 441 4 441 33] (self: t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 455 4 455 65] (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter)
  
   =
    [%#sslice'3] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Iter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter
  
  function produces_trans [#"../../creusot-contracts/src/std/slice.rs" 471 4 471 90] (a'0: t_Iter) (ab'0: Seq.seq t_T) (b'0: t_Iter) (bc'0: Seq.seq t_T) (c'0: t_Iter) : ()
  
  
  goal vc_produces_trans: ([%#sslice] produces a ab b)
   -> ([%#sslice'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#sslice'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 517 4 517 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 516 14 516 47
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 517 27 517 29
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 510 12 510 66
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 75 14 75 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 76 14 76 80
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 479 14 479 50
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'5] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'6] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 78 4 78 43] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). [%#sslice'2] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). [%#sslice'3] forall i: int. 0 <= i
  /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 480 4 480 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'1: forall self: t_IterMut. [%#sslice'4] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 508 4 508 65] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut)
  
   =
    [%#sslice'1] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_IterMut
  
  function produces_refl [#"../../creusot-contracts/src/std/slice.rs" 517 4 517 26] (self'0: t_IterMut) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#sslice] produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 524 4 524 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 521 15 521 32
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 522 15 522 32
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 523 14 523 42
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 524 91 524 93
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 510 12 510 66
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 75 14 75 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 76 14 76 80
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 479 14 479 50
  let%span sslice'7 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'8 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'7] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'8] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 78 4 78 43] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). [%#sslice'4] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). [%#sslice'5] forall i: int. 0 <= i
  /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 480 4 480 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'1: forall self: t_IterMut. [%#sslice'6] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 508 4 508 65] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut)
  
   =
    [%#sslice'3] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_IterMut
  
  constant ab  : Seq.seq (MutBorrow.t t_T)
  
  constant b  : t_IterMut
  
  constant bc  : Seq.seq (MutBorrow.t t_T)
  
  constant c  : t_IterMut
  
  function produces_trans [#"../../creusot-contracts/src/std/slice.rs" 524 4 524 90] (a'0: t_IterMut) (ab'0: Seq.seq (MutBorrow.t t_T)) (b'0: t_IterMut) (bc'0: Seq.seq (MutBorrow.t t_T)) (c'0: t_IterMut) : ()
  
  
  goal vc_produces_trans: ([%#sslice] produces a ab b)
   -> ([%#sslice'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#sslice'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 255 14 255 47
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 256 27 256 29
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 249 12 249 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 247 4 247 57] (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter)
  
   =
    [%#svec'1] view self = Seq.(++) visited (view rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 26] (self'0: t_IntoIter) : ()
  
  goal vc_produces_refl: [@expl:produces_refl ensures] [%#svec] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans [#"../../creusot-contracts/src/std/vec.rs" 263 4 263 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 260 15 260 32
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 261 15 261 32
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 262 14 262 42
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 263 73 263 75
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 249 12 249 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 247 4 247 57] (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter)
  
   =
    [%#svec'3] view self = Seq.(++) visited (view rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/vec.rs" 263 4 263 72] (a'0: t_IntoIter) (ab'0: Seq.seq t_T) (b'0: t_IntoIter) (bc'0: Seq.seq t_T) (c'0: t_IntoIter) : ()
  
  
  goal vc_produces_trans: ([%#svec] produces a ab b)
   -> ([%#svec'0] produces b bc c)  -> ([@expl:produces_trans ensures] [%#svec'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Real.(<=) x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Real.(<) x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Real.(>=) x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Real.(>) x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Real.real) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  constant z  : Real.real
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Real.real) (y'0: Real.real) (z'0: Real.real) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__fn_pure__qyi11638360339920708941__clone [#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (* <fn_pure::FnPureWrapper<F> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 30 14 30 18
  let%span sfn_pure'0 = "../../creusot-contracts/src/fn_pure.rs" 30 23 30 27
  let%span sfn_pure'1 = "../../creusot-contracts/src/fn_pure.rs" 29 14 29 58
  
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_F) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_F [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: t_F)
  
  axiom precondition_fndef: [%#slib] forall args: t_F [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_F) (result: t_F)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_F, res: t_F [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_F) (return'  (x:t_F))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_F)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FnPureWrapper) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FnPureWrapper [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_F, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_F, res: t_F. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_F, res_state: (), res: t_F. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_F, res: t_F [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_spec: forall self: (), args: t_F, res: t_F. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_F, res_state: (), res: t_F. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''0[#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (self:t_FnPureWrapper) (return'  (x:t_FnPureWrapper))= {[@expl:clone 'self' type invariant] [%#sfn_pure] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone' {self'0.t_FnPureWrapper__0} (fun (_ret:t_F) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_FnPureWrapper__0 = _3 } ] s1 | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0: t_FnPureWrapper = Any.any_l () | & self'0: t_FnPureWrapper = self | & _3: t_F = Any.any_l () ] 
    [ return''0 (result:t_FnPureWrapper)-> {[@expl:clone result type invariant] [%#sfn_pure'0] inv'1 result}
      {[@expl:clone ensures] [%#sfn_pure'1] postcondition () self.t_FnPureWrapper__0 result.t_FnPureWrapper__0}
      (! return' {result}) ]

end
module M_creusot_contracts__fn_pure__qyi4173004571708517458__qy95z_new [#"../../creusot-contracts/src/fn_pure.rs" 75 4 75 30] (* fn_pure::FnPureWrapper<F> *)
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 75 17 75 18
  let%span sfn_pure'0 = "../../creusot-contracts/src/fn_pure.rs" 75 26 75 30
  let%span sfn_pure'1 = "../../creusot-contracts/src/fn_pure.rs" 74 14 74 26
  let%span sfn_pure'2 = "../../creusot-contracts/src/fn_pure.rs" 83 8 83 14
  
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'0 x]. inv'0 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  function view [#"../../creusot-contracts/src/fn_pure.rs" 82 4 82 33] (self: t_FnPureWrapper) : t_F =
    [%#sfn_pure'2] self.t_FnPureWrapper__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec qy95z_new[#"../../creusot-contracts/src/fn_pure.rs" 75 4 75 30] (f:t_F) (return'  (x:t_FnPureWrapper))= {[@expl:__new 'f' type invariant] [%#sfn_pure] inv f}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- { t_FnPureWrapper__0 = f'0 } ] s1 | s1 = bb2 ]  | bb2 = return''0 {_0} ] )
    [ & _0: t_FnPureWrapper = Any.any_l () | & f'0: t_F = f ]
    
    [ return''0 (result:t_FnPureWrapper)-> {[@expl:__new result type invariant] [%#sfn_pure'0] inv'0 result}
      {[@expl:__new ensures] [%#sfn_pure'1] view result = f}
      (! return' {result}) ]

end
module M_creusot_contracts__invariant__qyi11000281680484769800__clone [#"../../creusot-contracts/src/invariant.rs" 286 4 286 27] (* <invariant::Subset<T> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 287 8 287 36
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 285 14 285 58
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 206 15 206 30
  let%span sinvariant'2 = "../../creusot-contracts/src/invariant.rs" 207 14 207 27
  let%span sinvariant'3 = "../../creusot-contracts/src/invariant.rs" 269 23 269 36
  let%span sinvariant'4 = "../../creusot-contracts/src/invariant.rs" 268 14 268 30
  let%span sinvariant'5 = "../../creusot-contracts/src/invariant.rs" 230 15 230 16
  let%span sinvariant'6 = "../../creusot-contracts/src/invariant.rs" 229 14 229 42
  let%span sinvariant'7 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'8 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'9 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span sinvariant'10 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use creusot.prelude.Any
  
  type t_Subset
  
  type t_T
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 72 4 72 31] (self: t_T)
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'7] invariant' (view self)
  
  function view_inj [#"../../creusot-contracts/src/invariant.rs" 208 4 208 38] (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. ([%#sinvariant'1] view self = view other)
   -> ([%#sinvariant'2] self = other)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom: forall x: t_T [inv x]. inv x  -> invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant'10] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Subset) : t_T =
    [%#smodel] view self
  
  let rec deref (self:t_Subset) (return'  (x:t_T))= any
    [ return''0 (result:t_T)-> {[%#sinvariant'3] inv'0 result}
      {[%#sinvariant'4] result = view'0 self}
      (! return' {result}) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: [%#slib] forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_T) : t_Subset
  
  axiom new_logic_spec: forall x: t_T. ([%#sinvariant'8] invariant' x)  -> ([%#sinvariant'9] view (new_logic x) = x)
  
  let rec new (x:t_T) (return'  (x'0:t_Subset))= {[@expl:new 'x' type invariant] [%#sinvariant'5] inv x}
    any [ return''0 (result:t_Subset)-> {[%#sinvariant'6] result = new_logic x} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''0[#"../../creusot-contracts/src/invariant.rs" 286 4 286 27] (self:t_Subset) (return'  (x:t_Subset))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- [%#sinvariant] () ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = deref {self'0} (fun (_ret:t_T) ->  [ &_7 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = clone' {_7} (fun (_ret:t_T) ->  [ &_5 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = new {_5} (fun (_ret:t_Subset) ->  [ &_0 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = return''0 {_0} ]
    )
    [ & _0: t_Subset = Any.any_l ()
    | & self'0: t_Subset = self
    | & _3: () = Any.any_l ()
    | & _5: t_T = Any.any_l ()
    | & _7: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Subset)-> {[@expl:clone ensures] [%#sinvariant'0] postcondition () (view'0 self) (view result)}
      (! return' {result}) ]

end
module M_creusot_contracts__local_invariant__qyi17763416549578214088__open [#"../../creusot-contracts/src/local_invariant.rs" 189 4 191 51] (* <ghost::Ghost<&'a local_invariant::LocalInvariant<T>> as local_invariant::LocalInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span slocal_invariant = "../../creusot-contracts/src/local_invariant.rs" 189 59 189 60
  let%span slocal_invariant'0 = "../../creusot-contracts/src/local_invariant.rs" 182 15 182 53
  let%span slocal_invariant'1 = "../../creusot-contracts/src/local_invariant.rs" 183 15 186 114
  let%span slocal_invariant'2 = "../../creusot-contracts/src/local_invariant.rs" 189 68 189 69
  let%span slocal_invariant'3 = "../../creusot-contracts/src/local_invariant.rs" 187 14 187 117
  let%span slocal_invariant'4 = "../../creusot-contracts/src/local_invariant.rs" 248 8 248 9
  let%span slocal_invariant'5 = "../../creusot-contracts/src/local_invariant.rs" 238 15 238 53
  let%span slocal_invariant'6 = "../../creusot-contracts/src/local_invariant.rs" 239 15 242 114
  let%span slocal_invariant'7 = "../../creusot-contracts/src/local_invariant.rs" 249 9 249 10
  let%span slocal_invariant'8 = "../../creusot-contracts/src/local_invariant.rs" 243 14 243 117
  let%span slocal_invariant'9 = "../../creusot-contracts/src/local_invariant.rs" 145 8 145 25
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 89 8 89 22
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  
  use set.Set
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_A
  
  type t_LocalInvariant
  
  type t_Namespaces
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/set.rs" 30 4 30 39] (self: Set.set t_Namespace) (e: t_Namespace)
  
   =
    [%#sset] Set.mem e self
  
  function namespaces [#"../../creusot-contracts/src/local_invariant.rs" 109 4 109 45] (self: t_Namespaces) : Set.set t_Namespace
  
  
  function view [#"../../creusot-contracts/src/local_invariant.rs" 144 4 144 35] (self: t_Namespaces) : Set.set t_Namespace
  
   =
    [%#slocal_invariant'9] namespaces self
  
  function view'0 [#"../../creusot-contracts/src/ghost.rs" 88 4 88 33] (self:  t_Namespaces) : Set.set t_Namespace =
    [%#sghost] view self
  
  function namespace [#"../../creusot-contracts/src/local_invariant.rs" 222 4 222 39] (self: t_LocalInvariant) : t_Namespace
  
  
  type t_T
  
  type t_Public
  
  predicate invariant_with_data [#"../../creusot-contracts/src/local_invariant.rs" 163 4 163 61] (self: t_T) (data: t_Public)
  
  
  function public [#"../../creusot-contracts/src/local_invariant.rs" 229 4 229 36] (self: t_LocalInvariant) : t_Public
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  (MutBorrow.t t_T)) =
    [%#sghost'0] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  (MutBorrow.t t_T))
  
  axiom inv_axiom'0 [@rewrite]: forall x:  (MutBorrow.t t_T) [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args:  (MutBorrow.t t_T))
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args:  (MutBorrow.t t_T)) (result: t_A)
  
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  let rec open (this: t_LocalInvariant) (namespaces'0: t_Namespaces) (f:t_F) (return'  (x:t_A))= {[@expl:open 'f' type invariant] [%#slocal_invariant'4] inv f}
    {[@expl:open requires #0] [%#slocal_invariant'5] contains (view'0 namespaces'0) (namespace this)}
    {[@expl:open requires #1] [%#slocal_invariant'6] forall t:  (MutBorrow.t t_T). invariant_with_data t.current (public this)
    /\ inv'2 t
     -> precondition f t /\ (forall res: t_A. postcondition_once f t res  -> invariant_with_data t.final (public this))}
    any
    [ return''0 (result:t_A)-> {[%#slocal_invariant'7] inv'3 result}
      {[%#slocal_invariant'8] exists t:  (MutBorrow.t t_T). invariant_with_data t.current (public this)
      /\ postcondition_once f t result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open'0[#"../../creusot-contracts/src/local_invariant.rs" 189 4 191 51] (self: t_LocalInvariant) (namespaces'0: t_Namespaces) (f:t_F) (return'  (x:t_A))= {[@expl:open 'f' type invariant] [%#slocal_invariant] inv f}
    {[@expl:open requires #0] [%#slocal_invariant'0] contains (view'0 namespaces'0) (namespace self)}
    {[@expl:open requires #1] [%#slocal_invariant'1] forall t:  (MutBorrow.t t_T). invariant_with_data t.current (public self)
    /\ inv'2 t
     -> precondition f t /\ (forall res: t_A. postcondition_once f t res  -> invariant_with_data t.final (public self))}
    (! bb0
    [ bb0 = s0 [ s0 = open {self'0} {namespaces'1} {f'0} (fun (_ret:t_A) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    )
    [ & _0: t_A = Any.any_l ()
    | & self'0:  t_LocalInvariant = self
    | & namespaces'1:  t_Namespaces = namespaces'0
    | & f'0: t_F = f ]
    
    [ return''0 (result:t_A)-> {[@expl:open result type invariant] [%#slocal_invariant'2] inv'3 result}
      {[@expl:open ensures] [%#slocal_invariant'3] exists t:  (MutBorrow.t t_T). invariant_with_data t.current (public self)
      /\ postcondition_once f t result}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 190 12 190 52
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 175 15 175 30
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 176 14 176 27
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option
  
  function view_inj [#"../../creusot-contracts/src/logic/fmap.rs" 177 4 177 34] (self: t_FMap) (other: t_FMap) : ()
  
  axiom view_inj_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'2] view self = view other)
   -> ([%#sfmap'3] self = other)
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'4] Map.get (view self) k
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FMap
  
  constant other  : t_FMap
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self'0: t_FMap) (other'0: t_FMap)
  
  goal vc_ext_eq: let _ = () in [@expl:ext_eq ensures] [%#sfmap] ([%#sfmap'0] forall k: t_K. get self k = get other k)
  = (self = other)
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__contains_ghost [#"../../creusot-contracts/src/logic/fmap.rs" 322 4 322 49] (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 322 27 322 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 322 33 322 36
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 321 14 321 43
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 344 22 344 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 344 28 344 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 344 40 344 50
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 343 14 343 55
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 265 8 265 24
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 57 16 57 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 58 26 58 51
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  
  use map.Map
  use creusot.prelude.Any
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_FMap
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'7] Map.get (view self) k
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 115 4 115 39] (self: t_FMap) (k: t_K)
  
   =
    [%#sfmap'6] get self k <> C_None'0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_K)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_V)
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option'0) : t_V =
    [%#soption'3] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 107 4 107 34] (self: t_FMap) (k: t_K) : t_V
  
   =
    [%#sfmap'10] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 264 4 264 46] (self: t_FMap) (key: t_K) : t_V
  
   =
    [%#sfmap'9] lookup self key
  
  predicate invariant' [#"../../creusot-contracts/src/logic/fmap.rs" 510 4 510 30] (self: t_FMap) =
    [%#sfmap'8] forall k: t_K. contains self k  -> inv k /\ inv'0 (index_logic'0 self k)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FMap) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMap)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_K) =
    [%#sinvariant] inv self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_K)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_K [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_V) =
    [%#sinvariant] inv'0 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_V [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_V) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  let rec get_ghost (self:t_FMap) (key:t_K) (return'  (x:t_Option))= {[@expl:get_ghost 'self' type invariant] [%#sfmap'2] inv'2 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap'3] inv'3 key}
    any
    [ return''0 (result:t_Option)-> {[%#sfmap'4] inv'5 result}
      {[%#sfmap'5] result = map_logic (get self key) (fun (v: t_V) -> v)}
      (! return' {result}) ]
  
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'5 self
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option [inv'6 x]. inv'6 x = invariant''3 x
  
  let rec is_some (self_:t_Option) (return'  (x:bool))= {[@expl:is_some 'self_' type invariant] [%#soption] inv'6 self_}
    any [ return''0 (result:bool)-> {[%#soption'0] result = (self_ <> C_None)} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains_ghost[#"../../creusot-contracts/src/logic/fmap.rs" 322 4 322 49] (self:t_FMap) (key:t_K) (return'  (x:bool))= {[@expl:contains_ghost 'self' type invariant] [%#sfmap] inv'2 self}
    {[@expl:contains_ghost 'key' type invariant] [%#sfmap'0] inv'3 key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost {self'0} {key'0} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = is_some {_5} (fun (_ret:bool) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0: bool = Any.any_l () | & self'0: t_FMap = self | & key'0: t_K = key | & _5: t_Option = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:contains_ghost ensures] [%#sfmap'1] result = contains self key}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__ext_eq [#"../../creusot-contracts/src/logic/fset.rs" 194 4 194 44] (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 193 14 193 39
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 196 12 196 63
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Fset.fset t_T
  
  constant other  : Fset.fset t_T
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fset.rs" 194 4 194 44] (self'0: Fset.fset t_T) (other'0: Fset.fset t_T)
  
  
  goal vc_ext_eq: [@expl:ext_eq ensures] [%#sfset] ([%#sfset'0] forall e: t_T. contains self e = contains other e)
  = (self = other)
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__singleton [#"../../creusot-contracts/src/logic/fset.rs" 206 4 206 34] (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 205 14 205 57
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 207 8 207 31
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 62 8 62 26
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 61 4 61 37] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T
  
   =
    [%#sfset'2] Fset.add e self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_T
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 206 4 206 34] (x'0: t_T) : Fset.fset t_T
  
  goal vc_singleton: [@expl:singleton ensures] [%#sfset] forall y: t_T. contains (insert (Fset.empty: Fset.fset t_T) x) y
  = (x = y)
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__unions [#"../../creusot-contracts/src/logic/fset.rs" 215 4 215 61] (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 213 14 213 102
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 214 14 214 24
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 216 8 221 9
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 89 8 89 26
  
  use set.Fset
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_U) (e: t_U)
  
   =
    [%#sfset'2] Fset.mem e self
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'2] Fset.mem e self
  
  function remove [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 88 4 88 37] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T
  
   =
    [%#sfset'3] Fset.remove e self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Fset.fset t_T
  
  constant f  : Map.map t_T (Fset.fset t_U)
  
  function unions [#"../../creusot-contracts/src/logic/fset.rs" 215 4 215 61] (self'0: Fset.fset t_T) (f'0: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  
  goal vc_unions: if Fset.cardinal self = 0 then
    [@expl:unions ensures] [%#sfset] forall y: t_U. contains (Fset.empty: Fset.fset t_U) y
    = (exists x: t_T. contains'0 self x /\ contains (Map.get f x) y)
  else
    let x = Fset.pick self in (0 <= ([%#sfset'0] Fset.cardinal self)
    /\ ([%#sfset'0] Fset.cardinal (remove self x)) < ([%#sfset'0] Fset.cardinal self))
    /\ (([%#sfset] forall y: t_U. contains (unions (remove self x) f) y
    = (exists x'0: t_T. contains'0 (remove self x) x'0 /\ contains (Map.get f x'0) y))
     -> ([@expl:unions ensures] [%#sfset] forall y: t_U. contains (Fset.union (Map.get f x) (unions (remove self x) f)) y
    = (exists x'0: t_T. contains'0 self x'0 /\ contains (Map.get f x'0) y)))

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate [#"../../creusot-contracts/src/logic/fset.rs" 272 4 272 50] (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 269 15 269 21
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 270 14 270 123
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 271 14 271 15
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 275 32 275 87
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 205 14 205 57
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 278 32 278 103
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 252 14 252 117
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 274 12 280 13
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 207 8 207 31
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 62 8 62 26
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 61 4 61 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'9] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 206 4 206 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'8] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'3] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 253 4 253 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'5] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Fset.fset t_T
  
  constant n  : int
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 272 4 272 50] (self'0: Fset.fset t_T) (n'0: int) : Fset.fset (Seq.seq t_T)
  
  
  goal vc_replicate: ([%#sfset] n >= 0)
   -> (if n = 0 then
    ([%#sfset'2] forall xs: Seq.seq t_T. Seq.length xs = 0  -> xs = (Seq.empty: Seq.seq t_T))
    && (let _ = () in let _ = () in ([%#sfset'3] forall y: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) y
    = ((Seq.empty: Seq.seq t_T) = y))
     -> ([@expl:replicate ensures] [%#sfset'0] forall xs: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) xs
    = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x))))
  else
    ([%#sfset'4] forall xs: Seq.seq t_T, i: int. 0 < i /\ i < Seq.length xs
     -> Seq.get xs i = Seq.get (tail xs) (i - 1))
    && (let _ = () in let _ = () in (([@expl:replicate requires] [%#sfset] n - 1 >= 0)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] forall xs: Seq.seq t_T. contains (replicate self (n - 1)) xs
    = (Seq.length xs = n - 1 /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
     -> ([%#sfset'5] forall xs: Seq.seq t_T. contains (cons self (replicate self (n - 1))) xs
    = (0 < Seq.length xs /\ contains'1 self (Seq.get xs 0) /\ contains (replicate self (n - 1)) (tail xs)))
     -> ([@expl:replicate ensures] [%#sfset'0] forall xs: Seq.seq t_T. contains (cons self (replicate self (n - 1))) xs
    = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))))
  )
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 290 4 290 56] (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 287 15 287 21
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 288 14 288 123
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 289 14 289 15
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 293 32 293 87
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 205 14 205 57
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 269 15 269 21
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 270 14 270 123
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 271 14 271 15
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 292 12 297 13
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 207 8 207 31
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 274 12 280 13
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 62 8 62 26
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 252 14 252 117
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'8] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'8] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 61 4 61 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'11] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 206 4 206 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'9] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'3] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 253 4 253 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'12] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 272 4 272 50] (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. ([%#sfset'4] n >= 0)
   -> replicate self n
  = ([%#sfset'10] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty: Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. ([%#sfset'4] n >= 0)
   -> ([%#sfset'5] forall xs: Seq.seq t_T. contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Fset.fset t_T
  
  constant n  : int
  
  function replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 290 4 290 56] (self'0: Fset.fset t_T) (n'0: int) : Fset.fset (Seq.seq t_T)
  
  
  goal vc_replicate_up_to: ([%#sfset] n >= 0)
   -> (if n = 0 then
    ([%#sfset'2] forall xs: Seq.seq t_T. Seq.length xs = 0  -> xs = (Seq.empty: Seq.seq t_T))
    && (let _ = () in let _ = () in ([%#sfset'3] forall y: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) y
    = ((Seq.empty: Seq.seq t_T) = y))
     -> ([@expl:replicate_up_to ensures] [%#sfset'0] forall xs: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) xs
    = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x))))
  else
    (([@expl:replicate_up_to requires] [%#sfset] n - 1 >= 0)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] forall xs: Seq.seq t_T. contains (replicate_up_to self (n - 1)) xs
    = (Seq.length xs <= n - 1 /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
     -> ([@expl:replicate requires] [%#sfset'4] n >= 0)
    /\ (([%#sfset'5] forall xs: Seq.seq t_T. contains (replicate self n) xs
    = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
     -> ([@expl:replicate_up_to ensures] [%#sfset'0] forall xs: Seq.seq t_T. contains (Fset.union (replicate_up_to self (n
    - 1)) (replicate self n)) xs
    = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))))
  )
end
module M_creusot_contracts__logic__fset__unions_union [#"../../creusot-contracts/src/logic/fset.rs" 494 0 494 27]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 491 10 491 125
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 492 10 493 76
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 494 28 494 30
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 213 14 213 102
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 214 14 214 24
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 216 8 221 9
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 89 8 89 26
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_U) (e: t_U)
  
   =
    [%#sfset'5] Fset.mem e self
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'5] Fset.mem e self
  
  function remove [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 88 4 88 37] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T
  
   =
    [%#sfset'6] Fset.remove e self
  
  function unions [#"../../creusot-contracts/src/logic/fset.rs" 215 4 215 61] (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  
  axiom unions_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions self f
  = ([%#sfset'4] if Fset.cardinal self = 0 then
    Fset.empty: Fset.fset t_U
  else
    let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
  )
  
  axiom unions_spec: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). [%#sfset'2] forall y: t_U. contains (unions self f) y
  = (exists x: t_T. contains'0 self x /\ contains (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unions_union [#"../../creusot-contracts/src/logic/fset.rs" 494 0 494 27]  : ()
  
  goal vc_unions_union: ([@expl:unions_union ensures #0] [%#sfset] forall s1: Fset.fset t_T, s2: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions (Fset.union s1 s2) f
  = Fset.union (unions s1 f) (unions s2 f))
  && ([@expl:unions_union ensures #1] [%#sfset'0] forall s: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U), g: Map.map t_T (Fset.fset t_U). unions s (fun (x: t_T) -> Fset.union (Map.get f x) (Map.get g x))
  = Fset.union (unions s f) (unions s g))
end
module M_creusot_contracts__logic__fset__map_union [#"../../creusot-contracts/src/logic/fset.rs" 500 0 500 24]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 499 10 499 104
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 500 25 500 27
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 236 8 236 27
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  function map [#"../../creusot-contracts/src/logic/fset.rs" 235 4 235 52] (self: Fset.fset t_T) (f: Map.map t_T t_U) : Fset.fset t_U
  
   =
    [%#sfset'1] Fset.map f self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function map_union [#"../../creusot-contracts/src/logic/fset.rs" 500 0 500 24]  : ()
  
  goal vc_map_union: [@expl:map_union ensures] [%#sfset] forall s: Fset.fset t_T, t: Fset.fset t_T, f: Map.map t_T t_U. map (Fset.union s t) f
  = Fset.union (map s f) (map t f)
end
module M_creusot_contracts__logic__fset__concat_union [#"../../creusot-contracts/src/logic/fset.rs" 509 0 509 24]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 505 10 506 83
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 507 10 508 83
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 509 25 509 27
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 261 14 261 144
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use seq.Seq
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'3] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 262 4 262 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'2] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function concat_union [#"../../creusot-contracts/src/logic/fset.rs" 509 0 509 24]  : ()
  
  goal vc_concat_union: ([@expl:concat_union ensures #0] [%#sfset] forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
  = Fset.union (concat s1 t) (concat s2 t))
  && ([@expl:concat_union ensures #1] [%#sfset'0] forall s: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s (Fset.union t1 t2)
  = Fset.union (concat s t1) (concat s t2))
end
module M_creusot_contracts__logic__fset__cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 515 0 515 23]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 240 8 240 27
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 514 10 514 133
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 516 20 516 115
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 517 20 517 74
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 518 20 518 89
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 516 4 516 117
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 261 14 261 144
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 252 14 252 117
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'6] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 262 4 262 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'4] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'6] Fset.mem e self
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 253 4 253 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'5] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'0 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function push_front [@inline:trivial] [#"../../creusot-contracts/src/logic/seq.rs" 239 4 239 41] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T
  
   =
    [%#sseq] Seq.cons x self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 515 0 515 23]  : ()
  
  goal vc_cons_concat: ([%#sfset'0] forall x: t_T, xs: Seq.seq t_T, ys: Seq.seq t_T. Seq.(++) (push_front xs x) ys
  = push_front (Seq.(++) xs ys) x)
  && (let _ = () in let _ = () in ([%#sfset'1] forall x: t_T, ys: Seq.seq t_T. tail (push_front ys x) = ys)
  && (let _ = () in let _ = () in ([%#sfset'2] forall ys: Seq.seq t_T. 0 < Seq.length ys
   -> ys = push_front (tail ys) (Seq.get ys 0))
  && (let _ = () in let _ = () in [@expl:cons_concat ensures] [%#sfset] forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
  = cons s (concat t u))))
end
module M_creusot_contracts__logic__fset__concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 527 0 527 54]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 524 11 524 27
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 525 10 525 76
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 526 10 526 11
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 269 15 269 21
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 270 14 270 123
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 271 14 271 15
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 541 10 541 61
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 542 10 542 61
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 514 10 514 133
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 529 8 534 9
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 274 12 280 13
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 261 14 261 144
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 544 4 544 70
  let%span sfset'13 = "../../creusot-contracts/src/logic/fset.rs" 205 14 205 57
  let%span sfset'14 = "../../creusot-contracts/src/logic/fset.rs" 207 8 207 31
  let%span sfset'15 = "../../creusot-contracts/src/logic/fset.rs" 516 4 516 117
  let%span sfset'16 = "../../creusot-contracts/src/logic/fset.rs" 252 14 252 117
  let%span sfset'17 = "../../creusot-contracts/src/logic/fset.rs" 62 8 62 26
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'11] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'11] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 61 4 61 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'17] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 206 4 206 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'14] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'13] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 253 4 253 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'16] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 272 4 272 50] (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. ([%#sfset'2] n >= 0)
   -> replicate self n
  = ([%#sfset'9] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty: Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. ([%#sfset'2] n >= 0)
   -> ([%#sfset'3] forall xs: Seq.seq t_T. contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 262 4 262 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'10] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 543 0 543 39] (s: Fset.fset (Seq.seq t_T)) : () =
    [%#sfset'12] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty_spec: forall s: Fset.fset (Seq.seq t_T). [%#sfset'5] concat (singleton (Seq.empty: Seq.seq t_T)) s
  = s
  
  axiom concat_empty_spec'0: forall s: Fset.fset (Seq.seq t_T). [%#sfset'6] concat s (singleton (Seq.empty: Seq.seq t_T))
  = s
  
  constant cons_concat: () = [%#sfset'15] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat_spec: [%#sfset'7] forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
  = cons s (concat t u)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T
  
  function concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 527 0 527 54] (n'0: int) (m'0: int) (s'0: Fset.fset t_T) : ()
  
  
  goal vc_concat_replicate: ([%#sfset] 0 <= n /\ 0 <= m)
   -> (if n = 0 then
    ([@expl:replicate requires] [%#sfset'2] m >= 0)
    /\ (([%#sfset'3] forall xs: Seq.seq t_T. contains (replicate s m) xs
    = (Seq.length xs = m /\ (forall x: t_T. contains'0 xs x  -> contains'1 s x)))
     -> ([%#sfset'5] concat (singleton (Seq.empty: Seq.seq t_T)) (replicate s m) = replicate s m)
    && ([%#sfset'6] concat (replicate s m) (singleton (Seq.empty: Seq.seq t_T)) = replicate s m)
     -> (let _ = concat_empty (replicate s m) in [@expl:concat_replicate ensures] [%#sfset'0] replicate s (n + m)
    = concat (replicate s n) (replicate s m)))
  else
    ([%#sfset'7] forall s'0: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s'0 t) u
    = cons s'0 (concat t u))
     -> (let _ = cons_concat in (([@expl:concat_replicate requires] [%#sfset] 0 <= n - 1 /\ 0 <= m)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] replicate s (n - 1 + m) = concat (replicate s (n - 1)) (replicate s m))
     -> (let _ = concat_replicate (n - 1) m s in [@expl:concat_replicate ensures] [%#sfset'0] replicate s (n + m)
    = concat (replicate s n) (replicate s m))))
  )
end
module M_creusot_contracts__logic__fset__concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 543 0 543 39]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 541 10 541 61
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 542 10 542 61
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 544 20 544 68
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 545 20 545 68
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 544 4 544 70
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 261 14 261 144
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 205 14 205 57
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 207 8 207 31
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 62 8 62 26
  
  use seq.Seq
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 262 4 262 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'4] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 61 4 61 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'8] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 206 4 206 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'6] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'5] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s  : Fset.fset (Seq.seq t_T)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 543 0 543 39] (s'0: Fset.fset (Seq.seq t_T)) : ()
  
  goal vc_concat_empty: ([%#sfset'1] forall xs: Seq.seq t_T. Seq.(++) xs (Seq.empty: Seq.seq t_T) = xs)
  && (let _ = () in let _ = () in ([%#sfset'2] forall xs: Seq.seq t_T. Seq.(++) (Seq.empty: Seq.seq t_T) xs = xs)
  && (let _ = () in let _ = () in ([@expl:concat_empty ensures #0] [%#sfset] concat (singleton (Seq.empty: Seq.seq t_T)) s
  = s)
  && ([@expl:concat_empty ensures #1] [%#sfset'0] concat s (singleton (Seq.empty: Seq.seq t_T)) = s)))
end
module M_creusot_contracts__logic__fset__concat_replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 555 0 555 60]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 551 11 551 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 552 10 553 67
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 554 10 554 11
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 269 15 269 21
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 270 14 270 123
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 271 14 271 15
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 541 10 541 61
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 542 10 542 61
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 505 10 506 83
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 507 10 508 83
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 524 11 524 27
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 525 10 525 76
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 526 10 526 11
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 557 8 563 9
  let%span sfset'13 = "../../creusot-contracts/src/logic/fset.rs" 287 15 287 21
  let%span sfset'14 = "../../creusot-contracts/src/logic/fset.rs" 288 14 288 123
  let%span sfset'15 = "../../creusot-contracts/src/logic/fset.rs" 289 14 289 15
  let%span sfset'16 = "../../creusot-contracts/src/logic/fset.rs" 292 12 297 13
  let%span sfset'17 = "../../creusot-contracts/src/logic/fset.rs" 261 14 261 144
  let%span sfset'18 = "../../creusot-contracts/src/logic/fset.rs" 274 12 280 13
  let%span sfset'19 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  let%span sfset'20 = "../../creusot-contracts/src/logic/fset.rs" 544 4 544 70
  let%span sfset'21 = "../../creusot-contracts/src/logic/fset.rs" 205 14 205 57
  let%span sfset'22 = "../../creusot-contracts/src/logic/fset.rs" 207 8 207 31
  let%span sfset'23 = "../../creusot-contracts/src/logic/fset.rs" 509 25 509 27
  let%span sfset'24 = "../../creusot-contracts/src/logic/fset.rs" 529 8 534 9
  let%span sfset'25 = "../../creusot-contracts/src/logic/fset.rs" 252 14 252 117
  let%span sfset'26 = "../../creusot-contracts/src/logic/fset.rs" 62 8 62 26
  let%span sfset'27 = "../../creusot-contracts/src/logic/fset.rs" 514 10 514 133
  let%span sfset'28 = "../../creusot-contracts/src/logic/fset.rs" 516 4 516 117
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'19] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'19] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 61 4 61 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'26] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 206 4 206 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'22] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'21] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 253 4 253 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'25] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 272 4 272 50] (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. ([%#sfset'2] n >= 0)
   -> replicate self n
  = ([%#sfset'18] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty: Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. ([%#sfset'2] n >= 0)
   -> ([%#sfset'3] forall xs: Seq.seq t_T. contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
  
  function replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 290 4 290 56] (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_up_to_def: forall self: Fset.fset t_T, n: int. ([%#sfset'13] n >= 0)
   -> replicate_up_to self n
  = ([%#sfset'16] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty: Seq.seq t_T)
  else
    Fset.union (replicate_up_to self (n - 1)) (replicate self n)
  )
  
  axiom replicate_up_to_spec: forall self: Fset.fset t_T, n: int. ([%#sfset'13] n >= 0)
   -> ([%#sfset'14] forall xs: Seq.seq t_T. contains (replicate_up_to self n) xs
  = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 262 4 262 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'17] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 543 0 543 39] (s: Fset.fset (Seq.seq t_T)) : () =
    [%#sfset'20] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty_spec: forall s: Fset.fset (Seq.seq t_T). [%#sfset'5] concat (singleton (Seq.empty: Seq.seq t_T)) s
  = s
  
  axiom concat_empty_spec'0: forall s: Fset.fset (Seq.seq t_T). [%#sfset'6] concat s (singleton (Seq.empty: Seq.seq t_T))
  = s
  
  constant concat_union: () = [%#sfset'23] ()
  
  axiom concat_union_spec: [%#sfset'7] forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
  = Fset.union (concat s1 t) (concat s2 t)
  
  axiom concat_union_spec'0: [%#sfset'8] forall s: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s (Fset.union t1 t2)
  = Fset.union (concat s t1) (concat s t2)
  
  constant cons_concat: () = [%#sfset'28] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat_spec: [%#sfset'27] forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
  = cons s (concat t u)
  
  function concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 527 0 527 54] (n: int) (m: int) (s: Fset.fset t_T) : ()
  
  
  axiom concat_replicate_def: forall n: int, m: int, s: Fset.fset t_T. ([%#sfset'9] 0 <= n /\ 0 <= m)
   -> concat_replicate n m s
  = ([%#sfset'24] if n = 0 then
    let _ = concat_empty (replicate s m) in ()
  else
    let _ = cons_concat in let _ = concat_replicate (n - 1) m s in ()
  )
  
  axiom concat_replicate_spec: forall n: int, m: int, s: Fset.fset t_T. ([%#sfset'9] 0 <= n /\ 0 <= m)
   -> ([%#sfset'10] replicate s (n + m) = concat (replicate s n) (replicate s m))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T
  
  function concat_replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 555 0 555 60] (n'0: int) (m'0: int) (s'0: Fset.fset t_T) : ()
  
  
  goal vc_concat_replicate_up_to: ([%#sfset] 0 <= n /\ n < m)
   -> (if n + 1 = m then
    ([@expl:replicate requires] [%#sfset'2] n + 1 >= 0)
    /\ (([%#sfset'3] forall xs: Seq.seq t_T. contains (replicate s (n + 1)) xs
    = (Seq.length xs = n + 1 /\ (forall x: t_T. contains'0 xs x  -> contains'1 s x)))
     -> ([%#sfset'5] concat (singleton (Seq.empty: Seq.seq t_T)) (replicate s (n + 1)) = replicate s (n + 1))
    && ([%#sfset'6] concat (replicate s (n + 1)) (singleton (Seq.empty: Seq.seq t_T)) = replicate s (n + 1))
     -> (let _ = concat_empty (replicate s (n
    + 1)) in [@expl:concat_replicate_up_to ensures] [%#sfset'0] replicate_up_to s m
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - n - 1)))))
  else
    ([%#sfset'7] forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
    = Fset.union (concat s1 t) (concat s2 t))
    && ([%#sfset'8] forall s'0: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s'0 (Fset.union t1 t2)
    = Fset.union (concat s'0 t1) (concat s'0 t2))
     -> (let _ = concat_union in ([@expl:concat_replicate requires] [%#sfset'9] 0 <= n /\ 0 <= m - n - 1)
    /\ (([%#sfset'10] replicate s (n + (m - n - 1)) = concat (replicate s n) (replicate s (m - n - 1)))
     -> (let _ = concat_replicate n (m - n - 1) s in (([@expl:concat_replicate_up_to requires] [%#sfset] 0 <= n
    /\ n < m - 1)
    /\ 0 <= ([%#sfset'1] m) /\ ([%#sfset'1] m - 1) < ([%#sfset'1] m))
    /\ (([%#sfset'0] replicate_up_to s (m - 1)
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - 1 - n - 1))))
     -> (let _ = concat_replicate_up_to n (m
    - 1) s in [@expl:concat_replicate_up_to ensures] [%#sfset'0] replicate_up_to s m
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - n - 1))))))))
  )
end
module M_creusot_contracts__logic__id__qyi676594641912026951__clone [#"../../creusot-contracts/src/logic/id.rs" 20 4 20 27] (* <logic::id::Id as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sid = "../../creusot-contracts/src/logic/id.rs" 19 14 19 29
  
  use creusot.prelude.Any
  
  type t_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone'[#"../../creusot-contracts/src/logic/id.rs" 20 4 20 27] (self:t_Id) (return'  (x:t_Id))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_Id = Any.any_l () | & self'0: t_Id = self ] 
    [ return''0 (result:t_Id)-> {[@expl:clone ensures] [%#sid] result = self} (! return' {result}) ]

end
module M_creusot_contracts__logic__id__qyi14416423697585690270__ne [#"../../creusot-contracts/src/logic/id.rs" 37 4 37 38] (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sid = "../../creusot-contracts/src/logic/id.rs" 36 14 36 41
  let%span sid'0 = "../../creusot-contracts/src/logic/id.rs" 29 14 29 41
  
  use creusot.prelude.Any
  
  type t_Id
  
  let rec eq (self:t_Id) (other:t_Id) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sid'0] result = (self = other)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ne[#"../../creusot-contracts/src/logic/id.rs" 37 4 37 38] (self:t_Id) (other:t_Id) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = eq {self'0} {other'0} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- not _4 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: bool = Any.any_l () | & self'0: t_Id = self | & other'0: t_Id = other | & _4: bool = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:ne ensures] [%#sid] result <> (self = other)} (! return' {result}) ]

end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  constant y  : int
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: int) (y'0: int) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] (x <= y) = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  constant y  : int
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: int) (y'0: int) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] (x < y) = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  constant y  : int
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: int) (y'0: int) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] (x >= y) = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  constant y  : int
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: int) (y'0: int) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] (x > y) = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: int) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'3] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  constant y  : int
  
  constant z  : int
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: int) (y'0: int) (z'0: int) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'2] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  constant y  : int
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: int) (y'0: int) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'2] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  constant y  : int
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: int) (y'0: int) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : int
  
  constant y  : int
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: int) (y'0: int) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] UInt8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] UInt8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] UInt8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] UInt8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt8.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'3] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  constant z  : UInt8.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt8.t) (y'0: UInt8.t) (z'0: UInt8.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'2] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'2] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] UInt16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] UInt16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] UInt16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] UInt16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt16.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'3] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  constant z  : UInt16.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt16.t) (y'0: UInt16.t) (z'0: UInt16.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'2] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'2] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] UInt32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] UInt32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] UInt32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] UInt32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt32.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'3] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  constant z  : UInt32.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt32.t) (y'0: UInt32.t) (z'0: UInt32.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'2] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'2] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt64.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'3] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt64.t) (y'0: UInt64.t) (z'0: UInt64.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] UInt128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] UInt128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] UInt128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] UInt128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt128.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'3] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  constant z  : UInt128.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt128.t) (y'0: UInt128.t) (z'0: UInt128.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'2] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'2] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt64.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'3] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt64.t) (y'0: UInt64.t) (z'0: UInt64.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Int8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Int8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Int8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Int8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int8.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'3] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  constant z  : Int8.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int8.t) (y'0: Int8.t) (z'0: Int8.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'2] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'2] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Int16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Int16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Int16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Int16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int16.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'3] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  constant z  : Int16.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int16.t) (y'0: Int16.t) (z'0: Int16.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'2] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'2] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Int32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Int32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Int32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Int32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int32.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'3] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  constant z  : Int32.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int32.t) (y'0: Int32.t) (z'0: Int32.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'2] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'2] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int64.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'3] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int64.t) (y'0: Int64.t) (z'0: Int64.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Int128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Int128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Int128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Int128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int128.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'3] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  constant z  : Int128.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int128.t) (y'0: Int128.t) (z'0: Int128.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'2] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'2] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int64.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'3] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int64.t) (y'0: Int64.t) (z'0: Int64.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Char.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Char.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Char.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Char.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Char.t) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'3] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  constant z  : Char.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Char.t) (y'0: Char.t) (z'0: Char.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'2] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'2] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: bool) (y'0: bool) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] Bool.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: bool) (y'0: bool) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] Bool.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: bool) (y'0: bool) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] Bool.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: bool) (y'0: bool) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] Bool.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: bool) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'3] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  constant y  : bool
  
  constant z  : bool
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: bool) (y'0: bool) (z'0: bool) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)
   -> ([%#sord'0] cmp_log y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'2] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: bool) (y'0: bool) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'2] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: bool) (y'0: bool) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : bool
  
  constant y  : bool
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: bool) (y'0: bool) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self: tuple) (o: tuple) =
    [%#sord'1] self._p0 = o._p0 /\ le_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] le_log'1 x y = (cmp_log'1 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self: tuple) (o: tuple) =
    [%#sord'1] self._p0 = o._p0 /\ lt_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] lt_log'1 x y = (cmp_log'1 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self: tuple) (o: tuple) =
    [%#sord'1] self._p0 = o._p0 /\ ge_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] ge_log'1 x y = (cmp_log'1 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self: tuple) (o: tuple) =
    [%#sord'1] self._p0 = o._p0 /\ gt_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] gt_log'1 x y = (cmp_log'1 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: tuple) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log'1 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'16] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'14] cmp_log x y = C_Greater)
   -> ([%#sord'15] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'12] cmp_log x y = C_Less)
   -> ([%#sord'13] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'9] cmp_log x y = o)
   -> ([%#sord'10] cmp_log y z = o)  -> ([%#sord'11] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'8] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'7] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'6] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'5] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'4] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'16] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'14] cmp_log'0 x y = C_Greater)
   -> ([%#sord'15] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'12] cmp_log'0 x y = C_Less)
   -> ([%#sord'13] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'9] cmp_log'0 x y = o)
   -> ([%#sord'10] cmp_log'0 y z = o)  -> ([%#sord'11] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'8] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'7] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'6] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'3] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  constant y  : tuple
  
  constant z  : tuple
  
  constant o  : t_Ordering
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: tuple) (y'0: tuple) (z'0: tuple) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log'1 x y = o)
   -> ([%#sord'0] cmp_log'1 y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log'1 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  constant y  : tuple
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log'1 x y = C_Less)
   -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log'1 y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  constant y  : tuple
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log'1 x y = C_Greater)
   -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log'1 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : tuple
  
  constant y  : tuple
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log'1 x y = C_Equal)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__factor [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Ag
  
  constant factor  : t_Ag
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (self'0: t_Ag) (factor'1: t_Ag) : t_Option
  
  
  goal vc_factor: [@expl:factor ensures] [%#sagree] match op self factor with
    | C_Some c -> op factor c = C_Some self
    | C_None -> forall c: t_Ag. op factor c <> C_Some self
    end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 29 37 29 39
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Ag
  
  constant b  : t_Ag
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36] (a'0: t_Ag) (b'0: t_Ag) : ()
  
  goal vc_commutative: [@expl:commutative ensures] [%#sagree] op a b = op b a
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 34 46 34 48
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  
  use map.Map
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Ag
  
  constant b  : t_Ag
  
  constant c  : t_Ag
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45] (a'0: t_Ag) (b'0: t_Ag) (c'0: t_Ag) : ()
  
  
  goal vc_associative: [@expl:associative ensures] [%#sagree] and_then_logic (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Ag) -> op a bc)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__core [#"../../creusot-contracts/src/logic/ra/agree.rs" 42 4 42 33] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 38 14 41 5
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 43 8 43 18
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Ag
  
  function core [#"../../creusot-contracts/src/logic/ra/agree.rs" 42 4 42 33] (self'0: t_Ag) : t_Option
  
  goal vc_core: [@expl:core ensures] [%#sagree] match C_Some self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/agree.rs" 53 4 53 43] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 47 15 47 33
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 48 15 48 39
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 49 14 52 5
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 53 44 53 46
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'4 = "../../creusot-contracts/src/logic/ra/agree.rs" 38 14 41 5
  let%span sagree'5 = "../../creusot-contracts/src/logic/ra/agree.rs" 43 8 43 18
  let%span sagree'6 = "../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'7 = "../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'3] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  function core [#"../../creusot-contracts/src/logic/ra/agree.rs" 42 4 42 33] (self: t_Ag) : t_Option =
    [%#sagree'5] C_Some self
  
  axiom core_spec: forall self: t_Ag. [%#sagree'4] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function factor [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (self: t_Ag) (factor'0: t_Ag) : t_Option
   =
    [%#sagree'7] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'6] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Ag. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Ag) (other: t_Ag) =
    [%#sra] factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Ag
  
  constant i  : t_Ag
  
  function core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/agree.rs" 53 4 53 43] (self'0: t_Ag) (i'0: t_Ag) : ()
  
  
  goal vc_core_is_maximal_idemp: ([%#sagree] op i i = C_Some i)
   -> ([%#sagree'0] op i self = C_Some self)
   -> ([@expl:core_is_maximal_idemp ensures] [%#sagree'1] match core self with
    | C_Some c -> incl i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 40 44 40 46
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_T) =
    [%#sauth'3] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Option
  
  constant f1  : t_T
  
  constant f2  : t_T
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a'0: t_Option) (f1'0: t_T) (f2'0: t_T) : ()
  
  
  goal vc_rel_mono: ([%#sauth] rel a f1)
   -> ([%#sauth'0] incl f2 f1)  -> ([@expl:rel_mono ensures] [%#sauth'1] rel a f2)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 44 36 44 38
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_T) =
    [%#sauth'1] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Option
  
  constant f  : t_T
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a'0: t_Option) (f'0: t_T) : ()
  
  goal vc_rel_none: [@expl:rel_none ensures] [%#sauth] rel (C_None) f
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 48 30 48 32
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'14] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'0] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'13] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'10] incl a b)
   -> ([%#sra'11] incl b c)  -> ([%#sra'12] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'9] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'8] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'7] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'5] op self other = C_Some comb)
   -> ([%#sra'6] incl self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_T) =
    [%#sauth'1] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. [%#sra'15] op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. [%#sra'16] op (core_total self) self = C_Some self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_T
  
  axiom unit_spec: [%#sra] forall x: t_T [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = [%#sra'4] ()
  
  axiom unit_core_spec: [%#sra'3] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'2] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'1] forall x: t_T. incl x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Option
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a'0: t_Option) : ()
  
  goal vc_rel_unit: [@expl:rel_unit ensures] [%#sauth] rel a unit'
end
module M_creusot_contracts__logic__ra__auth__qyi1963254905082259216__update [#"../../creusot-contracts/src/logic/ra/auth.rs" 72 4 72 52] (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 67 15 67 33
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 69 8 69 82
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 73 8 73 82
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 59 8 62 9
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'7 = "../../creusot-contracts/src/logic/ra/auth.rs" 40 44 40 46
  let%span sauth'8 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'9 = "../../creusot-contracts/src/logic/ra/auth.rs" 44 36 44 38
  let%span sauth'10 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sauth'11 = "../../creusot-contracts/src/logic/ra/auth.rs" 48 30 48 32
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 84 15 84 49
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 85 15 85 65
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 87 8 87 67
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate  =
    { t_AuthUpdate__0: t_U }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption'4] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'10] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'5] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra'1] op self other = C_Some comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_R) : t_R
  
  axiom core_total_spec: forall self: t_R. [%#sra'15] op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_R. [%#sra'16] op (core_total self) self = C_Some self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_R
  
  axiom unit_spec: [%#sra'0] forall x: t_R [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_R. incl x x
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_R) =
    [%#sauth'3] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option) : () =
    [%#sauth'11] ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sauth'10] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option) (f: t_R) : () =
    [%#sauth'9] ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_R. [%#sauth'8] rel (C_None) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option) (f1: t_R) (f2: t_R) : ()
   =
    [%#sauth'7] ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_R, f2: t_R. ([%#sauth'4] rel a f1)
   -> ([%#sauth'5] incl f2 f1)  -> ([%#sauth'6] rel a f2)
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_R
  
  axiom frag_spec: forall self: t_View. [%#sview] rel (auth self) (frag self)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 58 4 58 43] (self: t_AuthUpdate) (from: t_View) =
    [%#sauth'2] match auth from with
      | C_Some auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None -> false
      end
  
  type tuple  =
    { _p0: t_R; _p1: t_R }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U) (from_auth: t_R) (from_frag: t_R) : tuple
  
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_R bool) (a: t_R) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. ([%#sutil] exists x: t_R. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_R =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_R) -> true)
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0
  
   =
    [%#soption'3] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] and_then_logic'0 (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 90 4 90 76] (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option) : ()
  
  
  axiom frame_preserving_spec: forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option. ([%#supdate] premise self from_auth from_frag)
   -> ([%#supdate'0] op'0 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth))
   -> ([%#supdate'1] let {_p0 = to_auth ; _p1 = to_frag} = update self from_auth from_frag in op'0 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth))
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_R) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_R. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'1] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_R. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'2] frag (new auth'0 frag'0) = frag'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_AuthUpdate
  
  constant from  : t_View
  
  constant _2  : ()
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 72 4 72 52] (self'0: t_AuthUpdate) (from'0: t_View) (_2'0: ()) : t_View
  
  
  goal vc_update: ([%#sauth] premise'0 self from)
   -> ([@expl:unwrap_logic requires] [%#soption] auth from <> C_None)
  /\ (([%#sview] rel (auth from) (frag from))
   -> (let {_p0 = auth'0 ; _p1 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in let _ = () in ([@expl:new requires] [%#sview'0] rel (C_Some auth'0) frag'0)
  /\ (([%#sview'1] auth (new (C_Some auth'0) frag'0) = C_Some auth'0)
  && ([%#sview'2] frag (new (C_Some auth'0) frag'0) = frag'0)
   -> ([@expl:update ensures] [%#sauth'0] let {_p0 = auth'1 ; _p1 = frag'1} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in rel (C_Some auth'1) frag'1))))
end
module M_creusot_contracts__logic__ra__auth__qyi1963254905082259216__frame_preserving [#"../../creusot-contracts/src/logic/ra/auth.rs" 82 4 82 60] (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 79 15 79 33
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 80 15 80 37
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 81 14 81 57
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 83 8 83 46
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 59 8 62 9
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 67 15 67 33
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 69 8 69 82
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 73 8 73 82
  let%span sauth'7 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'8 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'9 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'10 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'11 = "../../creusot-contracts/src/logic/ra/auth.rs" 40 44 40 46
  let%span sauth'12 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'13 = "../../creusot-contracts/src/logic/ra/auth.rs" 44 36 44 38
  let%span sauth'14 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sauth'15 = "../../creusot-contracts/src/logic/ra/auth.rs" 48 30 48 32
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 84 15 84 49
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 85 15 85 65
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 87 8 87 67
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate  =
    { t_AuthUpdate__0: t_U }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption'4] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'0] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'5] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra'1] op self other = C_Some comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_R) : t_R
  
  axiom core_total_spec: forall self: t_R. [%#sra'15] op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_R. [%#sra'16] op (core_total self) self = C_Some self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_R
  
  axiom unit_spec: [%#sra'10] forall x: t_R [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_R. incl x x
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_R) =
    [%#sauth'7] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option) : () =
    [%#sauth'15] ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sauth'14] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option) (f: t_R) : () =
    [%#sauth'13] ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_R. [%#sauth'12] rel (C_None) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option) (f1: t_R) (f2: t_R) : ()
   =
    [%#sauth'11] ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_R, f2: t_R. ([%#sauth'8] rel a f1)
   -> ([%#sauth'9] incl f2 f1)  -> ([%#sauth'10] rel a f2)
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_R
  
  axiom frag_spec: forall self: t_View. [%#sview] rel (auth self) (frag self)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 58 4 58 43] (self: t_AuthUpdate) (from: t_View) =
    [%#sauth'3] match auth from with
      | C_Some auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None -> false
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_View
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_View t_Option'0) : t_Option'0
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_R) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_R. ([%#sview'3] rel auth'0 frag'0)
   -> ([%#sview'4] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_R. ([%#sview'3] rel auth'0 frag'0)
   -> ([%#sview'5] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option'0
  
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None ; _p1 = a} -> if rel a f then C_Some'0 (new a f) else C_None'0
        | {_p0 = a ; _p1 = C_None} -> if rel a f then C_Some'0 (new a f) else C_None'0
        | _ -> C_None'0
        end
      | C_None -> C_None'0
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'2] and_then_logic'0 (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'1] op'0 a b = op'0 b a
  
  type tuple'0  =
    { _p0'0: t_R; _p1'0: t_R }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U) (from_auth: t_R) (from_frag: t_R) : tuple'0
  
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_R bool) (a: t_R) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. ([%#sutil] exists x: t_R. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_R =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_R) -> true)
      end
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 72 4 72 52] (self: t_AuthUpdate) (from: t_View) (_2: ()) : t_View
  
   =
    [%#sauth'6] let {_p0'0 = auth'0 ; _p1'0 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in let _ = () in new (C_Some auth'0) frag'0
  
  axiom update_spec: forall self: t_AuthUpdate, from: t_View, _2: (). ([%#sauth'4] premise'0 self from)
   -> ([%#sauth'5] let {_p0'0 = auth'0 ; _p1'0 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in rel (C_Some auth'0) frag'0)
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_View bool) (a: t_View)
  
   =
    [%#smapping] Map.get self a
  
  function such_that'0 [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_View bool) : t_View
  
  axiom such_that_spec'0: forall p: Map.map t_View bool. ([%#sutil] exists x: t_View. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that'0 p))
  
  function unwrap_logic'0 [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option'0) : t_View =
    [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that'0 (fun (__0: t_View) -> true)
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option t_Option'1) : t_Option'1
  
   =
    [%#soption'4] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_R t_Option) : t_Option'1
  
   =
    [%#soption'3] match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'1
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'1 other
      | {_p1 = C_None} -> C_Some'1 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] and_then_logic'1 (op'1 a b) (fun (ab: t_Option) -> op'1 ab c)
  = and_then_logic'1 (op'1 b c) (fun (bc: t_Option) -> op'1 a bc)
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 90 4 90 76] (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option) : ()
  
  
  axiom frame_preserving_spec: forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option. ([%#supdate] premise self from_auth from_frag)
   -> ([%#supdate'0] op'1 (C_Some from_frag) frame = C_Some'1 (C_Some from_auth))
   -> ([%#supdate'1] let {_p0'0 = to_auth ; _p1'0 = to_frag} = update self from_auth from_frag in op'1 (C_Some to_frag) frame
  = C_Some'1 (C_Some to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_AuthUpdate
  
  constant from  : t_View
  
  constant frame  : t_View
  
  function frame_preserving'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 82 4 82 60] (self'0: t_AuthUpdate) (from'0: t_View) (frame'0: t_View) : ()
  
  
  goal vc_frame_preserving: ([%#sauth] premise'0 self from)
   -> ([%#sauth'0] op'0 from frame <> C_None'0)
   -> ([@expl:unwrap_logic requires] [%#soption] auth from <> C_None)
  /\ (let auth'0 = unwrap_logic (auth from) in ([@expl:unwrap_logic requires] [%#soption] op'0 from frame <> C_None'0)
  /\ (([%#sview] rel (auth (unwrap_logic'0 (op'0 from frame))) (frag (unwrap_logic'0 (op'0 from frame))))
   -> (let x = frag (unwrap_logic'0 (op'0 from frame)) in ([%#sra] match factor auth'0 x with
    | C_Some c -> op x c = C_Some auth'0
    | C_None -> forall c: t_R. op x c <> C_Some auth'0
    end)
   -> ([@expl:unwrap_logic requires] [%#soption] factor auth'0 x <> C_None)
  /\ (let y = unwrap_logic (factor auth'0 x) in ([%#sview] rel (auth frame) (frag frame))
   -> ([@expl:unwrap_logic requires] [%#soption] op (frag frame) y <> C_None)
  /\ (let f = unwrap_logic (op (frag frame) y) in ([%#sview] rel (auth from) (frag from))
   -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_AuthUpdate__0 auth'0 (frag from))
  && ([@expl:frame_preserving requires #1] [%#supdate'0] op'1 (C_Some (frag from)) (C_Some f)
  = C_Some'1 (C_Some auth'0)))
  /\ (([%#supdate'1] let {_p0'0 = to_auth ; _p1'0 = to_frag} = update self.t_AuthUpdate__0 auth'0 (frag from) in op'1 (C_Some to_frag) (C_Some f)
  = C_Some'1 (C_Some to_auth))
   -> (let _ = frame_preserving self.t_AuthUpdate__0 auth'0 (frag from) (C_Some f) in [@expl:frame_preserving ensures] [%#sauth'1] op'0 (update'0 self from ()) frame
  <> C_None'0)))))))
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__factor [#"../../creusot-contracts/src/logic/ra/excl.rs" 26 4 26 49] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 22 14 25 5
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 27 8 27 12
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'1] C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Excl
  
  constant factor  : t_Excl
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 26 4 26 49] (self'0: t_Excl) (factor'1: t_Excl) : t_Option
  
  
  goal vc_factor: [@expl:factor ensures] [%#sexcl] match C_None with
    | C_Some c -> op factor c = C_Some self
    | C_None -> forall c: t_Excl. op factor c <> C_Some self
    end
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 36] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 32
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 33 37 33 39
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'1] C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Excl
  
  constant b  : t_Excl
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 36] (a'0: t_Excl) (b'0: t_Excl) : ()
  
  goal vc_commutative: [@expl:commutative ensures] [%#sexcl] op a b = op b a
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 38 4 38 45] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 37 14 37 98
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 38 46 38 48
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  
  use map.Map
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Excl t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'1] C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Excl
  
  constant b  : t_Excl
  
  constant c  : t_Excl
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 38 4 38 45] (a'0: t_Excl) (b'0: t_Excl) (c'0: t_Excl) : ()
  
  
  goal vc_associative: [@expl:associative ensures] [%#sexcl] and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__core [#"../../creusot-contracts/src/logic/ra/excl.rs" 46 4 46 33] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 42 14 45 5
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 47 8 47 12
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'1] C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Excl
  
  function core [#"../../creusot-contracts/src/logic/ra/excl.rs" 46 4 46 33] (self'0: t_Excl) : t_Option
  
  goal vc_core: [@expl:core ensures] [%#sexcl] match C_None with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 57 4 57 43] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 51 15 51 33
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 52 15 52 39
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 53 14 56 5
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 57 44 57 46
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 42 14 45 5
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 47 8 47 12
  let%span sexcl'6 = "../../creusot-contracts/src/logic/ra/excl.rs" 22 14 25 5
  let%span sexcl'7 = "../../creusot-contracts/src/logic/ra/excl.rs" 27 8 27 12
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'3] C_None
  
  function core [#"../../creusot-contracts/src/logic/ra/excl.rs" 46 4 46 33] (self: t_Excl) : t_Option =
    [%#sexcl'5] C_None
  
  axiom core_spec: forall self: t_Excl. [%#sexcl'4] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function factor [#"../../creusot-contracts/src/logic/ra/excl.rs" 26 4 26 49] (self: t_Excl) (factor'0: t_Excl) : t_Option
  
   =
    [%#sexcl'7] C_None
  
  axiom factor_spec: forall self: t_Excl, factor'0: t_Excl. [%#sexcl'6] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Excl. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Excl) (other: t_Excl) =
    [%#sra] factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Excl
  
  constant i  : t_Excl
  
  function core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 57 4 57 43] (self'0: t_Excl) (i'0: t_Excl) : ()
  
  
  goal vc_core_is_maximal_idemp: ([%#sexcl] op i i = C_Some i)
   -> ([%#sexcl'0] op i self = C_Some self)
   -> ([@expl:core_is_maximal_idemp ensures] [%#sexcl'1] match core self with
    | C_Some c -> incl i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__excl__qyi10476702783314713742__update [#"../../creusot-contracts/src/logic/ra/excl.rs" 74 4 74 52] (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 73 15 73 33
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 75 8 75 21
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 68 8 68 12
  
  type t_T
  
  type t_ExclUpdate  =
    { t_ExclUpdate__0: t_T }
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/excl.rs" 67 4 67 40] (self: t_ExclUpdate) (_1: t_Excl) =
    [%#sexcl'1] true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ExclUpdate
  
  constant from  : t_Excl
  
  constant _2  : ()
  
  function update [#"../../creusot-contracts/src/logic/ra/excl.rs" 74 4 74 52] (self'0: t_ExclUpdate) (from'0: t_Excl) (_2'0: ()) : t_Excl
  
  
  goal vc_update: true
end
module M_creusot_contracts__logic__ra__excl__qyi10476702783314713742__frame_preserving [#"../../creusot-contracts/src/logic/ra/excl.rs" 82 4 82 60] (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 79 15 79 33
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 80 15 80 37
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 81 14 81 57
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 82 61 82 63
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 68 8 68 12
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 73 15 73 33
  let%span sexcl'6 = "../../creusot-contracts/src/logic/ra/excl.rs" 75 8 75 21
  let%span sexcl'7 = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 32
  let%span sexcl'8 = "../../creusot-contracts/src/logic/ra/excl.rs" 33 37 33 39
  let%span sexcl'9 = "../../creusot-contracts/src/logic/ra/excl.rs" 37 14 37 98
  let%span sexcl'10 = "../../creusot-contracts/src/logic/ra/excl.rs" 38 46 38 48
  
  use map.Map
  
  type t_T
  
  type t_ExclUpdate  =
    { t_ExclUpdate__0: t_T }
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/excl.rs" 67 4 67 40] (self: t_ExclUpdate) (_1: t_Excl) =
    [%#sexcl'3] true
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Excl t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'4] C_None
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 38 4 38 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
   =
    [%#sexcl'10] ()
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'9] and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 36] (a: t_Excl) (b: t_Excl) : () =
    [%#sexcl'8] ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'7] op a b = op b a
  
  function update [#"../../creusot-contracts/src/logic/ra/excl.rs" 74 4 74 52] (self: t_ExclUpdate) (from: t_Excl) (_2: ()) : t_Excl
  
   =
    [%#sexcl'6] { t_Excl__0 = self.t_ExclUpdate__0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ExclUpdate
  
  constant from  : t_Excl
  
  constant frame  : t_Excl
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/excl.rs" 82 4 82 60] (self'0: t_ExclUpdate) (from'0: t_Excl) (frame'0: t_Excl) : ()
  
  
  goal vc_frame_preserving: ([%#sexcl] premise self from)
   -> ([%#sexcl'0] op from frame <> C_None)
   -> ([@expl:frame_preserving ensures] [%#sexcl'1] op (update self from ()) frame <> C_None)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__factor [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 16 30 60
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 31 42 35 17
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'5] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'5] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'7] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'6] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'3] incl a b)
   -> ([%#sra'4] incl b c)  -> ([%#sra'5] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'9] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'8] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'3] and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'6] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'11] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                         _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'10] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'8] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'9] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'5] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a: t_Option'0) (b: t_Option'0) : ()
  
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. [%#soption'2] op'0 a b = op'0 b a
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1
  
   =
    [%#soption'0] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'0} -> C_Some'1 x
      | {_p0 = C_None'0} -> C_None'1
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. [%#soption] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option'0) (other: t_Option'0) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
   =
    [%#sra'6] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. ([%#sra'3] incl'0 a b)
   -> ([%#sra'4] incl'0 b c)  -> ([%#sra'5] incl'0 a c)
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
   =
    [%#sra'2] ()
  
  axiom incl_op_spec'0: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. ([%#sra'0] op'0 self other
  = C_Some'1 comb)  -> ([%#sra'1] incl'0 self comb)
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_Option'0) (a: tuple'1) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'1 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'1 t_Option'0. [%#sfmap'2] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic'1 f { _p0'1 = k; _p1'1 = v }
    end
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self: t_FMap) (other: t_FMap) =
    [%#sfmap'7] let _ = () in forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'3] ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FMap
  
  constant factor'1  : t_FMap
  
  function factor'2 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (self'0: t_FMap) (factor'3: t_FMap) : t_Option
  
  
  goal vc_factor: if [%#sfmap'0] forall k: t_K. incl'0 (get factor'1 k) (get self k) then
    (forall __0: tuple'1. let {_p0'1 = k ; _p1'1 = vo} = __0 in ([%#soption] match factor'0 (C_Some'0 vo) (get factor'1 k) with
      | C_Some'1 c -> op'0 (get factor'1 k) c = C_Some'1 (C_Some'0 vo)
      | C_None'1 -> forall c: t_Option'0. op'0 (get factor'1 k) c <> C_Some'1 (C_Some'0 vo)
      end)
     -> match factor'0 (C_Some'0 vo) (get factor'1 k) with
      | C_Some'1 r -> true
      | C_None'1 -> true
      end)
    /\ (([%#sfmap'2] forall k: t_K [get (filter_map self ([%#sfmap'1] fun (__0: tuple'1) -> let {_p0'1 = k'0 ; _p1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k'0) with
      | C_Some'1 r -> r
      | C_None'1 -> C_None'0
      end)) k]. get (filter_map self ([%#sfmap'1] fun (__0: tuple'1) -> let {_p0'1 = k'0 ; _p1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k'0) with
      | C_Some'1 r -> r
      | C_None'1 -> C_None'0
      end)) k
    = match get self k with
      | C_None'0 -> C_None'0
      | C_Some'0 v -> index_logic'1 ([%#sfmap'1] fun (__0: tuple'1) -> let {_p0'1 = k'0 ; _p1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k'0) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) { _p0'1 = k; _p1'1 = v }
      end)
     -> (let res = filter_map self ([%#sfmap'1] fun (__0: tuple'1) -> let {_p0'1 = k ; _p1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'1 k) with
      | C_Some'1 r -> r
      | C_None'1 -> C_None'0
      end) in match op'1 factor'1 res with
      | C_None -> false
      && (let _ = () in let _ = () in [@expl:factor ensures] [%#sfmap] match C_Some res with
        | C_Some c -> op'1 factor'1 c = C_Some self
        | C_None -> forall c: t_FMap. op'1 factor'1 c <> C_Some self
        end)
      | C_Some o -> ([%#sfmap'3] ext_eq o self = (o = self))
       -> ext_eq o self
      && (let _ = () in let _ = () in [@expl:factor ensures] [%#sfmap] match C_Some res with
        | C_Some c -> op'1 factor'1 c = C_Some self
        | C_None -> forall c: t_FMap. op'1 factor'1 c <> C_Some self
        end)
      end))
  else
    [@expl:factor ensures] [%#sfmap] match C_None with
      | C_Some c -> op'1 factor'1 c = C_Some self
      | C_None -> forall c: t_FMap. op'1 factor'1 c <> C_Some self
      end

end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__commutative [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'4] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'8] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                        _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'7] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'5] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'6] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'1] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self: t_FMap) (other: t_FMap) =
    [%#sfmap'3] let _ = () in forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'2] ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_FMap
  
  constant b  : t_FMap
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a'0: t_FMap) (b'0: t_FMap) : ()
  
  goal vc_commutative: let _ = () in [@expl:commutative ensures] [%#sfmap] op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__associative [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'4] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'8] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                        _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'7] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'5] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'6] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'2] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1  =
    { _p0'1: t_Option; _p1'1: t_Option }
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self: t_FMap) (other: t_FMap) =
    [%#sfmap'3] let _ = () in forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'0] ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_FMap
  
  constant b  : t_FMap
  
  constant c  : t_FMap
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a'0: t_FMap) (b'0: t_FMap) (c'0: t_FMap) : ()
  
  
  goal vc_associative: match { _p0'1 = op'1 a b; _p1'1 = op'1 b c } with
    | {_p0'1 = C_Some ab ; _p1'1 = C_Some bc} -> match { _p0'1 = op'1 ab c; _p1'1 = op'1 a bc } with
      | {_p0'1 = C_Some x ; _p1'1 = C_Some y} -> ([%#sfmap'0] ext_eq x y = (x = y))
       -> ext_eq x y
      && (let _ = () in [@expl:associative ensures] [%#sfmap] and_then_logic (op'1 a b) (fun (ab'0: t_FMap) -> op'1 ab'0 c)
      = and_then_logic (op'1 b c) (fun (bc'0: t_FMap) -> op'1 a bc'0))
      | _ -> [@expl:associative ensures] [%#sfmap] and_then_logic (op'1 a b) (fun (ab'0: t_FMap) -> op'1 ab'0 c)
      = and_then_logic (op'1 b c) (fun (bc'0: t_FMap) -> op'1 a bc'0)
      end
    | _ -> [@expl:associative ensures] [%#sfmap] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
    = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
    end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__core [#"../../creusot-contracts/src/logic/ra/fmap.rs" 73 4 73 33] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 69 14 72 5
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 74 8 74 31
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'4] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'5] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'10] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                         _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'8] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'6] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'7] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'3] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_Option'0) (a: tuple'1) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'1 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'1 t_Option'0. [%#sfmap'9] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic'1 f { _p0'1 = k; _p1'1 = v }
    end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. [%#sra] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (self: t_FMap) : t_FMap =
    [%#sfmap'4] let r = filter_map self (fun (__0: tuple'1) -> let {_p1'1 = v} = __0 in core v) in let _ = let _ = () in () in let _ = let _ = () in () in r
  
  axiom core_total_spec: forall self: t_FMap. [%#sfmap'0] op'1 (core_total self) (core_total self)
  = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. [%#sfmap'1] op'1 (core_total self) self = C_Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FMap
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 73 4 73 33] (self'0: t_FMap) : t_Option
  
  goal vc_core: ([%#sfmap'0] op'1 (core_total self) (core_total self) = C_Some (core_total self))
  && ([%#sfmap'1] op'1 (core_total self) self = C_Some self)
   -> ([@expl:core ensures] [%#sfmap] match C_Some (core_total self) with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/fmap.rs" 84 4 84 43] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 78 15 78 33
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 79 15 79 39
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 80 14 83 5
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 85 8 85 41
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 69 14 72 5
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 74 8 74 31
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'14 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 160 15 160 33
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 161 15 161 39
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 162 14 165 5
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'4] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'13] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'11] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'8] incl a b)
   -> ([%#sra'9] incl b c)  -> ([%#sra'10] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'7] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'6] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'5] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra'3] op self other = C_Some'0 comb)
   -> ([%#sra'4] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'6] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'15] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                         _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'9] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'7] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'8] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'3] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_Option'0) (a: tuple'1) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'1 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'1 t_Option'0. [%#sfmap'16] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic'1 f { _p0'1 = k; _p1'1 = v }
    end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. [%#sra'12] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (self: t_FMap) : t_FMap =
    [%#sfmap'12] let r = filter_map self (fun (__0: tuple'1) -> let {_p1'1 = v} = __0 in core v) in let _ = let _ = () in () in let _ = let _ = () in () in r
  
  axiom core_total_spec: forall self: t_FMap. [%#sfmap'10] op'1 (core_total self) (core_total self)
  = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. [%#sfmap'11] op'1 (core_total self) self = C_Some self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 73 4 73 33] (self: t_FMap) : t_Option =
    [%#sfmap'5] C_Some (core_total self)
  
  axiom core_spec'0: forall self: t_FMap. [%#sfmap'4] match core'0 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a: t_Option'0) (b: t_Option'0) : ()
  
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. [%#soption'5] op'0 a b = op'0 b a
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1
  
   =
    [%#soption'3] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'0} -> C_Some'1 x
      | {_p0 = C_None'0} -> C_None'1
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. [%#soption'2] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option'0) (other: t_Option'0) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
   =
    [%#sra'11] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. ([%#sra'8] incl'0 a b)
   -> ([%#sra'9] incl'0 b c)  -> ([%#sra'10] incl'0 a c)
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
   =
    [%#sra'5] ()
  
  axiom incl_op_spec'0: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. ([%#sra'3] op'0 self other
  = C_Some'1 comb)  -> ([%#sra'4] incl'0 self comb)
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (self: t_FMap) (factor'2: t_FMap) : t_Option
  
   =
    [%#sfmap'14] if forall k: t_K. incl'0 (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'1) -> let {_p0'1 = k ; _p1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in let _ = let _ = () in () in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'13] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'1 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None
  
  function core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 166 4 166 44] (self: t_V) (i: t_V) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_V, i: t_V. ([%#sra'0] op i i = C_Some'0 i)
   -> ([%#sra'1] op i self = C_Some'0 self)
   -> ([%#sra'2] match core self with
    | C_Some'0 c -> incl i c
    | C_None'0 -> false
    end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FMap
  
  constant i  : t_FMap
  
  function core_is_maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 84 4 84 43] (self'0: t_FMap) (i'0: t_FMap) : ()
  
  
  goal vc_core_is_maximal_idemp: ([%#sfmap] op'1 i i = C_Some i)
   -> ([%#sfmap'0] op'1 i self = C_Some self)
   -> (let _ = () in [@expl:core_is_maximal_idemp ensures] [%#sfmap'1] match core'0 self with
    | C_Some c -> incl'1 i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__unit [#"../../creusot-contracts/src/logic/ra/fmap.rs" 93 4 93 21] (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 94 22 94 82
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'14 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'15 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None'0} -> C_Some'1 other
      | {_p1'0 = C_None'0} -> C_Some'1 self
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'3] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'12] Map.get (view self) k
  
  type tuple'1  =
    { _p0'1: t_V; _p1'1: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. [%#sfmap'16] forall k: t_K [get (merge self m f) k]. match { _p0'0 = get self k;
                                                                                                                                         _p1'0 = get m k } with
    | {_p0'0 = C_None'0 ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None'0} -> get (merge self m f) k = x
    | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'1 = x; _p1'1 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'15] merge self other (fun (__0: tuple'1) -> let {_p0'1 = x ; _p1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'13] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)
   -> ([%#sfmap'14] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'5] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
   =
    [%#sfmap'11] match { _p0 = op'1 a b; _p1 = op'1 b c } with
      | {_p0 = C_Some ab ; _p1 = C_Some bc} -> match { _p0 = op'1 ab c; _p1 = op'1 a bc } with
        | {_p0 = C_Some x ; _p1 = C_Some y} -> let _ = () in ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'10] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : () =
    [%#sfmap'9] let _ = () in ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'8] op'1 a b = op'1 b a
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'6] len self >= 0
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 54 4 54 26]  : t_FMap
  
  axiom empty_spec: [%#sfmap'0] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'1] view empty = Const.const (C_None'0)
  
  predicate index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_FMap bool) (a: t_FMap)
  
   =
    [%#smapping] Map.get self a
  
  function such_that'0 [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec'0: forall p: Map.map t_FMap bool. ([%#sutil] exists x: t_FMap. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that'0 p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_FMap =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that'0 (fun (__0: t_FMap) -> true)
      end
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self: t_FMap) (other: t_FMap) =
    [%#sfmap'7] let _ = () in forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'2] ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit' [#"../../creusot-contracts/src/logic/ra/fmap.rs" 93 4 93 21]  : t_FMap
  
  goal vc_unit: (forall x: t_FMap. ([%#sfmap'0] len empty = 0) && ([%#sfmap'1] view empty = Const.const (C_None'0))
   -> ([@expl:unwrap_logic requires] [%#soption] op'1 x empty <> C_None))
  /\ ([%#sfmap'3] forall x: t_FMap. ext_eq (unwrap_logic (op'1 x empty)) x)
  && (let _ = () in let _ = () in ([%#sfmap'0] len empty = 0) && ([%#sfmap'1] view empty = Const.const (C_None'0))
   -> (let result = empty in [@expl:unit ensures] [%#sfmap] forall x: t_FMap [op'1 x result]. op'1 x result = C_Some x))
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 32 103 57
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'14 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'4] and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None'0} -> C_Some'1 other
      | {_p1'0 = C_None'0} -> C_Some'1 self
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'3] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'6] Map.get (view self) k
  
  type tuple'1  =
    { _p0'1: t_V; _p1'1: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. [%#sfmap'15] forall k: t_K [get (merge self m f) k]. match { _p0'0 = get self k;
                                                                                                                                         _p1'0 = get m k } with
    | {_p0'0 = C_None'0 ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None'0} -> get (merge self m f) k = x
    | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'1 = x; _p1'1 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'14] merge self other (fun (__0: tuple'1) -> let {_p0'1 = x ; _p1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'12] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)
   -> ([%#sfmap'13] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'5] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
   =
    [%#sfmap'11] match { _p0 = op'1 a b; _p1 = op'1 b c } with
      | {_p0 = C_Some ab ; _p1 = C_Some bc} -> match { _p0 = op'1 ab c; _p1 = op'1 a bc } with
        | {_p0 = C_Some x ; _p1 = C_Some y} -> let _ = () in ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'10] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : () =
    [%#sfmap'9] let _ = () in ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'8] op'1 a b = op'1 b a
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. [%#sra] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'2 t_Option'0) (a: tuple'2) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'2 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'2 t_Option'0. [%#sfmap'2] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic'1 f { _p0'2 = k; _p1'2 = v }
    end
  
  predicate index_logic'2 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_FMap bool) (a: t_FMap)
  
   =
    [%#smapping] Map.get self a
  
  function such_that'0 [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec'0: forall p: Map.map t_FMap bool. ([%#sutil] exists x: t_FMap. index_logic'2 p x)
   -> ([%#sutil'0] index_logic'2 p (such_that'0 p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_FMap =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that'0 (fun (__0: t_FMap) -> true)
      end
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self: t_FMap) (other: t_FMap) =
    [%#sfmap'7] let _ = () in forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'3] ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FMap
  
  function core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (self'0: t_FMap) : t_FMap
  
  goal vc_core_total: (forall __0: tuple'2. let {_p1'2 = v} = __0 in true)
  /\ (([%#sfmap'2] forall k: t_K [get (filter_map self ([%#sfmap'1] fun (__0: tuple'2) -> let {_p1'2 = v} = __0 in core v)) k]. get (filter_map self ([%#sfmap'1] fun (__0: tuple'2) -> let {_p1'2 = v} = __0 in core v)) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic'1 ([%#sfmap'1] fun (__0: tuple'2) -> let {_p1'2 = v'0} = __0 in core v'0) { _p0'2 = k;
                                                                                                            _p1'2 = v }
    end)
   -> (let r = filter_map self ([%#sfmap'1] fun (__0: tuple'2) -> let {_p1'2 = v} = __0 in core v) in ([@expl:unwrap_logic requires] [%#soption] op'1 r r
  <> C_None)
  /\ (([%#sfmap'3] ext_eq (unwrap_logic (op'1 r r)) r = (unwrap_logic (op'1 r r) = r))
   -> ext_eq (unwrap_logic (op'1 r r)) r
  && (let _ = () in let _ = () in ([@expl:unwrap_logic requires] [%#soption] op'1 r self <> C_None)
  /\ (([%#sfmap'3] ext_eq (unwrap_logic (op'1 r self)) self = (unwrap_logic (op'1 r self) = self))
   -> ext_eq (unwrap_logic (op'1 r self)) self
  && (let _ = () in let _ = () in let result = r in ([@expl:core_total ensures #0] [%#sfmap] op'1 result result
  = C_Some result)
  && ([@expl:core_total ensures #1] [%#sfmap'0] op'1 result self = C_Some self)))))))
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__core_is_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 111 4 111 26] (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 110 14 110 52
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 111 27 111 29
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 69 14 72 5
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 74 8 74 31
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'14 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'15 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'4] and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'12] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'16] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                         _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'15] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'13] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)
   -> ([%#sfmap'14] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  type tuple'1  =
    { _p0'1: t_Option; _p1'1: t_Option }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'10] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
   =
    [%#sfmap'9] match { _p0'1 = op'1 a b; _p1'1 = op'1 b c } with
      | {_p0'1 = C_Some ab ; _p1'1 = C_Some bc} -> match { _p0'1 = op'1 ab c; _p1'1 = op'1 a bc } with
        | {_p0'1 = C_Some x ; _p1'1 = C_Some y} -> let _ = () in ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'8] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : () =
    [%#sfmap'7] let _ = () in ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'6] op'1 a b = op'1 b a
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'2 t_Option'0) (a: tuple'2) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'2 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'2 t_Option'0. [%#sfmap'11] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic'1 f { _p0'2 = k; _p1'2 = v }
    end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. [%#sra] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (self: t_FMap) : t_FMap =
    [%#sfmap'5] let r = filter_map self (fun (__0: tuple'2) -> let {_p1'2 = v} = __0 in core v) in let _ = let _ = () in () in let _ = let _ = () in () in r
  
  axiom core_total_spec: forall self: t_FMap. [%#sfmap'3] op'1 (core_total self) (core_total self)
  = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. [%#sfmap'4] op'1 (core_total self) self = C_Some self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 73 4 73 33] (self: t_FMap) : t_Option =
    [%#sfmap'2] C_Some (core_total self)
  
  axiom core_spec'0: forall self: t_FMap. [%#sfmap'1] match core'0 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FMap
  
  function core_is_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 111 4 111 26] (self'0: t_FMap) : ()
  
  goal vc_core_is_total: [@expl:core_is_total ensures] [%#sfmap] core'0 self = C_Some (core_total self)
end
module M_creusot_contracts__logic__ra__fmap__qyi17941324210461407630__total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 121 27 121 35
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 26 122 9
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_V t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_V t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_V. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_V) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'5] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'3] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                        _p1 = get m k } with
    | {_p0 = C_None ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None} -> get (merge self m f) k = x
    | {_p0 = C_Some x ; _p1 = C_Some y} -> get (merge self m f) k = C_Some (index_logic'0 f { _p0'0 = x; _p1'0 = y })
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FMap
  
  constant other  : t_FMap
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self'0: t_FMap) (other'0: t_FMap) : t_FMap
  
  
  goal vc_total_op: ([%#sfmap] forall k: t_K. op'0 (get self k) (get other k) <> C_None'0)
   -> (forall __0: tuple'0. let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
    | C_Some r -> true
    | _ -> [@expl:such_that requires] [%#sutil] exists x'0: t_V. index_logic ([%#sfmap'1] fun (__0'0: t_V) -> true) x'0
    end)
  /\ (([%#sfmap'3] forall k: t_K [get (merge self other ([%#sfmap'2] fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
    | C_Some r -> r
    | _ -> such_that (fun (__0'0: t_V) -> true)
    end)) k]. match { _p0 = get self k; _p1 = get other k } with
    | {_p0 = C_None ; _p1 = y} -> get (merge self other ([%#sfmap'2] fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y'0} = __0 in match op x y'0 with
      | C_Some r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)) k
    = y
    | {_p0 = x ; _p1 = C_None} -> get (merge self other ([%#sfmap'2] fun (__0: tuple'0) -> let {_p0'0 = x'0 ; _p1'0 = y} = __0 in match op x'0 y with
      | C_Some r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)) k
    = x
    | {_p0 = C_Some x ; _p1 = C_Some y} -> get (merge self other ([%#sfmap'2] fun (__0: tuple'0) -> let {_p0'0 = x'0 ; _p1'0 = y'0} = __0 in match op x'0 y'0 with
      | C_Some r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)) k
    = C_Some (index_logic'0 ([%#sfmap'2] fun (__0: tuple'0) -> let {_p0'0 = x'0 ; _p1'0 = y'0} = __0 in match op x'0 y'0 with
      | C_Some r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end) { _p0'0 = x; _p1'0 = y })
    end)
   -> ([@expl:total_op ensures] [%#sfmap'0] forall k: t_K. C_Some'0 (get (merge self other ([%#sfmap'2] fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
    | C_Some r -> r
    | _ -> such_that (fun (__0'0: t_V) -> true)
    end)) k)
  = op'0 (get self k) (get other k)))
end
module M_creusot_contracts__logic__ra__fmap__qyi945878506295166927__frame_preserving [#"../../creusot-contracts/src/logic/ra/fmap.rs" 149 4 154 5] (* <logic::ra::fmap::FMapInsertLocalUpdate<K, V> as logic::ra::update::LocalUpdate<logic::fmap::FMap<K, V>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 143 15 143 49
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 144 15 144 65
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 146 8 146 67
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 155 8 155 67
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 132 8 132 38
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 138 8 138 80
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'14 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'15 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'16 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'17 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'19 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'20 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  use mach.int.Int
  
  type t_K
  
  type t_V
  
  type t_FMapInsertLocalUpdate  =
    { t_FMapInsertLocalUpdate__0: t_K; t_FMapInsertLocalUpdate__1: t_V }
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'7] Map.get (view self) k
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/fmap.rs" 131 4 131 66] (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (_2: t_FMap)
  
   =
    [%#sfmap'4] get from_auth self.t_FMapInsertLocalUpdate__0 = C_None'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Option'0
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_Option'0 t_Option'2) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'2
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'2
      | C_Some'0 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'2 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'2
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None'0} -> C_Some'2 other
      | {_p1'0 = C_None'0} -> C_Some'2 self
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> map_logic'0 (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] and_then_logic'1 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type tuple'1  =
    { _p0'1: t_V; _p1'1: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. [%#sfmap'20] forall k: t_K [get (merge self m f) k]. match { _p0'0 = get self k;
                                                                                                                                         _p1'0 = get m k } with
    | {_p0'0 = C_None'0 ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None'0} -> get (merge self m f) k = x
    | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'1 = x; _p1'1 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'17] merge self other (fun (__0: tuple'1) -> let {_p0'1 = x ; _p1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'15] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'2)
   -> ([%#sfmap'16] forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'8] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'2 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
   =
    [%#sfmap'14] match { _p0 = op'1 a b; _p1 = op'1 b c } with
      | {_p0 = C_Some ab ; _p1 = C_Some bc} -> match { _p0 = op'1 ab c; _p1 = op'1 a bc } with
        | {_p0 = C_Some x ; _p1 = C_Some y} -> let _ = () in ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'13] and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : () =
    [%#sfmap'12] let _ = () in ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'11] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'1
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'1 other
      | {_p1 = C_None} -> C_Some'1 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_FMap) -> C_Some z)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'2: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  type tuple'2  =
    { _p0'2: t_FMap; _p1'2: t_FMap }
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'18] len self >= 0
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 115 4 115 39] (self: t_FMap) (k: t_K)
  
   =
    [%#sfmap'19] get self k <> C_None'0
  
  function insert [#"../../creusot-contracts/src/logic/fmap.rs" 71 4 71 43] (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'9] view (insert self k v)
  = Map.set (view self) k (C_Some'0 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'10] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  function update [#"../../creusot-contracts/src/logic/ra/fmap.rs" 137 4 137 93] (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (from_frag: t_FMap) : tuple'2
  
   =
    [%#sfmap'5] { _p0'2 = insert from_auth self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1;
                  _p1'2 = insert from_frag self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1 }
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self: t_FMap) (other: t_FMap) =
    [%#sfmap'6] let _ = () in forall k: t_K. get self k = get other k
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'2] ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_FMapInsertLocalUpdate
  
  constant from_auth  : t_FMap
  
  constant from_frag  : t_FMap
  
  constant frame  : t_Option
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/fmap.rs" 149 4 154 5] (self'0: t_FMapInsertLocalUpdate) (from_auth'0: t_FMap) (from_frag'0: t_FMap) (frame'0: t_Option) : ()
  
  
  goal vc_frame_preserving: ([%#sfmap] premise self from_auth from_frag)
   -> ([%#sfmap'0] op'2 (C_Some from_frag) frame = C_Some'1 (C_Some from_auth))
   -> (let {_p0'2 = to_auth ; _p1'2 = to_frag} = update self from_auth from_frag in match op'2 (C_Some to_frag) frame with
    | C_Some'1 (C_Some x) -> ([%#sfmap'2] ext_eq to_auth x = (to_auth = x))
     -> ext_eq to_auth x
    && (let _ = () in let _ = () in [@expl:frame_preserving ensures] [%#sfmap'1] let {_p0'2 = to_auth'0 ; _p1'2 = to_frag'0} = update self from_auth from_frag in op'2 (C_Some to_frag'0) frame
    = C_Some'1 (C_Some to_auth'0))
    | _ -> false
    && (let _ = () in let _ = () in [@expl:frame_preserving ensures] [%#sfmap'1] let {_p0'2 = to_auth'0 ; _p1'2 = to_frag'0} = update self from_auth from_frag in op'2 (C_Some to_frag'0) frame
    = C_Some'1 (C_Some to_auth'0))
    end)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__factor [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'3] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'9] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Option
  
  constant factor'0  : t_Option
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self'0: t_Option) (factor'2: t_Option) : t_Option'0
  
  
  goal vc_factor: match { _p0 = self; _p1 = factor'0 } with
    | {_p0 = x ; _p1 = C_None} -> [@expl:factor ensures] [%#soption] match C_Some'0 x with
      | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
      | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
      end
    | {_p0 = C_None} -> [@expl:factor ensures] [%#soption] match C_None'0 with
      | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
      | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
      end
    | {_p0 = C_Some x ; _p1 = C_Some y} -> ([%#sra] match factor x y with
      | C_Some c -> op y c = C_Some x
      | C_None -> forall c: t_T. op y c <> C_Some x
      end)
     -> match factor x y with
      | C_Some z -> [@expl:factor ensures] [%#soption] match C_Some'0 (C_Some z) with
        | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
        | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
        end
      | C_None -> if x = y then
        [@expl:factor ensures] [%#soption] match C_Some'0 (C_None) with
          | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
          | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
          end
      else
        [@expl:factor ensures] [%#soption] match C_None'0 with
          | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
          | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
          end
      
      end
    end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__commutative [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 41 39
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'3] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Option
  
  constant b  : t_Option
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a'0: t_Option) (b'0: t_Option) : ()
  
  
  goal vc_commutative: let _ = () in [@expl:commutative ensures] [%#soption] op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__associative [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'3] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option; _p2: t_Option }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Option
  
  constant b  : t_Option
  
  constant c  : t_Option
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a'0: t_Option) (b'0: t_Option) (c'0: t_Option) : ()
  
  
  goal vc_associative: match { _p0'0 = a; _p1'0 = b; _p2 = c } with
    | {_p0'0 = C_None} -> [@expl:associative ensures] [%#soption] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
    = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
    | {_p1'0 = C_None} -> [@expl:associative ensures] [%#soption] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
    = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
    | {_p2 = C_None} -> [@expl:associative ensures] [%#soption] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
    = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
    | {_p0'0 = C_Some aa ; _p1'0 = C_Some bb ; _p2 = C_Some cc} -> ([%#sra] and_then_logic'0 (op aa bb) (fun (ab: t_T) -> op ab cc)
    = and_then_logic'0 (op bb cc) (fun (bc: t_T) -> op aa bc))
     -> ([@expl:associative ensures] [%#soption] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
    = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc))
    end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__core [#"../../creusot-contracts/src/logic/ra/option.rs" 66 4 66 33] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 62 14 65 5
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 95 14 95 47
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 96 14 96 43
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 67 8 67 31
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 98 8 101 9
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'5] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'6] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'10] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'9] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'3] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. [%#sra] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31] (self: t_Option) : t_Option =
    [%#soption'4] match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. [%#soption'0] op'0 (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. [%#soption'1] op'0 (core_total self) self = C_Some'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Option
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 66 4 66 33] (self'0: t_Option) : t_Option'0
  
  goal vc_core: ([%#soption'0] op'0 (core_total self) (core_total self) = C_Some'0 (core_total self))
  && ([%#soption'1] op'0 (core_total self) self = C_Some'0 self)
   -> ([@expl:core ensures] [%#soption] match C_Some'0 (core_total self) with
    | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
    | C_None'0 -> true
    end)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/option.rs" 77 4 77 43] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 71 15 71 33
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 72 15 72 39
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 73 14 76 5
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 78 8 81 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 62 14 65 5
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 67 8 67 31
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 95 14 95 47
  let%span soption'8 = "../../creusot-contracts/src/logic/ra/option.rs" 96 14 96 43
  let%span soption'9 = "../../creusot-contracts/src/logic/ra/option.rs" 98 8 101 9
  let%span soption'10 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'11 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'12 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 160 15 160 33
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 161 15 161 39
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 162 14 165 5
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'6] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'12] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'13] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'2] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'9] incl a b)
   -> ([%#sra'10] incl b c)  -> ([%#sra'11] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'8] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'7] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'6] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'4] op self other = C_Some comb)
   -> ([%#sra'5] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'3] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. [%#sra'3] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31] (self: t_Option) : t_Option =
    [%#soption'9] match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. [%#soption'7] op'0 (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. [%#soption'8] op'0 (core_total self) self = C_Some'0 self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 66 4 66 33] (self: t_Option) : t_Option'0 =
    [%#soption'5] C_Some'0 (core_total self)
  
  axiom core_spec'0: forall self: t_Option. [%#soption'4] match core'0 self with
    | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option) (factor'1: t_Option) : t_Option'0
  
   =
    [%#soption'11] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None} -> C_Some'0 x
      | {_p0 = C_None} -> C_None'0
      | {_p0 = C_Some x ; _p1 = C_Some y} -> match factor x y with
        | C_Some z -> C_Some'0 (C_Some z)
        | C_None -> if x = y then C_Some'0 (C_None) else C_None'0
        end
      end
  
  axiom factor_spec'0: forall self: t_Option, factor'1: t_Option. [%#soption'10] match factor'0 self factor'1 with
    | C_Some'0 c -> op'0 factor'1 c = C_Some'0 self
    | C_None'0 -> forall c: t_Option. op'0 factor'1 c <> C_Some'0 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option) (other: t_Option) =
    [%#sra'2] factor'0 other self <> C_None'0
  
  function core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 166 4 166 44] (self: t_T) (i: t_T) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_T, i: t_T. ([%#sra] op i i = C_Some i)
   -> ([%#sra'0] op i self = C_Some self)
   -> ([%#sra'1] match core self with
    | C_Some c -> incl i c
    | C_None -> false
    end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Option
  
  constant i  : t_Option
  
  function core_is_maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 77 4 77 43] (self'0: t_Option) (i'0: t_Option) : ()
  
  
  goal vc_core_is_maximal_idemp: ([%#soption] op'0 i i = C_Some'0 i)
   -> ([%#soption'0] op'0 i self = C_Some'0 self)
   -> match { _p0 = self; _p1 = i } with
    | {_p0 = C_Some x ; _p1 = C_Some i'0} -> (([@expl:core_is_maximal_idemp requires #0] [%#sra] op i'0 i'0
    = C_Some i'0)
    && ([@expl:core_is_maximal_idemp requires #1] [%#sra'0] op i'0 x = C_Some x))
    /\ (([%#sra'1] match core x with
      | C_Some c -> incl i'0 c
      | C_None -> false
      end)
     -> ([@expl:core_is_maximal_idemp ensures] [%#soption'1] match core'0 self with
      | C_Some'0 c -> incl'0 i c
      | C_None'0 -> false
      end))
    | _ -> [@expl:core_is_maximal_idemp ensures] [%#soption'1] match core'0 self with
      | C_Some'0 c -> incl'0 i c
      | C_None'0 -> false
      end
    end
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__unit [#"../../creusot-contracts/src/logic/ra/option.rs" 89 4 89 21] (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 88 14 88 78
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 90 8 90 12
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'5] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option; _p2: t_Option }
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'5] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'4] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
   =
    [%#soption'3] match { _p0 = a; _p1 = b; _p2 = c } with
      | {_p0 = C_None} -> ()
      | {_p1 = C_None} -> ()
      | {_p2 = C_None} -> ()
      | {_p0 = C_Some aa ; _p1 = C_Some bb ; _p2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit' [#"../../creusot-contracts/src/logic/ra/option.rs" 89 4 89 21]  : t_Option
  
  goal vc_unit: let result = C_None in [@expl:unit ensures] [%#soption] forall x: t_Option [op'0 x result]. op'0 x result
  = C_Some'0 x
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__core_total [#"../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31] (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 95 14 95 47
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 96 14 96 43
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 98 8 101 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'6] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option; _p2: t_Option }
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'6] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'10] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'9] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'5] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'2] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
   =
    [%#soption'4] match { _p0 = a; _p1 = b; _p2 = c } with
      | {_p0 = C_None} -> ()
      | {_p1 = C_None} -> ()
      | {_p2 = C_None} -> ()
      | {_p0 = C_Some aa ; _p1 = C_Some bb ; _p2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'3] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. [%#sra] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Option
  
  function core_total [#"../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31] (self'0: t_Option) : t_Option
  
  goal vc_core_total: match self with
    | C_None -> let result = C_None in ([@expl:core_total ensures #0] [%#soption] op'0 result result = C_Some'0 result)
    && ([@expl:core_total ensures #1] [%#soption'0] op'0 result self = C_Some'0 self)
    | C_Some x -> ([%#sra] match core x with
      | C_Some c -> op c c = C_Some c /\ op c x = C_Some x
      | C_None -> true
      end)
     -> (let result = core x in ([@expl:core_total ensures #0] [%#soption] op'0 result result = C_Some'0 result)
    && ([@expl:core_total ensures #1] [%#soption'0] op'0 result self = C_Some'0 self))
    end
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__core_is_total [#"../../creusot-contracts/src/logic/ra/option.rs" 106 4 106 26] (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 105 14 105 52
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 106 27 106 29
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 62 14 65 5
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 67 8 67 31
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 95 14 95 47
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 96 14 96 43
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 98 8 101 9
  let%span soption'6 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'8 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'10 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'9] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'10] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'9] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'10] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'9] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'1] op self other = C_Some comb)
   -> ([%#sra'2] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option; _p2: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'8] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
   =
    [%#soption'7] match { _p0'0 = a; _p1'0 = b; _p2 = c } with
      | {_p0'0 = C_None} -> ()
      | {_p1'0 = C_None} -> ()
      | {_p2 = C_None} -> ()
      | {_p0'0 = C_Some aa ; _p1'0 = C_Some bb ; _p2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'6] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. [%#sra] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31] (self: t_Option) : t_Option =
    [%#soption'5] match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. [%#soption'3] op'0 (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. [%#soption'4] op'0 (core_total self) self = C_Some'0 self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 66 4 66 33] (self: t_Option) : t_Option'0 =
    [%#soption'2] C_Some'0 (core_total self)
  
  axiom core_spec'0: forall self: t_Option. [%#soption'1] match core'0 self with
    | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Option
  
  function core_is_total [#"../../creusot-contracts/src/logic/ra/option.rs" 106 4 106 26] (self'0: t_Option) : ()
  
  goal vc_core_is_total: [@expl:core_is_total ensures] [%#soption] core'0 self = C_Some'0 (core_total self)
end
module M_creusot_contracts__logic__ra__option__qyi9919140421117497760__update [#"../../creusot-contracts/src/logic/ra/option.rs" 126 4 126 64] (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 125 15 125 33
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 127 8 130 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 117 8 120 9
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  
  type t_U
  
  type t_OptionUpdate  =
    { t_OptionUpdate__0: t_U }
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  type t_Choice
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 116 4 116 45] (self: t_OptionUpdate) (from: t_Option)
  
   =
    [%#soption'1] match from with
      | C_Some from'0 -> premise self.t_OptionUpdate__0 from'0
      | C_None -> false
      end
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_OptionUpdate
  
  constant from  : t_Option
  
  constant ch  : t_Choice
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 126 4 126 64] (self'0: t_OptionUpdate) (from'0: t_Option) (ch'0: t_Choice) : t_Option
  
  
  goal vc_update: ([%#soption] premise'0 self from)
   -> match from with
    | C_Some from'0 -> [@expl:update requires] [%#supdate] premise self.t_OptionUpdate__0 from'0
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__option__qyi9919140421117497760__frame_preserving [#"../../creusot-contracts/src/logic/ra/option.rs" 137 4 137 77] (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 134 15 134 33
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 135 15 135 37
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 136 14 136 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 140 30 140 38
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 138 8 141 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 117 8 120 9
  let%span soption'6 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 125 15 125 33
  let%span soption'8 = "../../creusot-contracts/src/logic/ra/option.rs" 127 8 130 9
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'10 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'11 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'12 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'13 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 17 15 17 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 18 15 18 37
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 19 14 19 57
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  
  use map.Map
  
  type t_U
  
  type t_OptionUpdate  =
    { t_OptionUpdate__0: t_U }
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  type t_Choice
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 116 4 116 45] (self: t_OptionUpdate) (from: t_Option)
  
   =
    [%#soption'5] match from with
      | C_Some from'0 -> premise self.t_OptionUpdate__0 from'0
      | C_None -> false
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'13] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option; _p2: t_Option }
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption'13] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0
  
   =
    [%#soption'12] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'6] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
   =
    [%#soption'11] match { _p0 = a; _p1 = b; _p2 = c } with
      | {_p0 = C_None} -> ()
      | {_p1 = C_None} -> ()
      | {_p2 = C_None} -> ()
      | {_p0 = C_Some aa ; _p1 = C_Some bb ; _p2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'10] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 126 4 126 64] (self: t_OptionUpdate) (from: t_Option) (ch: t_Choice) : t_Option
  
   =
    [%#soption'8] match from with
      | C_Some from'0 -> C_Some (update self.t_OptionUpdate__0 from'0 ch)
      | C_None -> C_None
      end
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_R bool) (a: t_R) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. ([%#sutil] exists x: t_R. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_R =
    [%#soption'9] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_R) -> true)
      end
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 20 4 20 65] (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  
  axiom frame_preserving_spec: forall self: t_U, from: t_R, frame: t_R. ([%#supdate] premise self from)
   -> ([%#supdate'0] op from frame <> C_None)
   -> ([%#supdate'1] op (update self from (frame_preserving self from frame)) frame <> C_None)
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice bool) (a: t_Choice)
  
   =
    [%#smapping] Map.get self a
  
  function such_that'0 [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec'0: forall p: Map.map t_Choice bool. ([%#sutil] exists x: t_Choice. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that'0 p))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_OptionUpdate
  
  constant from  : t_Option
  
  constant frame  : t_Option
  
  function frame_preserving'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 137 4 137 77] (self'0: t_OptionUpdate) (from'0: t_Option) (frame'0: t_Option) : t_Choice
  
  
  goal vc_frame_preserving: ([%#soption] premise'0 self from)
   -> ([%#soption'0] op'0 from frame <> C_None'0)
   -> match frame with
    | C_Some frame'0 -> ([@expl:unwrap_logic requires] [%#soption'2] from <> C_None)
    /\ (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_OptionUpdate__0 (unwrap_logic from))
    && ([@expl:frame_preserving requires #1] [%#supdate'0] op (unwrap_logic from) frame'0 <> C_None))
    /\ (([%#supdate'1] op (update self.t_OptionUpdate__0 (unwrap_logic from) (frame_preserving self.t_OptionUpdate__0 (unwrap_logic from) frame'0)) frame'0
    <> C_None)
     -> ([@expl:frame_preserving ensures] [%#soption'1] op'0 (update'0 self from (frame_preserving self.t_OptionUpdate__0 (unwrap_logic from) frame'0)) frame
    <> C_None'0))
    | C_None -> ([@expl:such_that requires] [%#sutil] exists x: t_Choice. index_logic'0 ([%#soption'3] fun (__0: t_Choice) -> true) x)
    /\ (([%#sutil'0] index_logic'0 ([%#soption'3] fun (__0: t_Choice) -> true) (such_that'0 ([%#soption'3] fun (__0: t_Choice) -> true)))
     -> ([@expl:frame_preserving ensures] [%#soption'1] op'0 (update'0 self from (such_that'0 ([%#soption'3] fun (__0: t_Choice) -> true))) frame
    <> C_None'0))
    end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__factor [#"../../creusot-contracts/src/logic/ra/prod.rs" 22 4 22 49] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 18 14 21 5
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 23 8 26 9
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'9] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'5] incl'0 a b)
   -> ([%#sra'6] incl'0 b c)  -> ([%#sra'7] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'4] and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'3] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra'0] op'0 self other = C_Some'1 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'1] and_then_logic (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                               _p1 = y }))
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : tuple
  
  constant factor'1  : tuple
  
  function factor'2 [#"../../creusot-contracts/src/logic/ra/prod.rs" 22 4 22 49] (self'0: tuple) (factor'3: tuple) : t_Option
  
  
  goal vc_factor: ([%#sra] match factor self._p0 factor'1._p0 with
    | C_Some'0 c -> op factor'1._p0 c = C_Some'0 (self._p0)
    | C_None'0 -> forall c: t_T. op factor'1._p0 c <> C_Some'0 (self._p0)
    end)
   -> ([%#sra] match factor'0 self._p1 factor'1._p1 with
    | C_Some'1 c -> op'0 factor'1._p1 c = C_Some'1 (self._p1)
    | C_None'1 -> forall c: t_U. op'0 factor'1._p1 c <> C_Some'1 (self._p1)
    end)
   -> match { _p0'0 = factor self._p0 factor'1._p0; _p1'0 = factor'0 self._p1 factor'1._p1 } with
    | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'1 y} -> [@expl:factor ensures] [%#sprod] match C_Some { _p0 = x;
                                                                                                   _p1 = y } with
      | C_Some c -> op'1 factor'1 c = C_Some self
      | C_None -> forall c: tuple. op'1 factor'1 c <> C_Some self
      end
    | _ -> [@expl:factor ensures] [%#sprod] match C_None with
      | C_Some c -> op'1 factor'1 c = C_Some self
      | C_None -> forall c: tuple. op'1 factor'1 c <> C_Some self
      end
    end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__commutative [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'1] and_then_logic (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                               _p1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : tuple
  
  constant b  : tuple
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a'0: tuple) (b'0: tuple) : ()
  
  goal vc_commutative: [@expl:commutative ensures] [%#sprod] op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__associative [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'1] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                                 _p1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : tuple
  
  constant b  : tuple
  
  constant c  : tuple
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a'0: tuple) (b'0: tuple) (c'0: tuple) : ()
  
  
  goal vc_associative: [@expl:associative ensures] [%#sprod] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__core [#"../../creusot-contracts/src/logic/ra/prod.rs" 45 4 45 33] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 44 5
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 46 8 49 9
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'10] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'9] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'5] incl'0 a b)
   -> ([%#sra'6] incl'0 b c)  -> ([%#sra'7] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'4] and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'3] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra'0] op'0 self other = C_Some'1 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'1] and_then_logic (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                               _p1 = y }))
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. [%#sra] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. [%#sra] match core'0 self with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : tuple
  
  function core'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 45 4 45 33] (self'0: tuple) : t_Option
  
  goal vc_core: ([%#sra] match core self._p0 with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self._p0 = C_Some'0 (self._p0)
    | C_None'0 -> true
    end)
   -> ([%#sra] match core'0 self._p1 with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self._p1 = C_Some'1 (self._p1)
    | C_None'1 -> true
    end)
   -> match { _p0'0 = core self._p0; _p1'0 = core'0 self._p1 } with
    | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'1 y} -> [@expl:core ensures] [%#sprod] match C_Some { _p0 = x; _p1 = y } with
      | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
      | C_None -> true
      end
    | _ -> [@expl:core ensures] [%#sprod] match C_None with
      | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
      | C_None -> true
      end
    end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/prod.rs" 59 4 59 43] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 160 15 160 33
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 161 15 161 39
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 162 14 165 5
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 53 15 53 33
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 54 15 54 39
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 55 14 58 5
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 52 4 52 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 44 5
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 46 8 49 9
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 18 14 21 5
  let%span sprod'7 = "../../creusot-contracts/src/logic/ra/prod.rs" 23 8 26 9
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'13] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'2] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'9] incl a b)
   -> ([%#sra'10] incl b c)  -> ([%#sra'11] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'8] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'7] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'6] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'4] op self other = C_Some'0 comb)
   -> ([%#sra'5] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'13] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'2] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'9] incl'0 a b)
   -> ([%#sra'10] incl'0 b c)  -> ([%#sra'11] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'8] and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'7] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'6] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra'4] op'0 self other = C_Some'1 comb)
   -> ([%#sra'5] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'3] and_then_logic (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                               _p1 = y }))
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. [%#sra'3] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. [%#sra'3] match core'0 self with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  function core'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 45 4 45 33] (self: tuple) : t_Option =
    [%#sprod'5] match { _p0'0 = core self._p0; _p1'0 = core'0 self._p1 } with
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'1 y} -> C_Some { _p0 = x; _p1 = y }
      | _ -> C_None
      end
  
  axiom core_spec'1: forall self: tuple. [%#sprod'4] match core'1 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 22 4 22 49] (self: tuple) (factor'2: tuple) : t_Option
  
   =
    [%#sprod'7] match { _p0'0 = factor self._p0 factor'2._p0; _p1'0 = factor'0 self._p1 factor'2._p1 } with
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'1 y} -> C_Some { _p0 = x; _p1 = y }
      | _ -> C_None
      end
  
  axiom factor_spec'1: forall self: tuple, factor'2: tuple. [%#sprod'6] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: tuple. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'1 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: tuple) (other: tuple) =
    [%#sra'2] factor'1 other self <> C_None
  
  function core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 166 4 166 44] (self: t_T) (i: t_T) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_T, i: t_T. ([%#sra] op i i = C_Some'0 i)
   -> ([%#sra'0] op i self = C_Some'0 self)
   -> ([%#sra'1] match core self with
    | C_Some'0 c -> incl i c
    | C_None'0 -> false
    end)
  
  function core_is_maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 166 4 166 44] (self: t_U) (i: t_U) : ()
  
  axiom core_is_maximal_idemp_spec'0: forall self: t_U, i: t_U. ([%#sra] op'0 i i = C_Some'1 i)
   -> ([%#sra'0] op'0 i self = C_Some'1 self)
   -> ([%#sra'1] match core'0 self with
    | C_Some'1 c -> incl'0 i c
    | C_None'1 -> false
    end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : tuple
  
  constant i  : tuple
  
  function core_is_maximal_idemp'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 59 4 59 43] (self'0: tuple) (i'0: tuple) : ()
  
  
  goal vc_core_is_maximal_idemp: ([%#sprod] op'1 i i = C_Some i)
   -> ([%#sprod'0] op'1 i self = C_Some self)
   -> (([@expl:core_is_maximal_idemp requires #0] [%#sra] op i._p0 i._p0 = C_Some'0 (i._p0))
  && ([@expl:core_is_maximal_idemp requires #1] [%#sra'0] op i._p0 self._p0 = C_Some'0 (self._p0)))
  /\ (([%#sra'1] match core self._p0 with
    | C_Some'0 c -> incl i._p0 c
    | C_None'0 -> false
    end)
   -> (let _ = core_is_maximal_idemp self._p0 i._p0 in (([@expl:core_is_maximal_idemp requires #0] [%#sra] op'0 i._p1 i._p1
  = C_Some'1 (i._p1))
  && ([@expl:core_is_maximal_idemp requires #1] [%#sra'0] op'0 i._p1 self._p1 = C_Some'1 (self._p1)))
  /\ (([%#sra'1] match core'0 self._p1 with
    | C_Some'1 c -> incl'0 i._p1 c
    | C_None'1 -> false
    end)
   -> (let _ = core_is_maximal_idemp'0 self._p1 i._p1 in [@expl:core_is_maximal_idemp ensures] [%#sprod'1] match core'1 self with
    | C_Some c -> incl'1 i c
    | C_None -> false
    end))))
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__unit [#"../../creusot-contracts/src/logic/ra/prod.rs" 68 4 68 21] (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 67 14 67 78
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 69 8 69 30
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'13] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'9] incl a b)
   -> ([%#sra'10] incl b c)  -> ([%#sra'11] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'8] and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'7] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'6] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'4] op self other = C_Some'0 comb)
   -> ([%#sra'5] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'16] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'13] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'9] incl'0 a b)
   -> ([%#sra'10] incl'0 b c)  -> ([%#sra'11] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'8] and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'7] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'6] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra'4] op'0 self other = C_Some'1 comb)
   -> ([%#sra'5] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'1] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                                 _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'5] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'4] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'3] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'2] op'1 a b = op'1 b a
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. [%#sra'14] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. [%#sra'15] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_T
  
  axiom unit_spec: [%#sra] forall x: t_T [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'3] ()
  
  axiom unit_core_spec: [%#sra'2] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'1] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'0] forall x: t_T. incl x x
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_U) : t_U
  
  axiom core_total_spec'1: forall self: t_U. [%#sra'14] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some'1 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_U. [%#sra'15] op'0 (core_total'0 self) self = C_Some'1 self
  
  constant unit''0 [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_U
  
  axiom unit_spec'0: [%#sra] forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x
  
  constant unit_core'0: () = [%#sra'3] ()
  
  axiom unit_core_spec'0: [%#sra'2] core_total'0 unit''0 = unit''0
  
  constant incl_refl'0: () = [%#sra'1] let _ = unit''0 in ()
  
  axiom incl_refl_spec'0: [%#sra'0] forall x: t_U. incl'0 x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit''1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 68 4 68 21]  : tuple
  
  goal vc_unit: ([%#sra] forall x: t_T [op x unit']. op x unit' = C_Some'0 x)
   -> ([%#sra] forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x)
   -> (let result = { _p0 = unit';
                      _p1 = unit''0 } in [@expl:unit ensures] [%#sprod] forall x: tuple [op'1 x result]. op'1 x result
  = C_Some x)
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__core_total [#"../../creusot-contracts/src/logic/ra/prod.rs" 76 4 76 31] (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 74 14 74 47
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 75 14 75 43
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 77 8 77 50
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'14] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'13] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'10] incl a b)
   -> ([%#sra'11] incl b c)  -> ([%#sra'12] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'9] and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'8] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'7] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'5] op self other = C_Some'0 comb)
   -> ([%#sra'6] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'16] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'14] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'13] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'10] incl'0 a b)
   -> ([%#sra'11] incl'0 b c)  -> ([%#sra'12] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'9] and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'8] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'7] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra'5] op'0 self other = C_Some'1 comb)
   -> ([%#sra'6] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'2] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                                 _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'6] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'5] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'4] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'3] op'1 a b = op'1 b a
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_T
  
  axiom unit_spec: [%#sra'15] forall x: t_T [op x unit']. op x unit' = C_Some'0 x
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. [%#sra] op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. [%#sra'0] op (core_total self) self = C_Some'0 self
  
  constant unit_core: () = [%#sra'4] ()
  
  axiom unit_core_spec: [%#sra'3] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'2] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'1] forall x: t_T. incl x x
  
  constant unit''0 [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_U
  
  axiom unit_spec'0: [%#sra'15] forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_U) : t_U
  
  axiom core_total_spec'1: forall self: t_U. [%#sra] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some'1 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_U. [%#sra'0] op'0 (core_total'0 self) self = C_Some'1 self
  
  constant unit_core'0: () = [%#sra'4] ()
  
  axiom unit_core_spec'0: [%#sra'3] core_total'0 unit''0 = unit''0
  
  constant incl_refl'0: () = [%#sra'2] let _ = unit''0 in ()
  
  axiom incl_refl_spec'0: [%#sra'1] forall x: t_U. incl'0 x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : tuple
  
  function core_total'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 76 4 76 31] (self'0: tuple) : tuple
  
  goal vc_core_total: ([%#sra] op (core_total self._p0) (core_total self._p0) = C_Some'0 (core_total self._p0))
  && ([%#sra'0] op (core_total self._p0) self._p0 = C_Some'0 (self._p0))
   -> ([%#sra] op'0 (core_total'0 self._p1) (core_total'0 self._p1) = C_Some'1 (core_total'0 self._p1))
  && ([%#sra'0] op'0 (core_total'0 self._p1) self._p1 = C_Some'1 (self._p1))
   -> (let result = { _p0 = core_total self._p0;
                      _p1 = core_total'0 self._p1 } in ([@expl:core_total ensures #0] [%#sprod] op'1 result result
  = C_Some result)
  && ([@expl:core_total ensures #1] [%#sprod'0] op'1 result self = C_Some self))
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__core_is_total [#"../../creusot-contracts/src/logic/ra/prod.rs" 82 4 82 26] (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 194 14 194 52
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'17 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'18 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 81 14 81 52
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 80 4 80 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 44 5
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 46 8 49 9
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 74 14 74 47
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 75 14 75 43
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 77 8 77 50
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'7 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'8 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'9 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  let%span sprod'10 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'18] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'16] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'15] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'12] incl a b)
   -> ([%#sra'13] incl b c)  -> ([%#sra'14] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'11] and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'10] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'9] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'7] op self other = C_Some'0 comb)
   -> ([%#sra'8] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'18] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'16] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'15] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'12] incl'0 a b)
   -> ([%#sra'13] incl'0 b c)  -> ([%#sra'14] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'11] and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'10] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'9] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra'7] op'0 self other = C_Some'1 comb)
   -> ([%#sra'8] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'10] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                                  _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'9] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'8] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'7] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'6] op'1 a b = op'1 b a
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. [%#sra'0] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. [%#sra'0] match core'0 self with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  function core'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 45 4 45 33] (self: tuple) : t_Option =
    [%#sprod'2] match { _p0'0 = core self._p0; _p1'0 = core'0 self._p1 } with
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'1 y} -> C_Some { _p0 = x; _p1 = y }
      | _ -> C_None
      end
  
  axiom core_spec'1: forall self: tuple. [%#sprod'1] match core'1 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_T
  
  axiom unit_spec: [%#sra'17] forall x: t_T [op x unit']. op x unit' = C_Some'0 x
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. [%#sra'1] op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. [%#sra'2] op (core_total self) self = C_Some'0 self
  
  constant unit_core: () = [%#sra'6] ()
  
  axiom unit_core_spec: [%#sra'5] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'4] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'3] forall x: t_T. incl x x
  
  constant unit''0 [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_U
  
  axiom unit_spec'0: [%#sra'17] forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_U) : t_U
  
  axiom core_total_spec'1: forall self: t_U. [%#sra'1] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some'1 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_U. [%#sra'2] op'0 (core_total'0 self) self = C_Some'1 self
  
  constant unit_core'0: () = [%#sra'6] ()
  
  axiom unit_core_spec'0: [%#sra'5] core_total'0 unit''0 = unit''0
  
  constant incl_refl'0: () = [%#sra'4] let _ = unit''0 in ()
  
  axiom incl_refl_spec'0: [%#sra'3] forall x: t_U. incl'0 x x
  
  function core_total'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 76 4 76 31] (self: tuple) : tuple =
    [%#sprod'5] { _p0 = core_total self._p0; _p1 = core_total'0 self._p1 }
  
  axiom core_total_spec'3: forall self: tuple. [%#sprod'3] op'1 (core_total'1 self) (core_total'1 self)
  = C_Some (core_total'1 self)
  
  axiom core_total_spec'4: forall self: tuple. [%#sprod'4] op'1 (core_total'1 self) self = C_Some self
  
  function core_is_total [#"../../creusot-contracts/src/logic/ra.rs" 195 4 195 27] (self: t_T) : ()
  
  axiom core_is_total_spec: forall self: t_T. [%#sra] core self = C_Some'0 (core_total self)
  
  function core_is_total'0 [#"../../creusot-contracts/src/logic/ra.rs" 195 4 195 27] (self: t_U) : ()
  
  axiom core_is_total_spec'0: forall self: t_U. [%#sra] core'0 self = C_Some'1 (core_total'0 self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : tuple
  
  function core_is_total'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 82 4 82 26] (self'0: tuple) : ()
  
  goal vc_core_is_total: ([%#sra] core self._p0 = C_Some'0 (core_total self._p0))
   -> (let _ = core_is_total self._p0 in ([%#sra] core'0 self._p1 = C_Some'1 (core_total'0 self._p1))
   -> (let _ = core_is_total'0 self._p1 in [@expl:core_is_total ensures] [%#sprod] core'1 self
  = C_Some (core_total'1 self)))
end
module M_creusot_contracts__logic__ra__prod__qyi12871785784760244066__update [#"../../creusot-contracts/src/logic/ra/prod.rs" 102 4 102 77] (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 101 15 101 33
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 103 8 103 66
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 93 4 93 12
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate  =
    { t_ProdUpdate__0: t_U1; t_ProdUpdate__1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tuple  =
    { _p0: t_R1; _p1: t_R2 }
  
  type t_Choice
  
  type t_Choice'0
  
  type tuple'0  =
    { _p0'0: t_Choice; _p1'0: t_Choice'0 }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U1) (from: t_R1)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U2) (from: t_R2)
  
  predicate premise'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 95 4 95 44] (self: t_ProdUpdate) (from: tuple) =
    [%#sprod'1] premise self.t_ProdUpdate__0 from._p0 /\ premise'0 self.t_ProdUpdate__1 from._p1
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ProdUpdate
  
  constant from  : tuple
  
  constant ch  : tuple'0
  
  function update'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 102 4 102 77] (self'0: t_ProdUpdate) (from'0: tuple) (ch'0: tuple'0) : tuple
  
  
  goal vc_update: ([%#sprod] premise'1 self from)
   -> ([@expl:update requires] [%#supdate] premise self.t_ProdUpdate__0 from._p0)
  /\ ([@expl:update requires] [%#supdate] premise'0 self.t_ProdUpdate__1 from._p1)
end
module M_creusot_contracts__logic__ra__prod__qyi12871785784760244066__frame_preserving [#"../../creusot-contracts/src/logic/ra/prod.rs" 110 4 110 78] (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 17 15 17 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 18 15 18 37
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 19 14 19 57
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 107 15 107 33
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 108 15 108 37
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 109 14 109 57
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 111 8 111 92
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 93 4 93 12
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 101 15 101 33
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 103 8 103 66
  let%span sprod'7 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'8 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'9 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'10 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  
  use map.Map
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate  =
    { t_ProdUpdate__0: t_U1; t_ProdUpdate__1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tuple  =
    { _p0: t_R1; _p1: t_R2 }
  
  type t_Choice
  
  type t_Choice'0
  
  type tuple'0  =
    { _p0'0: t_Choice; _p1'0: t_Choice'0 }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U1) (from: t_R1)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U2) (from: t_R2)
  
  predicate premise'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 95 4 95 44] (self: t_ProdUpdate) (from: tuple) =
    [%#sprod'3] premise self.t_ProdUpdate__0 from._p0 /\ premise'0 self.t_ProdUpdate__1 from._p1
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'4] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_R1) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_R2) -> { _p0 = x;
                                                                                                                                   _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'10] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'9] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'8] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'7] op'1 a b = op'1 b a
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  
  function update'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 102 4 102 77] (self: t_ProdUpdate) (from: tuple) (ch: tuple'0) : tuple
  
   =
    [%#sprod'6] { _p0 = update self.t_ProdUpdate__0 from._p0 ch._p0'0;
                  _p1 = update'0 self.t_ProdUpdate__1 from._p1 ch._p1'0 }
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 20 4 20 65] (self: t_U1) (from: t_R1) (frame: t_R1) : t_Choice
  
  
  axiom frame_preserving_spec: forall self: t_U1, from: t_R1, frame: t_R1. ([%#supdate] premise self from)
   -> ([%#supdate'0] op from frame <> C_None'0)
   -> ([%#supdate'1] op (update self from (frame_preserving self from frame)) frame <> C_None'0)
  
  function frame_preserving'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 20 4 20 65] (self: t_U2) (from: t_R2) (frame: t_R2) : t_Choice'0
  
  
  axiom frame_preserving_spec'0: forall self: t_U2, from: t_R2, frame: t_R2. ([%#supdate] premise'0 self from)
   -> ([%#supdate'0] op'0 from frame <> C_None'1)
   -> ([%#supdate'1] op'0 (update'0 self from (frame_preserving'0 self from frame)) frame <> C_None'1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ProdUpdate
  
  constant from  : tuple
  
  constant frame  : tuple
  
  function frame_preserving'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 110 4 110 78] (self'0: t_ProdUpdate) (from'0: tuple) (frame'0: tuple) : tuple'0
  
  
  goal vc_frame_preserving: ([%#sprod] premise'1 self from)
   -> ([%#sprod'0] op'1 from frame <> C_None)
   -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_ProdUpdate__0 from._p0)
  && ([@expl:frame_preserving requires #1] [%#supdate'0] op from._p0 frame._p0 <> C_None'0))
  /\ (([%#supdate'1] op (update self.t_ProdUpdate__0 from._p0 (frame_preserving self.t_ProdUpdate__0 from._p0 frame._p0)) frame._p0
  <> C_None'0)
   -> (([@expl:frame_preserving requires #0] [%#supdate] premise'0 self.t_ProdUpdate__1 from._p1)
  && ([@expl:frame_preserving requires #1] [%#supdate'0] op'0 from._p1 frame._p1 <> C_None'1))
  /\ (([%#supdate'1] op'0 (update'0 self.t_ProdUpdate__1 from._p1 (frame_preserving'0 self.t_ProdUpdate__1 from._p1 frame._p1)) frame._p1
  <> C_None'1)
   -> ([@expl:frame_preserving ensures] [%#sprod'1] op'1 (update'1 self from { _p0'0 = frame_preserving self.t_ProdUpdate__0 from._p0 frame._p0;
                                                                               _p1'0 = frame_preserving'0 self.t_ProdUpdate__1 from._p1 frame._p1 }) frame
  <> C_None)))
end
module M_creusot_contracts__logic__ra__prod__qyi5623508861439716845__frame_preserving [#"../../creusot-contracts/src/logic/ra/prod.rs" 141 4 141 96] (* <logic::ra::prod::ProdLocalUpdate<U1, U2> as logic::ra::update::LocalUpdate<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 84 15 84 49
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 85 15 85 65
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 87 8 87 67
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 135 15 135 49
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 136 15 136 65
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 138 8 138 67
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 134 4 134 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 120 4 120 12
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 129 8 129 75
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'7 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'8 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'9 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  
  use map.Map
  
  type t_U1
  
  type t_U2
  
  type t_ProdLocalUpdate  =
    { t_ProdLocalUpdate__0: t_U1; t_ProdLocalUpdate__1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tuple  =
    { _p0: t_R1; _p1: t_R2 }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U1) (from_auth: t_R1) (from_frag: t_R1)
  
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U2) (from_auth: t_R2) (from_frag: t_R2)
  
  
  predicate premise'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 122 4 122 70] (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple)
  
   =
    [%#sprod'3] premise self.t_ProdLocalUpdate__0 from_auth._p0 from_frag._p0
    /\ premise'0 self.t_ProdLocalUpdate__1 from_auth._p1 from_frag._p1
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map tuple t_Option) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R1
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R1 t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> Map.get f x
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'2 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'1 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'2) (f: Map.map t_R2 tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'3 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'2
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'3 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'3 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'2 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'5] and_then_logic'1 (op self._p0 other._p0) (fun (x: t_R1) -> map_logic'0 (op'0 self._p1 other._p1) (fun (y: t_R2) -> { _p0 = x;
                                                                                                                                     _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'9] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'8] and_then_logic'0 (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'7] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'6] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op'1 x y) (fun (z: tuple) -> C_Some z)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'2: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'1] and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  type tuple'1  =
    { _p0'1: tuple; _p1'1: tuple }
  
  type tuple'2  =
    { _p0'2: t_R1; _p1'2: t_R1 }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) : tuple'2
  
  
  type tuple'3  =
    { _p0'3: t_R2; _p1'3: t_R2 }
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) : tuple'3
  
  
  function update'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 128 4 128 85] (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple) : tuple'1
  
   =
    [%#sprod'4] let {_p0'2 = to_auth0 ; _p1'2 = to_frag0} = update self.t_ProdLocalUpdate__0 from_auth._p0 from_frag._p0 in let {_p0'3 = to_auth1 ; _p1'3 = to_frag1} = update'0 self.t_ProdLocalUpdate__1 from_auth._p1 from_frag._p1 in { _p0'1 = { _p0 = to_auth0;
                                                                                                                                                                                                                                                      _p1 = to_auth1 };
                                                                                                                                                                                                                                            _p1'1 = { _p0 = to_frag0;
                                                                                                                                                                                                                                                      _p1 = to_frag1 } }
  
  function map_logic'1 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map tuple t_R1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Option'1
  
  function and_then_logic'4 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'3) (f: Map.map t_Option'1 t_Option'3) : t_Option'3
  
   =
    [%#soption'2] match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple'4  =
    { _p0'4: t_Option'1; _p1'4: t_Option'1 }
  
  function map_logic'2 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'3
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'3
      | C_Some'1 x -> C_Some'3 (Map.get f x)
      end
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'1) (other: t_Option'1) : t_Option'3
  
   =
    [%#soption] match { _p0'4 = self; _p1'4 = other } with
      | {_p0'4 = C_None'1} -> C_Some'3 other
      | {_p1'4 = C_None'1} -> C_Some'3 self
      | {_p0'4 = C_Some'1 x ; _p1'4 = C_Some'1 y} -> map_logic'2 (op x y) (fun (z: t_R1) -> C_Some'1 z)
      end
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  
  axiom associative_spec'3: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'1] and_then_logic'4 (op'3 a b) (fun (ab: t_Option'1) -> op'3 ab c)
  = and_then_logic'4 (op'3 b c) (fun (bc: t_Option'1) -> op'3 a bc)
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 90 4 90 76] (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) (frame: t_Option'1) : ()
  
  
  axiom frame_preserving_spec: forall self: t_U1, from_auth: t_R1, from_frag: t_R1, frame: t_Option'1. ([%#supdate] premise self from_auth from_frag)
   -> ([%#supdate'0] op'3 (C_Some'1 from_frag) frame = C_Some'3 (C_Some'1 from_auth))
   -> ([%#supdate'1] let {_p0'2 = to_auth ; _p1'2 = to_frag} = update self from_auth from_frag in op'3 (C_Some'1 to_frag) frame
  = C_Some'3 (C_Some'1 to_auth))
  
  function map_logic'3 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map tuple t_R2) : t_Option'2
  
   =
    [%#soption'0] match self with
      | C_None -> C_None'2
      | C_Some x -> C_Some'2 (Map.get f x)
      end
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_Option'2
  
  function and_then_logic'5 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'4) (f: Map.map t_Option'2 t_Option'4) : t_Option'4
  
   =
    [%#soption'2] match self with
      | C_None'4 -> C_None'4
      | C_Some'4 x -> Map.get f x
      end
  
  type tuple'5  =
    { _p0'5: t_Option'2; _p1'5: t_Option'2 }
  
  function map_logic'4 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'4
  
   =
    [%#soption'0] match self with
      | C_None'2 -> C_None'4
      | C_Some'2 x -> C_Some'4 (Map.get f x)
      end
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'2) (other: t_Option'2) : t_Option'4
  
   =
    [%#soption] match { _p0'5 = self; _p1'5 = other } with
      | {_p0'5 = C_None'2} -> C_Some'4 other
      | {_p1'5 = C_None'2} -> C_Some'4 self
      | {_p0'5 = C_Some'2 x ; _p1'5 = C_Some'2 y} -> map_logic'4 (op'0 x y) (fun (z: t_R2) -> C_Some'2 z)
      end
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'2) (b: t_Option'2) (c: t_Option'2) : ()
  
  
  axiom associative_spec'4: forall a: t_Option'2, b: t_Option'2, c: t_Option'2. [%#soption'1] and_then_logic'5 (op'4 a b) (fun (ab: t_Option'2) -> op'4 ab c)
  = and_then_logic'5 (op'4 b c) (fun (bc: t_Option'2) -> op'4 a bc)
  
  function frame_preserving'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 90 4 90 76] (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) (frame: t_Option'2) : ()
  
  
  axiom frame_preserving_spec'0: forall self: t_U2, from_auth: t_R2, from_frag: t_R2, frame: t_Option'2. ([%#supdate] premise'0 self from_auth from_frag)
   -> ([%#supdate'0] op'4 (C_Some'2 from_frag) frame = C_Some'4 (C_Some'2 from_auth))
   -> ([%#supdate'1] let {_p0'3 = to_auth ; _p1'3 = to_frag} = update'0 self from_auth from_frag in op'4 (C_Some'2 to_frag) frame
  = C_Some'4 (C_Some'2 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ProdLocalUpdate
  
  constant from_auth  : tuple
  
  constant from_frag  : tuple
  
  constant frame  : t_Option
  
  function frame_preserving'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 141 4 141 96] (self'0: t_ProdLocalUpdate) (from_auth'0: tuple) (from_frag'0: tuple) (frame'0: t_Option) : ()
  
  
  goal vc_frame_preserving: ([%#sprod] premise'1 self from_auth from_frag)
   -> ([%#sprod'0] op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth))
   -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_ProdLocalUpdate__0 from_auth._p0 from_frag._p0)
  && ([@expl:frame_preserving requires #1] [%#supdate'0] op'3 (C_Some'1 (from_frag._p0)) (map_logic'1 frame ([%#sprod'2] fun (f: tuple) -> f._p0))
  = C_Some'3 (C_Some'1 (from_auth._p0))))
  /\ (([%#supdate'1] let {_p0'2 = to_auth ; _p1'2 = to_frag} = update self.t_ProdLocalUpdate__0 from_auth._p0 from_frag._p0 in op'3 (C_Some'1 to_frag) (map_logic'1 frame ([%#sprod'2] fun (f: tuple) -> f._p0))
  = C_Some'3 (C_Some'1 to_auth))
   -> (let _ = frame_preserving self.t_ProdLocalUpdate__0 from_auth._p0 from_frag._p0 (map_logic'1 frame ([%#sprod'2] fun (f: tuple) -> f._p0)) in (([@expl:frame_preserving requires #0] [%#supdate] premise'0 self.t_ProdLocalUpdate__1 from_auth._p1 from_frag._p1)
  && ([@expl:frame_preserving requires #1] [%#supdate'0] op'4 (C_Some'2 (from_frag._p1)) (map_logic'3 frame ([%#sprod'2] fun (f: tuple) -> f._p1))
  = C_Some'4 (C_Some'2 (from_auth._p1))))
  /\ (([%#supdate'1] let {_p0'3 = to_auth ; _p1'3 = to_frag} = update'0 self.t_ProdLocalUpdate__1 from_auth._p1 from_frag._p1 in op'4 (C_Some'2 to_frag) (map_logic'3 frame ([%#sprod'2] fun (f: tuple) -> f._p1))
  = C_Some'4 (C_Some'2 to_auth))
   -> (let _ = frame_preserving'0 self.t_ProdLocalUpdate__1 from_auth._p1 from_frag._p1 (map_logic'3 frame ([%#sprod'2] fun (f: tuple) -> f._p1)) in [@expl:frame_preserving ensures] [%#sprod'1] let {_p0'1 = to_auth ; _p1'1 = to_frag} = update'1 self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth)))))
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__factor [#"../../creusot-contracts/src/logic/ra/sum.rs" 35 4 35 49] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 31 14 34 5
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 37 68 37 85
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 38 70 38 88
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 36 8 40 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'4] and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'9] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'5] incl'0 a b)
   -> ([%#sra'6] incl'0 b c)  -> ([%#sra'7] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'4] and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'3] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'2] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra'0] op'0 self other = C_Some'1 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'3] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Sum
  
  constant factor'1  : t_Sum
  
  function factor'2 [#"../../creusot-contracts/src/logic/ra/sum.rs" 35 4 35 49] (self'0: t_Sum) (factor'3: t_Sum) : t_Option
  
  
  goal vc_factor: match { _p0 = self; _p1 = factor'1 } with
    | {_p0 = C_Left x ; _p1 = C_Left y} -> ([%#sra] match factor x y with
      | C_Some'0 c -> op y c = C_Some'0 x
      | C_None'0 -> forall c: t_R1. op y c <> C_Some'0 x
      end)
     -> ([@expl:factor ensures] [%#ssum] match map_logic (factor x y) ([%#ssum'0] fun (l: t_R1) -> C_Left l) with
      | C_Some c -> op'1 factor'1 c = C_Some self
      | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
      end)
    | {_p0 = C_Right x ; _p1 = C_Right y} -> ([%#sra] match factor'0 x y with
      | C_Some'1 c -> op'0 y c = C_Some'1 x
      | C_None'1 -> forall c: t_R2. op'0 y c <> C_Some'1 x
      end)
     -> ([@expl:factor ensures] [%#ssum] match map_logic'0 (factor'0 x y) ([%#ssum'1] fun (r: t_R2) -> C_Right r) with
      | C_Some c -> op'1 factor'1 c = C_Some self
      | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
      end)
    | _ -> [@expl:factor ensures] [%#ssum] match C_None with
      | C_Some c -> op'1 factor'1 c = C_Some self
      | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
      end
    end
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__commutative [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Sum
  
  constant b  : t_Sum
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a'0: t_Sum) (b'0: t_Sum) : ()
  
  goal vc_commutative: [@expl:commutative ensures] [%#ssum] op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__associative [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Sum
  
  constant b  : t_Sum
  
  constant c  : t_Sum
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a'0: t_Sum) (b'0: t_Sum) (c'0: t_Sum) : ()
  
  
  goal vc_associative: [@expl:associative ensures] [%#ssum] and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__core [#"../../creusot-contracts/src/logic/ra/sum.rs" 59 4 59 33] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 55 14 58 5
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 61 48 61 65
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 62 49 62 67
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 60 8 63 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'4] and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'10] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'9] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'5] incl'0 a b)
   -> ([%#sra'6] incl'0 b c)  -> ([%#sra'7] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'4] and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'3] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'2] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra'0] op'0 self other = C_Some'1 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'3] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_R1) : t_Option'0
  
  axiom core_spec: forall self: t_R1. [%#sra] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_R2) : t_Option'1
  
  axiom core_spec'0: forall self: t_R2. [%#sra] match core'0 self with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Sum
  
  function core'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 59 4 59 33] (self'0: t_Sum) : t_Option
  
  goal vc_core: match self with
    | C_Left x -> ([%#sra] match core x with
      | C_Some'0 c -> op c c = C_Some'0 c /\ op c x = C_Some'0 x
      | C_None'0 -> true
      end)
     -> ([@expl:core ensures] [%#ssum] match map_logic (core x) ([%#ssum'0] fun (l: t_R1) -> C_Left l) with
      | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
      | C_None -> true
      end)
    | C_Right x -> ([%#sra] match core'0 x with
      | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c x = C_Some'1 x
      | C_None'1 -> true
      end)
     -> ([@expl:core ensures] [%#ssum] match map_logic'0 (core'0 x) ([%#ssum'1] fun (r: t_R2) -> C_Right r) with
      | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
      | C_None -> true
      end)
    end
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/sum.rs" 73 4 73 43] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 160 15 160 33
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 161 15 161 39
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 162 14 165 5
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 67 15 67 33
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 68 15 68 39
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 69 14 72 5
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 74 8 78 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 55 14 58 5
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 60 8 63 9
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 31 14 34 5
  let%span ssum'7 = "../../creusot-contracts/src/logic/ra/sum.rs" 36 8 40 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'13] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'2] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'9] incl a b)
   -> ([%#sra'10] incl b c)  -> ([%#sra'11] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'8] and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'7] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'6] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra'4] op self other = C_Some'0 comb)
   -> ([%#sra'5] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'13] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'2] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'9] incl'0 a b)
   -> ([%#sra'10] incl'0 b c)  -> ([%#sra'11] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'8] and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'7] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'6] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra'4] op'0 self other = C_Some'1 comb)
   -> ([%#sra'5] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'3] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_R1) : t_Option'0
  
  axiom core_spec: forall self: t_R1. [%#sra'3] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_R2) : t_Option'1
  
  axiom core_spec'0: forall self: t_R2. [%#sra'3] match core'0 self with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  function core'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 59 4 59 33] (self: t_Sum) : t_Option =
    [%#ssum'5] match self with
      | C_Left x -> map_logic (core x) (fun (l: t_R1) -> C_Left l)
      | C_Right x -> map_logic'0 (core'0 x) (fun (r: t_R2) -> C_Right r)
      end
  
  axiom core_spec'1: forall self: t_Sum. [%#ssum'4] match core'1 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 35 4 35 49] (self: t_Sum) (factor'2: t_Sum) : t_Option
  
   =
    [%#ssum'7] match { _p0 = self; _p1 = factor'2 } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (factor x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (factor'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  axiom factor_spec'1: forall self: t_Sum, factor'2: t_Sum. [%#ssum'6] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: t_Sum. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'1 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Sum) (other: t_Sum) =
    [%#sra'2] factor'1 other self <> C_None
  
  function core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 166 4 166 44] (self: t_R1) (i: t_R1) : ()
  
  axiom core_is_maximal_idemp_spec: forall self: t_R1, i: t_R1. ([%#sra] op i i = C_Some'0 i)
   -> ([%#sra'0] op i self = C_Some'0 self)
   -> ([%#sra'1] match core self with
    | C_Some'0 c -> incl i c
    | C_None'0 -> false
    end)
  
  function core_is_maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 166 4 166 44] (self: t_R2) (i: t_R2) : ()
  
  axiom core_is_maximal_idemp_spec'0: forall self: t_R2, i: t_R2. ([%#sra] op'0 i i = C_Some'1 i)
   -> ([%#sra'0] op'0 i self = C_Some'1 self)
   -> ([%#sra'1] match core'0 self with
    | C_Some'1 c -> incl'0 i c
    | C_None'1 -> false
    end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Sum
  
  constant i  : t_Sum
  
  function core_is_maximal_idemp'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 73 4 73 43] (self'0: t_Sum) (i'0: t_Sum) : ()
  
  
  goal vc_core_is_maximal_idemp: ([%#ssum] op'1 i i = C_Some i)
   -> ([%#ssum'0] op'1 i self = C_Some self)
   -> match { _p0 = self; _p1 = i } with
    | {_p0 = C_Left s ; _p1 = C_Left i'0} -> (([@expl:core_is_maximal_idemp requires #0] [%#sra] op i'0 i'0
    = C_Some'0 i'0)
    && ([@expl:core_is_maximal_idemp requires #1] [%#sra'0] op i'0 s = C_Some'0 s))
    /\ (([%#sra'1] match core s with
      | C_Some'0 c -> incl i'0 c
      | C_None'0 -> false
      end)
     -> ([@expl:core_is_maximal_idemp ensures] [%#ssum'1] match core'1 self with
      | C_Some c -> incl'1 i c
      | C_None -> false
      end))
    | {_p0 = C_Right s ; _p1 = C_Right i'0} -> (([@expl:core_is_maximal_idemp requires #0] [%#sra] op'0 i'0 i'0
    = C_Some'1 i'0)
    && ([@expl:core_is_maximal_idemp requires #1] [%#sra'0] op'0 i'0 s = C_Some'1 s))
    /\ (([%#sra'1] match core'0 s with
      | C_Some'1 c -> incl'0 i'0 c
      | C_None'1 -> false
      end)
     -> ([@expl:core_is_maximal_idemp ensures] [%#ssum'1] match core'1 self with
      | C_Some c -> incl'1 i c
      | C_None -> false
      end))
    | _ -> [@expl:core_is_maximal_idemp ensures] [%#ssum'1] match core'1 self with
      | C_Some c -> incl'1 i c
      | C_None -> false
      end
    end
end
module M_creusot_contracts__logic__ra__sum__qyi1847493758823096333__update [#"../../creusot-contracts/src/logic/ra/sum.rs" 99 4 99 68] (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 98 15 98 33
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 100 8 103 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 90 8 93 9
  
  type t_U
  
  type t_SumUpdateL  =
    { t_SumUpdateL__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Choice
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R1)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 89 4 89 47] (self: t_SumUpdateL) (from: t_Sum) =
    [%#ssum'1] match from with
      | C_Left from'0 -> premise self.t_SumUpdateL__0 from'0
      | C_Right _ -> false
      end
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_SumUpdateL
  
  constant from  : t_Sum
  
  constant ch  : t_Choice
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 99 4 99 68] (self'0: t_SumUpdateL) (from'0: t_Sum) (ch'0: t_Choice) : t_Sum
  
  
  goal vc_update: ([%#ssum] premise'0 self from)
   -> match from with
    | C_Left from'0 -> [@expl:update requires] [%#supdate] premise self.t_SumUpdateL__0 from'0
    | x -> true
    end
end
module M_creusot_contracts__logic__ra__sum__qyi1847493758823096333__frame_preserving [#"../../creusot-contracts/src/logic/ra/sum.rs" 110 4 110 81] (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 17 15 17 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 18 15 18 37
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 19 14 19 57
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 107 15 107 33
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 108 15 108 37
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 109 14 109 57
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 113 27 113 35
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 111 8 114 9
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 90 8 93 9
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 98 15 98 33
  let%span ssum'7 = "../../creusot-contracts/src/logic/ra/sum.rs" 100 8 103 9
  let%span ssum'8 = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'9 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'10 = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'11 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateL  =
    { t_SumUpdateL__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Choice
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R1)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 89 4 89 47] (self: t_SumUpdateL) (from: t_Sum) =
    [%#ssum'4] match from with
      | C_Left from'0 -> premise self.t_SumUpdateL__0 from'0
      | C_Right _ -> false
      end
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
   =
    [%#ssum'11] ()
  
  axiom associative_spec'1: forall a: t_Sum, b: t_Sum, c: t_Sum. [%#ssum'10] and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a: t_Sum) (b: t_Sum) : () =
    [%#ssum'9] ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. [%#ssum'8] op'1 a b = op'1 b a
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 99 4 99 68] (self: t_SumUpdateL) (from: t_Sum) (ch: t_Choice) : t_Sum
  
   =
    [%#ssum'7] match from with
      | C_Left from'0 -> C_Left (update self.t_SumUpdateL__0 from'0 ch)
      | x -> x
      end
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 20 4 20 65] (self: t_U) (from: t_R1) (frame: t_R1) : t_Choice
  
  
  axiom frame_preserving_spec: forall self: t_U, from: t_R1, frame: t_R1. ([%#supdate] premise self from)
   -> ([%#supdate'0] op from frame <> C_None'0)
   -> ([%#supdate'1] op (update self from (frame_preserving self from frame)) frame <> C_None'0)
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice bool) (a: t_Choice)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. ([%#sutil] exists x: t_Choice. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_SumUpdateL
  
  constant from  : t_Sum
  
  constant frame  : t_Sum
  
  function frame_preserving'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 110 4 110 81] (self'0: t_SumUpdateL) (from'0: t_Sum) (frame'0: t_Sum) : t_Choice
  
  
  goal vc_frame_preserving: ([%#ssum] premise'0 self from)
   -> ([%#ssum'0] op'1 from frame <> C_None)
   -> match { _p0 = from; _p1 = frame } with
    | {_p0 = C_Left from'0 ; _p1 = C_Left frame'0} -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_SumUpdateL__0 from'0)
    && ([@expl:frame_preserving requires #1] [%#supdate'0] op from'0 frame'0 <> C_None'0))
    /\ (([%#supdate'1] op (update self.t_SumUpdateL__0 from'0 (frame_preserving self.t_SumUpdateL__0 from'0 frame'0)) frame'0
    <> C_None'0)
     -> ([@expl:frame_preserving ensures] [%#ssum'1] op'1 (update'0 self from (frame_preserving self.t_SumUpdateL__0 from'0 frame'0)) frame
    <> C_None))
    | _ -> ([@expl:such_that requires] [%#sutil] exists x: t_Choice. index_logic ([%#ssum'2] fun (__0: t_Choice) -> true) x)
    /\ (([%#sutil'0] index_logic ([%#ssum'2] fun (__0: t_Choice) -> true) (such_that ([%#ssum'2] fun (__0: t_Choice) -> true)))
     -> ([@expl:frame_preserving ensures] [%#ssum'1] op'1 (update'0 self from (such_that ([%#ssum'2] fun (__0: t_Choice) -> true))) frame
    <> C_None))
    end
end
module M_creusot_contracts__logic__ra__sum__qyi15765748900338894532__update [#"../../creusot-contracts/src/logic/ra/sum.rs" 135 4 135 64] (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 134 15 134 33
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 136 8 139 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 126 8 129 9
  
  type t_U
  
  type t_SumUpdateR  =
    { t_SumUpdateR__0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum  =
    | C_Left t_V
    | C_Right t_R
  
  type t_Choice
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 125 4 125 45] (self: t_SumUpdateR) (from: t_Sum) =
    [%#ssum'1] match from with
      | C_Right from'0 -> premise self.t_SumUpdateR__0 from'0
      | C_Left _ -> false
      end
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_SumUpdateR
  
  constant from  : t_Sum
  
  constant ch  : t_Choice
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 135 4 135 64] (self'0: t_SumUpdateR) (from'0: t_Sum) (ch'0: t_Choice) : t_Sum
  
  
  goal vc_update: ([%#ssum] premise'0 self from)
   -> match from with
    | C_Right from'0 -> [@expl:update requires] [%#supdate] premise self.t_SumUpdateR__0 from'0
    | x -> true
    end
end
module M_creusot_contracts__logic__ra__sum__qyi15765748900338894532__frame_preserving [#"../../creusot-contracts/src/logic/ra/sum.rs" 146 4 146 77] (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 17 15 17 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 18 15 18 37
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 19 14 19 57
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 143 15 143 33
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 144 15 144 37
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 145 14 145 57
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 149 27 149 35
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 147 8 150 9
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 126 8 129 9
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 134 15 134 33
  let%span ssum'7 = "../../creusot-contracts/src/logic/ra/sum.rs" 136 8 139 9
  let%span ssum'8 = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'9 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'10 = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'11 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateR  =
    { t_SumUpdateR__0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum  =
    | C_Left t_V
    | C_Right t_R
  
  type t_Choice
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 125 4 125 45] (self: t_SumUpdateR) (from: t_Sum) =
    [%#ssum'4] match from with
      | C_Right from'0 -> premise self.t_SumUpdateR__0 from'0
      | C_Left _ -> false
      end
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'1: t_R) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R, factor'1: t_R. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec'0: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_R) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_R) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec'0: forall a: t_R, b: t_R. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_V) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
   =
    [%#ssum'11] ()
  
  axiom associative_spec'1: forall a: t_Sum, b: t_Sum, c: t_Sum. [%#ssum'10] and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a: t_Sum) (b: t_Sum) : () =
    [%#ssum'9] ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. [%#ssum'8] op'1 a b = op'1 b a
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 135 4 135 64] (self: t_SumUpdateR) (from: t_Sum) (ch: t_Choice) : t_Sum
  
   =
    [%#ssum'7] match from with
      | C_Right from'0 -> C_Right (update self.t_SumUpdateR__0 from'0 ch)
      | x -> x
      end
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 20 4 20 65] (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  
  axiom frame_preserving_spec: forall self: t_U, from: t_R, frame: t_R. ([%#supdate] premise self from)
   -> ([%#supdate'0] op'0 from frame <> C_None'1)
   -> ([%#supdate'1] op'0 (update self from (frame_preserving self from frame)) frame <> C_None'1)
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice bool) (a: t_Choice)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. ([%#sutil] exists x: t_Choice. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_SumUpdateR
  
  constant from  : t_Sum
  
  constant frame  : t_Sum
  
  function frame_preserving'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 146 4 146 77] (self'0: t_SumUpdateR) (from'0: t_Sum) (frame'0: t_Sum) : t_Choice
  
  
  goal vc_frame_preserving: ([%#ssum] premise'0 self from)
   -> ([%#ssum'0] op'1 from frame <> C_None)
   -> match { _p0 = from; _p1 = frame } with
    | {_p0 = C_Right from'0 ; _p1 = C_Right frame'0} -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_SumUpdateR__0 from'0)
    && ([@expl:frame_preserving requires #1] [%#supdate'0] op'0 from'0 frame'0 <> C_None'1))
    /\ (([%#supdate'1] op'0 (update self.t_SumUpdateR__0 from'0 (frame_preserving self.t_SumUpdateR__0 from'0 frame'0)) frame'0
    <> C_None'1)
     -> ([@expl:frame_preserving ensures] [%#ssum'1] op'1 (update'0 self from (frame_preserving self.t_SumUpdateR__0 from'0 frame'0)) frame
    <> C_None))
    | _ -> ([@expl:such_that requires] [%#sutil] exists x: t_Choice. index_logic ([%#ssum'2] fun (__0: t_Choice) -> true) x)
    /\ (([%#sutil'0] index_logic ([%#ssum'2] fun (__0: t_Choice) -> true) (such_that ([%#ssum'2] fun (__0: t_Choice) -> true)))
     -> ([@expl:frame_preserving ensures] [%#ssum'1] op'1 (update'0 self from (such_that ([%#ssum'2] fun (__0: t_Choice) -> true))) frame
    <> C_None))
    end
end
module M_creusot_contracts__logic__ra__sum__qyi3083214512297526849__frame_preserving [#"../../creusot-contracts/src/logic/ra/sum.rs" 186 4 191 5] (* <logic::ra::sum::SumLocalUpdateL<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 84 15 84 49
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 85 15 85 65
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 87 8 87 67
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 180 15 180 49
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 181 15 181 65
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 183 8 183 67
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 192 8 200 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 160 8 164 9
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 170 8 176 9
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'7 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'8 = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'9 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateL  =
    { t_SumLocalUpdateL__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U) (from_auth: t_R1) (from_frag: t_R1)
  
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 159 4 159 76] (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum)
  
   =
    [%#ssum'3] match { _p0 = from_auth; _p1 = from_frag } with
      | {_p0 = C_Left from_auth'0 ; _p1 = C_Left from_frag'0} -> premise self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0
      | {_p0 = C_Right _ ; _p1 = C_Right _} -> false
      | _ -> true
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R1
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'1 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_R2
  
  function map_logic'1 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'2) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'2
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'2 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic'0 (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'1 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
   =
    [%#ssum'9] ()
  
  axiom associative_spec'1: forall a: t_Sum, b: t_Sum, c: t_Sum. [%#ssum'8] and_then_logic'0 (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a: t_Sum) (b: t_Sum) : () =
    [%#ssum'7] ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. [%#ssum'6] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_Sum) -> C_Some z)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'2: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  type tuple'1  =
    { _p0'1: t_R1; _p1'1: t_R1 }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U) (from_auth: t_R1) (from_frag: t_R1) : tuple'1
  
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple bool) (a: tuple)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map tuple bool) : tuple
  
  axiom such_that_spec: forall p: Map.map tuple bool. ([%#sutil] exists x: tuple. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 169 4 169 97] (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum) : tuple
  
   =
    [%#ssum'4] match { _p0 = from_auth; _p1 = from_frag } with
      | {_p0 = C_Left from_auth'0 ; _p1 = C_Left from_frag'0} -> let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0 in { _p0 = C_Left to_auth;
                                                                                                                                                                         _p1 = C_Left to_frag }
      | _ -> such_that (fun (__0: tuple) -> true)
      end
  
  type tuple'2  =
    { _p0'2: t_Sum; _p1'2: t_Sum; _p2: t_Option }
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Option'1
  
  function and_then_logic'3 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'3) (f: Map.map t_Option'1 t_Option'3) : t_Option'3
  
   =
    [%#soption'2] match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple'3  =
    { _p0'3: t_Option'1; _p1'3: t_Option'1 }
  
  function map_logic'2 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'3
  
   =
    [%#soption'1] match self with
      | C_None'1 -> C_None'3
      | C_Some'1 x -> C_Some'3 (Map.get f x)
      end
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'1) (other: t_Option'1) : t_Option'3
  
   =
    [%#soption] match { _p0'3 = self; _p1'3 = other } with
      | {_p0'3 = C_None'1} -> C_Some'3 other
      | {_p1'3 = C_None'1} -> C_Some'3 self
      | {_p0'3 = C_Some'1 x ; _p1'3 = C_Some'1 y} -> map_logic'2 (op x y) (fun (z: t_R1) -> C_Some'1 z)
      end
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  
  axiom associative_spec'3: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'0] and_then_logic'3 (op'3 a b) (fun (ab: t_Option'1) -> op'3 ab c)
  = and_then_logic'3 (op'3 b c) (fun (bc: t_Option'1) -> op'3 a bc)
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 90 4 90 76] (self: t_U) (from_auth: t_R1) (from_frag: t_R1) (frame: t_Option'1) : ()
  
  
  axiom frame_preserving_spec: forall self: t_U, from_auth: t_R1, from_frag: t_R1, frame: t_Option'1. ([%#supdate] premise self from_auth from_frag)
   -> ([%#supdate'0] op'3 (C_Some'1 from_frag) frame = C_Some'3 (C_Some'1 from_auth))
   -> ([%#supdate'1] let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self from_auth from_frag in op'3 (C_Some'1 to_frag) frame
  = C_Some'3 (C_Some'1 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_SumLocalUpdateL
  
  constant from_auth  : t_Sum
  
  constant from_frag  : t_Sum
  
  constant frame  : t_Option
  
  function frame_preserving'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 186 4 191 5] (self'0: t_SumLocalUpdateL) (from_auth'0: t_Sum) (from_frag'0: t_Sum) (frame'0: t_Option) : ()
  
  
  goal vc_frame_preserving: ([%#ssum] premise'0 self from_auth from_frag)
   -> ([%#ssum'0] op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth))
   -> match { _p0'2 = from_auth; _p1'2 = from_frag; _p2 = frame } with
    | {_p0'2 = C_Left from_auth'0 ; _p1'2 = C_Left from_frag'0 ; _p2 = C_Some (C_Left frame'0)} -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0)
    && ([@expl:frame_preserving requires #1] [%#supdate'0] op'3 (C_Some'1 from_frag'0) (C_Some'1 frame'0)
    = C_Some'3 (C_Some'1 from_auth'0)))
    /\ (([%#supdate'1] let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0 in op'3 (C_Some'1 to_frag) (C_Some'1 frame'0)
    = C_Some'3 (C_Some'1 to_auth))
     -> ([@expl:frame_preserving ensures] [%#ssum'1] let {_p0 = to_auth ; _p1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
    = C_Some'0 (C_Some to_auth)))
    | {_p0'2 = C_Left from_auth'0 ; _p1'2 = C_Left from_frag'0 ; _p2 = C_None} -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0)
    && ([@expl:frame_preserving requires #1] [%#supdate'0] op'3 (C_Some'1 from_frag'0) (C_None'1)
    = C_Some'3 (C_Some'1 from_auth'0)))
    /\ (([%#supdate'1] let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0 in op'3 (C_Some'1 to_frag) (C_None'1)
    = C_Some'3 (C_Some'1 to_auth))
     -> ([@expl:frame_preserving ensures] [%#ssum'1] let {_p0 = to_auth ; _p1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
    = C_Some'0 (C_Some to_auth)))
    | _ -> [@expl:frame_preserving ensures] [%#ssum'1] let {_p0 = to_auth ; _p1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
    = C_Some'0 (C_Some to_auth)
    end
end
module M_creusot_contracts__logic__ra__sum__qyi3543961907530750261__frame_preserving [#"../../creusot-contracts/src/logic/ra/sum.rs" 236 4 241 5] (* <logic::ra::sum::SumLocalUpdateR<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 84 15 84 49
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 85 15 85 65
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 87 8 87 67
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 230 15 230 49
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 231 15 231 65
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 233 8 233 67
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 242 8 250 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 210 8 214 9
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 220 8 226 9
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'7 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'8 = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'9 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateR  =
    { t_SumLocalUpdateR__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U) (from_auth: t_R2) (from_frag: t_R2)
  
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 209 4 209 76] (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum)
  
   =
    [%#ssum'3] match { _p0 = from_auth; _p1 = from_frag } with
      | {_p0 = C_Right from_auth'0 ; _p1 = C_Right from_frag'0} -> premise self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0
      | {_p0 = C_Left _ ; _p1 = C_Left _} -> false
      | _ -> true
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R1
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'1 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_R2
  
  function map_logic'1 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'2) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'2
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'2 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic'0 (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'1 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
   =
    [%#ssum'9] ()
  
  axiom associative_spec'1: forall a: t_Sum, b: t_Sum, c: t_Sum. [%#ssum'8] and_then_logic'0 (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a: t_Sum) (b: t_Sum) : () =
    [%#ssum'7] ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. [%#ssum'6] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_Sum) -> C_Some z)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'2: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  type tuple'1  =
    { _p0'1: t_R2; _p1'1: t_R2 }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U) (from_auth: t_R2) (from_frag: t_R2) : tuple'1
  
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple bool) (a: tuple)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map tuple bool) : tuple
  
  axiom such_that_spec: forall p: Map.map tuple bool. ([%#sutil] exists x: tuple. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 219 4 219 97] (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum) : tuple
  
   =
    [%#ssum'4] match { _p0 = from_auth; _p1 = from_frag } with
      | {_p0 = C_Right from_auth'0 ; _p1 = C_Right from_frag'0} -> let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0 in { _p0 = C_Right to_auth;
                                                                                                                                                                           _p1 = C_Right to_frag }
      | _ -> such_that (fun (__0: tuple) -> true)
      end
  
  type tuple'2  =
    { _p0'2: t_Sum; _p1'2: t_Sum; _p2: t_Option }
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Option'2
  
  function and_then_logic'3 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'3) (f: Map.map t_Option'2 t_Option'3) : t_Option'3
  
   =
    [%#soption'2] match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple'3  =
    { _p0'3: t_Option'2; _p1'3: t_Option'2 }
  
  function map_logic'2 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'3
  
   =
    [%#soption'1] match self with
      | C_None'2 -> C_None'3
      | C_Some'2 x -> C_Some'3 (Map.get f x)
      end
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'2) (other: t_Option'2) : t_Option'3
  
   =
    [%#soption] match { _p0'3 = self; _p1'3 = other } with
      | {_p0'3 = C_None'2} -> C_Some'3 other
      | {_p1'3 = C_None'2} -> C_Some'3 self
      | {_p0'3 = C_Some'2 x ; _p1'3 = C_Some'2 y} -> map_logic'2 (op'0 x y) (fun (z: t_R2) -> C_Some'2 z)
      end
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'2) (b: t_Option'2) (c: t_Option'2) : ()
  
  
  axiom associative_spec'3: forall a: t_Option'2, b: t_Option'2, c: t_Option'2. [%#soption'0] and_then_logic'3 (op'3 a b) (fun (ab: t_Option'2) -> op'3 ab c)
  = and_then_logic'3 (op'3 b c) (fun (bc: t_Option'2) -> op'3 a bc)
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 90 4 90 76] (self: t_U) (from_auth: t_R2) (from_frag: t_R2) (frame: t_Option'2) : ()
  
  
  axiom frame_preserving_spec: forall self: t_U, from_auth: t_R2, from_frag: t_R2, frame: t_Option'2. ([%#supdate] premise self from_auth from_frag)
   -> ([%#supdate'0] op'3 (C_Some'2 from_frag) frame = C_Some'3 (C_Some'2 from_auth))
   -> ([%#supdate'1] let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self from_auth from_frag in op'3 (C_Some'2 to_frag) frame
  = C_Some'3 (C_Some'2 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_SumLocalUpdateR
  
  constant from_auth  : t_Sum
  
  constant from_frag  : t_Sum
  
  constant frame  : t_Option
  
  function frame_preserving'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 236 4 241 5] (self'0: t_SumLocalUpdateR) (from_auth'0: t_Sum) (from_frag'0: t_Sum) (frame'0: t_Option) : ()
  
  
  goal vc_frame_preserving: ([%#ssum] premise'0 self from_auth from_frag)
   -> ([%#ssum'0] op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth))
   -> match { _p0'2 = from_auth; _p1'2 = from_frag; _p2 = frame } with
    | {_p0'2 = C_Right from_auth'0 ; _p1'2 = C_Right from_frag'0 ; _p2 = C_Some (C_Right frame'0)} -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0)
    && ([@expl:frame_preserving requires #1] [%#supdate'0] op'3 (C_Some'2 from_frag'0) (C_Some'2 frame'0)
    = C_Some'3 (C_Some'2 from_auth'0)))
    /\ (([%#supdate'1] let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0 in op'3 (C_Some'2 to_frag) (C_Some'2 frame'0)
    = C_Some'3 (C_Some'2 to_auth))
     -> ([@expl:frame_preserving ensures] [%#ssum'1] let {_p0 = to_auth ; _p1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
    = C_Some'0 (C_Some to_auth)))
    | {_p0'2 = C_Right from_auth'0 ; _p1'2 = C_Right from_frag'0 ; _p2 = C_None} -> (([@expl:frame_preserving requires #0] [%#supdate] premise self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0)
    && ([@expl:frame_preserving requires #1] [%#supdate'0] op'3 (C_Some'2 from_frag'0) (C_None'2)
    = C_Some'3 (C_Some'2 from_auth'0)))
    /\ (([%#supdate'1] let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0 in op'3 (C_Some'2 to_frag) (C_None'2)
    = C_Some'3 (C_Some'2 to_auth))
     -> ([@expl:frame_preserving ensures] [%#ssum'1] let {_p0 = to_auth ; _p1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
    = C_Some'0 (C_Some to_auth)))
    | _ -> [@expl:frame_preserving ensures] [%#ssum'1] let {_p0 = to_auth ; _p1 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
    = C_Some'0 (C_Some to_auth)
    end
end
module M_creusot_contracts__logic__ra__update__qyi11826117606277287715__update [#"../../creusot-contracts/src/logic/ra/update.rs" 37 4 37 40] (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 36 15 36 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 38 8 38 13
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 30 12 30 66
  
  use map.Map
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 28 4 28 37] (self: t_R) (from: t_R) =
    [%#supdate'1] forall y: t_R. op from y <> C_None  -> op self y <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_R
  
  constant from  : t_R
  
  constant _2  : ()
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 37 4 37 40] (self'0: t_R) (from'0: t_R) (_2'0: ()) : t_R
  
  
  goal vc_update: true
end
module M_creusot_contracts__logic__ra__update__qyi11826117606277287715__frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 45 4 45 48] (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 42 15 42 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 43 15 43 37
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 44 14 44 57
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 45 49 45 51
  let%span supdate'3 = "../../creusot-contracts/src/logic/ra/update.rs" 30 12 30 66
  let%span supdate'4 = "../../creusot-contracts/src/logic/ra/update.rs" 36 15 36 33
  let%span supdate'5 = "../../creusot-contracts/src/logic/ra/update.rs" 38 8 38 13
  
  use map.Map
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 28 4 28 37] (self: t_R) (from: t_R) =
    [%#supdate'3] forall y: t_R. op from y <> C_None  -> op self y <> C_None
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 37 4 37 40] (self: t_R) (from: t_R) (_2: ()) : t_R
   =
    [%#supdate'5] self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_R
  
  constant from  : t_R
  
  constant frame  : t_R
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 45 4 45 48] (self'0: t_R) (from'0: t_R) (frame'0: t_R) : ()
  
  
  goal vc_frame_preserving: ([%#supdate] premise self from)
   -> ([%#supdate'0] op from frame <> C_None)
   -> ([@expl:frame_preserving ensures] [%#supdate'1] op (update self from ()) frame <> C_None)
end
module M_creusot_contracts__logic__ra__update__qyi5477729486377161480__update [#"../../creusot-contracts/src/logic/ra/update.rs" 63 4 63 45] (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 62 15 62 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 60 4 60 12
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 55 12 56 57
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R
  
   =
    [%#smapping] Map.get self a
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 53 4 53 37] (self: Map.map t_Choice t_R) (from: t_R)
  
   =
    [%#supdate'1] forall y: t_R. op from y <> C_None  -> (exists ch: t_Choice. op (index_logic self ch) y <> C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Map.map t_Choice t_R
  
  constant from  : t_R
  
  constant ch  : t_Choice
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 63 4 63 45] (self'0: Map.map t_Choice t_R) (from'0: t_R) (ch'0: t_Choice) : t_R
  
  
  goal vc_update: true
end
module M_creusot_contracts__logic__ra__update__qyi5477729486377161480__frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 71 4 71 58] (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 68 15 68 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 69 15 69 37
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 70 14 70 57
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 62 15 62 33
  let%span supdate'3 = "../../creusot-contracts/src/logic/ra/update.rs" 72 18 72 62
  let%span supdate'4 = "../../creusot-contracts/src/logic/ra/update.rs" 72 8 72 63
  let%span supdate'5 = "../../creusot-contracts/src/logic/ra/update.rs" 55 12 56 57
  let%span supdate'6 = "../../creusot-contracts/src/logic/ra/update.rs" 60 4 60 12
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R
  
   =
    [%#smapping] Map.get self a
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 53 4 53 37] (self: Map.map t_Choice t_R) (from: t_R)
  
   =
    [%#supdate'5] forall y: t_R. op from y <> C_None  -> (exists ch: t_Choice. op (index_logic self ch) y <> C_None)
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 63 4 63 45] (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R
  
   =
    [%#supdate'6] index_logic self ch
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice bool) (a: t_Choice)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. ([%#sutil] exists x: t_Choice. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Map.map t_Choice t_R
  
  constant from  : t_R
  
  constant frame  : t_R
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 71 4 71 58] (self'0: Map.map t_Choice t_R) (from'0: t_R) (frame'0: t_R) : t_Choice
  
  
  goal vc_frame_preserving: ([%#supdate] premise self from)
   -> ([%#supdate'0] op from frame <> C_None)
   -> (forall ch: t_Choice. [@expl:update requires] [%#supdate'2] premise self from)
  /\ ([@expl:such_that requires] [%#sutil] exists x: t_Choice. index_logic'0 ([%#supdate'3] fun (ch: t_Choice) -> op (update self from ch) frame
  <> C_None) x)
  /\ (([%#sutil'0] index_logic'0 ([%#supdate'3] fun (ch: t_Choice) -> op (update self from ch) frame
  <> C_None) (such_that ([%#supdate'3] fun (ch: t_Choice) -> op (update self from ch) frame <> C_None)))
   -> ([@expl:frame_preserving ensures] [%#supdate'1] op (update self from (such_that ([%#supdate'3] fun (ch: t_Choice) -> op (update self from ch) frame
  <> C_None))) frame
  <> C_None))
end
module M_creusot_contracts__logic__ra__update__qyi10922308247021603688__frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 118 4 118 75] (* <snapshot::Snapshot<(R, R)> as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 112 15 112 63
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 113 15 113 65
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 115 8 115 81
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 118 76 118 78
  let%span supdate'3 = "../../creusot-contracts/src/logic/ra/update.rs" 98 12 100 56
  let%span supdate'4 = "../../creusot-contracts/src/logic/ra/update.rs" 107 8 107 13
  
  use map.Map
  
  type t_R
  
  type tuple  =
    { _p0: t_R; _p1: t_R }
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 96 4 96 56] (self: tuple) (from_auth: t_R) (from_frag: t_R)
  
   =
    [%#supdate'3] forall f: t_Option. op'0 (C_Some from_frag) f = C_Some'0 (C_Some from_auth)
     -> op'0 (C_Some (self._p1)) f = C_Some'0 (C_Some (self._p0))
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 106 4 106 41] (self: tuple) (_1: t_R) (_2: t_R) : tuple
  
   =
    [%#supdate'4] self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : tuple
  
  constant from_auth  : t_R
  
  constant from_frag  : t_R
  
  constant frame  : t_Option
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 118 4 118 75] (self'0: tuple) (from_auth'0: t_R) (from_frag'0: t_R) (frame'0: t_Option) : ()
  
  
  goal vc_frame_preserving: ([%#supdate] premise self from_auth from_frag)
   -> ([%#supdate'0] op'0 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth))
   -> ([@expl:frame_preserving ensures] [%#supdate'1] let {_p0 = to_auth ; _p1 = to_frag} = update self from_auth from_frag in op'0 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth))
end
module M_creusot_contracts__logic__ra__view__qyi3129231301466035151__inhabits [#"../../creusot-contracts/src/logic/ra/view.rs" 63 4 63 25] (* <logic::ra::view::InnerView<R> as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 62 14 62 32
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 64 8 64 50
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'13] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'9] incl a b)
   -> ([%#sra'10] incl b c)  -> ([%#sra'11] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'8] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'7] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'6] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'4] op self other = C_Some'0 comb)
   -> ([%#sra'5] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'14] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'15] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'3] ()
  
  axiom unit_core_spec: [%#sra'2] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'1] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'0] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'7] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'5] rel a f)  -> ([%#sview'6] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'2] rel a f1)
   -> ([%#sview'3] incl f2 f1)  -> ([%#sview'4] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'1] rel self.t_InnerView__auth self.t_InnerView__frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function inhabits [#"../../creusot-contracts/src/logic/ra/view.rs" 63 4 63 25]  : t_InnerView
  
  goal vc_inhabits: ([%#sra] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x)
   -> ([@expl:inhabits ensures] [%#sview] invariant' { t_InnerView__auth = C_None; t_InnerView__frag = unit' })
end
module M_creusot_contracts__logic__ra__view__qyi9160327263184903567__frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'5] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'0] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'8] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'6] rel a f)  -> ([%#sview'7] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'3] rel a f1)
   -> ([%#sview'4] incl f2 f1)  -> ([%#sview'5] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'2] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'1] (view self.t_View__0).t_InnerView__auth
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_View
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self'0: t_View) : t_Frag
  
  goal vc_frag: ([%#sinvariant] invariant' (view self.t_View__0))
   -> ([@expl:frag ensures] [%#sview] rel (auth self) (view self.t_View__0).t_InnerView__frag)
end
module M_creusot_contracts__logic__ra__view__qyi9160327263184903567__ext_eq [#"../../creusot-contracts/src/logic/ra/view.rs" 86 4 86 44] (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 206 15 206 30
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 207 14 207 27
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 85 14 85 39
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 87 8 87 49
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'5] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'0] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'9] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'7] rel a f)  -> ([%#sview'8] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'4] rel a f1)
   -> ([%#sview'5] incl f2 f1)  -> ([%#sview'6] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'10] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function view_inj [#"../../creusot-contracts/src/invariant.rs" 208 4 208 38] (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. ([%#sinvariant] view self = view other)
   -> ([%#sinvariant'0] self = other)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'2] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'3] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'0] rel (auth self) (frag self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_View
  
  constant other  : t_View
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/ra/view.rs" 86 4 86 44] (self'0: t_View) (other'0: t_View)
  
  goal vc_ext_eq: let _ = () in if auth self = auth other then
    ([%#sview'0] rel (auth self) (frag self))
     -> ([%#sview'0] rel (auth other) (frag other))
     -> ([@expl:ext_eq ensures] [%#sview] (frag self = frag other) = (self = other))
  else
    [@expl:ext_eq ensures] [%#sview] false = (self = other)

end
module M_creusot_contracts__logic__ra__view__qyi9160327263184903567__new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'5] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'0] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'12] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'10] rel a f)  -> ([%#sview'11] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'7] rel a f1)
   -> ([%#sview'8] incl f2 f1)  -> ([%#sview'9] rel a f2)
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'6] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'3] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'5] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'4] rel (auth self) (frag self)
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant] invariant' x)
   -> ([%#sinvariant'0] view (new_logic x) = x)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant auth'0  : t_Option
  
  constant frag'0  : t_Frag
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'1: t_Option) (frag'1: t_Frag) : t_View
  
  goal vc_new: ([%#sview] rel auth'0 frag'0)
   -> ([@expl:new_logic requires] [%#sinvariant] invariant' { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 })
  /\ (([%#sinvariant'0] view (new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 })
  = { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 })
   -> (let result = { t_View__0 = new_logic { t_InnerView__auth = auth'0;
                                              t_InnerView__frag = frag'0 } } in ([@expl:new ensures #0] [%#sview'0] auth result
  = auth'0)
  && ([@expl:new ensures #1] [%#sview'1] frag result = frag'0)))
end
module M_creusot_contracts__logic__ra__view__qyi9160327263184903567__new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'5] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'0] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'13] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'11] rel a f)  -> ([%#sview'12] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'8] rel a f1)
   -> ([%#sview'9] incl f2 f1)  -> ([%#sview'10] rel a f2)
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'14] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'5] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'7] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'6] rel (auth self) (frag self)
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant] invariant' x)
   -> ([%#sinvariant'0] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_Frag) : t_View
   =
    [%#sview'4] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'1] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'2] frag (new auth'0 frag'0) = frag'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant frag'0  : t_Frag
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'1: t_Frag) : t_View
  
  goal vc_new_frag: ([%#sview] rel (C_None) frag'0)  -> ([@expl:new requires] [%#sview'0] rel (C_None) frag'0)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__factor [#"../../creusot-contracts/src/logic/ra/view.rs" 138 4 138 49] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 206 15 206 30
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 207 14 207 27
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'2 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'3 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 134 14 137 5
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 139 8 139 49
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'4] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'10] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'16] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'14] rel a f)  -> ([%#sview'15] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'11] rel a f1)
   -> ([%#sview'12] incl f2 f1)  -> ([%#sview'13] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'17] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'8] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'7] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'0] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'2] invariant' x)
   -> ([%#sinvariant'3] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'9] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'1] rel auth'0 frag'0)
   -> ([%#sview'2] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'1] rel auth'0 frag'0)
   -> ([%#sview'3] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'6] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function view_inj [#"../../creusot-contracts/src/invariant.rs" 208 4 208 38] (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. ([%#sinvariant] view self = view other)
   -> ([%#sinvariant'0] self = other)
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_Frag) : t_View =
    [%#sview'10] new (C_None'1) frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_View
  
  constant factor'0  : t_View
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/view.rs" 138 4 138 49] (self'0: t_View) (factor'2: t_View) : t_Option
  
  
  goal vc_factor: let _ = () in ([%#sview'0] rel (auth self) (frag self))
   -> ([%#sview'0] rel (auth factor'0) (frag factor'0))
   -> ([%#sra] match factor (frag self) (frag factor'0) with
    | C_Some'0 c -> op (frag factor'0) c = C_Some'0 (frag self)
    | C_None'0 -> forall c: t_Frag. op (frag factor'0) c <> C_Some'0 (frag self)
    end)
   -> match factor (frag self) (frag factor'0) with
    | C_Some'0 f -> match { _p0 = auth self; _p1 = auth factor'0 } with
      | {_p0 = C_Some'1 a ; _p1 = C_None'1} -> ([@expl:new requires] [%#sview'1] rel (C_Some'1 a) f)
      /\ (([%#sview'2] auth (new (C_Some'1 a) f) = C_Some'1 a) && ([%#sview'3] frag (new (C_Some'1 a) f) = f)
       -> ([@expl:factor ensures] [%#sview] match C_Some (new (C_Some'1 a) f) with
        | C_Some c -> op'0 factor'0 c = C_Some self
        | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
        end))
      | {_p0 = a1 ; _p1 = a2} -> if a1 = a2 then
        ([@expl:new_frag requires] [%#sview'4] rel (C_None'1) f)
        /\ ([@expl:factor ensures] [%#sview] match C_Some (new_frag f) with
          | C_Some c -> op'0 factor'0 c = C_Some self
          | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
          end)
      else
        [@expl:factor ensures] [%#sview] match C_None with
          | C_Some c -> op'0 factor'0 c = C_Some self
          | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
          end
      
      end
    | C_None'0 -> [@expl:factor ensures] [%#sview] match C_None with
      | C_Some c -> op'0 factor'0 c = C_Some self
      | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
      end
    end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__commutative [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'14] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'12] rel a f)  -> ([%#sview'13] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'9] rel a f1)
   -> ([%#sview'10] incl f2 f1)  -> ([%#sview'11] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'15] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'4] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'3] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'2] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'8] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'6] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'7] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'1] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_View
  
  constant b  : t_View
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a'0: t_View) (b'0: t_View) : ()
  
  goal vc_commutative: [@expl:commutative ensures] [%#sview] op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__associative [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 206 15 206 30
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 207 14 207 27
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'2 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'3 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'14] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'12] rel a f)  -> ([%#sview'13] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'9] rel a f1)
   -> ([%#sview'10] incl f2 f1)  -> ([%#sview'11] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'15] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'4] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'3] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'0] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'2] invariant' x)
   -> ([%#sinvariant'3] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'8] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'6] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'7] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'2] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1; _p2: t_Option'1 }
  
  function view_inj [#"../../creusot-contracts/src/invariant.rs" 208 4 208 38] (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. ([%#sinvariant] view self = view other)
   -> ([%#sinvariant'0] self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_View
  
  constant b  : t_View
  
  constant c  : t_View
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a'0: t_View) (b'0: t_View) (c'0: t_View) : ()
  
  
  goal vc_associative: ([%#sview'0] rel (auth a) (frag a))
   -> ([%#sview'0] rel (auth b) (frag b))
   -> ([%#sview'0] rel (auth b) (frag b))
   -> ([%#sview'0] rel (auth c) (frag c))
   -> match { _p0'0 = op (frag a) (frag b); _p1'0 = op (frag b) (frag c) } with
    | {_p0'0 = C_Some'0 fab ; _p1'0 = C_Some'0 fbc} -> ([%#sview'0] rel (auth c) (frag c))
     -> ([%#sview'0] rel (auth a) (frag a))
     -> match { _p0'0 = op fab (frag c); _p1'0 = op (frag a) fbc } with
      | {_p0'0 = C_Some'0 fabc1 ; _p1'0 = C_Some'0 fabc2} -> fabc1 = fabc2
      && (let _ = () in let _ = () in match { _p0'1 = auth a; _p1'1 = auth b; _p2 = auth c } with
        | {_p0'1 = C_Some'1 _ ; _p1'1 = C_None'1 ; _p2 = C_None'1} | {_p0'1 = C_None'1 ; _p1'1 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'1 = C_None'1 ; _p1'1 = C_None'1 ; _p2 = C_Some'1 _} -> let _ = () in let _ = () in [@expl:associative ensures] [%#sview] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
        = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
        | _ -> let _ = () in let _ = () in [@expl:associative ensures] [%#sview] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
        = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
        end)
      | _ -> let _ = () in let _ = () in [@expl:associative ensures] [%#sview] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
      = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
      end
    | _ -> let _ = () in let _ = () in [@expl:associative ensures] [%#sview] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
    = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
    end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__core [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 182 14 185 5
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 187 8 187 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'14] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'5] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'0] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'15] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'13] ()
  
  axiom unit_core_spec: [%#sra'12] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'11] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'10] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'19] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'17] rel a f)  -> ([%#sview'18] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'14] rel a f1)
   -> ([%#sview'15] incl f2 f1)  -> ([%#sview'16] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'20] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'7] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'6] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'5] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'11] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'9] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'10] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'3] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_Frag) : t_View =
    [%#sview'13] new (C_None'1) frag'0
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (self: t_View) : t_View =
    [%#sview'4] let _ = () in let _ = () in new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. [%#sview'0] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. [%#sview'1] op'0 (core_total'0 self) self = C_Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_View
  
  function core [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (self'0: t_View) : t_Option
  
  goal vc_core: ([%#sview'0] op'0 (core_total'0 self) (core_total'0 self) = C_Some (core_total'0 self))
  && ([%#sview'1] op'0 (core_total'0 self) self = C_Some self)
   -> ([@expl:core ensures] [%#sview] match C_Some (core_total'0 self) with
    | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
    | C_None -> true
    end)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra/view.rs" 197 4 197 43] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 160 15 160 33
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 161 15 161 39
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 162 14 165 5
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 194 14 194 52
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'17 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'18 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'19 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'20 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'21 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 191 15 191 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 192 15 192 39
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 193 14 196 5
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 198 8 198 39
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 182 14 185 5
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 187 8 187 31
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 134 14 137 5
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 139 8 139 49
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'24 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'25 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'26 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'20] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'2] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'19] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'16] incl a b)
   -> ([%#sra'17] incl b c)  -> ([%#sra'18] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'15] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'14] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'13] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'11] op self other = C_Some'0 comb)
   -> ([%#sra'12] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'9] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'10] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'21] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'8] ()
  
  axiom unit_core_spec: [%#sra'7] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'6] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'5] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'23] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'21] rel a f)  -> ([%#sview'22] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'18] rel a f1)
   -> ([%#sview'19] incl f2 f1)  -> ([%#sview'20] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'26] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'8] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'7] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'2] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'12] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'9] rel auth'0 frag'0)
   -> ([%#sview'10] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'9] rel auth'0 frag'0)
   -> ([%#sview'11] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'4] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_Frag) : t_View =
    [%#sview'25] new (C_None'1) frag'0
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (self: t_View) : t_View =
    [%#sview'15] let _ = () in let _ = () in new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. [%#sview'13] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. [%#sview'14] op'0 (core_total'0 self) self = C_Some self
  
  function core [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (self: t_View) : t_Option =
    [%#sview'6] C_Some (core_total'0 self)
  
  axiom core_spec: forall self: t_View. [%#sview'5] match core self with
    | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
    | C_None -> true
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 138 4 138 49] (self: t_View) (factor'1: t_View) : t_Option
  
   =
    [%#sview'17] let _ = () in match factor (frag self) (frag factor'1) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth factor'1 } with
        | {_p0 = C_Some'1 a ; _p1 = C_None'1} -> C_Some (new (C_Some'1 a) f)
        | {_p0 = a1 ; _p1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'0: forall self: t_View, factor'1: t_View. [%#sview'16] match factor'0 self factor'1 with
    | C_Some c -> op'0 factor'1 c = C_Some self
    | C_None -> forall c: t_View. op'0 factor'1 c <> C_Some self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_View) (other: t_View) =
    [%#sra'2] factor'0 other self <> C_None
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_Frag) : t_Option'0
  
  axiom core_spec'0: forall self: t_Frag. [%#sra'4] match core'0 self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core_is_total [#"../../creusot-contracts/src/logic/ra.rs" 195 4 195 27] (self: t_Frag) : ()
  
  axiom core_is_total_spec: forall self: t_Frag. [%#sra'3] core'0 self = C_Some'0 (core_total self)
  
  function core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 166 4 166 44] (self: t_Frag) (i: t_Frag) : ()
  
  
  axiom core_is_maximal_idemp_spec: forall self: t_Frag, i: t_Frag. ([%#sra] op i i = C_Some'0 i)
   -> ([%#sra'0] op i self = C_Some'0 self)
   -> ([%#sra'1] match core'0 self with
    | C_Some'0 c -> incl i c
    | C_None'0 -> false
    end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_View
  
  constant i  : t_View
  
  function core_is_maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 197 4 197 43] (self'0: t_View) (i'0: t_View) : ()
  
  
  goal vc_core_is_maximal_idemp: ([%#sview] op'0 i i = C_Some i)
   -> ([%#sview'0] op'0 i self = C_Some self)
   -> (let _ = () in ([%#sview'2] rel (auth self) (frag self))
   -> ([%#sview'2] rel (auth i) (frag i))
   -> (([@expl:core_is_maximal_idemp requires #0] [%#sra] op (frag i) (frag i) = C_Some'0 (frag i))
  && ([@expl:core_is_maximal_idemp requires #1] [%#sra'0] op (frag i) (frag self) = C_Some'0 (frag self)))
  /\ (([%#sra'1] match core'0 (frag self) with
    | C_Some'0 c -> incl (frag i) c
    | C_None'0 -> false
    end)
   -> ([@expl:core_is_maximal_idemp ensures] [%#sview'1] match core self with
    | C_Some c -> incl'0 i c
    | C_None -> false
    end)))
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__unit [#"../../creusot-contracts/src/logic/ra/view.rs" 206 4 206 21] (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 205 14 205 78
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 207 8 207 29
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 85 14 85 39
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 87 8 87 49
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'13] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'9] incl a b)
   -> ([%#sra'10] incl b c)  -> ([%#sra'11] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'8] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'7] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'6] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'4] op self other = C_Some'0 comb)
   -> ([%#sra'5] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'14] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'15] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'3] ()
  
  axiom unit_core_spec: [%#sra'2] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'1] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'0] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'22] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'20] rel a f)  -> ([%#sview'21] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'17] rel a f1)
   -> ([%#sview'18] incl f2 f1)  -> ([%#sview'19] rel a f2)
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'23] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'12] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'11] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'10] rel (auth self) (frag self)
  
  type tuple'0  =
    { _p0'0: t_Option'1; _p1'0: t_Option'1; _p2: t_Option'1 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'16] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'13] rel auth'0 frag'0)
   -> ([%#sview'14] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'13] rel auth'0 frag'0)
   -> ([%#sview'15] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'2] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'1 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'9] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some'1 _ ; _p1'0 = C_None'1 ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'8] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'7] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'6] op'0 a b = op'0 b a
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/ra/view.rs" 86 4 86 44] (self: t_View) (other: t_View) =
    [%#sview'4] let _ = () in auth self = auth other /\ frag self = frag other
  
  axiom ext_eq_spec: forall self: t_View, other: t_View. [%#sview'3] ext_eq self other = (self = other)
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_Frag) : t_View =
    [%#sview'5] new (C_None'1) frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit''0 [#"../../creusot-contracts/src/logic/ra/view.rs" 206 4 206 21]  : t_View
  
  goal vc_unit: let _ = () in ([%#sra] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x)
   -> ([@expl:new_frag requires] [%#sview'0] rel (C_None'1) unit')
  /\ (let result = new_frag unit' in [@expl:unit ensures] [%#sview] forall x: t_View [op'0 x result]. op'0 x result
  = C_Some x)
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__core_total [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 194 14 194 52
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'17 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'18 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 85 14 85 39
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 87 8 87 49
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'24 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'18] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'16] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'15] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'12] incl a b)
   -> ([%#sra'13] incl b c)  -> ([%#sra'14] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'11] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'10] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'9] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'7] op self other = C_Some'0 comb)
   -> ([%#sra'8] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'0] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'17] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'5] ()
  
  axiom unit_core_spec: [%#sra'4] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'3] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'2] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'23] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'21] rel a f)  -> ([%#sview'22] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'18] rel a f1)
   -> ([%#sview'19] incl f2 f1)  -> ([%#sview'20] rel a f2)
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'24] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'8] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'7] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'1] rel (auth self) (frag self)
  
  type tuple'0  =
    { _p0'0: t_Option'1; _p1'0: t_Option'1; _p2: t_Option'1 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'17] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'14] rel auth'0 frag'0)
   -> ([%#sview'15] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'14] rel auth'0 frag'0)
   -> ([%#sview'16] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'4] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'1 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'13] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some'1 _ ; _p1'0 = C_None'1 ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'12] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'11] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'10] op'0 a b = op'0 b a
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_Frag) : t_Option'0
  
  axiom core_spec: forall self: t_Frag. [%#sra'6] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core_is_total [#"../../creusot-contracts/src/logic/ra.rs" 195 4 195 27] (self: t_Frag) : ()
  
  axiom core_is_total_spec: forall self: t_Frag. [%#sra'1] core self = C_Some'0 (core_total self)
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/ra/view.rs" 86 4 86 44] (self: t_View) (other: t_View) =
    [%#sview'6] let _ = () in auth self = auth other /\ frag self = frag other
  
  axiom ext_eq_spec: forall self: t_View, other: t_View. [%#sview'5] ext_eq self other = (self = other)
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_Frag) : t_View =
    [%#sview'9] new (C_None'1) frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_View
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (self'0: t_View) : t_View
  
  goal vc_core_total: let _ = () in let _ = () in ([%#sview'1] rel (auth self) (frag self))
   -> ([%#sra] op (core_total (frag self)) (core_total (frag self)) = C_Some'0 (core_total (frag self)))
  && ([%#sra'0] op (core_total (frag self)) (frag self) = C_Some'0 (frag self))
   -> ([@expl:new_frag requires] [%#sview'2] rel (C_None'1) (core_total (frag self)))
  /\ (let result = new_frag (core_total (frag self)) in ([@expl:core_total ensures #0] [%#sview] op'0 result result
  = C_Some result)
  && ([@expl:core_total ensures #1] [%#sview'0] op'0 result self = C_Some self))
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__core_is_total [#"../../creusot-contracts/src/logic/ra/view.rs" 223 4 223 26] (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 222 14 222 52
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 223 27 223 29
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 182 14 185 5
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 187 8 187 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'24 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'25 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'26 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'14] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'13] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'10] incl a b)
   -> ([%#sra'11] incl b c)  -> ([%#sra'12] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'9] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'8] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'7] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'5] op self other = C_Some'0 comb)
   -> ([%#sra'6] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'0] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'15] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'4] ()
  
  axiom unit_core_spec: [%#sra'3] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'2] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'1] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'25] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'23] rel a f)  -> ([%#sview'24] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'20] rel a f1)
   -> ([%#sview'21] incl f2 f1)  -> ([%#sview'22] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'26] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'15] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'14] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'13] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'19] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'16] rel auth'0 frag'0)
   -> ([%#sview'17] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'16] rel auth'0 frag'0)
   -> ([%#sview'18] frag (new auth'0 frag'0) = frag'0)
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1; _p2: t_Option'1 }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'10] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'9] let _ = match { _p0'0 = op (frag a) (frag b); _p1'0 = op (frag b) (frag c) } with
      | {_p0'0 = C_Some'0 fab ; _p1'0 = C_Some'0 fbc} -> match { _p0'0 = op fab (frag c); _p1'0 = op (frag a) fbc } with
        | {_p0'0 = C_Some'0 fabc1 ; _p1'0 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'1 = auth a;
                                                                                                   _p1'1 = auth b;
                                                                                                   _p2 = auth c } with
          | {_p0'1 = C_Some'1 _ ; _p1'1 = C_None'1 ; _p2 = C_None'1} | {_p0'1 = C_None'1 ; _p1'1 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'1 = C_None'1 ; _p1'1 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'8] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'7] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'6] op'0 a b = op'0 b a
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_Frag) : t_View =
    [%#sview'12] new (C_None'1) frag'0
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (self: t_View) : t_View =
    [%#sview'5] let _ = () in let _ = () in new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. [%#sview'3] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. [%#sview'4] op'0 (core_total'0 self) self = C_Some self
  
  function core [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (self: t_View) : t_Option =
    [%#sview'2] C_Some (core_total'0 self)
  
  axiom core_spec: forall self: t_View. [%#sview'1] match core self with
    | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
    | C_None -> true
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_View
  
  function core_is_total [#"../../creusot-contracts/src/logic/ra/view.rs" 223 4 223 26] (self'0: t_View) : ()
  
  goal vc_core_is_total: [@expl:core_is_total ensures] [%#sview] core self = C_Some (core_total'0 self)
end
module M_creusot_contracts__logic__ra__view__qyi5759646997670148869__update [#"../../creusot-contracts/src/logic/ra/view.rs" 253 4 253 57] (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 252 15 252 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 254 8 254 51
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 235 12 246 21
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'14] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'12] rel a f)  -> ([%#sview'13] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'9] rel a f1)
   -> ([%#sview'10] incl f2 f1)  -> ([%#sview'11] rel a f2)
  
  type tuple  =
    { _p0: t_Auth; _p1: t_Frag }
  
  type t_ViewUpdate  =
    { t_ViewUpdate__0: Map.map t_Choice tuple }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'15] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'6] (view self.t_View__0).t_InnerView__auth
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice tuple) (a: t_Choice) : tuple
  
   =
    [%#smapping] Map.get self a
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'8] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'7] rel (auth self) (frag self)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 233 4 233 43] (self: t_ViewUpdate) (from: t_View) =
    [%#sview'4] auth from <> C_None
    /\ (forall ch: t_Choice. rel (C_Some ((index_logic self.t_ViewUpdate__0 ch)._p0)) (index_logic self.t_ViewUpdate__0 ch)._p1)
    /\ (forall frame: t_Frag. match op (frag from) frame with
      | C_Some'0 ff -> rel (auth from) ff
      | C_None'0 -> false
      end
     -> (exists ch: t_Choice. match op (index_logic self.t_ViewUpdate__0 ch)._p1 frame with
      | C_Some'0 ff -> rel (C_Some ((index_logic self.t_ViewUpdate__0 ch)._p0)) ff
      | C_None'0 -> false
      end))
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant] invariant' x)
   -> ([%#sinvariant'0] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_Frag) : t_View
   =
    [%#sview'5] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'1] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'2] frag (new auth'0 frag'0) = frag'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ViewUpdate
  
  constant from  : t_View
  
  constant ch  : t_Choice
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 253 4 253 57] (self'0: t_ViewUpdate) (from'0: t_View) (ch'0: t_Choice) : t_View
  
  
  goal vc_update: ([%#sview] premise self from)
   -> ([@expl:new requires] [%#sview'0] rel (C_Some ((index_logic self.t_ViewUpdate__0 ch)._p0)) (index_logic self.t_ViewUpdate__0 ch)._p1)
end
module M_creusot_contracts__logic__ra__view__qyi5759646997670148869__frame_preserving [#"../../creusot-contracts/src/logic/ra/view.rs" 261 4 261 70] (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 258 15 258 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 259 15 259 37
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 260 14 260 57
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 252 15 252 33
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 262 18 262 62
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 262 8 262 63
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 235 12 246 21
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 254 8 254 51
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'24 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'25 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'24] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'22] rel a f)  -> ([%#sview'23] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'19] rel a f1)
   -> ([%#sview'20] incl f2 f1)  -> ([%#sview'21] rel a f2)
  
  type tuple  =
    { _p0: t_Auth; _p1: t_Frag }
  
  type t_ViewUpdate  =
    { t_ViewUpdate__0: Map.map t_Choice tuple }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'25] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'8] (view self.t_View__0).t_InnerView__auth
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice tuple) (a: t_Choice) : tuple
  
   =
    [%#smapping] Map.get self a
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'10] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'9] rel (auth self) (frag self)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 233 4 233 43] (self: t_ViewUpdate) (from: t_View) =
    [%#sview'5] auth from <> C_None
    /\ (forall ch: t_Choice. rel (C_Some ((index_logic self.t_ViewUpdate__0 ch)._p0)) (index_logic self.t_ViewUpdate__0 ch)._p1)
    /\ (forall frame: t_Frag. match op (frag from) frame with
      | C_Some'0 ff -> rel (auth from) ff
      | C_None'0 -> false
      end
     -> (exists ch: t_Choice. match op (index_logic self.t_ViewUpdate__0 ch)._p1 frame with
      | C_Some'0 ff -> rel (C_Some ((index_logic self.t_ViewUpdate__0 ch)._p0)) ff
      | C_None'0 -> false
      end))
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_View
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_View t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  type tuple'1  =
    { _p0'1: t_Option; _p1'1: t_Option; _p2: t_Option }
  
  type tuple'2  =
    { _p0'2: t_Option; _p1'2: t_Option }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_Frag) : t_View
   =
    [%#sview'18] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'15] rel auth'0 frag'0)
   -> ([%#sview'16] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'15] rel auth'0 frag'0)
   -> ([%#sview'17] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option'1
  
   =
    [%#sview'6] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'2 = auth self; _p1'2 = auth other } with
        | {_p0'2 = C_None ; _p1'2 = a} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | {_p0'2 = a ; _p1'2 = C_None} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | _ -> C_None'1
        end
      | C_None'0 -> C_None'1
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'14] let _ = match { _p0'0 = op (frag a) (frag b); _p1'0 = op (frag b) (frag c) } with
      | {_p0'0 = C_Some'0 fab ; _p1'0 = C_Some'0 fbc} -> match { _p0'0 = op fab (frag c); _p1'0 = op (frag a) fbc } with
        | {_p0'0 = C_Some'0 fabc1 ; _p1'0 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'1 = auth a;
                                                                                                   _p1'1 = auth b;
                                                                                                   _p2 = auth c } with
          | {_p0'1 = C_Some _ ; _p1'1 = C_None ; _p2 = C_None} | {_p0'1 = C_None ; _p1'1 = C_Some _ ; _p2 = C_None} | {_p0'1 = C_None ; _p1'1 = C_None ; _p2 = C_Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'13] and_then_logic'0 (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'12] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'11] op'0 a b = op'0 b a
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 253 4 253 57] (self: t_ViewUpdate) (from: t_View) (ch: t_Choice) : t_View
  
   =
    [%#sview'7] new (C_Some ((index_logic self.t_ViewUpdate__0 ch)._p0)) (index_logic self.t_ViewUpdate__0 ch)._p1
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice bool) (a: t_Choice)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. ([%#sutil] exists x: t_Choice. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ViewUpdate
  
  constant from  : t_View
  
  constant frame  : t_View
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/view.rs" 261 4 261 70] (self'0: t_ViewUpdate) (from'0: t_View) (frame'0: t_View) : t_Choice
  
  
  goal vc_frame_preserving: ([%#sview] premise self from)
   -> ([%#sview'0] op'0 from frame <> C_None'1)
   -> (forall ch: t_Choice. [@expl:update requires] [%#sview'2] premise self from)
  /\ ([@expl:such_that requires] [%#sutil] exists x: t_Choice. index_logic'0 ([%#sview'3] fun (ch: t_Choice) -> op'0 (update self from ch) frame
  <> C_None'1) x)
  /\ (([%#sutil'0] index_logic'0 ([%#sview'3] fun (ch: t_Choice) -> op'0 (update self from ch) frame
  <> C_None'1) (such_that ([%#sview'3] fun (ch: t_Choice) -> op'0 (update self from ch) frame <> C_None'1)))
   -> ([@expl:frame_preserving ensures] [%#sview'1] op'0 (update self from (such_that ([%#sview'3] fun (ch: t_Choice) -> op'0 (update self from ch) frame
  <> C_None'1))) frame
  <> C_None'1))
end
module M_creusot_contracts__logic__ra__view__qyi7400797033094478444__update [#"../../creusot-contracts/src/logic/ra/view.rs" 288 4 288 52] (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 286 15 286 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 287 14 287 44
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 289 8 289 41
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 275 12 280 17
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'15] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'13] rel a f)  -> ([%#sview'14] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'10] rel a f1)
   -> ([%#sview'11] incl f2 f1)  -> ([%#sview'12] rel a f2)
  
  type t_ViewUpdateInsert  =
    { t_ViewUpdateInsert__0: t_Auth; t_ViewUpdateInsert__1: t_Frag }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'16] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'7] (view self.t_View__0).t_InnerView__auth
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 273 4 273 43] (self: t_ViewUpdateInsert) (from: t_View)
  
   =
    [%#sview'5] auth from <> C_None
    /\ (forall f: t_Frag. rel (auth from) f
     -> match op self.t_ViewUpdateInsert__1 f with
      | C_Some'0 ff -> rel (C_Some (self.t_ViewUpdateInsert__0)) ff
      | C_None'0 -> false
      end)
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'9] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'8] rel (auth self) (frag self)
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant] invariant' x)
   -> ([%#sinvariant'0] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_Frag) : t_View
   =
    [%#sview'6] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'1] rel auth'0 frag'0)
   -> ([%#sview'2] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'1] rel auth'0 frag'0)
   -> ([%#sview'3] frag (new auth'0 frag'0) = frag'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ViewUpdateInsert
  
  constant from  : t_View
  
  constant _2  : ()
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 288 4 288 52] (self'0: t_ViewUpdateInsert) (from'0: t_View) (_2'0: ()) : t_View
  
  
  goal vc_update: ([%#sview] premise self from)
   -> ([@expl:new requires] [%#sview'1] rel (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1)
  /\ (([%#sview'2] auth (new (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1)
  = C_Some (self.t_ViewUpdateInsert__0))
  && ([%#sview'3] frag (new (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1)
  = self.t_ViewUpdateInsert__1)
   -> ([@expl:update ensures] [%#sview'0] rel (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1))
end
module M_creusot_contracts__logic__ra__view__qyi7400797033094478444__frame_preserving [#"../../creusot-contracts/src/logic/ra/view.rs" 296 4 296 60] (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 293 15 293 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 294 15 294 37
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 295 14 295 57
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 297 8 297 53
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 275 12 280 17
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 286 15 286 33
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 287 14 287 44
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 289 8 289 41
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'24 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'25 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'24] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'22] rel a f)  -> ([%#sview'23] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'19] rel a f1)
   -> ([%#sview'20] incl f2 f1)  -> ([%#sview'21] rel a f2)
  
  type t_ViewUpdateInsert  =
    { t_ViewUpdateInsert__0: t_Auth; t_ViewUpdateInsert__1: t_Frag }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'25] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'8] (view self.t_View__0).t_InnerView__auth
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 273 4 273 43] (self: t_ViewUpdateInsert) (from: t_View)
  
   =
    [%#sview'3] auth from <> C_None
    /\ (forall f: t_Frag. rel (auth from) f
     -> match op self.t_ViewUpdateInsert__1 f with
      | C_Some'0 ff -> rel (C_Some (self.t_ViewUpdateInsert__0)) ff
      | C_None'0 -> false
      end)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_View
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_View t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'14] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'13] rel (auth self) (frag self)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option; _p2: t_Option }
  
  type tuple'1  =
    { _p0'1: t_Option; _p1'1: t_Option }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_Frag) : t_View
   =
    [%#sview'18] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'15] rel auth'0 frag'0)
   -> ([%#sview'16] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'15] rel auth'0 frag'0)
   -> ([%#sview'17] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option'1
  
   =
    [%#sview'4] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None ; _p1'1 = a} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | {_p0'1 = a ; _p1'1 = C_None} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | _ -> C_None'1
        end
      | C_None'0 -> C_None'1
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'12] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some _ ; _p1'0 = C_None ; _p2 = C_None} | {_p0'0 = C_None ; _p1'0 = C_Some _ ; _p2 = C_None} | {_p0'0 = C_None ; _p1'0 = C_None ; _p2 = C_Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'11] and_then_logic'0 (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'10] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'9] op'0 a b = op'0 b a
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 288 4 288 52] (self: t_ViewUpdateInsert) (from: t_View) (_2: ()) : t_View
  
   =
    [%#sview'7] new (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  axiom update_spec: forall self: t_ViewUpdateInsert, from: t_View, _2: (). ([%#sview'5] premise self from)
   -> ([%#sview'6] rel (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ViewUpdateInsert
  
  constant from  : t_View
  
  constant frame  : t_View
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/view.rs" 296 4 296 60] (self'0: t_ViewUpdateInsert) (from'0: t_View) (frame'0: t_View) : ()
  
  
  goal vc_frame_preserving: ([%#sview] premise self from)
   -> ([%#sview'0] op'0 from frame <> C_None'1)
   -> rel (C_Some (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  && (let _ = () in [@expl:frame_preserving ensures] [%#sview'1] op'0 (update self from ()) frame <> C_None'1)
end
module M_creusot_contracts__logic__ra__view__qyi5746217084655472194__update [#"../../creusot-contracts/src/logic/ra/view.rs" 324 4 324 52] (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 322 15 322 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 323 14 323 52
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 325 8 325 31
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 310 12 316 40
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 104 8 104 46
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'13] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'9] incl a b)
   -> ([%#sra'10] incl b c)  -> ([%#sra'11] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'8] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'7] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'6] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'4] op self other = C_Some'0 comb)
   -> ([%#sra'5] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'14] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'15] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'3] ()
  
  axiom unit_core_spec: [%#sra'2] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'1] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'0] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'12] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'10] rel a f)  -> ([%#sview'11] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'7] rel a f1)
   -> ([%#sview'8] incl f2 f1)  -> ([%#sview'9] rel a f2)
  
  type t_ViewUpdateRemove  =
    { t_ViewUpdateRemove__0: t_Auth }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'17] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'4] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'6] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'5] rel (auth self) (frag self)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 308 4 308 43] (self: t_ViewUpdateRemove) (from: t_View)
  
   =
    [%#sview'2] auth from <> C_None
    /\ (forall f: t_Frag. match op (frag from) f with
      | C_Some'0 ff -> rel (auth from) ff
      | C_None'0 -> false
      end  -> rel (C_Some (self.t_ViewUpdateRemove__0)) f)
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_Frag) : t_View
   =
    [%#sview'16] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'13] rel auth'0 frag'0)
   -> ([%#sview'14] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'13] rel auth'0 frag'0)
   -> ([%#sview'15] frag (new auth'0 frag'0) = frag'0)
  
  function new_auth [#"../../creusot-contracts/src/logic/ra/view.rs" 103 4 103 42] (auth'0: t_Auth) : t_View =
    [%#sview'3] new (C_Some auth'0) unit'
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ViewUpdateRemove
  
  constant from  : t_View
  
  constant _2  : ()
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 324 4 324 52] (self'0: t_ViewUpdateRemove) (from'0: t_View) (_2'0: ()) : t_View
  
  
  goal vc_update: ([%#sview] premise self from)
   -> ([@expl:update ensures] [%#sview'0] rel (C_Some (self.t_ViewUpdateRemove__0)) unit')
end
module M_creusot_contracts__logic__ra__view__qyi5746217084655472194__frame_preserving [#"../../creusot-contracts/src/logic/ra/view.rs" 332 4 332 60] (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 329 15 329 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 330 15 330 37
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 331 14 331 57
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 332 61 332 63
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 310 12 316 40
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 322 15 322 33
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 323 14 323 52
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 325 8 325 31
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 104 8 104 46
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'24 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'25 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'26 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'13] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'4] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'14] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'15] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'12] ()
  
  axiom unit_core_spec: [%#sra'11] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'10] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'9] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'25] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'23] rel a f)  -> ([%#sview'24] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'20] rel a f1)
   -> ([%#sview'21] incl f2 f1)  -> ([%#sview'22] rel a f2)
  
  type t_ViewUpdateRemove  =
    { t_ViewUpdateRemove__0: t_Auth }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'26] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'8] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'10] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'9] rel (auth self) (frag self)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 308 4 308 43] (self: t_ViewUpdateRemove) (from: t_View)
  
   =
    [%#sview'3] auth from <> C_None
    /\ (forall f: t_Frag. match op (frag from) f with
      | C_Some'0 ff -> rel (auth from) ff
      | C_None'0 -> false
      end  -> rel (C_Some (self.t_ViewUpdateRemove__0)) f)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_View
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_View t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option; _p2: t_Option }
  
  type tuple'1  =
    { _p0'1: t_Option; _p1'1: t_Option }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_Frag) : t_View
   =
    [%#sview'18] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'15] rel auth'0 frag'0)
   -> ([%#sview'16] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_Frag. ([%#sview'15] rel auth'0 frag'0)
   -> ([%#sview'17] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option'1
  
   =
    [%#sview'4] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None ; _p1'1 = a} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | {_p0'1 = a ; _p1'1 = C_None} -> if rel a f then C_Some'1 (new a f) else C_None'1
        | _ -> C_None'1
        end
      | C_None'0 -> C_None'1
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'14] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some _ ; _p1'0 = C_None ; _p2 = C_None} | {_p0'0 = C_None ; _p1'0 = C_Some _ ; _p2 = C_None} | {_p0'0 = C_None ; _p1'0 = C_None ; _p2 = C_Some _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'13] and_then_logic'0 (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'12] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'11] op'0 a b = op'0 b a
  
  function new_auth [#"../../creusot-contracts/src/logic/ra/view.rs" 103 4 103 42] (auth'0: t_Auth) : t_View =
    [%#sview'19] new (C_Some auth'0) unit'
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 324 4 324 52] (self: t_ViewUpdateRemove) (from: t_View) (_2: ()) : t_View
  
   =
    [%#sview'7] new_auth self.t_ViewUpdateRemove__0
  
  axiom update_spec: forall self: t_ViewUpdateRemove, from: t_View, _2: (). ([%#sview'5] premise self from)
   -> ([%#sview'6] rel (C_Some (self.t_ViewUpdateRemove__0)) unit')
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_ViewUpdateRemove
  
  constant from  : t_View
  
  constant frame  : t_View
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/view.rs" 332 4 332 60] (self'0: t_ViewUpdateRemove) (from'0: t_View) (frame'0: t_View) : ()
  
  
  goal vc_frame_preserving: ([%#sview] premise self from)
   -> ([%#sview'0] op'0 from frame <> C_None'1)
   -> ([@expl:frame_preserving ensures] [%#sview'1] op'0 (update self from ()) frame <> C_None'1)
end
module M_creusot_contracts__logic__ra__RA__incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  type t_Self
  
  type t_Option  =
    | C_None
    | C_Some t_Self
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Self) (other: t_Self) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. [%#sra'3] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Self) (other: t_Self) =
    [%#sra'2] factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Self
  
  constant other  : t_Self
  
  constant comb  : t_Self
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self'0: t_Self) (other'0: t_Self) (comb'0: t_Self) : ()
  
  
  goal vc_incl_op: ([%#sra] op self other = C_Some comb)  -> ([@expl:incl_op ensures] [%#sra'0] incl self comb)
end
module M_creusot_contracts__logic__ra__RA__incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_Self
  
  type t_Option  =
    | C_None
    | C_Some t_Self
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Self) (other: t_Self) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. [%#sra'5] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Self) (other: t_Self) =
    [%#sra'3] factor other self <> C_None
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Self t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  
  axiom associative_spec: forall a: t_Self, b: t_Self, c: t_Self. [%#sra'4] and_then_logic (op a b) (fun (ab: t_Self) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Self) -> op a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a  : t_Self
  
  constant b  : t_Self
  
  constant c  : t_Self
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a'0: t_Self) (b'0: t_Self) (c'0: t_Self) : ()
  
  
  goal vc_incl_transitive: ([%#sra] incl a b)
   -> ([%#sra'0] incl b c)  -> (let _ = () in [@expl:incl_transitive ensures] [%#sra'1] incl a c)
end
module M_creusot_contracts__logic__ra__UnitRA__incl_refl [#"../../creusot-contracts/src/logic/ra.rs" 176 4 176 18]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_Self
  
  type t_Option  =
    | C_None
    | C_Some t_Self
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Self t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Self) (other: t_Self) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. [%#sra'12] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Self) (other: t_Self) =
    [%#sra'2] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
   =
    [%#sra'11] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Self, b: t_Self, c: t_Self. ([%#sra'8] incl a b)
   -> ([%#sra'9] incl b c)  -> ([%#sra'10] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  
  axiom associative_spec: forall a: t_Self, b: t_Self, c: t_Self. [%#sra'7] and_then_logic (op a b) (fun (ab: t_Self) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Self) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_spec: forall a: t_Self, b: t_Self. [%#sra'6] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
   =
    [%#sra'5] ()
  
  axiom incl_op_spec: forall self: t_Self, other: t_Self, comb: t_Self. ([%#sra'3] op self other = C_Some comb)
   -> ([%#sra'4] incl self comb)
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Self
  
  axiom unit_spec: [%#sra'0] forall x: t_Self [op x unit']. op x unit' = C_Some x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function incl_refl [#"../../creusot-contracts/src/logic/ra.rs" 176 4 176 18]  : ()
  
  goal vc_incl_refl: ([%#sra'0] forall x: t_Self [op x unit']. op x unit' = C_Some x)
   -> (let _ = unit' in [@expl:incl_refl ensures] [%#sra] forall x: t_Self. incl x x)
end
module M_creusot_contracts__logic__ra__UnitRA__unit_core [#"../../creusot-contracts/src/logic/ra.rs" 182 4 182 18]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_Self
  
  type t_Option  =
    | C_None
    | C_Some t_Self
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Self t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Self) (other: t_Self) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. [%#sra'14] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Self) (other: t_Self) =
    [%#sra'13] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
   =
    [%#sra'12] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Self, b: t_Self, c: t_Self. ([%#sra'9] incl a b)
   -> ([%#sra'10] incl b c)  -> ([%#sra'11] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  
  axiom associative_spec: forall a: t_Self, b: t_Self, c: t_Self. [%#sra'8] and_then_logic (op a b) (fun (ab: t_Self) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Self) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_spec: forall a: t_Self, b: t_Self. [%#sra'7] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
   =
    [%#sra'6] ()
  
  axiom incl_op_spec: forall self: t_Self, other: t_Self, comb: t_Self. ([%#sra'4] op self other = C_Some comb)
   -> ([%#sra'5] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Self) : t_Self
  
  axiom core_total_spec: forall self: t_Self. [%#sra'1] op (core_total self) (core_total self)
  = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_Self. [%#sra'2] op (core_total self) self = C_Some self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Self
  
  axiom unit_spec: [%#sra'3] forall x: t_Self [op x unit']. op x unit' = C_Some x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_core [#"../../creusot-contracts/src/logic/ra.rs" 182 4 182 18]  : ()
  
  goal vc_unit_core: [@expl:unit_core ensures] [%#sra] core_total unit' = unit'
end
module M_creusot_contracts__logic__ra__UnitRA__core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 160 15 160 33
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 161 15 161 39
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 162 14 165 5
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_Self
  
  type t_Option  =
    | C_None
    | C_Some t_Self
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Self t_Option) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Self) (other: t_Self) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Self) (factor'0: t_Self) : t_Option
  
  axiom factor_spec: forall self: t_Self, factor'0: t_Self. [%#sra'16] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Self. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Self) (other: t_Self) =
    [%#sra'6] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
   =
    [%#sra'15] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Self, b: t_Self, c: t_Self. ([%#sra'12] incl a b)
   -> ([%#sra'13] incl b c)  -> ([%#sra'14] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  
  axiom associative_spec: forall a: t_Self, b: t_Self, c: t_Self. [%#sra'11] and_then_logic (op a b) (fun (ab: t_Self) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Self) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_spec: forall a: t_Self, b: t_Self. [%#sra'10] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
   =
    [%#sra'9] ()
  
  axiom incl_op_spec: forall self: t_Self, other: t_Self, comb: t_Self. ([%#sra'7] op self other = C_Some comb)
   -> ([%#sra'8] incl self comb)
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Self
  
  axiom unit_spec: [%#sra'1] forall x: t_Self [op x unit']. op x unit' = C_Some x
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_Self) : t_Option
  
  axiom core_spec: forall self: t_Self. [%#sra'5] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function core_is_maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 166 4 166 44] (self: t_Self) (i: t_Self) : ()
  
  
  axiom core_is_maximal_idemp_spec: forall self: t_Self, i: t_Self. ([%#sra'2] op i i = C_Some i)
   -> ([%#sra'3] op i self = C_Some self)
   -> ([%#sra'4] match core self with
    | C_Some c -> incl i c
    | C_None -> false
    end)
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Self bool) (a: t_Self)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_Self bool) : t_Self
  
  axiom such_that_spec: forall p: Map.map t_Self bool. ([%#sutil] exists x: t_Self. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_Self =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_Self) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Self
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self'0: t_Self) : t_Self
  
  goal vc_core_total: ([%#sra'1] forall x: t_Self [op x unit']. op x unit' = C_Some x)
   -> (([@expl:core_is_maximal_idemp requires #0] [%#sra'2] op unit' unit' = C_Some unit')
  && ([@expl:core_is_maximal_idemp requires #1] [%#sra'3] op unit' self = C_Some self))
  /\ (([%#sra'4] match core self with
    | C_Some c -> incl unit' c
    | C_None -> false
    end)
   -> (let _ = core_is_maximal_idemp self unit' in ([%#sra'5] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end)
   -> ([@expl:unwrap_logic requires] [%#soption] core self <> C_None)
  /\ (let result = unwrap_logic (core self) in ([@expl:core_total ensures #0] [%#sra] op result result = C_Some result)
  && ([@expl:core_total ensures #1] [%#sra'0] op result self = C_Some self))))
end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__flat_map [#"../../creusot-contracts/src/logic/seq.rs" 285 4 285 65] (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 284 14 284 24
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 286 8 290 9
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'1] Seq.([..]) self 1 (Seq.length self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Seq.seq t_T
  
  constant other  : Map.map t_T (Seq.seq t_U)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 285 4 285 65] (self'0: Seq.seq t_T) (other'0: Map.map t_T (Seq.seq t_U)) : Seq.seq t_U
  
  
  goal vc_flat_map: if Seq.length self = 0 then
    true
  else
    0 <= ([%#sseq] Seq.length self) /\ ([%#sseq] Seq.length (tail self)) < ([%#sseq] Seq.length self)

end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 381 4 381 28] (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 379 14 380 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 381 29 381 31
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 381 4 381 28]  : ()
  
  goal vc_concat_contains: [@expl:concat_contains ensures] [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains (Seq.(++) a b) x
  = contains a x
  \/ contains b x
end
module M_creusot_contracts__logic__seq__qyi16115490154402163220__flatten [#"../../creusot-contracts/src/logic/seq.rs" 388 4 388 34] (* logic::seq::Seq<logic::seq::Seq<T>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 387 14 387 24
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 389 8 393 9
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq (Seq.seq t_T)) : Seq.seq (Seq.seq t_T)
  
   =
    [%#sseq'1] Seq.([..]) self 1 (Seq.length self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : Seq.seq (Seq.seq t_T)
  
  function flatten [#"../../creusot-contracts/src/logic/seq.rs" 388 4 388 34] (self'0: Seq.seq (Seq.seq t_T)) : Seq.seq t_T
  
  
  goal vc_flatten: if Seq.length self = 0 then
    true
  else
    0 <= ([%#sseq] Seq.length self) /\ ([%#sseq] Seq.length (tail self)) < ([%#sseq] Seq.length self)

end
module M_creusot_contracts__logic__seq__flat_map_singleton [#"../../creusot-contracts/src/logic/seq.rs" 690 0 690 33]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 689 10 689 87
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 690 34 690 36
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 284 14 284 24
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 286 8 290 9
  let%span sseq'3 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  
  use seq.Seq
  use map.Map
  
  type t_A
  
  type t_B
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq t_A) : Seq.seq t_A =
    [%#sseq'3] Seq.([..]) self 1 (Seq.length self)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 285 4 285 65] (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  
  axiom flat_map_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map self other
  = ([%#sseq'2] if Seq.length self = 0 then
    Seq.empty: Seq.seq t_B
  else
    Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
  )
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function flat_map_singleton [#"../../creusot-contracts/src/logic/seq.rs" 690 0 690 33]  : ()
  
  goal vc_flat_map_singleton: [@expl:flat_map_singleton ensures] [%#sseq] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.singleton x) f
  = Map.get f x
end
module M_creusot_contracts__logic__seq__flat_map_push_back [#"../../creusot-contracts/src/logic/seq.rs" 696 0 696 43]
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 694 10 694 108
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 695 10 695 18
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 699 24 699 85
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 697 4 700 5
  let%span sseq'3 = "../../creusot-contracts/src/logic/seq.rs" 284 14 284 24
  let%span sseq'4 = "../../creusot-contracts/src/logic/seq.rs" 286 8 290 9
  let%span sseq'5 = "../../creusot-contracts/src/logic/seq.rs" 162 8 162 39
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 161 4 161 29] (self: Seq.seq t_A) : Seq.seq t_A =
    [%#sseq'5] Seq.([..]) self 1 (Seq.length self)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 285 4 285 65] (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  
  axiom flat_map_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map self other
  = ([%#sseq'4] if Seq.length self = 0 then
    Seq.empty: Seq.seq t_B
  else
    Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
  )
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant xs  : Seq.seq t_A
  
  function flat_map_push_back [#"../../creusot-contracts/src/logic/seq.rs" 696 0 696 43] (xs'0: Seq.seq t_A) : ()
  
  goal vc_flat_map_push_back: if Seq.length xs > 0 then
    (0 <= ([%#sseq'0] Seq.length xs) /\ ([%#sseq'0] Seq.length (tail xs)) < ([%#sseq'0] Seq.length xs))
    /\ (([%#sseq] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc (tail xs) x) f
    = Seq.(++) (flat_map (tail xs) f) (Map.get f x))
     -> (let _ = flat_map_push_back (tail xs) in ([%#sseq'1] forall x: t_A. Seq.snoc (tail xs) x = tail (Seq.snoc xs x))
    && (let _ = () in [@expl:flat_map_push_back ensures] [%#sseq] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc xs x) f
    = Seq.(++) (flat_map xs f) (Map.get f x))))
  else
    [@expl:flat_map_push_back ensures] [%#sseq] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc xs x) f
    = Seq.(++) (flat_map xs f) (Map.get f x)

end
module M_creusot_contracts__pcell__qyi14846468513926953542__take [#"../../creusot-contracts/src/pcell.rs" 258 4 258 65] (* pcell::PCell<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 139 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 258 24 258 28
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 258 30 258 34
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 254 15 254 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 258 64 258 65
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 255 14 255 53
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 256 14 256 46
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 257 14 257 66
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 137 27 137 31
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 137 33 137 37
  let%span spcell'8 = "../../creusot-contracts/src/pcell.rs" 137 64 137 67
  let%span spcell'9 = "../../creusot-contracts/src/pcell.rs" 133 15 133 37
  let%span spcell'10 = "../../creusot-contracts/src/pcell.rs" 137 75 137 76
  let%span spcell'11 = "../../creusot-contracts/src/pcell.rs" 134 14 134 43
  let%span spcell'12 = "../../creusot-contracts/src/pcell.rs" 135 14 135 46
  let%span spcell'13 = "../../creusot-contracts/src/pcell.rs" 136 14 136 53
  let%span spcell'14 = "../../creusot-contracts/src/pcell.rs" 36 8 36 19
  let%span spcell'15 = "../../creusot-contracts/src/pcell.rs" 61 20 61 46
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: ())
  
  axiom precondition_fndef: [%#slib] forall args: () [precondition () args]. (let () = args in true)
   -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: ()) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_T }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_UnsafeCell)
  
  axiom inv_axiom [@rewrite]: forall x: t_UnsafeCell [inv'0 x]. inv'0 x
  = match x with
    | {t_UnsafeCell__value = value} -> inv value
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCell)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PCell [inv'1 x]. inv'1 x
  = match x with
    | {t_PCell__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_PCell) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCell)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PCell [inv'2 x]. inv'2 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_T [inv'3 x]. inv'3 x = invariant''0 x
  
  function val' [#"../../creusot-contracts/src/pcell.rs" 78 4 78 33] (self: t_PCellOwn) : t_T
  
  predicate invariant''1 [#"../../creusot-contracts/src/pcell.rs" 60 4 60 30] (self: t_PCellOwn) =
    [%#spcell'15] inv'3 (val' self)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCellOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PCellOwn [inv'4 x]. inv'4 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_PCellOwn) =
    [%#sinvariant'0] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_PCellOwn)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_PCellOwn [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  (MutBorrow.t t_PCellOwn)) =
    [%#sghost] inv'5 self
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  (MutBorrow.t t_PCellOwn))
  
  axiom inv_axiom'5 [@rewrite]: forall x:  (MutBorrow.t t_PCellOwn) [inv'6 x]. inv'6 x = invariant''3 x
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/pcell.rs" 219 4 219 25] (self: t_PCell) : t_Id
  
  function id'0 [#"../../creusot-contracts/src/pcell.rs" 71 4 71 25] (self: t_PCellOwn) : t_Id
  
  function view [#"../../creusot-contracts/src/pcell.rs" 35 4 35 33] (self: t_PCellOwn) : t_T =
    [%#spcell'14] val' self
  
  let rec replace (self:t_PCell) (perm: (MutBorrow.t t_PCellOwn)) (val''0:t_T) (return'  (x:t_T))= {[@expl:replace 'self' type invariant] [%#spcell'6] inv'2 self}
    {[@expl:replace 'perm' type invariant] [%#spcell'7] inv'6 perm}
    {[@expl:replace 'val' type invariant] [%#spcell'8] inv val''0}
    {[@expl:replace requires] [%#spcell'9] id self = id'0 perm.current}
    any
    [ return''0 (result:t_T)-> {[%#spcell'10] inv result}
      {[%#spcell'11] val''0 = view perm.final}
      {[%#spcell'12] result = view perm.current}
      {[%#spcell'13] id self = id'0 perm.final}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: (), res: t_T [postcondition () args res]. postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take[#"../../creusot-contracts/src/pcell.rs" 258 4 258 65] (self:t_PCell) (perm: (MutBorrow.t t_PCellOwn)) (return'  (x:t_T))= {[@expl:take 'self' type invariant] [%#spcell] inv'2 self}
    {[@expl:take 'perm' type invariant] [%#spcell'0] inv'6 perm}
    {[@expl:take requires] [%#spcell'1] id self = id'0 perm.current}
    (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_9 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = replace {self'0} {perm'0} {_9} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    )
    [ & _0: t_T = Any.any_l ()
    | & self'0: t_PCell = self
    | & perm'0:  (MutBorrow.t t_PCellOwn) = perm
    | & _9: t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:take result type invariant] [%#spcell'2] inv result}
      {[@expl:take ensures #0] [%#spcell'3] id self = id'0 perm.final}
      {[@expl:take ensures #1] [%#spcell'4] result = view perm.current}
      {[@expl:take ensures #2] [%#spcell'5] postcondition () () (view perm.final)}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18263836234684628832__clone [#"../../creusot-contracts/src/peano.rs" 34 9 34 14] (* <peano::PeanoInt as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span speano = "../../creusot-contracts/src/peano.rs" 37 20 37 27
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  let rec clone' (self_:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = self_} (! return' {result}) ]
  
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: UInt64.t) (result: UInt64.t)
  
   =
    let self_ = args in result = self_
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: UInt64.t) (result_state: ()) (result: UInt64.t)
  
   =
    let self_ = args in result = self_
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  
  axiom fn_mut_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: UInt64.t) (result: UInt64.t)
  
   =
    let self_ = args in result = self_
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  
  axiom fn_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''0[#"../../creusot-contracts/src/peano.rs" 34 9 34 14] (self:t_PeanoInt) (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- self'0.t_PeanoInt__0 ] s1
      | s1 = clone' {_5} (fun (_ret:UInt64.t) ->  [ &_3 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = _3 } ] s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0: t_PeanoInt = Any.any_l ()
    | & self'0: t_PeanoInt = self
    | & _3: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l () ]
    
    [ return''0 (result:t_PeanoInt)-> {[@expl:clone ensures] [%#speano] postcondition () self.t_PeanoInt__0 result.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi17635635094782400840__default [#"../../creusot-contracts/src/peano.rs" 34 22 34 29] (* <peano::PeanoInt as std::default::Default> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span snum = "../../creusot-contracts/src/std/num.rs" 30 26 30 41
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span speano = "../../creusot-contracts/src/peano.rs" 34 22 34 29
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec default (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = (0: UInt64.t)} (! return' {result}) ]
  
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: ()) (result: UInt64.t)
  
   =
    let () = args in result = (0: UInt64.t)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: ()) (result_state: ()) (result: UInt64.t)
  
   =
    let () = args in result = (0: UInt64.t)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: ()) (res: UInt64.t) : ()
  
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: UInt64.t. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: UInt64.t. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: ()) (result: UInt64.t)
  
   =
    let () = args in result = (0: UInt64.t)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: ()) (res: UInt64.t) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: UInt64.t. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: UInt64.t. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default'0[#"../../creusot-contracts/src/peano.rs" 34 22 34 29] (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:UInt64.t) ->  [ &_2 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = _2 } ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_PeanoInt = Any.any_l () | & _2: UInt64.t = Any.any_l () ] 
    [ return''0 (result:t_PeanoInt)-> {[@expl:default ensures] [%#speano] true
      /\ postcondition () () result.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi13288218011503588188__assert_receiver_is_total_eq [#"../../creusot-contracts/src/peano.rs" 34 31 34 33] (* <peano::PeanoInt as std::cmp::Eq> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq[#"../../creusot-contracts/src/peano.rs" 34 31 34 33] (self:t_PeanoInt) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () ]  [ return''0 (result:())-> (! return' {result}) ] 
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 54 4 54 12
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'6] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate le_log [#"../../creusot-contracts/src/peano.rs" 56 4 56 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano] UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  constant y  : t_PeanoInt
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: t_PeanoInt) (y'0: t_PeanoInt) : ()
  
  
  goal vc_cmp_le_log: [@expl:cmp_le_log ensures] [%#sord] le_log x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 59 4 59 12
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'6] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate lt_log [#"../../creusot-contracts/src/peano.rs" 61 4 61 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano] UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  constant y  : t_PeanoInt
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: t_PeanoInt) (y'0: t_PeanoInt) : ()
  
  
  goal vc_cmp_lt_log: [@expl:cmp_lt_log ensures] [%#sord] lt_log x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 64 4 64 12
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'6] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/peano.rs" 66 4 66 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano] UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  constant y  : t_PeanoInt
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: t_PeanoInt) (y'0: t_PeanoInt) : ()
  
  
  goal vc_cmp_ge_log: [@expl:cmp_ge_log ensures] [%#sord] ge_log x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 69 4 69 12
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'6] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate gt_log [#"../../creusot-contracts/src/peano.rs" 71 4 71 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano] UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  constant y  : t_PeanoInt
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: t_PeanoInt) (y'0: t_PeanoInt) : ()
  
  
  goal vc_cmp_gt_log: [@expl:cmp_gt_log ensures] [%#sord] gt_log x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'6] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: t_PeanoInt) : ()
  
  goal vc_refl: [@expl:refl ensures] [%#sord] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__peano__qyi5347411415401763779__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'3] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'16] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'14] cmp_log x y = C_Greater)
   -> ([%#sord'15] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'12] cmp_log x y = C_Less)
   -> ([%#sord'13] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'9] cmp_log x y = o)
   -> ([%#sord'10] cmp_log y z = o)  -> ([%#sord'11] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'8] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'7] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'6] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  constant y  : t_PeanoInt
  
  constant z  : t_PeanoInt
  
  constant o  : t_Ordering
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: t_PeanoInt) (y'0: t_PeanoInt) (z'0: t_PeanoInt) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log'0 x y = o)
   -> ([%#sord'0] cmp_log'0 y z = o)  -> ([@expl:trans ensures] [%#sord'1] cmp_log'0 x z = o)
end
module M_creusot_contracts__peano__qyi5347411415401763779__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'7] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'6] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  constant y  : t_PeanoInt
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: t_PeanoInt) (y'0: t_PeanoInt) : ()
  
  
  goal vc_antisym1: ([%#sord] cmp_log'0 x y = C_Less)
   -> ([@expl:antisym1 ensures] [%#sord'0] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'7] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'6] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  constant y  : t_PeanoInt
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: t_PeanoInt) (y'0: t_PeanoInt) : ()
  
  
  goal vc_antisym2: ([%#sord] cmp_log'0 x y = C_Greater)
   -> ([@expl:antisym2 ensures] [%#sord'0] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'6] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'5] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x  : t_PeanoInt
  
  constant y  : t_PeanoInt
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: t_PeanoInt) (y'0: t_PeanoInt) : ()
  
  goal vc_eq_cmp: [@expl:eq_cmp ensures] [%#sord] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__peano__qyi18300662544233371341__partial_cmp [#"../../creusot-contracts/src/peano.rs" 89 4 89 59] (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'17 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'18 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'19 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'20 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'21 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'22 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'23 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'24 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'25 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'26 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'27 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'28 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'29 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'30 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'31 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'32 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'33 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'34 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 88 14 88 53
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 95 14 95 47
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  let%span speano'2 = "../../creusot-contracts/src/peano.rs" 54 4 54 12
  let%span speano'3 = "../../creusot-contracts/src/peano.rs" 59 4 59 12
  let%span speano'4 = "../../creusot-contracts/src/peano.rs" 64 4 64 12
  let%span speano'5 = "../../creusot-contracts/src/peano.rs" 69 4 69 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'21] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'34] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'32] cmp_log x y = C_Greater)
   -> ([%#sord'33] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'30] cmp_log x y = C_Less)
   -> ([%#sord'31] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'27] cmp_log x y = o)
   -> ([%#sord'28] cmp_log y z = o)  -> ([%#sord'29] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'26] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'25] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'24] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'23] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'22] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'1] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'20] ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'19] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'18] ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ([%#sord'16] cmp_log'0 x y = C_Greater)
   -> ([%#sord'17] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'15] ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ([%#sord'13] cmp_log'0 x y = C_Less)
   -> ([%#sord'14] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : ()
  
   =
    [%#sord'12] ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. ([%#sord'9] cmp_log'0 x y = o)
   -> ([%#sord'10] cmp_log'0 y z = o)  -> ([%#sord'11] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: t_PeanoInt) : () =
    [%#sord'8] ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/peano.rs" 71 4 71 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'5] UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'6] ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'5] gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/peano.rs" 66 4 66 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'4] UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'4] ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'3] ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/peano.rs" 61 4 61 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'3] UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'2] ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'1] lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/peano.rs" 56 4 56 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'2] UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'0] ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord] le_log x y = (cmp_log'0 x y <> C_Greater)
  
  let rec cmp (self:t_PeanoInt) (other:t_PeanoInt) (return'  (x:t_Ordering))= any
    [ return''0 (result:t_Ordering)-> {[%#speano'0] result = cmp_log'0 self other} (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec partial_cmp[#"../../creusot-contracts/src/peano.rs" 89 4 89 59] (self:t_PeanoInt) (other:t_PeanoInt) (return'  (x:t_Option))= (! bb0
    [ bb0 = s0 [ s0 = cmp {self'0} {other'0} (fun (_ret:t_Ordering) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- C_Some _4 ] s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self'0: t_PeanoInt = self
    | & other'0: t_PeanoInt = other
    | & _4: t_Ordering = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:partial_cmp ensures] [%#speano] result = C_Some (cmp_log'0 self other)}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18409208157518949721__cmp [#"../../creusot-contracts/src/peano.rs" 96 4 96 43] (* <peano::PeanoInt as std::cmp::Ord> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 194 18 194 77
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'17 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'18 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'19 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'20 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'21 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'22 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'23 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'24 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'25 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'26 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'27 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'28 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'29 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'30 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'31 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'32 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'33 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'34 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'35 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'36 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'37 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'38 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'39 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'40 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'41 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'42 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'43 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'44 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'45 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'46 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'47 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'48 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  let%span speano = "../../creusot-contracts/src/peano.rs" 95 14 95 47
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 54 4 54 12
  let%span speano'2 = "../../creusot-contracts/src/peano.rs" 59 4 59 12
  let%span speano'3 = "../../creusot-contracts/src/peano.rs" 64 4 64 12
  let%span speano'4 = "../../creusot-contracts/src/peano.rs" 69 4 69 12
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: int) (y: int) : ()
  
  axiom eq_cmp_spec: forall x: int, y: int. [%#sord'35] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: int) (y: int) : ()
  
  axiom antisym2_spec: forall x: int, y: int. ([%#sord'33] cmp_log x y = C_Greater)
   -> ([%#sord'34] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: int) (y: int) : ()
  
  axiom antisym1_spec: forall x: int, y: int. ([%#sord'31] cmp_log x y = C_Less)
   -> ([%#sord'32] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'28] cmp_log x y = o)
   -> ([%#sord'29] cmp_log y z = o)  -> ([%#sord'30] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: int) : ()
  
  axiom refl_spec: forall x: int. [%#sord'27] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec: forall x: int, y: int. [%#sord'26] (x > y) = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec: forall x: int, y: int. [%#sord'25] (x >= y) = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec: forall x: int, y: int. [%#sord'24] (x < y) = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec: forall x: int, y: int. [%#sord'23] (x <= y) = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/std/num.rs" 23 12 23 52] (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Ordering))= any
    [ return''0 (result:t_Ordering)-> {[%#scmp] result = cmp_log (deep_model self_) (deep_model rhs)}
      (! return' {result}) ]
  
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'22] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec'0: forall x: UInt64.t, y: UInt64.t. [%#sord'48] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec'0: forall x: UInt64.t, y: UInt64.t. ([%#sord'46] cmp_log'0 x y = C_Greater)
   -> ([%#sord'47] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec'0: forall x: UInt64.t, y: UInt64.t. ([%#sord'44] cmp_log'0 x y = C_Less)
   -> ([%#sord'45] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'41] cmp_log'0 x y = o)
   -> ([%#sord'42] cmp_log'0 y z = o)  -> ([%#sord'43] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec'0: forall x: UInt64.t. [%#sord'40] cmp_log'0 x x = C_Equal
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec'0: forall x: UInt64.t, y: UInt64.t. [%#sord'39] UInt64.gt x y = (cmp_log'0 x y = C_Greater)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec'0: forall x: UInt64.t, y: UInt64.t. [%#sord'38] UInt64.ge x y = (cmp_log'0 x y <> C_Less)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec'0: forall x: UInt64.t, y: UInt64.t. [%#sord'37] UInt64.lt x y = (cmp_log'0 x y = C_Less)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec'0: forall x: UInt64.t, y: UInt64.t. [%#sord'36] UInt64.le x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log'0 self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'21] ()
  
  axiom eq_cmp_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'20] (x = y) = (cmp_log'1 x y = C_Equal)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'19] ()
  
  axiom antisym2_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. ([%#sord'17] cmp_log'1 x y = C_Greater)
   -> ([%#sord'18] cmp_log'1 y x = C_Less)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'16] ()
  
  axiom antisym1_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. ([%#sord'14] cmp_log'1 x y = C_Less)
   -> ([%#sord'15] cmp_log'1 y x = C_Greater)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : ()
  
   =
    [%#sord'13] ()
  
  axiom trans_spec'1: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. ([%#sord'10] cmp_log'1 x y = o)
   -> ([%#sord'11] cmp_log'1 y z = o)  -> ([%#sord'12] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: t_PeanoInt) : () =
    [%#sord'9] ()
  
  axiom refl_spec'1: forall x: t_PeanoInt. [%#sord'8] cmp_log'1 x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/peano.rs" 71 4 71 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'4] UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'7] ()
  
  axiom cmp_gt_log_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'6] gt_log x y = (cmp_log'1 x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/peano.rs" 66 4 66 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'3] UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'5] ()
  
  axiom cmp_ge_log_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'4] ge_log x y = (cmp_log'1 x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/peano.rs" 61 4 61 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'2] UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'3] ()
  
  axiom cmp_lt_log_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'2] lt_log x y = (cmp_log'1 x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/peano.rs" 56 4 56 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'1] UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'1] ()
  
  axiom cmp_le_log_spec'1: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'0] le_log x y = (cmp_log'1 x y <> C_Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec cmp'0[#"../../creusot-contracts/src/peano.rs" 96 4 96 43] (self:t_PeanoInt) (other:t_PeanoInt) (return'  (x:t_Ordering))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- other'0.t_PeanoInt__0 ] s1
      | s1 = cmp {self'0.t_PeanoInt__0} {_6} (fun (_ret:t_Ordering) ->  [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = return''0 {_0} ]
    )
    [ & _0: t_Ordering = Any.any_l ()
    | & self'0: t_PeanoInt = self
    | & other'0: t_PeanoInt = other
    | & _6: UInt64.t = Any.any_l () ]
    
    [ return''0 (result:t_Ordering)-> {[@expl:cmp ensures] [%#speano] result = cmp_log'1 self other}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi14634619887680291373__eq [#"../../creusot-contracts/src/peano.rs" 103 4 103 38] (* <peano::PeanoInt as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 102 14 102 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq[#"../../creusot-contracts/src/peano.rs" 103 4 103 38] (self:t_PeanoInt) (other:t_PeanoInt) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0.t_PeanoInt__0 = other'0.t_PeanoInt__0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: bool = Any.any_l () | & self'0: t_PeanoInt = self | & other'0: t_PeanoInt = other ] 
    [ return''0 (result:bool)-> {[@expl:eq ensures] [%#speano] result = (self = other)} (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__new [#"../../creusot-contracts/src/peano.rs" 112 4 112 24] (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 113 13 113 14
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 111 14 111 30
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new[#"../../creusot-contracts/src/peano.rs" 112 4 112 24] (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = ([%#speano] (0: UInt64.t)) } ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_PeanoInt = Any.any_l () ] 
    [ return''0 (result:t_PeanoInt)-> {[@expl:new ensures] [%#speano'0] result.t_PeanoInt__0 = (0: UInt64.t)}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u64 [#"../../creusot-contracts/src/peano.rs" 143 4 143 30] (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 142 14 142 30
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_u64[#"../../creusot-contracts/src/peano.rs" 143 4 143 30] (self:t_PeanoInt) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0.t_PeanoInt__0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & self'0: t_PeanoInt = self ] 
    [ return''0 (result:UInt64.t)-> {[@expl:to_u64 ensures] [%#speano] result = self.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u128 [#"../../creusot-contracts/src/peano.rs" 158 4 158 32] (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 157 14 157 32
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_u128[#"../../creusot-contracts/src/peano.rs" 158 4 158 32] (self:t_PeanoInt) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt128.of_int {UInt64.t'int self'0.t_PeanoInt__0} (fun (_ret_from:UInt128.t) ->  [ &_0 <- _ret_from ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt128.t = Any.any_l () | & self'0: t_PeanoInt = self ] 
    [ return''0 (result:UInt128.t)-> {[@expl:to_u128 ensures] [%#speano] UInt128.t'int result
      = UInt64.t'int self.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_i128 [#"../../creusot-contracts/src/peano.rs" 165 4 165 32] (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 164 14 164 32
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_i128[#"../../creusot-contracts/src/peano.rs" 165 4 165 32] (self:t_PeanoInt) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int128.of_int {UInt64.t'int self'0.t_PeanoInt__0} (fun (_ret_from:Int128.t) ->  [ &_0 <- _ret_from ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int128.t = Any.any_l () | & self'0: t_PeanoInt = self ] 
    [ return''0 (result:Int128.t)-> {[@expl:to_i128 ensures] [%#speano] Int128.to_int result
      = UInt64.t'int self.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi924939193479538090__from [#"../../creusot-contracts/src/peano.rs" 173 4 173 34] (* <u64 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 172 14 172 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 142 14 142 30
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  let rec to_u64 (self:t_PeanoInt) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#speano'0] result = self.t_PeanoInt__0} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 173 4 173 34] (val':t_PeanoInt) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 = to_u64 {val''0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: UInt64.t = Any.any_l () | & val''0: t_PeanoInt = val' ] 
    [ return''0 (result:UInt64.t)-> {[@expl:from ensures] [%#speano] result = val'.t_PeanoInt__0} (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18279771819627139730__from [#"../../creusot-contracts/src/peano.rs" 181 4 181 34] (* <i64 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 180 14 180 31
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 150 14 150 32
  
  use creusot.int.Int64
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  let rec to_i64 (self:t_PeanoInt) (return'  (x:Int64.t))= any
    [ return''0 (result:Int64.t)-> {[%#speano'0] Int64.to_int result = UInt64.t'int self.t_PeanoInt__0}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 181 4 181 34] (val':t_PeanoInt) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0 [ s0 = to_i64 {val''0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ]  | bb1 = return''0 {_0} ]
    ) [ & _0: Int64.t = Any.any_l () | & val''0: t_PeanoInt = val' ] 
    [ return''0 (result:Int64.t)-> {[@expl:from ensures] [%#speano] Int64.to_int result
      = UInt64.t'int val'.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi6128796959392123454__from [#"../../creusot-contracts/src/peano.rs" 189 4 189 34] (* <u128 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 188 14 188 31
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 157 14 157 32
  
  use creusot.int.UInt128
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  let rec to_u128 (self:t_PeanoInt) (return'  (x:UInt128.t))= any
    [ return''0 (result:UInt128.t)-> {[%#speano'0] UInt128.t'int result = UInt64.t'int self.t_PeanoInt__0}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 189 4 189 34] (val':t_PeanoInt) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0 [ s0 = to_u128 {val''0} (fun (_ret:UInt128.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: UInt128.t = Any.any_l () | & val''0: t_PeanoInt = val' ] 
    [ return''0 (result:UInt128.t)-> {[@expl:from ensures] [%#speano] UInt128.t'int result
      = UInt64.t'int val'.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi11594489632978387465__from [#"../../creusot-contracts/src/peano.rs" 197 4 197 34] (* <i128 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span speano = "../../creusot-contracts/src/peano.rs" 196 14 196 31
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 164 14 164 32
  
  use creusot.int.Int128
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  let rec to_i128 (self:t_PeanoInt) (return'  (x:Int128.t))= any
    [ return''0 (result:Int128.t)-> {[%#speano'0] Int128.to_int result = UInt64.t'int self.t_PeanoInt__0}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 197 4 197 34] (val':t_PeanoInt) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0 [ s0 = to_i128 {val''0} (fun (_ret:Int128.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: Int128.t = Any.any_l () | & val''0: t_PeanoInt = val' ] 
    [ return''0 (result:Int128.t)-> {[@expl:from ensures] [%#speano] Int128.to_int result
      = UInt64.t'int val'.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__new [#"../../creusot-contracts/src/ptr_own.rs" 55 4 55 53] (* ptr_own::PtrOwn<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 55 15 55 16
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 55 24 55 53
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 54 14 54 64
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 64 20 64 23
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 64 36 64 65
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 63 14 63 67
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 33 8 33 16
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 37 4 37 12
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 47 8 47 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_T }
  
  type tuple  =
    { _p0: Opaque.ptr; _p1:  t_PtrOwn }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self: Opaque.ptr) : UInt64.t
  
  predicate is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self: Opaque.ptr) =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr [#"../../creusot-contracts/src/ptr_own.rs" 32 4 32 33] (self: t_PtrOwn) : Opaque.ptr =
    [%#sptr_own'5] self.t_PtrOwn__ptr
  
  predicate invariant''0 [#"../../creusot-contracts/src/ptr_own.rs" 46 4 46 30] (self: t_PtrOwn) =
    [%#sptr_own'7] not is_null_logic (ptr self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'0 val'
    end)
  
  predicate invariant''1 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_PtrOwn) =
    [%#sghost] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x:  t_PtrOwn [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple [inv'3 x]. inv'3 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'2 x1)
  
  function val' [#"../../creusot-contracts/src/ptr_own.rs" 38 4 38 33] (self: t_PtrOwn) : t_T =
    [%#sptr_own'6] self.t_PtrOwn__val
  
  let rec from_box (val''0:t_T) (return'  (x:tuple))= {[@expl:from_box 'val' type invariant] [%#sptr_own'2] inv'0 val''0}
    any
    [ return''0 (result:tuple)-> {[%#sptr_own'3] inv'3 result}
      {[%#sptr_own'4] ptr result._p1 = result._p0 /\ val' result._p1 = val''0}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new[#"../../creusot-contracts/src/ptr_own.rs" 55 4 55 53] (v:t_T) (return'  (x:tuple))= {[@expl:new 'v' type invariant] [%#sptr_own] inv v}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = from_box {v'0} (fun (_ret:tuple) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = return''0 {_0} ]
    ) [ & _0: tuple = Any.any_l () | & v'0: t_T = v ] 
    [ return''0 (result:tuple)-> {[@expl:new result type invariant] [%#sptr_own'0] inv'3 result}
      {[@expl:new ensures] [%#sptr_own'1] ptr result._p1 = result._p0 /\ val' result._p1 = v}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__drop [#"../../creusot-contracts/src/ptr_own.rs" 129 4 129 61] (* ptr_own::PtrOwn<T> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 62 8 62 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 129 39 129 42
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 128 15 128 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 116 41 116 44
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 113 15 113 31
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 116 67 116 73
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 114 14 114 35
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 33 8 33 16
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 37 4 37 12
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 47 8 47 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_T }
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self: Opaque.ptr) : UInt64.t
  
  predicate is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self: Opaque.ptr) =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr [#"../../creusot-contracts/src/ptr_own.rs" 32 4 32 33] (self: t_PtrOwn) : Opaque.ptr =
    [%#sptr_own'5] self.t_PtrOwn__ptr
  
  predicate invariant' [#"../../creusot-contracts/src/ptr_own.rs" 46 4 46 30] (self: t_PtrOwn) =
    [%#sptr_own'7] not is_null_logic (ptr self)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'0 val'
    end)
  
  predicate invariant''1 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_PtrOwn) =
    [%#sghost] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x:  t_PtrOwn [inv'2 x]. inv'2 x = invariant''1 x
  
  function val' [#"../../creusot-contracts/src/ptr_own.rs" 38 4 38 33] (self: t_PtrOwn) : t_T =
    [%#sptr_own'6] self.t_PtrOwn__val
  
  let rec to_box (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:t_T))= {[@expl:to_box 'own' type invariant] [%#sptr_own'1] inv'2 own}
    {[@expl:to_box requires] [%#sptr_own'2] ptr'0 = ptr own}
    any
    [ return''0 (result:t_T)-> {[%#sptr_own'3] inv'0 result} {[%#sptr_own'4] result = val' own} (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 28] (self: t_T) =
    [%#sresolve] resolve self
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T) =
    resolve'0 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec drop[#"../../creusot-contracts/src/ptr_own.rs" 129 4 129 61] (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:()))= {[@expl:drop 'own' type invariant] [%#sptr_own] inv'2 own}
    {[@expl:drop requires] [%#sptr_own'0] ptr'0 = ptr own}
    (! bb0
    [ bb0 = s0 [ s0 = to_box {ptr'1} {own'0} (fun (_ret:t_T) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 _4} s1 | s1 = -{resolve'1 _4}- s2 | s2 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () | & ptr'1: Opaque.ptr = ptr'0 | & own'0:  t_PtrOwn = own | & _4: t_T = Any.any_l () ] 
    [ return''0 (result:())-> (! return' {result}) ]

end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 42 4 42 30] (* <(T1, T2) as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 40 15 40 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 41 14 41 28
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 42 31 42 33
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 36 8 36 42
  
  type t_T1
  
  type t_T2
  
  type tuple  =
    { _p0: t_T1; _p1: t_T2 }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T2)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T1)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: tuple) =
    let {_p0 = x0 ; _p1 = x1} = _0 in resolve x1 /\ resolve'0 x0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 35 4 35 28] (self: tuple) =
    [%#sresolve'2] resolve'0 self._p0 /\ resolve self._p1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : tuple
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 42 4 42 30] (self'0: tuple) : ()
  
  goal vc_resolve_coherence: ([%#sresolve] structural_resolve self)
   -> ([@expl:resolve_coherence ensures] [%#sresolve'0] resolve'1 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 55 4 55 30] (* <&mut T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 15 53 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 54 14 54 28
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 55 31 55 33
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: MutBorrow.t t_T) =
    _0.final = _0.current
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve'2] self.final = self.current
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : MutBorrow.t t_T
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 55 4 55 30] (self'0: MutBorrow.t t_T) : ()
  
  goal vc_resolve_coherence: ([%#sresolve] structural_resolve self)
   -> ([@expl:resolve_coherence ensures] [%#sresolve'0] resolve self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 68 4 68 30] (* <std::boxed::Box<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 66 15 66 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 67 14 67 28
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 68 31 68 33
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 62 8 62 22
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_T) =
    resolve _0
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 28] (self: t_T) =
    [%#sresolve'2] resolve self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_T
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 68 4 68 30] (self'0: t_T) : ()
  
  goal vc_resolve_coherence: ([%#sresolve] structural_resolve self)
   -> ([@expl:resolve_coherence ensures] [%#sresolve'0] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 84 4 84 30] (* <std::option::Option<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 82 15 82 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 83 14 83 28
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 84 31 84 33
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Option) =
    match _0 with
      | C_None -> true
      | C_Some x0 -> resolve x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve'2] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Option
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 84 4 84 30] (self'0: t_Option) : ()
  
  goal vc_resolve_coherence: ([%#sresolve] structural_resolve self)
   -> ([@expl:resolve_coherence ensures] [%#sresolve'0] resolve'0 self)
end
module M_creusot_contracts__resource__fmap_view__qyi505596245403307893__new [#"../../creusot-contracts/src/resource/fmap_view.rs" 80 4 80 31] (* resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 214 14 217 5
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'14 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'6 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 181 14 181 29
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 164 24 164 28
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 89 8 89 22
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 104 8 104 46
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 82 40 82 80
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 83 22 83 46
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 80 20 80 31
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 79 14 79 38
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 55 4 55 12
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 41 8 41 36
  let%span sresource = "../../creusot-contracts/src/resource.rs" 87 18 87 31
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'1
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option'0 =
    [%#sagree] if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'1] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'3] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'6] Map.get (view self) k
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'11] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)
   -> ([%#sfmap'12] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'7] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'10] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'9] op'1 a b = op'1 b a
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'5] len self >= 0
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 54 4 54 26]  : t_FMap
  
  axiom empty_spec: [%#sfmap] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'0] view empty = Const.const (C_None'0)
  
  constant unit': t_FMap = [%#sfmap'4] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'3] forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some x
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a: t_Option'0) (b: t_Option'0) : ()
  
  
  axiom commutative_spec'1: forall a: t_Option'0, b: t_Option'0. [%#soption'7] op'0 a b = op'0 b a
  
  function factor [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (self: t_Ag) (factor'0: t_Ag) : t_Option'0
  
   =
    [%#sagree'3] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'2] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Ag. op factor'0 c <> C_Some'0 self
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1
  
   =
    [%#soption'6] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'0} -> C_Some'1 x
      | {_p0 = C_None'0} -> C_None'1
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. [%#soption'5] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option'0) (other: t_Option'0) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom incl_transitive_spec: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
  
  axiom incl_op_spec: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. ([%#sra'0] op'0 self other
  = C_Some'1 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_Option'0) (a: tuple'0) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'0 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option'0. [%#sfmap'15] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (self: t_FMap) (factor'2: t_FMap) : t_Option
  
   =
    [%#sfmap'14] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in let _ = let _ = () in () in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'13] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some comb)
   -> ([%#sra'1] incl'0 self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_FMap) =
    [%#sauth] match a with
      | C_Some a'0 -> incl'0 f a'0
      | C_None -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sauth'4] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_FMap. [%#sauth'3] rel (C_None) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option) (f1: t_FMap) (f2: t_FMap) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_FMap, f2: t_FMap. ([%#sauth'0] rel a f1)
   -> ([%#sauth'1] incl'0 f2 f1)  -> ([%#sauth'2] rel a f2)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. [%#sview'3] rel (auth self) (frag self)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_FMap. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'1] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_FMap. ([%#sview'0] rel auth'0 frag'0)
   -> ([%#sview'2] frag (new auth'0 frag'0) = frag'0)
  
  function new_auth [#"../../creusot-contracts/src/logic/ra/view.rs" 103 4 103 42] (auth'0: t_FMap) : t_View =
    [%#sview] new (C_Some auth'0) unit'
  
  type t_Resource
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_View
  
  function view'0 [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_View =
    [%#sresource'0] val' self
  
  function view'1 [#"../../creusot-contracts/src/ghost.rs" 88 4 88 33] (self:  t_Resource) : t_View =
    [%#sghost'3] view'0 self
  
  let rec alloc (r:t_View) (return'  (x: t_Resource))= any
    [ return''0 (result: t_Resource)-> {[%#sresource] view'1 result = r} (! return' {result}) ]
  
  
  let rec into_inner (self: t_Resource) (return'  (x:t_Resource))= any
    [ return''0 (result:t_Resource)-> {[%#sghost] result = self} (! return' {result}) ]
  
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  predicate invariant' [#"../../creusot-contracts/src/resource/fmap_view.rs" 40 4 40 30] (self: t_Authority) =
    [%#sfmap_view'4] auth (view'0 self.t_Authority__0) <> C_None
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_Authority) =
    [%#sghost'4] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x:  t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  let rec new'0 (x:t_Authority) (return'  (x'0: t_Authority))= {[@expl:new 'x' type invariant] [%#sghost'0] inv x}
    any
    [ return''0 (result: t_Authority)-> {[%#sghost'1] inv'0 result} {[%#sghost'2] result = x} (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function view'2 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap'0) : Map.map t_K t_Option'2
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap'0) (k: t_K) : t_Option'2
  
   =
    [%#sfmap'6] Map.get (view'2 self) k
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self: t_FMap'0) (other: t_FMap'0) =
    [%#sfmap'2] let _ = () in forall k: t_K. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap'1] ext_eq self other = (self = other)
  
  function index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function map [#"../../creusot-contracts/src/logic/fmap.rs" 218 4 220 17] (self: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap'0
  
  
  axiom map_spec: forall self: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'8] forall k: t_K [get'0 (map self f) k]. get'0 (map self f) k
  = match get self k with
    | C_None'0 -> C_None'2
    | C_Some'0 v -> C_Some'2 (index_logic'0 f { _p0'0 = k; _p1'0 = v })
    end
  
  predicate index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_FMap bool) (a: t_FMap)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. ([%#sutil] exists x: t_FMap. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_FMap =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_FMap) -> true)
      end
  
  function view'3 [#"../../creusot-contracts/src/resource/fmap_view.rs" 56 4 56 31] (self: t_Authority) : t_FMap'0 =
    [%#sfmap_view'3] map (unwrap_logic (auth (view'0 self.t_Authority__0))) (fun (__0: tuple'0) -> let {_p1'0 = x} = __0 in x.t_Ag__0)
  
  function view'4 [#"../../creusot-contracts/src/ghost.rs" 88 4 88 33] (self:  t_Authority) : t_FMap'0 =
    [%#sghost'3] view'3 self
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'5] len'0 self >= 0
  
  constant empty'0 [#"../../creusot-contracts/src/logic/fmap.rs" 54 4 54 26]  : t_FMap'0
  
  axiom empty_spec'1: [%#sfmap] len'0 empty'0 = 0
  
  axiom empty_spec'2: [%#sfmap'0] view'2 empty'0 = Const.const (C_None'2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'1[#"../../creusot-contracts/src/resource/fmap_view.rs" 80 4 80 31] (return'  (x: t_Authority))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_6 <- [%#sfmap_view] new_auth empty ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = alloc {_6} (fun (_ret: t_Resource) ->  [ &_5 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = into_inner {_5} (fun (_ret:t_Resource) ->  [ &_4 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 =  [ &_3 <- { t_Authority__0 = _4 } ] s1
      | s1 = new'0 {_3} (fun (_ret: t_Authority) ->  [ &r <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#sfmap_view'0] ext_eq (view'4 r) empty'0} s1
      | s1 =  [ &_0 <- r ] s2
      | s2 = return''0 {_0} ]
     ]
    )
    [ & _0:  t_Authority = Any.any_l ()
    | & r:  t_Authority = Any.any_l ()
    | & _3: t_Authority = Any.any_l ()
    | & _4: t_Resource = Any.any_l ()
    | & _5:  t_Resource = Any.any_l ()
    | & _6: t_View = Any.any_l () ]
    
    [ return''0 (result: t_Authority)-> {[@expl:new result type invariant] [%#sfmap_view'1] inv'0 result}
      {[@expl:new ensures] [%#sfmap_view'2] view'4 result = empty'0}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__fmap_view__qyi505596245403307893__insert [#"../../creusot-contracts/src/resource/fmap_view.rs" 96 4 96 78] (* resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 186 14 186 39
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 189 12 189 35
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 214 14 217 5
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 132 8 132 38
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 138 8 138 80
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'14 = "../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'15 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'16 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'17 = "../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'18 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'19 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'20 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'21 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'22 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'23 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 38 14 41 5
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 43 8 43 18
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sagree'4 = "../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'5 = "../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 59 8 62 9
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 67 15 67 33
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 69 8 69 82
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 73 8 73 82
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'7 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'8 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 182 14 185 5
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 187 8 187 31
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 97 16 97 32
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 98 58 98 75
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 99 22 99 53
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 23 96 27
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 89 15 89 34
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 96 64 96 78
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 90 14 90 46
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 91 14 91 39
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 92 14 92 33
  let%span sfmap_view'8 = "../../creusot-contracts/src/resource/fmap_view.rs" 93 14 93 38
  let%span sfmap_view'9 = "../../creusot-contracts/src/resource/fmap_view.rs" 55 4 55 12
  let%span sfmap_view'10 = "../../creusot-contracts/src/resource/fmap_view.rs" 72 4 72 12
  let%span sfmap_view'11 = "../../creusot-contracts/src/resource/fmap_view.rs" 66 8 66 26
  let%span sfmap_view'12 = "../../creusot-contracts/src/resource/fmap_view.rs" 115 4 115 12
  let%span sfmap_view'13 = "../../creusot-contracts/src/resource/fmap_view.rs" 47 20 47 68
  let%span sfmap_view'14 = "../../creusot-contracts/src/resource/fmap_view.rs" 41 8 41 36
  let%span sresource = "../../creusot-contracts/src/resource.rs" 235 19 235 37
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 236 18 236 43
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 237 18 237 56
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 107 19 107 39
  let%span sresource'3 = "../../creusot-contracts/src/resource.rs" 108 18 108 42
  let%span sresource'4 = "../../creusot-contracts/src/resource.rs" 109 18 109 47
  let%span sresource'5 = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  let%span ssnapshot = "../../creusot-contracts/src/snapshot.rs" 50 8 50 27
  
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_V
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_K
  
  type t_FMapInsertLocalUpdate  =
    { t_FMapInsertLocalUpdate__0: t_K; t_FMapInsertLocalUpdate__1: t_Ag }
  
  type t_AuthUpdate  =
    { t_AuthUpdate__0: t_FMapInsertLocalUpdate }
  
  type t_Resource
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'4] Map.get (view self) k
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/fmap.rs" 131 4 131 66] (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (_2: t_FMap)
  
   =
    [%#sfmap'7] get from_auth self.t_FMapInsertLocalUpdate__0 = C_None'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'1
  
   =
    [%#soption'6] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Ag t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option'0 =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some'0 self else C_None'0
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'5] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'19] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)
   -> ([%#sfmap'20] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'9] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'16] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'15] op'1 a b = op'1 b a
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'5] len self >= 0
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 54 4 54 26]  : t_FMap
  
  axiom empty_spec: [%#sfmap'22] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'23] view empty = Const.const (C_None'0)
  
  constant unit': t_FMap = [%#sfmap'14] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'13] forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some x
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a: t_Option'0) (b: t_Option'0) : ()
  
  
  axiom commutative_spec'1: forall a: t_Option'0, b: t_Option'0. [%#soption'7] op'0 a b = op'0 b a
  
  function factor [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (self: t_Ag) (factor'0: t_Ag) : t_Option'0
  
   =
    [%#sagree'5] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'4] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Ag. op factor'0 c <> C_Some'0 self
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1
  
   =
    [%#soption'4] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'0} -> C_Some'1 x
      | {_p0 = C_None'0} -> C_None'1
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. [%#soption'3] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option'0) (other: t_Option'0) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom incl_transitive_spec: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
  
  axiom incl_op_spec: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. ([%#sra'0] op'0 self other
  = C_Some'1 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_Option'0) (a: tuple'0) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'0 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option'0. [%#sfmap'21] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (self: t_FMap) (factor'2: t_FMap) : t_Option
  
   =
    [%#sfmap'18] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in let _ = let _ = () in () in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'17] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some comb)
   -> ([%#sra'1] incl'0 self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_FMap) =
    [%#sauth'3] match a with
      | C_Some a'0 -> incl'0 f a'0
      | C_None -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sauth'8] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_FMap. [%#sauth'7] rel (C_None) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option) (f1: t_FMap) (f2: t_FMap) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_FMap, f2: t_FMap. ([%#sauth'4] rel a f1)
   -> ([%#sauth'5] incl'0 f2 f1)  -> ([%#sauth'6] rel a f2)
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. [%#sview'1] rel (auth self) (frag self)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 58 4 58 43] (self: t_AuthUpdate) (from: t_View) =
    [%#sauth] match auth from with
      | C_Some auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None -> false
      end
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_View
  
  function view'0 [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_View =
    [%#sresource'5] val' self
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Resource) : t_View =
    [%#smodel] view'0 self.current
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 59 8 59 29] (self: t_Resource) : t_Id
  
  type tuple'1  =
    { _p0'1: t_FMap; _p1'1: t_FMap }
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 115 4 115 39] (self: t_FMap) (k: t_K)
  
   =
    [%#sfmap'3] get self k <> C_None'0
  
  function insert [#"../../creusot-contracts/src/logic/fmap.rs" 71 4 71 43] (self: t_FMap) (k: t_K) (v: t_Ag) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_Ag. [%#sfmap'1] view (insert self k v)
  = Map.set (view self) k (C_Some'0 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_Ag. [%#sfmap'2] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  function update [#"../../creusot-contracts/src/logic/ra/fmap.rs" 137 4 137 93] (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (from_frag: t_FMap) : tuple'1
  
   =
    [%#sfmap'8] { _p0'1 = insert from_auth self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1;
                  _p1'1 = insert from_frag self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1 }
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_FMap bool) (a: t_FMap)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. ([%#sutil] exists x: t_FMap. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_FMap =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_FMap) -> true)
      end
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option) (frag'0: t_FMap) : t_View
  
  axiom new_spec: forall auth'0: t_Option, frag'0: t_FMap. ([%#sview'2] rel auth'0 frag'0)
   -> ([%#sview'3] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option, frag'0: t_FMap. ([%#sview'2] rel auth'0 frag'0)
   -> ([%#sview'4] frag (new auth'0 frag'0) = frag'0)
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 72 4 72 52] (self: t_AuthUpdate) (from: t_View) (_2: ()) : t_View
  
   =
    [%#sauth'2] let {_p0'1 = auth'0 ; _p1'1 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in let _ = () in new (C_Some auth'0) frag'0
  
  axiom update_spec: forall self: t_AuthUpdate, from: t_View, _2: (). ([%#sauth'0] premise'0 self from)
   -> ([%#sauth'1] let {_p0'1 = auth'0 ; _p1'1 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in rel (C_Some auth'0) frag'0)
  
  let rec update'1 (self:MutBorrow.t t_Resource) (upd:t_AuthUpdate) (return'  (x:()))= {[@expl:update requires] [%#sresource] premise'0 upd (view'1 self)}
    any
    [ return''0 (result:())-> {[%#sresource'0] id self.final = id self.current}
      {[%#sresource'1] view'0 self.final = update'0 upd (view'1 self) result}
      (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function view'2 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap'0) : Map.map t_K t_Option'2
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap'0) (k: t_K) : t_Option'2
  
   =
    [%#sfmap'4] Map.get (view'2 self) k
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self: t_FMap'0) (other: t_FMap'0) =
    [%#sfmap'0] let _ = () in forall k: t_K. get'0 self k = get'0 other k
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap] ext_eq self other = (self = other)
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function map [#"../../creusot-contracts/src/logic/fmap.rs" 218 4 220 17] (self: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap'0
  
  
  axiom map_spec: forall self: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'6] forall k: t_K [get'0 (map self f) k]. get'0 (map self f) k
  = match get self k with
    | C_None'0 -> C_None'2
    | C_Some'0 v -> C_Some'2 (index_logic'1 f { _p0'0 = k; _p1'0 = v })
    end
  
  function view'3 [#"../../creusot-contracts/src/resource/fmap_view.rs" 56 4 56 31] (self: t_Authority) : t_FMap'0 =
    [%#sfmap_view'9] map (unwrap_logic (auth (view'0 self.t_Authority__0))) (fun (__0: tuple'0) -> let {_p1'0 = x} = __0 in x.t_Ag__0)
  
  function view'4 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Authority) : t_FMap'0 =
    [%#smodel] view'3 self.current
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'5] len'0 self >= 0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 115 4 115 39] (self: t_FMap'0) (k: t_K)
  
   =
    [%#sfmap'3] get'0 self k <> C_None'2
  
  function insert'0 [#"../../creusot-contracts/src/logic/fmap.rs" 71 4 71 43] (self: t_FMap'0) (k: t_K) (v: t_V) : t_FMap'0
  
  
  axiom insert_spec'1: forall self: t_FMap'0, k: t_K, v: t_V. [%#sfmap'1] view'2 (insert'0 self k v)
  = Map.set (view'2 self) k (C_Some'2 v)
  
  axiom insert_spec'2: forall self: t_FMap'0, k: t_K, v: t_V. [%#sfmap'2] len'0 (insert'0 self k v)
  = (if contains'0 self k then len'0 self else len'0 self + 1)
  
  function view'5 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Authority) : t_FMap'0 =
    [%#smodel'0] view'3 self
  
  function view'6 [#"../../creusot-contracts/src/snapshot.rs" 49 4 49 33] (self: t_Authority) : t_FMap'0 =
    [%#ssnapshot] view'5 self
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_View
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'3) (f: Map.map t_View t_Option'3) : t_Option'3
  
   =
    [%#soption'1] match self with
      | C_None'3 -> C_None'3
      | C_Some'3 x -> Map.get f x
      end
  
  type tuple'2  =
    { _p0'2: t_Option; _p1'2: t_Option }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option'3
  
   =
    [%#sview'7] match op'1 (frag self) (frag other) with
      | C_Some f -> match { _p0'2 = auth self; _p1'2 = auth other } with
        | {_p0'2 = C_None ; _p1'2 = a} -> if rel a f then C_Some'3 (new a f) else C_None'3
        | {_p0'2 = a ; _p1'2 = C_None} -> if rel a f then C_Some'3 (new a f) else C_None'3
        | _ -> C_None'3
        end
      | C_None -> C_None'3
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'2: forall a: t_View, b: t_View, c: t_View. [%#sview'6] and_then_logic'2 (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
  = and_then_logic'2 (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'5] op'2 a b = op'2 b a
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_FMap) : t_View =
    [%#sview'12] new (C_None) frag'0
  
  function core [#"../../creusot-contracts/src/logic/ra/agree.rs" 42 4 42 33] (self: t_Ag) : t_Option'0 =
    [%#sagree'0] C_Some'0 self
  
  axiom core_spec: forall self: t_Ag. [%#sagree] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (self: t_FMap) : t_FMap =
    [%#sfmap'12] let r = filter_map self (fun (__0: tuple'0) -> let {_p1'0 = v} = __0 in core v) in let _ = let _ = () in () in let _ = let _ = () in () in r
  
  axiom core_total_spec: forall self: t_FMap. [%#sfmap'10] op'1 (core_total self) (core_total self)
  = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. [%#sfmap'11] op'1 (core_total self) self = C_Some self
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (self: t_View) : t_View =
    [%#sview'10] let _ = () in let _ = () in new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. [%#sview'8] op'2 (core_total'0 self) (core_total'0 self)
  = C_Some'3 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. [%#sview'9] op'2 (core_total'0 self) self = C_Some'3 self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (self: t_View) : t_Option'3 =
    [%#sview'0] C_Some'3 (core_total'0 self)
  
  axiom core_spec'0: forall self: t_View. [%#sview] match core'0 self with
    | C_Some'3 c -> op'2 c c = C_Some'3 c /\ op'2 c self = C_Some'3 self
    | C_None'3 -> true
    end
  
  function view'7 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Resource) : t_View =
    [%#smodel'0] view'0 self
  
  let rec core'1 (self:t_Resource) (return'  (x:t_Resource))= {[@expl:core requires] [%#sresource'2] core'0 (view'7 self)
    <> C_None'3}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'3] id result = id self}
      {[%#sresource'4] C_Some'3 (view'0 result) = core'0 (view'7 self)}
      (! return' {result}) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/resource/fmap_view.rs" 40 4 40 30] (self: t_Authority) =
    [%#sfmap_view'14] auth (view'0 self.t_Authority__0) <> C_None
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Authority) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Authority) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Authority) =
    resolve _0
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  predicate invariant''1 [#"../../creusot-contracts/src/resource/fmap_view.rs" 46 4 46 30] (self: t_Fragment) =
    [%#sfmap_view'13] get (frag (view'0 self.t_Fragment__0)) self.t_Fragment__1
    = C_Some'0 { t_Ag__0 = self.t_Fragment__2 }
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fragment)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x
  = (invariant''1 x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  function id'0 [#"../../creusot-contracts/src/resource/fmap_view.rs" 73 4 73 25] (self: t_Authority) : t_Id =
    [%#sfmap_view'10] id self.t_Authority__0
  
  type tuple'3  =
    { _p0'3: t_K; _p1'3: t_V }
  
  function view'8 [#"../../creusot-contracts/src/resource/fmap_view.rs" 65 4 65 27] (self: t_Fragment) : tuple'3 =
    [%#sfmap_view'11] { _p0'3 = self.t_Fragment__1; _p1'3 = self.t_Fragment__2 }
  
  function id'1 [#"../../creusot-contracts/src/resource/fmap_view.rs" 116 4 116 25] (self: t_Fragment) : t_Id =
    [%#sfmap_view'12] id self.t_Fragment__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert'1[#"../../creusot-contracts/src/resource/fmap_view.rs" 96 4 96 78] (self:MutBorrow.t t_Authority) (k:t_K) (v:t_V) (return'  (x:t_Fragment))= {[@expl:insert 'self' type invariant] [%#sfmap_view'2] inv'0 self}
    {[@expl:insert requires] [%#sfmap_view'3] not contains'0 (view'4 self) k}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &s <- [%#sfmap_view] self'0.current ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_16 <- [%#sfmap_view'0] { t_Ag__0 = v'0 } ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_14 <- { t_FMapInsertLocalUpdate__0 = k'0; t_FMapInsertLocalUpdate__1 = _16 } ] s1
      | s1 =  [ &_13 <- { t_AuthUpdate__0 = _14 } ] s2
      | s2 = MutBorrow.borrow_final
          <t_Resource>
          {(self'0.current).t_Authority__0}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_12 <- _ret ] 
             [ &self'0 <- { self'0 with current = { t_Authority__0 = _ret.final } } ] 
            s3)
      | s3 = update'1 {_12} {_13} (fun (_ret:()) ->  [ &_11 <- _ret ] s4)
      | s4 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#sfmap_view'1] ext_eq (view'4 self'0) (insert'0 (view'6 s) k'0 v'0)} s1
      | s1 = core'1 {(self'0.current).t_Authority__0} (fun (_ret:t_Resource) ->  [ &_20 <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0 <- { t_Fragment__0 = _20; t_Fragment__1 = k'0; t_Fragment__2 = v'0 } ] s3
      | s3 = return''0 {_0} ]
     ]
    )
    [ & _0: t_Fragment = Any.any_l ()
    | & self'0: MutBorrow.t t_Authority = self
    | & k'0: t_K = k
    | & v'0: t_V = v
    | & s: t_Authority = Any.any_l ()
    | & _11: () = Any.any_l ()
    | & _12: MutBorrow.t t_Resource = Any.any_l ()
    | & _13: t_AuthUpdate = Any.any_l ()
    | & _14: t_FMapInsertLocalUpdate = Any.any_l ()
    | & _16: t_Ag = Any.any_l ()
    | & _20: t_Resource = Any.any_l () ]
    
    [ return''0 (result:t_Fragment)-> {[@expl:insert result type invariant] [%#sfmap_view'4] inv'1 result}
      {[@expl:insert ensures #0] [%#sfmap_view'5] view'3 self.final = insert'0 (view'4 self) k v}
      {[@expl:insert ensures #1] [%#sfmap_view'6] id'0 self.final = id'0 self.current}
      {[@expl:insert ensures #2] [%#sfmap_view'7] view'8 result = { _p0'3 = k; _p1'3 = v }}
      {[@expl:insert ensures #3] [%#sfmap_view'8] id'1 result = id'0 self.current}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__fmap_view__qyi505596245403307893__contains [#"../../creusot-contracts/src/resource/fmap_view.rs" 108 4 108 49] (* resource::fmap_view::Authority<K, V> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 214 14 217 5
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span soption'6 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 93 8 93 41
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 134 14 137 5
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 139 8 139 49
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 110 22 110 76
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 108 21 108 25
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 108 27 108 31
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 104 15 104 37
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 105 14 105 49
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 72 4 72 12
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 115 4 115 12
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 66 8 66 26
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 55 4 55 12
  let%span sfmap_view'8 = "../../creusot-contracts/src/resource/fmap_view.rs" 41 8 41 36
  let%span sfmap_view'9 = "../../creusot-contracts/src/resource/fmap_view.rs" 47 20 47 68
  let%span sresource = "../../creusot-contracts/src/resource.rs" 192 19 192 42
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 193 18 193 42
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 194 18 194 67
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Authority  =
    { t_Authority__0: t_Resource }
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 59 8 59 29] (self: t_Resource) : t_Id
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Ag
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Option'1
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2
  
   =
    [%#soption'1] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2
  
   =
    [%#soption'7] match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option'1 =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'1) (other: t_Option'1) : t_Option'2
  
   =
    [%#soption'4] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'6] and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'1
  
   =
    [%#sfmap] Map.get (view self) k
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'11] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'2)
   -> ([%#sfmap'12] forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option'0
   =
    [%#sfmap'7] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'4] and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'3] op'1 a b = op'1 b a
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'13] len self >= 0
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 54 4 54 26]  : t_FMap
  
  axiom empty_spec: [%#sfmap'8] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'9] view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = [%#sfmap'2] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'1] forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a: t_Option'1) (b: t_Option'1) : ()
  
  
  axiom commutative_spec'1: forall a: t_Option'1, b: t_Option'1. [%#soption'5] op'0 a b = op'0 b a
  
  function factor [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (self: t_Ag) (factor'0: t_Ag) : t_Option'1
  
   =
    [%#sagree'0] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2
  
   =
    [%#soption'3] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. [%#soption'2] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option'1) (other: t_Option'1) =
    [%#sra'5] factor'0 other self <> C_None'2
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. ([%#sra'0] op'0 self other
  = C_Some'2 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option'1. [%#sfmap'10] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'1 -> C_None'1
    | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (self: t_FMap) (factor'2: t_FMap) : t_Option'0
  
   =
    [%#sfmap'6] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in let _ = let _ = () in () in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'5] match factor'1 self factor'2 with
    | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
    | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_FMap) (other: t_FMap) =
    [%#sra'5] factor'1 other self <> C_None'0
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some'0 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option'0) (f: t_FMap) =
    [%#sauth] match a with
      | C_Some'0 a'0 -> incl'0 f a'0
      | C_None'0 -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option'0) : ()
  
  axiom rel_unit_spec: forall a: t_Option'0. [%#sauth'4] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option'0) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_FMap. [%#sauth'3] rel (C_None'0) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option'0) (f1: t_FMap) (f2: t_FMap) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'0, f1: t_FMap, f2: t_FMap. ([%#sauth'0] rel a f1)
   -> ([%#sauth'1] incl'0 f2 f1)  -> ([%#sauth'2] rel a f2)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'0
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. [%#sview] rel (auth self) (frag self)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'0) (frag'0: t_FMap) : t_View
  
  
  axiom new_spec: forall auth'0: t_Option'0, frag'0: t_FMap. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'6] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'0, frag'0: t_FMap. ([%#sview'5] rel auth'0 frag'0)
   -> ([%#sview'7] frag (new auth'0 frag'0) = frag'0)
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'2] match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'0 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'0} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'2: forall a: t_View, b: t_View, c: t_View. [%#sview'1] and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'0] op'2 a b = op'2 b a
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_FMap) : t_View =
    [%#sview'9] new (C_None'0) frag'0
  
  function factor'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 138 4 138 49] (self: t_View) (factor'3: t_View) : t_Option
  
   =
    [%#sview'4] let _ = () in match factor'1 (frag self) (frag factor'3) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth factor'3 } with
        | {_p0'1 = C_Some'0 a ; _p1'1 = C_None'0} -> C_Some (new (C_Some'0 a) f)
        | {_p0'1 = a1 ; _p1'1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'2: forall self: t_View, factor'3: t_View. [%#sview'3] match factor'2 self factor'3 with
    | C_Some c -> op'2 factor'3 c = C_Some self
    | C_None -> forall c: t_View. op'2 factor'3 c <> C_Some self
    end
  
  predicate incl'1 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_View) (other: t_View) =
    [%#sra'5] factor'2 other self <> C_None
  
  function incl_transitive'1 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom incl_transitive_spec'1: forall a: t_View, b: t_View, c: t_View. ([%#sra'2] incl'1 a b)
   -> ([%#sra'3] incl'1 b c)  -> ([%#sra'4] incl'1 a c)
  
  function incl_op'1 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_View) (other: t_View) (comb: t_View) : ()
  
  
  axiom incl_op_spec'1: forall self: t_View, other: t_View, comb: t_View. ([%#sra'0] op'2 self other = C_Some comb)
   -> ([%#sra'1] incl'1 self comb)
  
  predicate incl_eq [#"../../creusot-contracts/src/logic/ra.rs" 92 4 92 41] (self: t_View) (other: t_View) =
    [%#sra] self = other \/ incl'1 self other
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_View
  
  function view'0 [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_View =
    [%#sresource'2] val' self
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Resource) : t_View =
    [%#smodel] view'0 self
  
  let rec join_shared (self:t_Resource) (other:t_Resource) (return'  (x:t_Resource))= {[@expl:join_shared requires] [%#sresource] id self
    = id other}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'0] id result = id self}
      {[%#sresource'1] incl_eq (view'1 self) (view'1 result) /\ incl_eq (view'1 other) (view'1 result)}
      (! return' {result}) ]
  
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function view'2 [#"../../creusot-contracts/src/resource/fmap_view.rs" 65 4 65 27] (self: t_Fragment) : tuple'2 =
    [%#sfmap_view'6] { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function view'3 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Fragment) : tuple'2 =
    [%#smodel] view'2 self
  
  predicate invariant' [#"../../creusot-contracts/src/resource/fmap_view.rs" 40 4 40 30] (self: t_Authority) =
    [%#sfmap_view'8] auth (view'0 self.t_Authority__0) <> C_None'0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Authority)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Authority__0 = a_0} -> true
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Authority) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Authority)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Authority [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/resource/fmap_view.rs" 46 4 46 30] (self: t_Fragment) =
    [%#sfmap_view'9] get (frag (view'0 self.t_Fragment__0)) self.t_Fragment__1
    = C_Some'1 { t_Ag__0 = self.t_Fragment__2 }
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fragment)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Fragment [inv'1 x]. inv'1 x
  = (invariant''1 x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Fragment) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fragment)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Fragment [inv'2 x]. inv'2 x = invariant''2 x
  
  function id'0 [#"../../creusot-contracts/src/resource/fmap_view.rs" 73 4 73 25] (self: t_Authority) : t_Id =
    [%#sfmap_view'4] id self.t_Authority__0
  
  function id'1 [#"../../creusot-contracts/src/resource/fmap_view.rs" 116 4 116 25] (self: t_Fragment) : t_Id =
    [%#sfmap_view'5] id self.t_Fragment__0
  
  type t_FMap'0
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_V
  
  function view'4 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap'0) : Map.map t_K t_Option'3
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap'0) (k: t_K) : t_Option'3
  
   =
    [%#sfmap] Map.get (view'4 self) k
  
  function index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function map [#"../../creusot-contracts/src/logic/fmap.rs" 218 4 220 17] (self: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap'0
  
  
  axiom map_spec: forall self: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'0] forall k: t_K [get'0 (map self f) k]. get'0 (map self f) k
  = match get self k with
    | C_None'1 -> C_None'3
    | C_Some'1 v -> C_Some'3 (index_logic'0 f { _p0'0 = k; _p1'0 = v })
    end
  
  predicate index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_FMap bool) (a: t_FMap)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_FMap bool) : t_FMap
  
  axiom such_that_spec: forall p: Map.map t_FMap bool. ([%#sutil] exists x: t_FMap. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option'0) : t_FMap =
    [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_FMap) -> true)
      end
  
  function view'5 [#"../../creusot-contracts/src/resource/fmap_view.rs" 56 4 56 31] (self: t_Authority) : t_FMap'0 =
    [%#sfmap_view'7] map (unwrap_logic (auth (view'0 self.t_Authority__0))) (fun (__0: tuple'0) -> let {_p1'0 = x} = __0 in x.t_Ag__0)
  
  function view'6 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Authority) : t_FMap'0 =
    [%#smodel] view'5 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains[#"../../creusot-contracts/src/resource/fmap_view.rs" 108 4 108 49] (self:t_Authority) (frag'0:t_Fragment) (return'  (x:()))= {[@expl:contains 'self' type invariant] [%#sfmap_view'0] inv'0 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'1] inv'2 frag'0}
    {[@expl:contains requires] [%#sfmap_view'2] id'0 self = id'1 frag'0}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_8 <- frag'1.t_Fragment__0 ] s1
      | s1 = join_shared {self'0.t_Authority__0} {_8} (fun (_ret:t_Resource) ->  [ &new_resource <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#sfmap_view] get (frag (view'1 new_resource)) (view'3 frag'1)._p0'2
        = C_Some'1 { t_Ag__0 = (view'3 frag'1)._p1'2 }}
        s1
      | s1 = return''0 {_0} ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: t_Authority = self
    | & frag'1: t_Fragment = frag'0
    | & new_resource: t_Resource = Any.any_l ()
    | & _8: t_Resource = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:contains ensures] [%#sfmap_view'3] get'0 (view'6 self) (view'3 frag'0)._p0'2
      = C_Some'3 ((view'3 frag'0)._p1'2)}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__fmap_view__qyi10168537497030408938__clone [#"../../creusot-contracts/src/resource/fmap_view.rs" 124 4 124 27] (* <resource::fmap_view::Fragment<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 38 14 41 5
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 43 8 43 18
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sagree'4 = "../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'5 = "../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 182 14 185 5
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 187 8 187 31
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 124 14 124 18
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 124 23 124 27
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 123 14 123 30
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 66 8 66 26
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 47 20 47 68
  let%span sresource = "../../creusot-contracts/src/resource.rs" 107 19 107 39
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 108 18 108 42
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 109 18 109 47
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_FMap
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Ag
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Option'1
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2
  
   =
    [%#soption] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Ag t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option'1 =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some'1 self else C_None'1
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'2 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'1) (other: t_Option'1) : t_Option'2
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'1} -> C_Some'2 other
      | {_p1 = C_None'1} -> C_Some'2 self
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some'1 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'1] and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'1
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'6] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'2)  -> ([%#sfmap'7] forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option'0
   =
    [%#sfmap] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'2 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'5] and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'4] op'1 a b = op'1 b a
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'15] len self >= 0
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 54 4 54 26]  : t_FMap
  
  axiom empty_spec: [%#sfmap'13] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'14] view empty = Const.const (C_None'1)
  
  constant unit': t_FMap = [%#sfmap'10] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'9] forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a: t_Option'1) (b: t_Option'1) : ()
  
  
  axiom commutative_spec'1: forall a: t_Option'1, b: t_Option'1. [%#soption'5] op'0 a b = op'0 b a
  
  function factor [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (self: t_Ag) (factor'0: t_Ag) : t_Option'1
  
   =
    [%#sagree'5] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'4] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_Ag. op factor'0 c <> C_Some'1 self
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option'1) (factor'1: t_Option'1) : t_Option'2
  
   =
    [%#soption'4] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'1} -> C_Some'2 x
      | {_p0 = C_None'1} -> C_None'2
      | {_p0 = C_Some'1 x ; _p1 = C_Some'1 y} -> match factor x y with
        | C_Some'1 z -> C_Some'2 (C_Some'1 z)
        | C_None'1 -> if x = y then C_Some'2 (C_None'1) else C_None'2
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'1, factor'1: t_Option'1. [%#soption'3] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_Option'1. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option'1) (other: t_Option'1) =
    [%#sra] factor'0 other self <> C_None'2
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  
  axiom incl_transitive_spec: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Option'1) (other: t_Option'1) (comb: t_Option'1) : ()
  
  
  axiom incl_op_spec: forall self: t_Option'1, other: t_Option'1, comb: t_Option'1. ([%#sra'0] op'0 self other
  = C_Some'2 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_Option'1) (a: tuple'0) : t_Option'1
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'0 t_Option'1) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option'1. [%#sfmap'8] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'1 -> C_None'1
    | C_Some'1 v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (self: t_FMap) (factor'2: t_FMap) : t_Option'0
  
   =
    [%#sfmap'12] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some'1 vo) (get factor'2 k) with
        | C_Some'2 r -> r
        | C_None'2 -> C_None'1
        end) in let _ = let _ = () in () in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'11] match factor'1 self factor'2 with
    | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
    | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None'0
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some'0 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option'0) (f: t_FMap) =
    [%#sauth] match a with
      | C_Some'0 a'0 -> incl'0 f a'0
      | C_None'0 -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option'0) : ()
  
  axiom rel_unit_spec: forall a: t_Option'0. [%#sauth'4] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option'0) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_FMap. [%#sauth'3] rel (C_None'0) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option'0) (f1: t_FMap) (f2: t_FMap) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'0, f1: t_FMap, f2: t_FMap. ([%#sauth'0] rel a f1)
   -> ([%#sauth'1] incl'0 f2 f1)  -> ([%#sauth'2] rel a f2)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'0
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. [%#sview'7] rel (auth self) (frag self)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'0) (frag'0: t_FMap) : t_View
  
  
  axiom new_spec: forall auth'0: t_Option'0, frag'0: t_FMap. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'9] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'0, frag'0: t_FMap. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'10] frag (new auth'0 frag'0) = frag'0)
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'3] match op'1 (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'0 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'0} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'2: forall a: t_View, b: t_View, c: t_View. [%#sview'2] and_then_logic (op'2 a b) (fun (ab: t_View) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_View) -> op'2 a bc)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'1] op'2 a b = op'2 b a
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_FMap) : t_View =
    [%#sview'12] new (C_None'0) frag'0
  
  function core [#"../../creusot-contracts/src/logic/ra/agree.rs" 42 4 42 33] (self: t_Ag) : t_Option'1 =
    [%#sagree'0] C_Some'1 self
  
  axiom core_spec: forall self: t_Ag. [%#sagree] match core self with
    | C_Some'1 c -> op c c = C_Some'1 c /\ op c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (self: t_FMap) : t_FMap =
    [%#sfmap'2] let r = filter_map self (fun (__0: tuple'0) -> let {_p1'0 = v} = __0 in core v) in let _ = let _ = () in () in let _ = let _ = () in () in r
  
  axiom core_total_spec: forall self: t_FMap. [%#sfmap'0] op'1 (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. [%#sfmap'1] op'1 (core_total self) self = C_Some'0 self
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (self: t_View) : t_View =
    [%#sview'6] let _ = () in let _ = () in new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. [%#sview'4] op'2 (core_total'0 self) (core_total'0 self)
  = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. [%#sview'5] op'2 (core_total'0 self) self = C_Some self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (self: t_View) : t_Option =
    [%#sview'0] C_Some (core_total'0 self)
  
  axiom core_spec'0: forall self: t_View. [%#sview] match core'0 self with
    | C_Some c -> op'2 c c = C_Some c /\ op'2 c self = C_Some self
    | C_None -> true
    end
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_View
  
  function view'0 [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_View =
    [%#sresource'2] val' self
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Resource) : t_View =
    [%#smodel] view'0 self
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 59 8 59 29] (self: t_Resource) : t_Id
  
  let rec core'1 (self:t_Resource) (return'  (x:t_Resource))= {[@expl:core requires] [%#sresource] core'0 (view'1 self)
    <> C_None}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'0] id result = id self}
      {[%#sresource'1] C_Some (view'0 result) = core'0 (view'1 self)}
      (! return' {result}) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/resource/fmap_view.rs" 46 4 46 30] (self: t_Fragment) =
    [%#sfmap_view'3] get (frag (view'0 self.t_Fragment__0)) self.t_Fragment__1
    = C_Some'1 { t_Ag__0 = self.t_Fragment__2 }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Fragment) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''0 x
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function view'2 [#"../../creusot-contracts/src/resource/fmap_view.rs" 65 4 65 27] (self: t_Fragment) : tuple'2 =
    [%#sfmap_view'2] { _p0'2 = self.t_Fragment__1; _p1'2 = self.t_Fragment__2 }
  
  function view'3 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Fragment) : tuple'2 =
    [%#smodel] view'2 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone'[#"../../creusot-contracts/src/resource/fmap_view.rs" 124 4 124 27] (self:t_Fragment) (return'  (x:t_Fragment))= {[@expl:clone 'self' type invariant] [%#sfmap_view] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = core'1 {self'0.t_Fragment__0} (fun (_ret:t_Resource) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = 
        [ &_0 <- { t_Fragment__0 = _3; t_Fragment__1 = self'0.t_Fragment__1; t_Fragment__2 = self'0.t_Fragment__2 } ]
        
        s1
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: t_Fragment = Any.any_l () | & self'0: t_Fragment = self | & _3: t_Resource = Any.any_l () ] 
    [ return''0 (result:t_Fragment)-> {[@expl:clone result type invariant] [%#sfmap_view'0] inv result}
      {[@expl:clone ensures] [%#sfmap_view'1] view'2 result = view'3 self}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__m__qyi10819468878980253437__split_off [#"../../creusot-contracts/src/resource.rs" 151 8 151 75] (* resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 99 8 102 9
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 93 8 93 41
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sresource = "../../creusot-contracts/src/resource.rs" 147 19 147 47
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 148 18 148 71
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 149 18 149 32
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 150 18 150 31
  let%span sresource'3 = "../../creusot-contracts/src/resource.rs" 124 19 124 47
  let%span sresource'4 = "../../creusot-contracts/src/resource.rs" 125 18 125 74
  let%span sresource'5 = "../../creusot-contracts/src/resource.rs" 126 18 126 33
  let%span sresource'6 = "../../creusot-contracts/src/resource.rs" 127 18 127 33
  let%span sresource'7 = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  
  type t_Resource
  
  let rec dummy (return'  (x:t_Resource))= any [ return''0 (result:t_Resource)-> (! return' {result}) ] 
  
  let rec replace (dest:MutBorrow.t t_Resource) (src:t_Resource) (return'  (x:t_Resource))= any
    [ return''0 (result:t_Resource)-> {[%#smem] dest.final = src}
      {[%#smem'0] result = dest.current}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: t_Resource; _p1: t_Resource }
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  predicate incl_eq [#"../../creusot-contracts/src/logic/ra.rs" 92 4 92 41] (self: t_R) (other: t_R) =
    [%#sra'7] self = other \/ incl self other
  
  predicate incl_eq_op [#"../../creusot-contracts/src/logic/ra.rs" 98 4 98 52] (a: t_R) (b: t_R) (x: t_R) =
    [%#sra] match op a b with
      | C_None -> false
      | C_Some ab -> incl_eq ab x
      end
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_R
  
  function view [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_R =
    [%#sresource'7] val' self
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 59 8 59 29] (self: t_Resource) : t_Id
  
  let rec split (self:t_Resource) (a:t_R) (b:t_R) (return'  (x:tuple))= {[@expl:split requires] [%#sresource'3] incl_eq_op a b (view self)}
    any
    [ return''0 (result:tuple)-> {[%#sresource'4] id result._p0 = id self /\ id result._p1 = id self}
      {[%#sresource'5] view result._p0 = a}
      {[%#sresource'6] view result._p1 = b}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Resource) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Resource) =
    resolve _0
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Resource) : t_R =
    [%#smodel] view self.current
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec split_off[#"../../creusot-contracts/src/resource.rs" 151 8 151 75] (self:MutBorrow.t t_Resource) (r:t_R) (s:t_R) (return'  (x:t_Resource))= {[@expl:split_off requires] [%#sresource] incl_eq_op r s (view'0 self)}
    (! bb0
    [ bb0 = s0 [ s0 = dummy (fun (_ret:t_Resource) ->  [ &_10 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <t_Resource> {self'0.current}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_9 <- _ret ] 
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_9} {_10} (fun (_ret:t_Resource) ->  [ &this <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = split {this} {r'0} {s'0} (fun (_ret:tuple) ->  [ &_13 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 =  [ &r'1 <- _13._p0 ] s1
      | s1 =  [ &this'0 <- _13._p1 ] s2
      | s2 = MutBorrow.borrow_final <t_Resource> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_18 <- _ret ] 
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s3)
      | s3 = replace {_18} {this'0} (fun (_ret:t_Resource) ->  [ &_17 <- _ret ] s4)
      | s4 = bb4 ]
    
    | bb4 = s0 [ s0 = -{resolve'0 self'0}- s1 | s1 =  [ &_0 <- r'1 ] s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: t_Resource = Any.any_l ()
    | & self'0: MutBorrow.t t_Resource = self
    | & r'0: t_R = r
    | & s'0: t_R = s
    | & this: t_Resource = Any.any_l ()
    | & _9: MutBorrow.t t_Resource = Any.any_l ()
    | & _10: t_Resource = Any.any_l ()
    | & r'1: t_Resource = Any.any_l ()
    | & this'0: t_Resource = Any.any_l ()
    | & _13: tuple = Any.any_l ()
    | & _17: t_Resource = Any.any_l ()
    | & _18: MutBorrow.t t_Resource = Any.any_l () ]
    
    [ return''0 (result:t_Resource)-> {[@expl:split_off ensures #0] [%#sresource'0] id self.final = id self.current
      /\ id result = id self.current}
      {[@expl:split_off ensures #1] [%#sresource'1] view self.final = s}
      {[@expl:split_off ensures #2] [%#sresource'2] view result = r}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__m__qyi10819468878980253437__join_in [#"../../creusot-contracts/src/resource.rs" 179 8 179 46] (* resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sresource = "../../creusot-contracts/src/resource.rs" 176 19 176 42
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 177 18 177 43
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 178 18 178 52
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 167 19 167 42
  let%span sresource'3 = "../../creusot-contracts/src/resource.rs" 168 18 168 42
  let%span sresource'4 = "../../creusot-contracts/src/resource.rs" 169 18 169 51
  let%span sresource'5 = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  
  use creusot.prelude.MutBorrow
  use map.Map
  use creusot.prelude.Any
  
  type t_Resource
  
  let rec dummy (return'  (x:t_Resource))= any [ return''0 (result:t_Resource)-> (! return' {result}) ] 
  
  let rec replace (dest:MutBorrow.t t_Resource) (src:t_Resource) (return'  (x:t_Resource))= any
    [ return''0 (result:t_Resource)-> {[%#smem] dest.final = src}
      {[%#smem'0] result = dest.current}
      (! return' {result}) ]
  
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 59 8 59 29] (self: t_Resource) : t_Id
  
  type t_R
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_R
  
  function view [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_R =
    [%#sresource'5] val' self
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'7] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'6] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'3] incl a b)
   -> ([%#sra'4] incl b c)  -> ([%#sra'5] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'2] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'1] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  let rec join (self:t_Resource) (other:t_Resource) (return'  (x:t_Resource))= {[@expl:join requires] [%#sresource'2] id self
    = id other}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'3] id result = id self}
      {[%#sresource'4] C_Some (view result) = op (view self) (view other)}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Resource) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Resource) =
    resolve _0
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Resource) : t_R =
    [%#smodel] view self.current
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec join_in[#"../../creusot-contracts/src/resource.rs" 179 8 179 46] (self:MutBorrow.t t_Resource) (other:t_Resource) (return'  (x:()))= {[@expl:join_in requires] [%#sresource] id self.current
    = id other}
    (! bb0
    [ bb0 = s0 [ s0 = dummy (fun (_ret:t_Resource) ->  [ &_8 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <t_Resource> {self'0.current}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_7 <- _ret ] 
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_7} {_8} (fun (_ret:t_Resource) ->  [ &this <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = join {this} {other'0} (fun (_ret:t_Resource) ->  [ &this'0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_13 <- _ret ] 
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_13} {this'0} (fun (_ret:t_Resource) ->  [ &_12 <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 = -{resolve'0 self'0}- s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Resource = self
    | & other'0: t_Resource = other
    | & this: t_Resource = Any.any_l ()
    | & _7: MutBorrow.t t_Resource = Any.any_l ()
    | & _8: t_Resource = Any.any_l ()
    | & this'0: t_Resource = Any.any_l ()
    | & _12: t_Resource = Any.any_l ()
    | & _13: MutBorrow.t t_Resource = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:join_in ensures #0] [%#sresource'0] id self.final = id self.current}
      {[@expl:join_in ensures #1] [%#sresource'1] C_Some (view self.final) = op (view'0 self) (view other)}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__m__qyi10819468878980253437__weaken [#"../../creusot-contracts/src/resource.rs" 204 8 204 53] (* resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 99 8 102 9
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 93 8 93 41
  let%span sresource = "../../creusot-contracts/src/resource.rs" 205 20 205 68
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 201 19 201 37
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 202 18 202 43
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 203 18 203 37
  let%span sresource'3 = "../../creusot-contracts/src/resource.rs" 147 19 147 47
  let%span sresource'4 = "../../creusot-contracts/src/resource.rs" 148 18 148 71
  let%span sresource'5 = "../../creusot-contracts/src/resource.rs" 149 18 149 32
  let%span sresource'6 = "../../creusot-contracts/src/resource.rs" 150 18 150 31
  let%span sresource'7 = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  
  use map.Map
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_R bool) (a: t_R) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. ([%#sutil] exists x: t_R. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_R =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_R) -> true)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'0] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'4] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra'1] op self other = C_Some comb)
   -> ([%#sra'2] incl self comb)
  
  type t_Resource
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_R
  
  function view [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_R =
    [%#sresource'7] val' self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Resource) : t_R =
    [%#smodel] view self.current
  
  predicate incl_eq [#"../../creusot-contracts/src/logic/ra.rs" 92 4 92 41] (self: t_R) (other: t_R) =
    [%#sra'9] self = other \/ incl self other
  
  predicate incl_eq_op [#"../../creusot-contracts/src/logic/ra.rs" 98 4 98 52] (a: t_R) (b: t_R) (x: t_R) =
    [%#sra'8] match op a b with
      | C_None -> false
      | C_Some ab -> incl_eq ab x
      end
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 59 8 59 29] (self: t_Resource) : t_Id
  
  let rec split_off (self:MutBorrow.t t_Resource) (r:t_R) (s:t_R) (return'  (x:t_Resource))= {[@expl:split_off requires] [%#sresource'3] incl_eq_op r s (view'0 self)}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'4] id self.final = id self.current /\ id result = id self.current}
      {[%#sresource'5] view self.final = s}
      {[%#sresource'6] view result = r}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Resource) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Resource) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec weaken[#"../../creusot-contracts/src/resource.rs" 204 8 204 53] (self:MutBorrow.t t_Resource) (target:t_R) (return'  (x:()))= {[@expl:weaken requires] [%#sresource'0] incl target (view'0 self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &f <- [%#sresource] unwrap_logic (factor (view'0 self'0) target'0) ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_9 <- _ret ] 
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = split_off {_9} {f} {target'0} (fun (_ret:t_Resource) ->  [ &_8 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = -{resolve'0 self'0}- s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Resource = self
    | & target'0: t_R = target
    | & f: t_R = Any.any_l ()
    | & _8: t_Resource = Any.any_l ()
    | & _9: MutBorrow.t t_Resource = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:weaken ensures #0] [%#sresource'1] id self.final = id self.current}
      {[@expl:weaken ensures #1] [%#sresource'2] view self.final = target}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__m__qyi10819468878980253437__update [#"../../creusot-contracts/src/resource.rs" 238 8 238 77] (* resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sset = "../../creusot-contracts/src/logic/set.rs" 31 8 31 26
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 17 15 17 33
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 18 15 18 37
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 19 14 19 57
  let%span sresource = "../../creusot-contracts/src/resource.rs" 239 20 239 36
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 240 27 240 97
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 241 26 241 80
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 243 16 244 74
  let%span sresource'3 = "../../creusot-contracts/src/resource.rs" 246 20 246 50
  let%span sresource'4 = "../../creusot-contracts/src/resource.rs" 248 12 248 63
  let%span sresource'5 = "../../creusot-contracts/src/resource.rs" 238 47 238 50
  let%span sresource'6 = "../../creusot-contracts/src/resource.rs" 235 19 235 37
  let%span sresource'7 = "../../creusot-contracts/src/resource.rs" 236 18 236 43
  let%span sresource'8 = "../../creusot-contracts/src/resource.rs" 237 18 237 56
  let%span sresource'9 = "../../creusot-contracts/src/resource.rs" 220 19 221 82
  let%span sresource'10 = "../../creusot-contracts/src/resource.rs" 222 18 222 43
  let%span sresource'11 = "../../creusot-contracts/src/resource.rs" 223 18 223 44
  let%span sresource'12 = "../../creusot-contracts/src/resource.rs" 224 18 224 37
  let%span sresource'13 = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  
  use creusot.prelude.MutBorrow
  use set.Set
  use map.Map
  use creusot.prelude.Any
  
  type t_U
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_U)
  
  type t_Resource
  
  type t_R
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_R
  
  function view [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_R =
    [%#sresource'13] val' self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Resource) : t_R =
    [%#smodel] view self.current
  
  type t_Choice
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/set.rs" 30 4 30 39] (self: Set.set t_R) (e: t_R)
  
   =
    [%#sset] Set.mem e self
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice bool) (a: t_Choice)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_spec: forall p: Map.map t_Choice bool. ([%#sutil] exists x: t_Choice. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'7] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'6] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'3] incl a b)
   -> ([%#sra'4] incl b c)  -> ([%#sra'5] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'2] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'1] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function frame_preserving [#"../../creusot-contracts/src/logic/ra/update.rs" 20 4 20 65] (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  
  axiom frame_preserving_spec: forall self: t_U, from: t_R, frame: t_R. ([%#supdate'0] premise self from)
   -> ([%#supdate'1] op from frame <> C_None)
   -> ([%#supdate'2] op (update self from (frame_preserving self from frame)) frame <> C_None)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 59 8 59 29] (self: t_Resource) : t_Id
  
  let rec update_raw (self:MutBorrow.t t_Resource) (target_s:Set.set t_R) (return'  (x:t_R))= {[@expl:update_raw requires] [%#sresource'9] forall f: t_Option. op'0 (C_Some (view'0 self)) f
    <> C_None'0  -> (exists x: t_R. contains target_s x /\ op'0 (C_Some x) f <> C_None'0)}
    any
    [ return''0 (result:t_R)-> {[%#sresource'10] id self.final = id self.current}
      {[%#sresource'11] contains target_s result}
      {[%#sresource'12] view self.final = result}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Resource) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: MutBorrow.t t_Resource) =
    resolve'0 _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec update'0[#"../../creusot-contracts/src/resource.rs" 238 8 238 77] (self:MutBorrow.t t_Resource) (upd:t_U) (return'  (x:t_Choice))= {[@expl:update 'upd' type invariant] [%#sresource'5] inv upd}
    {[@expl:update requires] [%#sresource'6] premise upd (view'0 self)}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:type invariant] inv upd'0} s1
      | s1 = -{resolve upd'0}- s2
      | s2 =  [ &v <- [%#sresource] view'0 self'0 ] s3
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &target_s <- [%#sresource'0] fun (r'0: t_R) -> exists ch: t_Choice. update upd'0 v ch = r'0 ] s1
      | s1 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:assertion] [%#sresource'1] contains target_s (update upd'0 v (such_that (fun (__0: t_Choice) -> true)))}
        s1
      | s1 = {[@expl:assertion] [%#sresource'2] forall f: t_R. op v f <> C_None
         -> (exists ch: t_Choice. op (update upd'0 v ch) f <> C_None)}
        s2
      | s2 =  [ &_14 <- [%#sresource'3] () ] s3
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_17 <- _ret ] 
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = update_raw {_17} {target_s} (fun (_ret:t_R) ->  [ &r <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0
      [ s0 = -{resolve'1 self'0}- s1
      | s1 =  [ &_0 <- [%#sresource'4] such_that (fun (ch: t_Choice) -> update upd'0 v ch = r) ] s2
      | s2 = bb6 ]
    
    | bb6 = return''0 {_0} ]
    )
    [ & _0: t_Choice = Any.any_l ()
    | & self'0: MutBorrow.t t_Resource = self
    | & upd'0: t_U = upd
    | & v: t_R = Any.any_l ()
    | & target_s: Set.set t_R = Any.any_l ()
    | & _14: () = Any.any_l ()
    | & r: t_R = Any.any_l ()
    | & _17: MutBorrow.t t_Resource = Any.any_l () ]
    
    [ return''0 (result:t_Choice)-> {[@expl:update ensures #0] [%#sresource'7] id self.final = id self.current}
      {[@expl:update ensures #1] [%#sresource'8] view self.final = update upd (view'0 self) result}
      (! return' {result}) ]

end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone [#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span ssnapshot = "../../creusot-contracts/src/snapshot.rs" 56 14 56 29
  
  use creusot.prelude.Any
  
  type t_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone'[#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (self:t_T) (return'  (x:t_T))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_T = Any.any_l () | & self'0: t_T = self ] 
    [ return''0 (result:t_T)-> {[@expl:clone ensures] [%#ssnapshot] result = self} (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl__refines [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 71 4 71 26
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#sarray'0] view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sarray] forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans__refines [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 78 4 78 90
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#sarray'0] view self = Seq.(++) visited (view o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sarray] forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self: t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_map] forall self: t_IntoIter'0. forall result: (). produces self (Seq.empty: Seq.seq tuple'0) self
   -> produces self (Seq.empty: Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self: t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_map] forall a: t_IntoIter'0. forall ab: Seq.seq tuple'0. forall b: t_IntoIter'0. forall bc: Seq.seq tuple'0. forall c: t_IntoIter'0. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self: t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_map] forall a: t_Iter'0. forall ab: Seq.seq tuple. forall b: t_Iter'0. forall bc: Seq.seq tuple. forall c: t_Iter'0. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self: t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_map] forall self: t_Iter'0. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
   -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self: t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_map] forall a: t_IterMut'0. forall ab: Seq.seq tuple. forall b: t_IterMut'0. forall bc: Seq.seq tuple. forall c: t_IterMut'0. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self: t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] Map.get (view'0 self) k
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_map] forall self: t_IterMut'0. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
   -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_set] forall self: t_IntoIter'1. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_set] forall a: t_IntoIter'1. forall ab: Seq.seq t_T. forall b: t_IntoIter'1. forall bc: Seq.seq t_T. forall c: t_IntoIter'1. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_set] forall a: t_Iter'1. forall ab: Seq.seq t_T. forall b: t_Iter'1. forall bc: Seq.seq t_T. forall c: t_Iter'1. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_set] forall self: t_Iter'1. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_set] forall self: t_Intersection. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_set] forall a: t_Intersection. forall ab: Seq.seq t_T. forall b: t_Intersection. forall bc: Seq.seq t_T. forall c: t_Intersection. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self: t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_set] forall self: t_Difference. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 352 20 352 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self: t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 351 4 351 39] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#shash_set] forall a: t_Difference. forall ab: Seq.seq t_T. forall b: t_Difference. forall bc: Seq.seq t_T. forall c: t_Difference. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans__refines [#"../../creusot-contracts/src/std/deque.rs" 184 4 184 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 184 4 184 90
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 170 12 170 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 84 14 84 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 85 14 85 76
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'1] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'2] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 86 4 86 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. [%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. [%#sslice'0] forall i: int. 0 <= i
  /\ i < Seq.length (to_ref_seq self)  -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 154 4 154 33] (self: t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 168 4 168 65] (self: t_Iter'0) (visited: Seq.seq t_T) (tl: t_Iter'0)
  
   =
    [%#sdeque'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sdeque] forall a: t_Iter'0. forall ab: Seq.seq t_T. forall b: t_Iter'0. forall bc: Seq.seq t_T. forall c: t_Iter'0. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl__refines [#"../../creusot-contracts/src/std/deque.rs" 177 4 177 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 177 4 177 26
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 170 12 170 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 84 14 84 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 85 14 85 76
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'1] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'2] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 86 4 86 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. [%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. [%#sslice'0] forall i: int. 0 <= i
  /\ i < Seq.length (to_ref_seq self)  -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 154 4 154 33] (self: t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 168 4 168 65] (self: t_Iter'0) (visited: Seq.seq t_T) (tl: t_Iter'0)
  
   =
    [%#sdeque'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sdeque] forall self: t_Iter'0. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 72] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 72
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 50 12 53 98
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv'1 res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv'1 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv'1 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 48 4 48 55] (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned)
  
   =
    [%#scloned'0] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scloned] forall a: t_Cloned. forall ab: Seq.seq t_T. forall b: t_Cloned. forall bc: Seq.seq t_T. forall c: t_Cloned. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 59 4 59 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 59 4 59 26
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 50 12 53 98
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv'1 res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv'1 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv'1 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 48 4 48 55] (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned)
  
   =
    [%#scloned'0] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scloned] forall self: t_Cloned. forall result: (). produces'0 self (Seq.empty: Seq.seq t_T) self
   -> produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 26
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 48 4 48 64] (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied)
  
   =
    [%#scopied'0] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scopied] forall self: t_Copied. forall result: (). produces'0 self (Seq.empty: Seq.seq t_T) self
   -> produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 48 4 48 64] (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied)
  
   =
    [%#scopied'0] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scopied] forall a: t_Copied. forall ab: Seq.seq t_T. forall b: t_Copied. forall bc: Seq.seq t_T. forall c: t_Copied. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 56
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty)
  
   =
    [%#sempty'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sempty] forall self: t_Empty. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 56
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty)
  
   =
    [%#sempty'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sempty] forall a: t_Empty. forall ab: Seq.seq t_T. forall b: t_Empty. forall bc: Seq.seq t_T. forall c: t_Empty. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 90
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 73 12 77 108
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 46 12 50 87
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self: t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 44 4 44 30] (self: t_Enumerate) =
    [%#senumerate'2] (forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i: MutBorrow.t t_I. completed i  -> produces i.current (Seq.empty: Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv'0 x]. inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 71 4 71 64] (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate)
  
   =
    [%#senumerate'0] Seq.length visited = n o - n self
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#senumerate] forall a: t_Enumerate. forall ab: Seq.seq tuple. forall b: t_Enumerate. forall bc: Seq.seq tuple. forall c: t_Enumerate. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 73 12 77 108
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 46 12 50 87
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self: t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 44 4 44 30] (self: t_Enumerate) =
    [%#senumerate'2] (forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i: MutBorrow.t t_I. completed i  -> produces i.current (Seq.empty: Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv'0 x]. inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 71 4 71 64] (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate)
  
   =
    [%#senumerate'0] Seq.length visited = n o - n self
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#senumerate] forall self: t_Enumerate. forall result: (). produces'0 self (Seq.empty: Seq.seq tuple) self
   -> produces'0 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 139
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 118
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: bool) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: bool. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self: t_Filter) =
    [%#sfilter'1] forall f: t_F, i: t_Item. precondition f i
    /\ (forall f'0: t_F, g: t_F. hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1: t_F, f2: t_F, i'0: t_Item. not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Filter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Filter [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self: t_Filter) : t_F
  
  axiom func_spec: forall self: t_Filter. [%#sfilter'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self: t_Filter) : t_I
  
  axiom iter_spec: forall self: t_Filter. [%#sfilter'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter)
  
   =
    [%#sfilter'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfilter] forall self: t_Filter. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 139
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 118
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: bool) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: bool. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self: t_Filter) =
    [%#sfilter'1] forall f: t_F, i: t_Item. precondition f i
    /\ (forall f'0: t_F, g: t_F. hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1: t_F, f2: t_F, i'0: t_Item. not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Filter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Filter [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self: t_Filter) : t_F
  
  axiom func_spec: forall self: t_Filter. [%#sfilter'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self: t_Filter) : t_I
  
  axiom iter_spec: forall self: t_Filter. [%#sfilter'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter)
  
   =
    [%#sfilter'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfilter] forall a: t_Filter. forall ab: Seq.seq t_Item. forall b: t_Filter. forall bc: Seq.seq t_Item. forall c: t_Filter. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 143
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 49
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 53
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 130
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f: t_F) =
    [%#sfilter_map'4] forall i: t_Item. precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f: t_F) =
    [%#sfilter_map'5] forall g: t_F. hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1: t_F) =
    [%#sfilter_map'6] forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self: t_FilterMap) : t_F
  
  axiom func_spec: forall self: t_FilterMap. [%#sfilter_map'2] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self: t_FilterMap) =
    [%#sfilter_map'1] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite]: forall x: t_FilterMap [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self: t_FilterMap) : t_I
  
  axiom iter_spec: forall self: t_FilterMap. [%#sfilter_map'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap)
  
   =
    [%#sfilter_map'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j: int. 0 <= j /\ j < Seq.length s
     -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfilter_map] forall self: t_FilterMap. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
   -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 143
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 49
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 53
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 130
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f: t_F) =
    [%#sfilter_map'4] forall i: t_Item. precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f: t_F) =
    [%#sfilter_map'5] forall g: t_F. hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1: t_F) =
    [%#sfilter_map'6] forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self: t_FilterMap) : t_F
  
  axiom func_spec: forall self: t_FilterMap. [%#sfilter_map'2] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self: t_FilterMap) =
    [%#sfilter_map'1] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite]: forall x: t_FilterMap [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self: t_FilterMap) : t_I
  
  axiom iter_spec: forall self: t_FilterMap. [%#sfilter_map'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap)
  
   =
    [%#sfilter_map'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j: int. 0 <= j /\ j < Seq.length s
     -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfilter_map] forall a: t_FilterMap. forall ab: Seq.seq t_B. forall b: t_FilterMap. forall bc: Seq.seq t_B. forall c: t_FilterMap. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. [%#sfuse'1] inv'1 self  -> inv'0 (view self)
  
  axiom view_spec'0: forall self: t_Fuse. [%#sfuse'2] forall other: t_Fuse. view self = view other  -> self = other
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfuse] forall a: t_Fuse. forall ab: Seq.seq t_Item. forall b: t_Fuse. forall bc: Seq.seq t_Item. forall c: t_Fuse. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. [%#sfuse'1] inv'1 self  -> inv'0 (view self)
  
  axiom view_spec'0: forall self: t_Fuse. [%#sfuse'2] forall other: t_Fuse. view self = view other  -> self = other
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfuse] forall self: t_Fuse. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi306403796899090344__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map.rs" 76 4 76 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 76 4 76 26
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 59 12 70 75
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'1] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'2] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 57 4 57 67] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map)
  
   =
    [%#smap'0] hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#smap] forall self: t_Map. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
   -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi306403796899090344__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map.rs" 82 4 82 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 82 4 82 90
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 59 12 70 75
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Item) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: t_Item) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'1] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'2] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 57 4 57 67] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map)
  
   =
    [%#smap'0] hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#smap] forall a: t_Map. forall ab: Seq.seq t_B. forall b: t_Map. forall bc: Seq.seq t_B. forall c: t_Map. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'0] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#smap_inv] forall self: t_MapInv. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
   -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'0] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#smap_inv] forall a: t_MapInv. forall ab: Seq.seq t_B. forall b: t_MapInv. forall bc: Seq.seq t_B. forall c: t_MapInv. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans__refines [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self: t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self: t_Once) (visited: Seq.seq t_T) (o: t_Once)
  
   =
    [%#sonce'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sonce] forall a: t_Once. forall ab: Seq.seq t_T. forall b: t_Once. forall bc: Seq.seq t_T. forall c: t_Once. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl__refines [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self: t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self: t_Once) (visited: Seq.seq t_T) (o: t_Once)
  
   =
    [%#sonce'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sonce] forall self: t_Once. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'0] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srange] forall self: t_Range. forall result: (). produces self (Seq.empty: Seq.seq t_Idx) self
   -> produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'0] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srange] forall a: t_Range. forall ab: Seq.seq t_Idx. forall b: t_Range. forall bc: Seq.seq t_Idx. forall c: t_Range. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'1] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srange] forall a: t_RangeInclusive. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'1] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srange] forall self: t_RangeInclusive. forall result: (). produces self (Seq.empty: Seq.seq t_Idx) self
   -> produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 99
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self: t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat)
  
   =
    [%#srepeat'0] self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> postcondition () (view self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srepeat] forall self: t_Repeat. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 99
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self: t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat)
  
   =
    [%#srepeat'0] self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> postcondition () (view self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srepeat] forall a: t_Repeat. forall ab: Seq.seq t_T. forall b: t_Repeat. forall bc: Seq.seq t_T. forall c: t_Repeat. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 76 14 76 52
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 80 15 80 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 81 15 81 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 82 14 82 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 73 4 73 70] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 83 4 83 96] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_back_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 77 4 77 32] (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. [%#siter] produces_back self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rev)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rev [inv'0 x]. inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self: t_Rev) : t_I
  
  axiom iter_spec: forall self: t_Rev. [%#srev'1] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev)
  
   =
    [%#srev'0] produces_back (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srev] forall self: t_Rev. forall result: (). produces self (Seq.empty: Seq.seq t_Item) self
   -> produces self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 76 14 76 52
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 80 15 80 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 81 15 81 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 82 14 82 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 73 4 73 70] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 83 4 83 96] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_back_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 77 4 77 32] (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. [%#siter] produces_back self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rev)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rev [inv'0 x]. inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self: t_Rev) : t_I
  
  axiom iter_spec: forall self: t_Rev. [%#srev'1] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev)
  
   =
    [%#srev'0] produces_back (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srev] forall a: t_Rev. forall ab: Seq.seq t_Item. forall b: t_Rev. forall bc: Seq.seq t_Item. forall c: t_Rev. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 64 12 69 68
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self: t_Skip) : int
  
  axiom n_spec: forall self: t_Skip. [%#sskip'1] n self >= 0 /\ n self <= UInt64.t'int v_MAX
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'2] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 62 4 62 64] (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip)
  
   =
    [%#sskip'0] visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sskip] forall a: t_Skip. forall ab: Seq.seq t_Item. forall b: t_Skip. forall bc: Seq.seq t_Item. forall c: t_Skip. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 64 12 69 68
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self: t_Skip) : int
  
  axiom n_spec: forall self: t_Skip. [%#sskip'1] n self >= 0 /\ n self <= UInt64.t'int v_MAX
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'2] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 62 4 62 64] (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip)
  
   =
    [%#sskip'0] visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sskip] forall self: t_Skip. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl__refines [#"../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 67 12 67 88
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 33 14 33 50
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 34 4 34 21] (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. [%#stake'1] n self >= 0 /\ n self <= UInt64.t'int v_MAX
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 65 4 65 64] (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take)
  
   =
    [%#stake'0] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#stake] forall self: t_Take. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans__refines [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 67 12 67 88
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 33 14 33 50
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 34 4 34 21] (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. [%#stake'1] n self >= 0 /\ n self <= UInt64.t'int v_MAX
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 65 4 65 64] (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take)
  
   =
    [%#stake'0] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#stake] forall a: t_Take. forall ab: Seq.seq t_Item. forall b: t_Take. forall bc: Seq.seq t_Item. forall c: t_Take. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Zip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip [inv'1 x]. inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self: t_Zip) : t_A
  
  axiom itera_spec: forall self: t_Zip. [%#szip'1] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  
  axiom produces_trans_spec'0: forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self: t_Zip) : t_B
  
  axiom iterb_spec: forall self: t_Zip. [%#szip'2] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip)
  
   =
    [%#szip'0] exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#szip] forall a: t_Zip. forall ab: Seq.seq tuple. forall b: t_Zip. forall bc: Seq.seq tuple. forall c: t_Zip. produces'1 b bc c
  /\ produces'1 a ab b
   -> produces'1 b bc c
  /\ produces'1 a ab b /\ (forall result: (). produces'1 a (Seq.(++) ab bc) c  -> produces'1 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Zip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip [inv'1 x]. inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self: t_Zip) : t_A
  
  axiom itera_spec: forall self: t_Zip. [%#szip'1] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  
  axiom produces_trans_spec'0: forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self: t_Zip) : t_B
  
  axiom iterb_spec: forall self: t_Zip. [%#szip'2] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip)
  
   =
    [%#szip'0] exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#szip] forall self: t_Zip. forall result: (). produces'1 self (Seq.empty: Seq.seq tuple) self
   -> produces'1 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl__refines [#"../../creusot-contracts/src/std/iter.rs" 233 4 233 26] (* <&mut I as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 233 4 233 26
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 221 20 221 64
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'2] produces a ab b)
   -> ([%#siter'3] produces b bc c)  -> ([%#siter'4] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter'1] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 220 4 220 64] (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I)
  
   =
    [%#siter'0] produces self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#siter] forall self: MutBorrow.t t_I. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans__refines [#"../../creusot-contracts/src/std/iter.rs" 240 4 240 90] (* <&mut I as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 240 4 240 90
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 221 20 221 64
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'2] produces a ab b)
   -> ([%#siter'3] produces b bc c)  -> ([%#siter'4] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter'1] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 220 4 220 64] (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I)
  
   =
    [%#siter'0] produces self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#siter] forall a: MutBorrow.t t_I. forall ab: Seq.seq t_Item. forall b: MutBorrow.t t_I. forall bc: Seq.seq t_Item. forall c: MutBorrow.t t_I. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 650 4 650 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 650 4 650 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 643 12 644 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 627 4 627 30] (self: t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 641 4 641 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 656 4 656 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 656 4 656 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 643 12 644 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 627 4 627 30] (self: t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 641 4 641 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 693 4 693 90] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 693 4 693 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 680 12 681 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 664 4 664 34] (self: t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 678 4 678 64] (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall a: t_Iter. forall ab: Seq.seq t_T. forall b: t_Iter. forall bc: Seq.seq t_T. forall c: t_Iter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 687 4 687 26] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 687 4 687 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 680 12 681 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 664 4 664 34] (self: t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 678 4 678 64] (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 724 4 724 26] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 724 4 724 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 717 12 718 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 701 4 701 38] (self: t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 715 4 715 64] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_IterMut. forall result: (). produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
   -> produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 730 4 730 90] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 730 4 730 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 717 12 718 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 701 4 701 38] (self: t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 715 4 715 64] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall a: t_IterMut. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 471 4 471 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 471 4 471 90
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 457 12 457 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 84 14 84 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 85 14 85 76
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'3] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'4] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 86 4 86 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. [%#sslice'1] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. [%#sslice'2] forall i: int. 0 <= i
  /\ i < Seq.length (to_ref_seq self)  -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 441 4 441 33] (self: t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 455 4 455 65] (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter)
  
   =
    [%#sslice'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sslice] forall a: t_Iter. forall ab: Seq.seq t_T. forall b: t_Iter. forall bc: Seq.seq t_T. forall c: t_Iter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 464 4 464 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 464 4 464 26
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 457 12 457 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 84 14 84 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 85 14 85 76
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'3] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'4] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 86 4 86 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. [%#sslice'1] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self)
  
  axiom to_ref_seq_spec'0: forall self: Slice64.slice t_T. [%#sslice'2] forall i: int. 0 <= i
  /\ i < Seq.length (to_ref_seq self)  -> Seq.get (to_ref_seq self) i = index_logic self i
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 441 4 441 33] (self: t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 455 4 455 65] (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter)
  
   =
    [%#sslice'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sslice] forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 524 4 524 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 524 4 524 90
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 510 12 510 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 75 14 75 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 76 14 76 80
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 479 14 479 50
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'4] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'5] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 78 4 78 43] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). [%#sslice'1] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). [%#sslice'2] forall i: int. 0 <= i
  /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 480 4 480 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'1: forall self: t_IterMut. [%#sslice'3] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 508 4 508 65] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut)
  
   =
    [%#sslice'0] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sslice] forall a: t_IterMut. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 517 4 517 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 517 4 517 26
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 510 12 510 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 75 14 75 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 76 14 76 80
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 479 14 479 50
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'4] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'5] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 78 4 78 43] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). [%#sslice'1] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self)
  
  axiom to_mut_seq_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). [%#sslice'2] forall i: int. 0 <= i
  /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 480 4 480 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'1: forall self: t_IterMut. [%#sslice'3] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 508 4 508 65] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut)
  
   =
    [%#sslice'0] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sslice] forall self: t_IterMut. forall result: (). produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
   -> produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans__refines [#"../../creusot-contracts/src/std/vec.rs" 263 4 263 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 263 4 263 72
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 249 12 249 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 247 4 247 57] (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter)
  
   =
    [%#svec'0] view self = Seq.(++) visited (view rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#svec] forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl__refines [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 256 4 256 26
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 249 12 249 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 247 4 247 57] (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter)
  
   =
    [%#svec'0] view self = Seq.(++) visited (view rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#svec] forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 267 4 267 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 267 4 267 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). lt_log'0 x y
  = (cmp_log'0 x y = C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1__refines [#"../../creusot-contracts/src/std/cmp.rs" 295 4 295 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 295 4 295 33
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. cmp_log'0 x y = C_Less
   -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater  -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp__refines [#"../../creusot-contracts/src/std/cmp.rs" 306 4 306 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 306 4 306 31
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). (x = y)
  = (cmp_log'0 x y = C_Equal)  -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl__refines [#"../../creusot-contracts/src/std/cmp.rs" 282 4 282 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 282 4 282 20
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall result: (). cmp_log'0 x x = C_Equal  -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans__refines [#"../../creusot-contracts/src/std/cmp.rs" 289 4 289 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 289 4 289 52
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall z: t_Reverse. forall o: t_Ordering. cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2__refines [#"../../creusot-contracts/src/std/cmp.rs" 301 4 301 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 301 4 301 33
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. cmp_log'0 x y = C_Greater
   -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less  -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 262 4 262 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 262 4 262 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). le_log'0 x y
  = (cmp_log'0 x y <> C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 272 4 272 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 272 4 272 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). ge_log'0 x y
  = (cmp_log'0 x y <> C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 277 4 277 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 277 4 277 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 252 8 256 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 251 4 251 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). gt_log'0 x y
  = (cmp_log'0 x y = C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). (x = y) = (cmp_log'0 x y = C_Equal)
   -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_Option) (o: t_Option) =
    [%#sord'0] cmp_log'0 self o = C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). lt_log'0 x y
  = (cmp_log'0 x y = C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. cmp_log'0 x y = C_Less
   -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater  -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_Option) (o: t_Option) =
    [%#sord'0] cmp_log'0 self o <> C_Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). ge_log'0 x y
  = (cmp_log'0 x y <> C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_Option) (o: t_Option) =
    [%#sord'0] cmp_log'0 self o = C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). gt_log'0 x y
  = (cmp_log'0 x y = C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall z: t_Option. forall o: t_Ordering. cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall result: (). cmp_log'0 x x = C_Equal  -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_Option) (o: t_Option) =
    [%#sord'0] cmp_log'0 self o <> C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). le_log'0 x y
  = (cmp_log'0 x y <> C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 611 8 616 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 610 4 610 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. cmp_log'0 x y = C_Greater
   -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less  -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). Real.(<=) x y
  = (cmp_log x y <> C_Greater)  -> Real.(<=) x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). Real.(<) x y
  = (cmp_log x y = C_Less)  -> Real.(<) x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). Real.(>=) x y
  = (cmp_log x y <> C_Less)  -> Real.(>=) x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). Real.(>) x y
  = (cmp_log x y = C_Greater)  -> Real.(>) x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall z: Real.real. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Real.real. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x >= y) = (cmp_log x y <> C_Less)
   -> (x >= y) = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall y: int. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x > y) = (cmp_log x y = C_Greater)
   -> (x > y) = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x <= y) = (cmp_log x y <> C_Greater)
   -> (x <= y) = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x < y) = (cmp_log x y = C_Less)
   -> (x < y) = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall y: int. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: int. forall y: int. forall z: int. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.ge x y = (cmp_log x y <> C_Less)
   -> UInt8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.gt x y
  = (cmp_log x y = C_Greater)  -> UInt8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.lt x y = (cmp_log x y = C_Less)
   -> UInt8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.le x y
  = (cmp_log x y <> C_Greater)  -> UInt8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall z: UInt8.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.gt x y
  = (cmp_log x y = C_Greater)  -> UInt16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall z: UInt16.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.le x y
  = (cmp_log x y <> C_Greater)  -> UInt16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.lt x y
  = (cmp_log x y = C_Less)  -> UInt16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.ge x y
  = (cmp_log x y <> C_Less)  -> UInt16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt16.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.ge x y
  = (cmp_log x y <> C_Less)  -> UInt32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.lt x y
  = (cmp_log x y = C_Less)  -> UInt32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.le x y
  = (cmp_log x y <> C_Greater)  -> UInt32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall z: UInt32.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.gt x y
  = (cmp_log x y = C_Greater)  -> UInt32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y
  = (cmp_log x y = C_Greater)  -> UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y
  = (cmp_log x y = C_Less)  -> UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y
  = (cmp_log x y <> C_Less)  -> UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y
  = (cmp_log x y <> C_Greater)  -> UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall z: UInt128.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.le x y
  = (cmp_log x y <> C_Greater)  -> UInt128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.ge x y
  = (cmp_log x y <> C_Less)  -> UInt128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.gt x y
  = (cmp_log x y = C_Greater)  -> UInt128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.lt x y
  = (cmp_log x y = C_Less)  -> UInt128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y
  = (cmp_log x y <> C_Greater)  -> UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y
  = (cmp_log x y <> C_Less)  -> UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y
  = (cmp_log x y = C_Greater)  -> UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y
  = (cmp_log x y = C_Less)  -> UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.ge x y = (cmp_log x y <> C_Less)
   -> Int8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.le x y = (cmp_log x y <> C_Greater)
   -> Int8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.lt x y = (cmp_log x y = C_Less)
   -> Int8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.gt x y = (cmp_log x y = C_Greater)
   -> Int8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall z: Int8.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int8.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.lt x y = (cmp_log x y = C_Less)
   -> Int16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.ge x y = (cmp_log x y <> C_Less)
   -> Int16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall z: Int16.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.gt x y
  = (cmp_log x y = C_Greater)  -> Int16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.le x y
  = (cmp_log x y <> C_Greater)  -> Int16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.ge x y = (cmp_log x y <> C_Less)
   -> Int32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall z: Int32.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.le x y
  = (cmp_log x y <> C_Greater)  -> Int32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.lt x y = (cmp_log x y = C_Less)
   -> Int32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.gt x y
  = (cmp_log x y = C_Greater)  -> Int32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y
  = (cmp_log x y <> C_Greater)  -> Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y
  = (cmp_log x y = C_Greater)  -> Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log x y = C_Less)
   -> Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log x y <> C_Less)
   -> Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.lt x y
  = (cmp_log x y = C_Less)  -> Int128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall z: Int128.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.gt x y
  = (cmp_log x y = C_Greater)  -> Int128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.le x y
  = (cmp_log x y <> C_Greater)  -> Int128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.ge x y
  = (cmp_log x y <> C_Less)  -> Int128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y
  = (cmp_log x y = C_Greater)  -> Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log x y <> C_Less)
   -> Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log x y = C_Less)
   -> Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y
  = (cmp_log x y <> C_Greater)  -> Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). Char.ge x y = (cmp_log x y <> C_Less)
   -> Char.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). Char.lt x y = (cmp_log x y = C_Less)
   -> Char.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall z: Char.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). Char.gt x y = (cmp_log x y = C_Greater)
   -> Char.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). Char.le x y = (cmp_log x y <> C_Greater)
   -> Char.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). Bool.le x y = (cmp_log x y <> C_Greater)
   -> Bool.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall y: bool. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall y: bool. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). Bool.ge x y = (cmp_log x y <> C_Less)
   -> Bool.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). Bool.lt x y = (cmp_log x y = C_Less)
   -> Bool.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall z: bool. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). Bool.gt x y = (cmp_log x y = C_Greater)
   -> Bool.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self: tuple) (o: tuple) =
    [%#sord'0] self._p0 = o._p0 /\ gt_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). gt_log'1 x y = (cmp_log'1 x y = C_Greater)
   -> gt_log'1 x y = (cmp_log'1 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self: tuple) (o: tuple) =
    [%#sord'0] self._p0 = o._p0 /\ ge_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). ge_log'1 x y = (cmp_log'1 x y <> C_Less)
   -> ge_log'1 x y = (cmp_log'1 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. cmp_log'1 x y = C_Greater
   -> cmp_log'1 x y = C_Greater /\ (forall result: (). cmp_log'1 y x = C_Less  -> cmp_log'1 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). (x = y) = (cmp_log'1 x y = C_Equal)
   -> (x = y) = (cmp_log'1 x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self: tuple) (o: tuple) =
    [%#sord'0] self._p0 = o._p0 /\ le_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). le_log'1 x y
  = (cmp_log'1 x y <> C_Greater)  -> le_log'1 x y = (cmp_log'1 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall result: (). cmp_log'1 x x = C_Equal  -> cmp_log'1 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall z: tuple. forall o: t_Ordering. cmp_log'1 y z = o
  /\ cmp_log'1 x y = o
   -> cmp_log'1 y z = o /\ cmp_log'1 x y = o /\ (forall result: (). cmp_log'1 x z = o  -> cmp_log'1 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self: tuple) (o: tuple) =
    [%#sord'0] self._p0 = o._p0 /\ lt_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). lt_log'1 x y = (cmp_log'1 x y = C_Less)
   -> lt_log'1 x y = (cmp_log'1 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. cmp_log'1 x y = C_Less
   -> cmp_log'1 x y = C_Less /\ (forall result: (). cmp_log'1 y x = C_Greater  -> cmp_log'1 y x = C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall y: t_PeanoInt. cmp_log'0 x y = C_Greater
   -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less  -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall y: t_PeanoInt. forall z: t_PeanoInt. forall o: t_Ordering. cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 64 4 64 12
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/peano.rs" 66 4 66 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano] UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). ge_log x y
  = (cmp_log'0 x y <> C_Less)  -> ge_log x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall y: t_PeanoInt. cmp_log'0 x y = C_Less
   -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater  -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 59 4 59 12
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate lt_log [#"../../creusot-contracts/src/peano.rs" 61 4 61 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano] UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). lt_log x y
  = (cmp_log'0 x y = C_Less)  -> lt_log x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 54 4 54 12
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate le_log [#"../../creusot-contracts/src/peano.rs" 56 4 56 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano] UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). le_log x y
  = (cmp_log'0 x y <> C_Greater)  -> le_log x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__peano__qyi5347411415401763779__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall result: (). cmp_log'0 x x = C_Equal  -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__peano__qyi5347411415401763779__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). (x = y)
  = (cmp_log'0 x y = C_Equal)  -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__peano__qyi5347411415401763779__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 69 4 69 12
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'5] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'4] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'3] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  predicate gt_log [#"../../creusot-contracts/src/peano.rs" 71 4 71 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano] UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sord] forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). gt_log x y
  = (cmp_log'0 x y = C_Greater)  -> gt_log x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__deque__qyi15330951746891243504__resolve_coherence__refines [#"../../creusot-contracts/src/std/deque.rs" 73 4 73 30] (* <std::collections::VecDeque<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 73 4 73 30
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 66 20 66 76
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 18 14 18 41
  let%span sdeque'2 = "../../creusot-contracts/src/std/deque.rs" 46 8 46 31
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_VecDeque  =
    { t_VecDeque__head: UInt64.t; t_VecDeque__len: UInt64.t; t_VecDeque__buf: t_RawVec }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_VecDeque) =
    match _0 with
      | {t_VecDeque__head = x0 ; t_VecDeque__len = x1 ; t_VecDeque__buf = x2} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_VecDeque)
  
  axiom inv_axiom [@rewrite]: forall x: t_VecDeque [inv x]. inv x = true
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/deque.rs" 19 4 19 27] (self: t_VecDeque) : Seq.seq t_T
  
  axiom view_spec: forall self: t_VecDeque. [%#sdeque'1] Seq.length (view self) <= UInt64.t'int v_MAX
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/std/deque.rs" 45 4 45 47] (self: t_VecDeque) (ix: int) : t_T
  
   =
    [%#sdeque'2] Seq.get (view self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/deque.rs" 65 4 65 28] (self: t_VecDeque) =
    [%#sdeque'0] forall i: int. 0 <= i /\ i < Seq.length (view self)  -> resolve (index_logic self i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sdeque] forall self: t_VecDeque. structural_resolve self /\ inv self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi7712864753404203214__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 30 4 30 30] (* <std::iter::Cloned<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 30 4 30 30
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 23 8 23 28
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Cloned) =
    match _0 with
      | {t_Cloned__it = x0} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 22 4 22 28] (self: t_Cloned) =
    [%#scloned'0] resolve (iter self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scloned] forall self: t_Cloned. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi10817769304312191898__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 30 4 30 30] (* <std::iter::Copied<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 30 4 30 30
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 23 8 23 28
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Copied) =
    match _0 with
      | {t_Copied__it = x0} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 22 4 22 28] (self: t_Copied) =
    [%#scopied'0] resolve (iter self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#scopied] forall self: t_Copied. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi7229971731912667430__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 39 4 39 30] (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 39 4 39 30
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 32 8 32 28
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Enumerate) =
    match _0 with
      | {t_Enumerate__iter = x0 ; t_Enumerate__count = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  axiom inv_axiom: forall x: t_Enumerate [inv'0 x]. inv'0 x
   -> match x with
    | {t_Enumerate__iter = iter ; t_Enumerate__count = count} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 31 4 31 28] (self: t_Enumerate) =
    [%#senumerate'0] resolve (iter self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#senumerate] forall self: t_Enumerate. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi7619436869179474426__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map.rs" 41 4 41 30] (* <std::iter::Map<I, F> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 41 4 41 30
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 34 8 34 52
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Map) =
    match _0 with
      | {t_Map__iter = x0 ; t_Map__f = x1} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'1] inv'1 self  -> inv (iter self)
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'2] inv'1 self  -> inv'0 (func self)
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map.rs" 33 4 33 28] (self: t_Map) =
    [%#smap'0] resolve'0 (iter self) /\ resolve (func self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#smap] forall self: t_Map. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 63 4 63 30] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 63 4 63 30
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 48
  
  use seq.Seq
  
  type t_I
  
  type t_F
  
  type t_B
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_B }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_MapInv) =
    match _0 with
      | {t_MapInv__iter = x0 ; t_MapInv__func = x1 ; t_MapInv__produced = x2} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_MapInv)
  
  axiom inv_axiom: forall x: t_MapInv [inv'1 x]. inv'1 x
   -> match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'0 func
    end
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 56 4 56 28] (self: t_MapInv) =
    [%#smap_inv'0] resolve'0 self.t_MapInv__iter /\ resolve self.t_MapInv__func
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#smap_inv] forall self: t_MapInv. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi1800235112549046777__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 42 4 42 30] (* <std::iter::Skip<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 42 4 42 30
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 34 12 34 32
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Skip) =
    match _0 with
      | {t_Skip__iter = x0 ; t_Skip__n = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 32 4 32 28] (self: t_Skip) =
    [%#sskip'0] resolve (iter self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sskip] forall self: t_Skip. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi7846602308660485643__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/take.rs" 50 4 50 30] (* <std::iter::Take<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 50 4 50 30
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 43 8 43 28
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Take) =
    match _0 with
      | {t_Take__iter = x0 ; t_Take__n = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/take.rs" 42 4 42 28] (self: t_Take) =
    [%#stake'0] resolve (iter self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#stake] forall self: t_Take. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi6798028551487775744__resolve_coherence__refines [#"../../creusot-contracts/src/std/slice.rs" 496 4 496 30] (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 496 4 496 30
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 489 20 489 36
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 479 14 479 50
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 30 14 30 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 31 14 31 42
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_IterMut) =
    match _0 with
      | {t_IterMut__ptr = x0 ; t_IterMut__end_or_len = x1 ; t_IterMut__qy95zmarker = x2} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_IterMut)
  
  axiom inv_axiom [@rewrite]: forall x: t_IterMut [inv x]. inv x = true
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 32 4 32 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. [%#sslice'2] Seq.length (view self) <= UInt64.t'int v_MAX
  
  axiom view_spec'0: forall self: Slice64.slice t_T. [%#sslice'3] view self = Slice64.id self
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 480 4 480 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'1: forall self: t_IterMut. [%#sslice'1] Seq.length (view (view'0 self).final)
  = Seq.length (view (view'0 self).current)
  
  predicate resolve [#"../../creusot-contracts/src/std/slice.rs" 488 4 488 28] (self: t_IterMut) =
    [%#sslice'0] (view'0 self).current = (view'0 self).final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sslice] forall self: t_IterMut. structural_resolve self /\ inv self
   -> structural_resolve self /\ (forall result: (). resolve self  -> resolve self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi16169840827095121464__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 53 4 53 30] (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 53 4 53 30
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 46 20 46 76
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_A
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: t_A }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Vec) =
    match _0 with
      | {t_Vec__buf = x0 ; t_Vec__len = x1} -> true
      end
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/seq.rs" 682 4 682 30] (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'0 (Seq.get self i)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 22 4 22 27] (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'1] Seq.length (view self) <= UInt64.t'int v_MAX
  
  predicate invariant''1 [#"../../creusot-contracts/src/std/vec.rs" 62 4 62 30] (self: t_Vec) =
    [%#svec'2] inv'1 (view self)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 28 4 28 47] (self: t_Vec) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 45 4 45 28] (self: t_Vec) =
    [%#svec'0] forall i: int. 0 <= i /\ i < Seq.length (view self)  -> resolve (index_logic self i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#svec] forall self: t_Vec. structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9945000909994515642__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 234 4 234 30] (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 234 4 234 30
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 227 20 227 77
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_IntoIter) =
    match _0 with
      | {t_IntoIter__buf = x0 ; t_IntoIter__phantom = x1 ; t_IntoIter__cap = x2 ; t_IntoIter__alloc = x3 ; t_IntoIter__ptr = x4 ; t_IntoIter__end = x5} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_ManuallyDrop)
  
  axiom inv_axiom [@rewrite]: forall x: t_ManuallyDrop [inv'0 x]. inv'0 x
  = match x with
    | {t_ManuallyDrop__value = value} -> inv value
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_IntoIter)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_IntoIter [inv'1 x]. inv'1 x
  = match x with
    | {t_IntoIter__buf = buf ; t_IntoIter__phantom = phantom ; t_IntoIter__cap = cap ; t_IntoIter__alloc = alloc ; t_IntoIter__ptr = ptr ; t_IntoIter__end = end'} -> inv'0 alloc
    end
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 226 4 226 28] (self: t_IntoIter) =
    [%#svec'0] forall i: int. 0 <= i /\ i < Seq.length (view self)  -> resolve (Seq.get (view self) i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#svec] forall self: t_IntoIter. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost__qyi8064556118965643473__resolve_coherence__refines [#"../../creusot-contracts/src/ghost.rs" 114 4 114 30] (* <ghost::Ghost<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 114 4 114 30
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 107 8 107 22
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0:  t_T)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_T) =
    [%#sghost'1] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_T)
  
  axiom inv_axiom [@rewrite]: forall x:  t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/ghost.rs" 106 4 106 28] (self:  t_T) =
    [%#sghost'0] resolve self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sghost] forall self:  t_T. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__invariant__qyi4568223824573003996__resolve_coherence__refines [#"../../creusot-contracts/src/invariant.rs" 305 4 305 30] (* <invariant::Subset<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 305 4 305 30
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 298 20 298 34
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  
  type t_Subset
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Subset)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Subset)
  
  axiom inv_axiom [@rewrite]: forall x: t_Subset [inv x]. inv x = true
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 72 4 72 31] (self: t_T)
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/invariant.rs" 297 4 297 28] (self: t_Subset) =
    [%#sinvariant'0] resolve (view self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sinvariant] forall self: t_Subset. structural_resolve self /\ inv self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__pcell__qyi12897409324816536085__resolve_coherence__refines [#"../../creusot-contracts/src/pcell.rs" 52 4 52 30] (* <pcell::PCellOwn<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 52 4 52 30
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 44 8 44 27
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_PCellOwn) =
    match _0 with
      | {t_PCellOwn__0 = x0} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCellOwn)
  
  axiom inv_axiom: forall x: t_PCellOwn [inv x]. inv x
   -> match x with
    | {t_PCellOwn__0 = a_0} -> true
    end
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  function val' [#"../../creusot-contracts/src/pcell.rs" 78 4 78 33] (self: t_PCellOwn) : t_T
  
  predicate resolve'0 [#"../../creusot-contracts/src/pcell.rs" 43 4 43 28] (self: t_PCellOwn) =
    [%#spcell'0] resolve (val' self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#spcell] forall self: t_PCellOwn. structural_resolve self /\ inv self
   -> structural_resolve self /\ inv self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 42 4 42 30] (* <(T1, T2) as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 42 4 42 30
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 36 8 36 42
  
  type t_T1
  
  type t_T2
  
  type tuple  =
    { _p0: t_T1; _p1: t_T2 }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T2)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T1)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: tuple) =
    let {_p0 = x0 ; _p1 = x1} = _0 in resolve x1 /\ resolve'0 x0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T1)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T2)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom [@rewrite]: forall x: tuple [inv'1 x]. inv'1 x = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 35 4 35 28] (self: tuple) =
    [%#sresolve'0] resolve'0 self._p0 /\ resolve self._p1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sresolve] forall self: tuple. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 55 4 55 30] (* <&mut T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 55 4 55 30
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: MutBorrow.t t_T) =
    _0.final = _0.current
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sresolve] forall self: MutBorrow.t t_T. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve self  -> resolve self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 68 4 68 30] (* <std::boxed::Box<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 68 4 68 30
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 62 8 62 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_T) =
    resolve _0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 28] (self: t_T) =
    [%#sresolve'0] resolve self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sresolve] forall self: t_T. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 84 4 84 30] (* <std::option::Option<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 84 4 84 30
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 50] (_0: t_Option) =
    match _0 with
      | C_None -> true
      | C_Some x0 -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sresolve] forall self: t_Option. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 47
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'6 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'7 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'8 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'9 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. [%#sfuse'8] inv'1 self  -> inv'0 (view self)
  
  axiom view_spec'0: forall self: t_Fuse. [%#sfuse'9] forall other: t_Fuse. view self = view other  -> self = other
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a: t_Fuse) (ab: Seq.seq t_Item) (b: t_Fuse) (bc: Seq.seq t_Item) (c: t_Fuse) : ()
  
   =
    [%#sfuse'7] ()
  
  axiom produces_trans_spec'0: forall a: t_Fuse, ab: Seq.seq t_Item, b: t_Fuse, bc: Seq.seq t_Item, c: t_Fuse. ([%#sfuse'4] produces'0 a ab b)
   -> ([%#sfuse'5] produces'0 b bc c)  -> ([%#sfuse'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self: t_Fuse) : () =
    [%#sfuse'3] ()
  
  axiom produces_refl_spec'0: forall self: t_Fuse. [%#sfuse'2] produces'0 self (Seq.empty: Seq.seq t_Item) self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Fuse) : t_Option =
    [%#smodel] view self.current
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self: MutBorrow.t t_Fuse) =
    [%#sfuse'1] (view'0 self = C_None
    \/ (exists it: MutBorrow.t t_I. completed it /\ view'0 self = C_Some (it.current)))
    /\ view self.final = C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfuse] forall self: MutBorrow.t t_Fuse. forall steps: Seq.seq t_Item. forall next: t_Fuse. produces'0 self.final steps next
  /\ completed'0 self
   -> produces'0 self.final steps next
  /\ completed'0 self
  /\ (forall result: (). steps = (Seq.empty: Seq.seq t_Item) /\ self.final = next
   -> steps = (Seq.empty: Seq.seq t_Item) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 89 4 89 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 47
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 89 4 89 44
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 17 8 20 9
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 176 14 176 68
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 12 184 74
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 47
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 27 25 29
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv'8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv'9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span smap_inv'10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 73 12 75 73
  let%span smap_inv'11 = "../../creusot-contracts/src/std/iter/map_inv.rs" 152 12 155 47
  let%span smap_inv'12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 123 14 123 83
  let%span smap_inv'13 = "../../creusot-contracts/src/std/iter/map_inv.rs" 126 12 131 88
  let%span smap_inv'14 = "../../creusot-contracts/src/std/iter/map_inv.rs" 116 12 118 63
  let%span smap_inv'15 = "../../creusot-contracts/src/std/iter/map_inv.rs" 139 12 144 71
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: tuple)
  
  predicate next_precondition [#"../../creusot-contracts/src/std/iter/map_inv.rs" 114 4 114 78] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'14] forall e: t_Item, i: t_I. produces iter (Seq.singleton e) i
     -> precondition func { _p0 = e; _p1 = produced }
  
  type t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 137 4 137 49] (iter: t_I) (func: t_F) =
    [%#smap_inv'15] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  predicate reinitialize [#"../../creusot-contracts/src/std/iter/map_inv.rs" 150 4 150 33]  =
    [%#smap_inv'11] forall iter: MutBorrow.t t_I, func: t_F. completed iter
     -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 124 4 124 77] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'13] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = Seq.(++) produced s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec: forall iter: t_I, func: t_F, produced: Seq.seq t_Item. [%#smap_inv'12] produced
  = (Seq.empty: Seq.seq t_Item)  -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/map_inv.rs" 71 4 71 30] (self: t_MapInv) =
    [%#smap_inv'10] reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_MapInv)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'0 func
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_MapInv) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_MapInv)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_MapInv [inv'2 x]. inv'2 x = invariant''0 x
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'3] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : ()
  
   =
    [%#smap_inv'9] ()
  
  axiom produces_trans_spec'0: forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. ([%#smap_inv'6] produces'0 a ab b)
   -> ([%#smap_inv'7] produces'0 b bc c)  -> ([%#smap_inv'8] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self: t_MapInv) : () =
    [%#smap_inv'5] ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. [%#smap_inv'4] produces'0 self (Seq.empty: Seq.seq t_B) self
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 16 4 16 35] (self: MutBorrow.t t_MapInv) =
    [%#smap_inv'0] (self.final).t_MapInv__produced = (Seq.empty: Seq.seq t_Item)
    /\ completed (MutBorrow.borrow_logic (self.current).t_MapInv__iter (self.final).t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func = (self.final).t_MapInv__func
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 177 4 177 57] (self: t_MapInv) (visited: t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'2] exists f: MutBorrow.t t_F, e: t_Item. f.current = self.t_MapInv__func
    /\ f.final = succ.t_MapInv__func
    /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
    /\ precondition f.current { _p0 = e; _p1 = self.t_MapInv__produced }
    /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited
  
  axiom produces_one_spec: forall self: t_MapInv, visited: t_B, succ: t_MapInv. [%#smap_inv'1] produces_one self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#smap_inv] forall self_: MutBorrow.t t_MapInv. inv'2 self_
   -> inv'2 self_
  /\ (forall result: t_Option. match result with
    | C_None -> completed'0 self_
    | C_Some v -> produces_one self_.current v self_.final
    end
  /\ inv'4 result
   -> match result with
    | C_None -> completed'0 self_
    | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
    end
  /\ inv'4 result)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'0] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srange] forall self: t_Range. forall result: (). produces_back self (Seq.empty: Seq.seq t_Idx) self
   -> produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'0] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srange] forall a: t_Range. forall ab: Seq.seq t_Idx. forall b: t_Range. forall bc: Seq.seq t_Idx. forall c: t_Range. produces_back b bc c
  /\ produces_back a ab b
   -> produces_back b bc c
  /\ produces_back a ab b
  /\ (forall result: (). produces_back a (Seq.(++) ab bc) c  -> produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'1] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srange] forall self: t_RangeInclusive. forall result: (). produces_back self (Seq.empty: Seq.seq t_Idx) self
   -> produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 236 14 236 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 224 4 224 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 230 4 230 27] (self: t_RangeInclusive) : t_Idx
  
  predicate is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 237 4 240 35] (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'1] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#srange] forall a: t_RangeInclusive. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive. produces_back b bc c
  /\ produces_back a ab b
   -> produces_back b bc c
  /\ produces_back a ab b
  /\ (forall result: (). produces_back a (Seq.(++) ab bc) c  -> produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__hist_inv_trans__refines [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 147 4 147 45
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sops] forall self: t_F. forall b: t_F. forall c: t_F. hist_inv b c /\ hist_inv self b
   -> hist_inv b c /\ hist_inv self b /\ (forall result: (). hist_inv self c  -> hist_inv self c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__fn_mut_once__refines [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 153 4 153 55
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Args) (result: t_Output)
  
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sops] forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
   -> postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__postcondition_mut_hist_inv__refines [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 135 4 135 87
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sops] forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. postcondition_mut self args res_state res
   -> postcondition_mut self args res_state res
  /\ (forall result: (). hist_inv self res_state  -> hist_inv self res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__hist_inv_refl__refines [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 140 4 140 26
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sops] forall self: t_F. forall result: (). hist_inv self self  -> hist_inv self self
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_mut__refines [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 170 4 170 67
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: t_F) (args: t_Args) (result: t_Output)
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sops] forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. forall result: (). postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
   -> postcondition_mut self args res_state res = (postcondition self args res /\ self = res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_once__refines [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 175 4 175 51
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_F) (args: t_Args) (result: t_Output)
  
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: t_F) (args: t_Args) (result: t_Output)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sops] forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once self args res
  = (postcondition self args res /\ resolve self)
   -> postcondition_once self args res = (postcondition self args res /\ resolve self)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_hist_inv__refines [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 180 4 180 41
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sops] forall self: t_F. forall res_state: t_F. forall result: (). hist_inv self res_state
  = (self = res_state)  -> hist_inv self res_state = (self = res_state)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (* <*const T as std::ptr::PointerExt<T>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 60 4 60 34
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self: Opaque.ptr) : UInt64.t
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sptr] forall self: Opaque.ptr. forall result: bool. result = (addr_logic self = (0: UInt64.t))
   -> result = (addr_logic self = (0: UInt64.t))
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 75 4 75 34
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 68 4 68 32] (self: Opaque.ptr) : UInt64.t
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sptr] forall self: Opaque.ptr. forall result: bool. result = (addr_logic self = (0: UInt64.t))
   -> result = (addr_logic self = (0: UInt64.t))
end
module M_creusot_contracts__fn_pure__qyi11638360339920708941__clone__refines [#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (* <fn_pure::FnPureWrapper<F> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span slib = "../../creusot-contracts/src/lib.rs" 1 0 165 4
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 30 4 30 27
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'0 x]. inv'0 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FnPureWrapper) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x = invariant' x
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: ()) (args: t_F) (result: t_F)
  
  
  axiom postcondition_fndef: [%#slib] forall args: t_F, res: t_F [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 39] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  
  axiom postcondition_fndef'0: [%#slib] forall args: t_F, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 153 4 153 55] (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_F, res: t_F. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 127 4 127 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 147 4 147 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 140 4 140 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 87] (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_F, res_state: (), res: t_F. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 180 4 180 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1: [%#slib] forall args: t_F, res: t_F [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 175 4 175 51] (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_spec: forall self: (), args: t_F, res: t_F. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 170 4 170 67] (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_F, res_state: (), res: t_F. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_F) =
    [%#sinvariant] inv self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_F [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: ()) (args: t_F)
  
  axiom precondition_fndef: [%#slib] forall args: t_F [precondition () args]. (let self_ = args in inv'2 self_)
   -> precondition () args
  
  let rec clone' (self_:t_F) (return'  (x:t_F))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_F)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfn_pure] forall self_: t_FnPureWrapper. inv'1 self_
   -> inv'1 self_
  /\ (forall result: t_FnPureWrapper. postcondition () self_.t_FnPureWrapper__0 result.t_FnPureWrapper__0
  /\ inv'0 result  -> inv'0 result)
end
module M_creusot_contracts__ghost__qyi11517682701084838082__clone__refines [#"../../creusot-contracts/src/ghost.rs" 55 4 55 27] (* <ghost::Ghost<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 55 4 55 27
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_T) =
    [%#sghost'0] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_T)
  
  axiom inv_axiom [@rewrite]: forall x:  t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self:  t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x:  t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sghost] forall self_:  t_T. inv'1 self_
   -> inv'1 self_ /\ (forall result:  t_T. result = self_ /\ inv'0 result  -> inv'0 result)
end
module M_creusot_contracts__logic__fmap__qyi1775402764303793352__clone__refines [#"../../creusot-contracts/src/logic/fmap.rs" 497 4 497 27] (* <logic::fmap::FMap<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 497 4 497 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 511 20 511 76
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 265 8 265 24
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 108 8 108 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 115 4 115 39] (self: t_FMap) (k: t_K)
  
   =
    [%#sfmap'1] get self k <> C_None
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_K)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_V)
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option) : t_V =
    [%#soption'0] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: t_V) -> true)
      end
  
  function lookup [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 107 4 107 34] (self: t_FMap) (k: t_K) : t_V
  
   =
    [%#sfmap'4] unwrap_logic (get self k)
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 264 4 264 46] (self: t_FMap) (key: t_K) : t_V
  
   =
    [%#sfmap'2] lookup self key
  
  predicate invariant' [#"../../creusot-contracts/src/logic/fmap.rs" 510 4 510 30] (self: t_FMap) =
    [%#sfmap'0] forall k: t_K. contains self k  -> inv k /\ inv'0 (index_logic'0 self k)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMap)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FMap) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMap)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''0 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall self_: t_FMap. inv'2 self_
   -> inv'2 self_ /\ (forall result: t_FMap. result = self_ /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__logic__fset__qyi13324666171263681189__clone__refines [#"../../creusot-contracts/src/logic/fset.rs" 468 4 468 27] (* <logic::fset::FSet<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 468 4 468 27
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 482 20 482 60
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 43 8 43 26
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 42 4 42 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/logic/fset.rs" 481 4 481 30] (self: Fset.fset t_T) =
    [%#sfset'0] forall x: t_T. contains self x  -> inv x
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Fset.fset t_T)
  
  axiom inv_axiom [@rewrite]: forall x: Fset.fset t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: Fset.fset t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Fset.fset t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Fset.fset t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfset] forall self_: Fset.fset t_T. inv'1 self_
   -> inv'1 self_ /\ (forall result: Fset.fset t_T. result = self_ /\ inv'0 result  -> inv'0 result)
end
module M_creusot_contracts__logic__seq__qyi7164078029063507335__clone__refines [#"../../creusot-contracts/src/logic/seq.rs" 670 4 670 27] (* <logic::seq::Seq<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 670 4 670 27
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 683 20 683 91
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/seq.rs" 682 4 682 30] (self: Seq.seq t_T) =
    [%#sseq'0] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'0 (Seq.get self i)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: Seq.seq t_T) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sseq] forall self_: Seq.seq t_T. inv'2 self_
   -> inv'2 self_ /\ (forall result: Seq.seq t_T. result = self_ /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__resource__fmap_view__qyi10168537497030408938__clone__refines [#"../../creusot-contracts/src/resource/fmap_view.rs" 124 4 124 27] (* <resource::fmap_view::Fragment<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 92 14 92 78
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 94 8 94 83
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 52 14 52 31
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 53 14 53 43
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 28 14 28 32
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 33 14 33 99
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 124 4 124 27
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 66 8 66 26
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 47 20 47 68
  let%span sresource = "../../creusot-contracts/src/resource.rs" 48 12 48 22
  
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Resource
  
  type t_K
  
  type t_V
  
  type t_Fragment  =
    { t_Fragment__0: t_Resource; t_Fragment__1: t_K; t_Fragment__2: t_V }
  
  type t_FMap
  
  type t_Ag  =
    { t_Ag__0: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap] Map.get (view self) k
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_FMap t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option'1
  
   =
    [%#soption'5] match self with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'1] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'3] and_then_logic'1 (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_Ag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'2] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'1
  
   =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'1 other
      | {_p1 = C_None} -> C_Some'1 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_Ag) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'4] and_then_logic'0 (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'10] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)
   -> ([%#sfmap'11] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option'0
   =
    [%#sfmap'6] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some'0 (total_op self other)
    else
      C_None'0
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'3] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'2] op'1 a b = op'1 b a
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'12] len self >= 0
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 54 4 54 26]  : t_FMap
  
  axiom empty_spec: [%#sfmap'7] len empty = 0
  
  axiom empty_spec'0: [%#sfmap'8] view empty = Const.const (C_None)
  
  constant unit': t_FMap = [%#sfmap'1] let _ = let _ = () in () in empty
  
  axiom unit_spec: [%#sfmap'0] forall x: t_FMap [op'1 x unit']. op'1 x unit' = C_Some'0 x
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a: t_Option) (b: t_Option) : ()
  
  axiom commutative_spec'1: forall a: t_Option, b: t_Option. [%#soption'3] op'0 a b = op'0 b a
  
  function factor [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (self: t_Ag) (factor'0: t_Ag) : t_Option
   =
    [%#sagree'0] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Ag. op factor'0 c <> C_Some self
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option) (factor'1: t_Option) : t_Option'1
  
   =
    [%#soption'1] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None} -> C_Some'1 x
      | {_p0 = C_None} -> C_None'1
      | {_p0 = C_Some x ; _p1 = C_Some y} -> match factor x y with
        | C_Some z -> C_Some'1 (C_Some z)
        | C_None -> if x = y then C_Some'1 (C_None) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option, factor'1: t_Option. [%#soption'0] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_Option. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option) (other: t_Option) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom incl_transitive_spec: forall a: t_Option, b: t_Option, c: t_Option. ([%#sra'2] incl a b)
   -> ([%#sra'3] incl b c)  -> ([%#sra'4] incl a c)
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Option) (other: t_Option) (comb: t_Option) : ()
  
  
  axiom incl_op_spec: forall self: t_Option, other: t_Option, comb: t_Option. ([%#sra'0] op'0 self other
  = C_Some'1 comb)  -> ([%#sra'1] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_Ag }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_Option) (a: tuple'0) : t_Option
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'0 t_Option) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'0 t_Option. [%#sfmap'9] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None -> C_None
    | C_Some v -> index_logic f { _p0'0 = k; _p1'0 = v }
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (self: t_FMap) (factor'2: t_FMap) : t_Option'0
  
   =
    [%#sfmap'5] if forall k: t_K. incl (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'0) -> let {_p0'0 = k ; _p1'0 = vo} = __0 in match factor'0 (C_Some vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None
        end) in let _ = let _ = () in () in C_Some'0 res
    else
      C_None'0
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'4] match factor'1 self factor'2 with
    | C_Some'0 c -> op'1 factor'2 c = C_Some'0 self
    | C_None'0 -> forall c: t_FMap. op'1 factor'2 c <> C_Some'0 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None'0
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom incl_transitive_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. ([%#sra'2] incl'0 a b)
   -> ([%#sra'3] incl'0 b c)  -> ([%#sra'4] incl'0 a c)
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_FMap) (other: t_FMap) (comb: t_FMap) : ()
  
  
  axiom incl_op_spec'0: forall self: t_FMap, other: t_FMap, comb: t_FMap. ([%#sra'0] op'1 self other = C_Some'0 comb)
   -> ([%#sra'1] incl'0 self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option'0) (f: t_FMap) =
    [%#sauth] match a with
      | C_Some'0 a'0 -> incl'0 f a'0
      | C_None'0 -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option'0) : ()
  
  axiom rel_unit_spec: forall a: t_Option'0. [%#sauth'4] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option'0) (f: t_FMap) : ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_FMap. [%#sauth'3] rel (C_None'0) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option'0) (f1: t_FMap) (f2: t_FMap) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'0, f1: t_FMap, f2: t_FMap. ([%#sauth'0] rel a f1)
   -> ([%#sauth'1] incl'0 f2 f1)  -> ([%#sauth'2] rel a f2)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'0
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_FMap
  
  axiom frag_spec: forall self: t_View. [%#sview] rel (auth self) (frag self)
  
  function val' [#"../../creusot-contracts/src/resource.rs" 76 8 76 29] (self: t_Resource) : t_View
  
  function view'0 [#"../../creusot-contracts/src/resource.rs" 47 8 47 26] (self: t_Resource) : t_View =
    [%#sresource] val' self
  
  predicate invariant' [#"../../creusot-contracts/src/resource/fmap_view.rs" 46 4 46 30] (self: t_Fragment) =
    [%#sfmap_view'1] get (frag (view'0 self.t_Fragment__0)) self.t_Fragment__1 = C_Some { t_Ag__0 = self.t_Fragment__2 }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fragment)
  
  axiom inv_axiom [@rewrite]: forall x: t_Fragment [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Fragment__0 = a_0 ; t_Fragment__1 = a_1 ; t_Fragment__2 = a_2} -> true
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Fragment) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fragment)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fragment [inv'0 x]. inv'0 x = invariant''0 x
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  function view'1 [#"../../creusot-contracts/src/resource/fmap_view.rs" 65 4 65 27] (self: t_Fragment) : tuple'1 =
    [%#sfmap_view'0] { _p0'1 = self.t_Fragment__1; _p1'1 = self.t_Fragment__2 }
  
  function view'2 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Fragment) : tuple'1 =
    [%#smodel] view'1 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap_view] forall self_: t_Fragment. inv'0 self_
   -> inv'0 self_ /\ (forall result: t_Fragment. view'1 result = view'2 self_ /\ inv result  -> inv result)
end
module M_creusot_contracts__fn_pure__qyi15308794846353696785__call_once__refines [#"../../creusot-contracts/src/fn_pure.rs" 44 4 44 66] (* <fn_pure::FnPureWrapper<F> as std::ops::FnOnce<I>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 44 4 44 66
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_FnPureWrapper) (args: t_I) =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: t_F) (args: t_I) (result: t_Output)
  
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self: t_FnPureWrapper) (args: t_I) (result: t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfn_pure] forall self_: t_FnPureWrapper. forall arg: t_I. precondition'0 self_ arg
  /\ inv arg /\ inv'1 self_
   -> precondition'0 self_ arg
  /\ inv arg
  /\ inv'1 self_
  /\ (forall result: t_Output. postcondition_once self_ arg result /\ inv'2 result
   -> postcondition_once self_ arg result /\ inv'2 result)
end
module M_creusot_contracts__fn_pure__qyi5108156253941351966__call_mut__refines [#"../../creusot-contracts/src/fn_pure.rs" 54 4 54 70] (* <fn_pure::FnPureWrapper<F> as std::ops::FnMut<I>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 54 4 54 70
  
  use creusot.prelude.MutBorrow
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_FnPureWrapper) (args: t_I) =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_FnPureWrapper) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_FnPureWrapper [inv'2 x]. inv'2 x = invariant' x
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: t_F) (args: t_I) (result: t_Output)
  
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 118 4 118 92] (self: t_FnPureWrapper) (args: t_I) (result_state: t_FnPureWrapper) (result: t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result /\ self = result_state
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfn_pure] forall self_: MutBorrow.t t_FnPureWrapper. forall arg: t_I. precondition'0 self_.current arg
  /\ inv arg /\ inv'2 self_
   -> precondition'0 self_.current arg
  /\ inv arg
  /\ inv'2 self_
  /\ (forall result: t_Output. postcondition_mut self_.current arg self_.final result /\ inv'3 result
   -> postcondition_mut self_.current arg self_.final result /\ inv'3 result)
end
module M_creusot_contracts__fn_pure__qyi448029234342275964__call__refines [#"../../creusot-contracts/src/fn_pure.rs" 64 4 64 62] (* <fn_pure::FnPureWrapper<F> as std::ops::Fn<I>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 64 4 64 62
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_F) (args: t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 97 4 97 45] (self: t_FnPureWrapper) (args: t_I) =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FnPureWrapper) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FnPureWrapper [inv'2 x]. inv'2 x = invariant' x
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: t_F) (args: t_I) (result: t_Output)
  
  
  predicate postcondition'0 [#"../../creusot-contracts/src/std/ops.rs" 163 4 163 68] (self: t_FnPureWrapper) (args: t_I) (result: t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfn_pure] forall self_: t_FnPureWrapper. forall arg: t_I. precondition'0 self_ arg
  /\ inv arg /\ inv'2 self_
   -> precondition'0 self_ arg
  /\ inv arg
  /\ inv'2 self_
  /\ (forall result: t_Output. postcondition'0 self_ arg result /\ inv'3 result
   -> postcondition'0 self_ arg result /\ inv'3 result)
end
module M_creusot_contracts__invariant__qyi13867431616591602486__eq__refines [#"../../creusot-contracts/src/invariant.rs" 312 4 312 36] (* <invariant::Subset<T> as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 312 4 312 36
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 173 20 173 38
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  type t_Subset
  
  type t_DeepModelTy
  
  type t_T
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 72 4 72 31] (self: t_T)
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function deep_model'0 [#"../../creusot-contracts/src/invariant.rs" 172 4 172 41] (self: t_Subset) : t_DeepModelTy =
    [%#sinvariant'0] deep_model (view self)
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Subset) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sinvariant] forall self_: t_Subset. forall rhs: t_Subset. forall result: bool. result
  = (deep_model'1 self_ = deep_model'1 rhs)  -> result = (deep_model'1 self_ = deep_model'1 rhs)
end
module M_creusot_contracts__logic__id__qyi14416423697585690270__ne__refines [#"../../creusot-contracts/src/logic/id.rs" 37 4 37 38] (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span sid = "../../creusot-contracts/src/logic/id.rs" 37 4 37 38
  let%span sid'0 = "../../creusot-contracts/src/logic/id.rs" 48 8 48 12
  
  type t_Id
  
  function deep_model [#"../../creusot-contracts/src/logic/id.rs" 47 4 47 44] (self: t_Id) : t_Id =
    [%#sid'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Id) : t_Id =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sid] forall self_: t_Id. forall rhs: t_Id. forall result: bool. result <> (self_ = rhs)
   -> result = (deep_model'0 self_ <> deep_model'0 rhs)
end
module M_creusot_contracts__logic__id__qyi14416423697585690270__eq__refines [#"../../creusot-contracts/src/logic/id.rs" 31 4 31 38] (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span sid = "../../creusot-contracts/src/logic/id.rs" 31 4 31 38
  let%span sid'0 = "../../creusot-contracts/src/logic/id.rs" 48 8 48 12
  
  type t_Id
  
  function deep_model [#"../../creusot-contracts/src/logic/id.rs" 47 4 47 44] (self: t_Id) : t_Id =
    [%#sid'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Id) : t_Id =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sid] forall self_: t_Id. forall rhs: t_Id. forall result: bool. result = (self_ = rhs)
   -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_creusot_contracts__logic__int__qyi8495612394334423323__eq__refines [#"../../creusot-contracts/src/logic/int.rs" 238 4 238 38] (* <logic::int::Int as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 238 4 238 38
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sint] forall self_: int. forall rhs: int. forall result: bool. result = (self_ = rhs)
   -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_creusot_contracts__peano__qyi14634619887680291373__eq__refines [#"../../creusot-contracts/src/peano.rs" 103 4 103 38] (* <peano::PeanoInt as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span speano = "../../creusot-contracts/src/peano.rs" 103 4 103 38
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 44 8 44 14
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function deep_model [#"../../creusot-contracts/src/peano.rs" 43 4 43 30] (self: t_PeanoInt) : UInt64.t =
    [%#speano'0] self.t_PeanoInt__0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_PeanoInt) : UInt64.t =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#speano] forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: bool. result = (self_ = rhs)
   -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__lt__refines [#"../../creusot-contracts/src/logic/int.rs" 256 4 256 38] (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 256 4 256 38
  
  use mach.int.Int
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sint] forall self_: int. forall other: int. forall result: bool. result = (self_ < other)
   -> result = (deep_model'0 self_ < deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__gt__refines [#"../../creusot-contracts/src/logic/int.rs" 272 4 272 38] (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 272 4 272 38
  
  use mach.int.Int
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sint] forall self_: int. forall other: int. forall result: bool. result = (self_ > other)
   -> result = (deep_model'0 self_ > deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__le__refines [#"../../creusot-contracts/src/logic/int.rs" 264 4 264 38] (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 264 4 264 38
  
  use mach.int.Int
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sint] forall self_: int. forall other: int. forall result: bool. result = (self_ <= other)
   -> result = (deep_model'0 self_ <= deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__ge__refines [#"../../creusot-contracts/src/logic/int.rs" 280 4 280 38] (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 280 4 280 38
  
  use mach.int.Int
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sint] forall self_: int. forall other: int. forall result: bool. result = (self_ >= other)
   -> result = (deep_model'0 self_ >= deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__partial_cmp__refines [#"../../creusot-contracts/src/logic/int.rs" 248 4 248 69] (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span smodel = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 248 4 248 69
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel] self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sint] forall self_: int. forall rhs: int. forall result: t_Option. result
  = C_Some (cmp_log self_ rhs)  -> result = C_Some (cmp_log (deep_model self_) (deep_model rhs))
end
module M_creusot_contracts__peano__qyi18300662544233371341__partial_cmp__refines [#"../../creusot-contracts/src/peano.rs" 89 4 89 59] (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'17 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'18 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'19 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'20 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'21 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'22 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'23 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'24 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'25 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'26 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'27 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'28 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'29 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'30 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'31 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'32 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'33 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'34 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 89 4 89 59
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 44 8 44 14
  let%span speano'2 = "../../creusot-contracts/src/peano.rs" 54 4 54 12
  let%span speano'3 = "../../creusot-contracts/src/peano.rs" 59 4 59 12
  let%span speano'4 = "../../creusot-contracts/src/peano.rs" 64 4 64 12
  let%span speano'5 = "../../creusot-contracts/src/peano.rs" 69 4 69 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'34] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'32] cmp_log x y = C_Greater)
   -> ([%#sord'33] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'30] cmp_log x y = C_Less)
   -> ([%#sord'31] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'27] cmp_log x y = o)
   -> ([%#sord'28] cmp_log y z = o)  -> ([%#sord'29] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'26] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'25] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'24] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'23] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'22] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'21] ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'20] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'19] ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ([%#sord'17] cmp_log'0 x y = C_Greater)
   -> ([%#sord'18] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'16] ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ([%#sord'14] cmp_log'0 x y = C_Less)
   -> ([%#sord'15] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : ()
  
   =
    [%#sord'13] ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. ([%#sord'10] cmp_log'0 x y = o)
   -> ([%#sord'11] cmp_log'0 y z = o)  -> ([%#sord'12] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: t_PeanoInt) : () =
    [%#sord'9] ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. [%#sord'8] cmp_log'0 x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/peano.rs" 71 4 71 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'5] UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'7] ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'6] gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/peano.rs" 66 4 66 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'4] UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'5] ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'4] ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/peano.rs" 61 4 61 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'3] UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'3] ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'2] lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/peano.rs" 56 4 56 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'2] UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'1] ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'0] le_log x y = (cmp_log'0 x y <> C_Greater)
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function deep_model [#"../../creusot-contracts/src/peano.rs" 43 4 43 30] (self: t_PeanoInt) : UInt64.t =
    [%#speano'1] self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#speano] forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: t_Option. result
  = C_Some (cmp_log'0 self_ rhs)  -> result = C_Some (cmp_log (deep_model self_) (deep_model rhs))
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__associative__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 34 4 34 45
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  
  use map.Map
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Ag t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'0] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sagree] forall a: t_Ag. forall b: t_Ag. forall c: t_Ag. forall result: (). and_then_logic (op a b) (fun (ab: t_Ag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Ag) -> op a bc)
   -> and_then_logic (op a b) (fun (ab: t_Ag) -> op ab c) = and_then_logic (op b c) (fun (bc: t_Ag) -> op a bc)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__factor__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'0] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sagree] forall self: t_Ag. forall factor: t_Ag. forall result: t_Option. match result with
    | C_Some c -> op factor c = C_Some self
    | C_None -> forall c: t_Ag. op factor c <> C_Some self
    end
   -> match result with
    | C_Some c -> op factor c = C_Some self
    | C_None -> forall c: t_Ag. op factor c <> C_Some self
    end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__core_is_maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 53 4 53 43] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 53 4 53 43
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 38 14 41 5
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 43 8 43 18
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 18 14 21 5
  let%span sagree'4 = "../../creusot-contracts/src/logic/ra/agree.rs" 23 8 23 23
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'0] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  function core [#"../../creusot-contracts/src/logic/ra/agree.rs" 42 4 42 33] (self: t_Ag) : t_Option =
    [%#sagree'2] C_Some self
  
  axiom core_spec: forall self: t_Ag. [%#sagree'1] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function factor [#"../../creusot-contracts/src/logic/ra/agree.rs" 22 4 22 49] (self: t_Ag) (factor'0: t_Ag) : t_Option
   =
    [%#sagree'4] op self factor'0
  
  axiom factor_spec: forall self: t_Ag, factor'0: t_Ag. [%#sagree'3] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Ag. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Ag) (other: t_Ag) =
    [%#sra] factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sagree] forall self: t_Ag. forall i: t_Ag. op i self = C_Some self /\ op i i = C_Some i
   -> op i self = C_Some self
  /\ op i i = C_Some i
  /\ (forall result: (). match core self with
    | C_Some c -> incl i c
    | C_None -> false
    end
   -> match core self with
    | C_Some c -> incl i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__core__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 42 4 42 33] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 42 4 42 33
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'0] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sagree] forall self: t_Ag. forall result: t_Option. match result with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
   -> match result with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__commutative__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 29 4 29 36
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 13 8 13 57
  
  type t_T
  
  type t_Ag  =
    { t_Ag__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 12 4 12 44] (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'0] if self.t_Ag__0 = other.t_Ag__0 then C_Some self else C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sagree] forall a: t_Ag. forall b: t_Ag. forall result: (). op a b = op b a  -> op a b = op b a
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__commutative__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 36] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 36
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'0] C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sexcl] forall a: t_Excl. forall b: t_Excl. forall result: (). op a b = op b a  -> op a b = op b a
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__associative__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 38 4 38 45] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 38 4 38 45
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  
  use map.Map
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Excl t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'0] C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sexcl] forall a: t_Excl. forall b: t_Excl. forall c: t_Excl. forall result: (). and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
   -> and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c) = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__core_is_maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 57 4 57 43] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 57 4 57 43
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 42 14 45 5
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 47 8 47 12
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 22 14 25 5
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 27 8 27 12
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'0] C_None
  
  function core [#"../../creusot-contracts/src/logic/ra/excl.rs" 46 4 46 33] (self: t_Excl) : t_Option =
    [%#sexcl'2] C_None
  
  axiom core_spec: forall self: t_Excl. [%#sexcl'1] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function factor [#"../../creusot-contracts/src/logic/ra/excl.rs" 26 4 26 49] (self: t_Excl) (factor'0: t_Excl) : t_Option
  
   =
    [%#sexcl'4] C_None
  
  axiom factor_spec: forall self: t_Excl, factor'0: t_Excl. [%#sexcl'3] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_Excl. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Excl) (other: t_Excl) =
    [%#sra] factor other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sexcl] forall self: t_Excl. forall i: t_Excl. op i self = C_Some self /\ op i i = C_Some i
   -> op i self = C_Some self
  /\ op i i = C_Some i
  /\ (forall result: (). match core self with
    | C_Some c -> incl i c
    | C_None -> false
    end
   -> match core self with
    | C_Some c -> incl i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__core__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 46 4 46 33] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 46 4 46 33
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'0] C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sexcl] forall self: t_Excl. forall result: t_Option. match result with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
   -> match result with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__factor__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 26 4 26 49] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 26 4 26 49
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'0] C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sexcl] forall self: t_Excl. forall factor: t_Excl. forall result: t_Option. match result with
    | C_Some c -> op factor c = C_Some self
    | C_None -> forall c: t_Excl. op factor c <> C_Some self
    end
   -> match result with
    | C_Some c -> op factor c = C_Some self
    | C_None -> forall c: t_Excl. op factor c <> C_Some self
    end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__factor__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'5] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                        _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'4] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'2] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'3] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'0] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall self: t_FMap. forall factor'0: t_FMap. forall result: t_Option. match result with
    | C_Some c -> op'1 factor'0 c = C_Some self
    | C_None -> forall c: t_FMap. op'1 factor'0 c <> C_Some self
    end
   -> match result with
    | C_Some c -> op'1 factor'0 c = C_Some self
    | C_None -> forall c: t_FMap. op'1 factor'0 c <> C_Some self
    end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__core__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 73 4 73 33] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 73 4 73 33
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'5] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                        _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'4] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'2] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'3] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'0] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall self: t_FMap. forall result: t_Option. match result with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
   -> match result with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__core_is_maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 84 4 84 43] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 84 4 84 43
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 69 14 72 5
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 74 8 74 31
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 24 14 27 5
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 30 12 45 13
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 32
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'4] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'5] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'12] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                         _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'6] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'4] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'5] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'0] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_Option'0) (a: tuple'1) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'1 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'1 t_Option'0. [%#sfmap'13] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic'1 f { _p0'1 = k; _p1'1 = v }
    end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. [%#sra'0] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (self: t_FMap) : t_FMap =
    [%#sfmap'9] let r = filter_map self (fun (__0: tuple'1) -> let {_p1'1 = v} = __0 in core v) in let _ = let _ = () in () in let _ = let _ = () in () in r
  
  axiom core_total_spec: forall self: t_FMap. [%#sfmap'7] op'1 (core_total self) (core_total self)
  = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. [%#sfmap'8] op'1 (core_total self) self = C_Some self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 73 4 73 33] (self: t_FMap) : t_Option =
    [%#sfmap'2] C_Some (core_total self)
  
  axiom core_spec'0: forall self: t_FMap. [%#sfmap'1] match core'0 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (a: t_Option'0) (b: t_Option'0) : ()
  
  
  axiom commutative_spec'0: forall a: t_Option'0, b: t_Option'0. [%#soption'5] op'0 a b = op'0 b a
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option'0) (factor'1: t_Option'0) : t_Option'1
  
   =
    [%#soption'3] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None'0} -> C_Some'1 x
      | {_p0 = C_None'0} -> C_None'1
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> match factor x y with
        | C_Some'0 z -> C_Some'1 (C_Some'0 z)
        | C_None'0 -> if x = y then C_Some'1 (C_None'0) else C_None'1
        end
      end
  
  axiom factor_spec'0: forall self: t_Option'0, factor'1: t_Option'0. [%#soption'2] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_Option'0. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option'0) (other: t_Option'0) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. ([%#sra'6] incl'0 a b)
   -> ([%#sra'7] incl'0 b c)  -> ([%#sra'8] incl'0 a c)
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Option'0) (other: t_Option'0) (comb: t_Option'0) : ()
  
   =
    [%#sra'3] ()
  
  axiom incl_op_spec'0: forall self: t_Option'0, other: t_Option'0, comb: t_Option'0. ([%#sra'1] op'0 self other
  = C_Some'1 comb)  -> ([%#sra'2] incl'0 self comb)
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 28 4 28 49] (self: t_FMap) (factor'2: t_FMap) : t_Option
  
   =
    [%#sfmap'11] if forall k: t_K. incl'0 (get factor'2 k) (get self k) then
      let res = filter_map self (fun (__0: tuple'1) -> let {_p0'1 = k ; _p1'1 = vo} = __0 in match factor'0 (C_Some'0 vo) (get factor'2 k) with
        | C_Some'1 r -> r
        | C_None'1 -> C_None'0
        end) in let _ = let _ = () in () in C_Some res
    else
      C_None
  
  
  axiom factor_spec'1: forall self: t_FMap, factor'2: t_FMap. [%#sfmap'10] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: t_FMap. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'1 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_FMap) (other: t_FMap) =
    [%#sra] factor'1 other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall self: t_FMap. forall i: t_FMap. op'1 i self = C_Some self /\ op'1 i i = C_Some i
   -> op'1 i self = C_Some self
  /\ op'1 i i = C_Some i
  /\ (forall result: (). match core'0 self with
    | C_Some c -> incl'1 i c
    | C_None -> false
    end
   -> match core'0 self with
    | C_Some c -> incl'1 i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__commutative__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'5] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                        _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'4] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'2] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'3] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'0] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall a: t_FMap. forall b: t_FMap. forall result: (). op'1 a b = op'1 b a
   -> op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__associative__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'5] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                        _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'4] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'2] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'3] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'0] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall a: t_FMap. forall b: t_FMap. forall c: t_FMap. forall result: (). and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
   -> and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__commutative__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 36
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall a: t_Option. forall b: t_Option. forall result: (). op'0 a b = op'0 b a
   -> op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__core__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 66 4 66 33] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 66 4 66 33
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_Option. forall result: t_Option'0. match result with
    | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
    | C_None'0 -> true
    end
   -> match result with
    | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
    | C_None'0 -> true
    end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__core_is_maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 77 4 77 43] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 77 4 77 43
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 62 14 65 5
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 67 8 67 31
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 95 14 95 47
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 96 14 96 43
  let%span soption'6 = "../../creusot-contracts/src/logic/ra/option.rs" 98 8 101 9
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 16 14 19 5
  let%span soption'8 = "../../creusot-contracts/src/logic/ra/option.rs" 21 8 34 9
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'3] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'9] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'10] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. [%#sra'9] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31] (self: t_Option) : t_Option =
    [%#soption'6] match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. [%#soption'4] op'0 (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. [%#soption'5] op'0 (core_total self) self = C_Some'0 self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 66 4 66 33] (self: t_Option) : t_Option'0 =
    [%#soption'2] C_Some'0 (core_total self)
  
  axiom core_spec'0: forall self: t_Option. [%#soption'1] match core'0 self with
    | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (self: t_Option) (factor'1: t_Option) : t_Option'0
  
   =
    [%#soption'8] match { _p0 = self; _p1 = factor'1 } with
      | {_p0 = x ; _p1 = C_None} -> C_Some'0 x
      | {_p0 = C_None} -> C_None'0
      | {_p0 = C_Some x ; _p1 = C_Some y} -> match factor x y with
        | C_Some z -> C_Some'0 (C_Some z)
        | C_None -> if x = y then C_Some'0 (C_None) else C_None'0
        end
      end
  
  axiom factor_spec'0: forall self: t_Option, factor'1: t_Option. [%#soption'7] match factor'0 self factor'1 with
    | C_Some'0 c -> op'0 factor'1 c = C_Some'0 self
    | C_None'0 -> forall c: t_Option. op'0 factor'1 c <> C_Some'0 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Option) (other: t_Option) =
    [%#sra] factor'0 other self <> C_None'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_Option. forall i: t_Option. op'0 i self = C_Some'0 self
  /\ op'0 i i = C_Some'0 i
   -> op'0 i self = C_Some'0 self
  /\ op'0 i i = C_Some'0 i
  /\ (forall result: (). match core'0 self with
    | C_Some'0 c -> incl'0 i c
    | C_None'0 -> false
    end
   -> match core'0 self with
    | C_Some'0 c -> incl'0 i c
    | C_None'0 -> false
    end)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__associative__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall a: t_Option. forall b: t_Option. forall c: t_Option. forall result: (). and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
   -> and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__factor__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49] (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 20 4 20 49
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_Option. forall factor'0: t_Option. forall result: t_Option'0. match result with
    | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
    end
   -> match result with
    | C_Some'0 c -> op'0 factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Option. op'0 factor'0 c <> C_Some'0 self
    end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__commutative__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'0] and_then_logic (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                               _p1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall a: tuple. forall b: tuple. forall result: (). op'1 a b = op'1 b a
   -> op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__factor__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 22 4 22 49] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 4 22 49
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'0] and_then_logic (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                               _p1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall self: tuple. forall factor'1: tuple. forall result: t_Option. match result with
    | C_Some c -> op'1 factor'1 c = C_Some self
    | C_None -> forall c: tuple. op'1 factor'1 c <> C_Some self
    end
   -> match result with
    | C_Some c -> op'1 factor'1 c = C_Some self
    | C_None -> forall c: tuple. op'1 factor'1 c <> C_Some self
    end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__core_is_maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 59 4 59 43] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 59 4 59 43
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 44 5
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 46 8 49 9
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 18 14 21 5
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 23 8 26 9
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'5] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'10] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'6] incl'0 a b)
   -> ([%#sra'7] incl'0 b c)  -> ([%#sra'8] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'5] and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'4] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'3] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra'1] op'0 self other = C_Some'1 comb)
   -> ([%#sra'2] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'0] and_then_logic (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                               _p1 = y }))
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. [%#sra'0] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. [%#sra'0] match core'0 self with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  function core'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 45 4 45 33] (self: tuple) : t_Option =
    [%#sprod'2] match { _p0'0 = core self._p0; _p1'0 = core'0 self._p1 } with
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'1 y} -> C_Some { _p0 = x; _p1 = y }
      | _ -> C_None
      end
  
  axiom core_spec'1: forall self: tuple. [%#sprod'1] match core'1 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 22 4 22 49] (self: tuple) (factor'2: tuple) : t_Option
  
   =
    [%#sprod'4] match { _p0'0 = factor self._p0 factor'2._p0; _p1'0 = factor'0 self._p1 factor'2._p1 } with
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'1 y} -> C_Some { _p0 = x; _p1 = y }
      | _ -> C_None
      end
  
  axiom factor_spec'1: forall self: tuple, factor'2: tuple. [%#sprod'3] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: tuple. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'1 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: tuple) (other: tuple) =
    [%#sra] factor'1 other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall self: tuple. forall i: tuple. op'1 i self = C_Some self /\ op'1 i i = C_Some i
   -> op'1 i self = C_Some self
  /\ op'1 i i = C_Some i
  /\ (forall result: (). match core'1 self with
    | C_Some c -> incl'1 i c
    | C_None -> false
    end
   -> match core'1 self with
    | C_Some c -> incl'1 i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__core__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 45 4 45 33] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 45 4 45 33
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'0] and_then_logic (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                               _p1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall self: tuple. forall result: t_Option. match result with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
   -> match result with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__associative__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'0] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                                 _p1 = y }))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall a: tuple. forall b: tuple. forall c: tuple. forall result: (). and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
   -> and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__associative__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall a: t_Sum. forall b: t_Sum. forall c: t_Sum. forall result: (). and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
   -> and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__core_is_maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 73 4 73 43] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 73 4 73 43
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 55 14 58 5
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 60 8 63 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 31 14 34 5
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 36 8 40 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'5] and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'10] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'6] incl'0 a b)
   -> ([%#sra'7] incl'0 b c)  -> ([%#sra'8] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'5] and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'4] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'3] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra'1] op'0 self other = C_Some'1 comb)
   -> ([%#sra'2] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_R1) : t_Option'0
  
  axiom core_spec: forall self: t_R1. [%#sra'0] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_R2) : t_Option'1
  
  axiom core_spec'0: forall self: t_R2. [%#sra'0] match core'0 self with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  function core'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 59 4 59 33] (self: t_Sum) : t_Option =
    [%#ssum'2] match self with
      | C_Left x -> map_logic (core x) (fun (l: t_R1) -> C_Left l)
      | C_Right x -> map_logic'0 (core'0 x) (fun (r: t_R2) -> C_Right r)
      end
  
  axiom core_spec'1: forall self: t_Sum. [%#ssum'1] match core'1 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  function factor'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 35 4 35 49] (self: t_Sum) (factor'2: t_Sum) : t_Option
  
   =
    [%#ssum'4] match { _p0 = self; _p1 = factor'2 } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (factor x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (factor'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  axiom factor_spec'1: forall self: t_Sum, factor'2: t_Sum. [%#ssum'3] match factor'1 self factor'2 with
    | C_Some c -> op'1 factor'2 c = C_Some self
    | C_None -> forall c: t_Sum. op'1 factor'2 c <> C_Some self
    end
  
  predicate incl'1 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Sum) (other: t_Sum) =
    [%#sra] factor'1 other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_Sum. forall i: t_Sum. op'1 i self = C_Some self /\ op'1 i i = C_Some i
   -> op'1 i self = C_Some self
  /\ op'1 i i = C_Some i
  /\ (forall result: (). match core'1 self with
    | C_Some c -> incl'1 i c
    | C_None -> false
    end
   -> match core'1 self with
    | C_Some c -> incl'1 i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__commutative__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall a: t_Sum. forall b: t_Sum. forall result: (). op'1 a b = op'1 b a
   -> op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__factor__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 35 4 35 49] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 35 4 35 49
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_Sum. forall factor'1: t_Sum. forall result: t_Option. match result with
    | C_Some c -> op'1 factor'1 c = C_Some self
    | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
    end
   -> match result with
    | C_Some c -> op'1 factor'1 c = C_Some self
    | C_None -> forall c: t_Sum. op'1 factor'1 c <> C_Some self
    end
end
module M_creusot_contracts__logic__ra__sum__qyi4205504013086611447__core__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 59 4 59 33] (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 59 4 59 33
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'0 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_Sum. forall result: t_Option. match result with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
   -> match result with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__commutative__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'13] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'11] rel a f)  -> ([%#sview'12] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'8] rel a f1)
   -> ([%#sview'9] incl f2 f1)  -> ([%#sview'10] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'14] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'3] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'2] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'1] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'7] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'4] rel auth'0 frag'0)
   -> ([%#sview'5] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'4] rel auth'0 frag'0)
   -> ([%#sview'6] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall a: t_View. forall b: t_View. forall result: (). op'0 a b = op'0 b a
   -> op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__core_is_maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 197 4 197 43] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 197 4 197 43
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 182 14 185 5
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 187 8 187 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 134 14 137 5
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 139 8 139 49
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'11] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'4] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'9] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'10] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'12] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'16] ()
  
  axiom unit_core_spec: [%#sra'15] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'14] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'13] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'20] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'18] rel a f)  -> ([%#sview'19] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'15] rel a f1)
   -> ([%#sview'16] incl f2 f1)  -> ([%#sview'17] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'23] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'5] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'4] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'3] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'9] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'6] rel auth'0 frag'0)
   -> ([%#sview'7] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'6] rel auth'0 frag'0)
   -> ([%#sview'8] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_Frag) : t_View =
    [%#sview'22] new (C_None'1) frag'0
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (self: t_View) : t_View =
    [%#sview'12] let _ = () in let _ = () in new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. [%#sview'10] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. [%#sview'11] op'0 (core_total'0 self) self = C_Some self
  
  function core [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (self: t_View) : t_Option =
    [%#sview'2] C_Some (core_total'0 self)
  
  axiom core_spec: forall self: t_View. [%#sview'1] match core self with
    | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
    | C_None -> true
    end
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 138 4 138 49] (self: t_View) (factor'1: t_View) : t_Option
  
   =
    [%#sview'14] let _ = () in match factor (frag self) (frag factor'1) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth factor'1 } with
        | {_p0 = C_Some'1 a ; _p1 = C_None'1} -> C_Some (new (C_Some'1 a) f)
        | {_p0 = a1 ; _p1 = a2} -> if a1 = a2 then C_Some (new_frag f) else C_None
        end
      | C_None'0 -> C_None
      end
  
  axiom factor_spec'0: forall self: t_View, factor'1: t_View. [%#sview'13] match factor'0 self factor'1 with
    | C_Some c -> op'0 factor'1 c = C_Some self
    | C_None -> forall c: t_View. op'0 factor'1 c <> C_Some self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_View) (other: t_View) =
    [%#sra] factor'0 other self <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_View. forall i: t_View. op'0 i self = C_Some self /\ op'0 i i = C_Some i
   -> op'0 i self = C_Some self
  /\ op'0 i i = C_Some i
  /\ (forall result: (). match core self with
    | C_Some c -> incl'0 i c
    | C_None -> false
    end
   -> match core self with
    | C_Some c -> incl'0 i c
    | C_None -> false
    end)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__factor__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 138 4 138 49] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 138 4 138 49
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'13] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'11] rel a f)  -> ([%#sview'12] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'8] rel a f1)
   -> ([%#sview'9] incl f2 f1)  -> ([%#sview'10] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'14] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'3] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'2] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'1] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'7] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'4] rel auth'0 frag'0)
   -> ([%#sview'5] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'4] rel auth'0 frag'0)
   -> ([%#sview'6] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_View. forall factor'0: t_View. forall result: t_Option. match result with
    | C_Some c -> op'0 factor'0 c = C_Some self
    | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
    end
   -> match result with
    | C_Some c -> op'0 factor'0 c = C_Some self
    | C_None -> forall c: t_View. op'0 factor'0 c <> C_Some self
    end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__core__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'13] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'11] rel a f)  -> ([%#sview'12] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'8] rel a f1)
   -> ([%#sview'9] incl f2 f1)  -> ([%#sview'10] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'14] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'3] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'2] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'1] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'7] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'4] rel auth'0 frag'0)
   -> ([%#sview'5] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'4] rel auth'0 frag'0)
   -> ([%#sview'6] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_View. forall result: t_Option. match result with
    | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
    | C_None -> true
    end
   -> match result with
    | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
    | C_None -> true
    end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__associative__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'13] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'11] rel a f)  -> ([%#sview'12] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'8] rel a f1)
   -> ([%#sview'9] incl f2 f1)  -> ([%#sview'10] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'14] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'3] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'2] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'1] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'7] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'4] rel auth'0 frag'0)
   -> ([%#sview'5] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'4] rel auth'0 frag'0)
   -> ([%#sview'6] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall a: t_View. forall b: t_View. forall c: t_View. forall result: (). and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
   -> and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_mono__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_T) =
    [%#sauth'0] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sauth] forall a: t_Option. forall f1: t_T. forall f2: t_T. incl f2 f1 /\ rel a f1
   -> incl f2 f1 /\ rel a f1 /\ (forall result: (). rel a f2  -> rel a f2)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_unit__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'14] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'0] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'13] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'10] incl a b)
   -> ([%#sra'11] incl b c)  -> ([%#sra'12] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'9] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'8] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'7] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'5] op self other = C_Some comb)
   -> ([%#sra'6] incl self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_T) =
    [%#sauth'0] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. [%#sra'15] op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. [%#sra'16] op (core_total self) self = C_Some self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_T
  
  axiom unit_spec: [%#sra] forall x: t_T [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = [%#sra'4] ()
  
  axiom unit_core_spec: [%#sra'3] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'2] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'1] forall x: t_T. incl x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sauth] forall a: t_Option. forall result: (). rel a unit'  -> rel a unit'
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_none__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] and_then_logic (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_T) =
    [%#sauth'0] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sauth] forall a: t_Option. forall f: t_T. rel a f
   -> (forall result: (). rel (C_None) f  -> rel (C_None) f)
end
module M_creusot_contracts__logic__ra__auth__qyi1963254905082259216__update__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 72 4 72 52] (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 72 4 72 52
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 59 8 62 9
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 40 44 40 46
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'7 = "../../creusot-contracts/src/logic/ra/auth.rs" 44 36 44 38
  let%span sauth'8 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sauth'9 = "../../creusot-contracts/src/logic/ra/auth.rs" 48 30 48 32
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate  =
    { t_AuthUpdate__0: t_U }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'10] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'5] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra'1] op self other = C_Some comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_R) : t_R
  
  axiom core_total_spec: forall self: t_R. [%#sra'15] op (core_total self) (core_total self) = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_R. [%#sra'16] op (core_total self) self = C_Some self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_R
  
  axiom unit_spec: [%#sra'0] forall x: t_R [op x unit']. op x unit' = C_Some x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_R. incl x x
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option) (f: t_R) =
    [%#sauth'1] match a with
      | C_Some a'0 -> incl f a'0
      | C_None -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option) : () =
    [%#sauth'9] ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sauth'8] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option) (f: t_R) : () =
    [%#sauth'7] ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_R. [%#sauth'6] rel (C_None) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option) (f1: t_R) (f2: t_R) : ()
   =
    [%#sauth'5] ()
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_R, f2: t_R. ([%#sauth'2] rel a f1)
   -> ([%#sauth'3] incl f2 f1)  -> ([%#sauth'4] rel a f2)
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_R
  
  axiom frag_spec: forall self: t_View. [%#sview] rel (auth self) (frag self)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 58 4 58 43] (self: t_AuthUpdate) (from: t_View) =
    [%#sauth'0] match auth from with
      | C_Some auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None -> false
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sauth] forall self: t_AuthUpdate. forall from: t_View. forall ch: (). premise'0 self from
   -> premise'0 self from
end
module M_creusot_contracts__logic__ra__auth__qyi1963254905082259216__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 82 4 82 60] (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 15 751 27
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 753 8 756 9
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 82 4 82 60
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 59 8 62 9
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 67 15 67 33
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 69 8 69 82
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 73 8 73 82
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 30 8 33 9
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 37 15 37 31
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 38 15 38 26
  let%span sauth'7 = "../../creusot-contracts/src/logic/ra/auth.rs" 39 14 39 30
  let%span sauth'8 = "../../creusot-contracts/src/logic/ra/auth.rs" 40 44 40 46
  let%span sauth'9 = "../../creusot-contracts/src/logic/ra/auth.rs" 43 14 43 32
  let%span sauth'10 = "../../creusot-contracts/src/logic/ra/auth.rs" 44 36 44 38
  let%span sauth'11 = "../../creusot-contracts/src/logic/ra/auth.rs" 47 14 47 37
  let%span sauth'12 = "../../creusot-contracts/src/logic/ra/auth.rs" 48 30 48 32
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_R
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option'0
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_R) : t_R
  
  axiom core_total_spec: forall self: t_R. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_R. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_R
  
  axiom unit_spec: [%#sra'9] forall x: t_R [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_R. incl x x
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 38] (a: t_Option'0) (f: t_R) =
    [%#sauth'4] match a with
      | C_Some'0 a'0 -> incl f a'0
      | C_None'0 -> true
      end
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/auth.rs" 48 4 48 29] (a: t_Option'0) : () =
    [%#sauth'12] ()
  
  axiom rel_unit_spec: forall a: t_Option'0. [%#sauth'11] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/auth.rs" 44 4 44 35] (a: t_Option'0) (f: t_R) : () =
    [%#sauth'10] ()
  
  axiom rel_none_spec: forall a: t_Option'0, f: t_R. [%#sauth'9] rel (C_None'0) f
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 40 4 40 43] (a: t_Option'0) (f1: t_R) (f2: t_R) : ()
  
   =
    [%#sauth'8] ()
  
  axiom rel_mono_spec: forall a: t_Option'0, f1: t_R, f2: t_R. ([%#sauth'5] rel a f1)
   -> ([%#sauth'6] incl f2 f1)  -> ([%#sauth'7] rel a f2)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'0
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_R
  
  axiom frag_spec: forall self: t_View. [%#sview'2] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'0) (frag'0: t_R) : t_View
  
  axiom new_spec: forall auth'0: t_Option'0, frag'0: t_R. ([%#sview'3] rel auth'0 frag'0)
   -> ([%#sview'4] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'0, frag'0: t_R. ([%#sview'3] rel auth'0 frag'0)
   -> ([%#sview'5] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'0 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'0} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'1] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'0] op'0 a b = op'0 b a
  
  type t_U
  
  type t_AuthUpdate  =
    { t_AuthUpdate__0: t_U }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 58 4 58 43] (self: t_AuthUpdate) (from: t_View) =
    [%#sauth'0] match auth from with
      | C_Some'0 auth'0 -> premise self.t_AuthUpdate__0 auth'0 (frag from)
      | C_None'0 -> false
      end
  
  type tuple'0  =
    { _p0'0: t_R; _p1'0: t_R }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U) (from_auth: t_R) (from_frag: t_R) : tuple'0
  
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_R bool) (a: t_R) =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_R bool) : t_R
  
  axiom such_that_spec: forall p: Map.map t_R bool. ([%#sutil] exists x: t_R. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function unwrap_logic [#"../../creusot-contracts/src/std/option.rs" 752 4 752 30] (self: t_Option'0) : t_R =
    [%#soption'0] match self with
      | C_Some'0 x -> x
      | C_None'0 -> such_that (fun (__0: t_R) -> true)
      end
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 72 4 72 52] (self: t_AuthUpdate) (from: t_View) (_2: ()) : t_View
  
   =
    [%#sauth'3] let {_p0'0 = auth'0 ; _p1'0 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in let _ = () in new (C_Some'0 auth'0) frag'0
  
  axiom update_spec: forall self: t_AuthUpdate, from: t_View, _2: (). ([%#sauth'1] premise'0 self from)
   -> ([%#sauth'2] let {_p0'0 = auth'0 ; _p1'0 = frag'0} = update self.t_AuthUpdate__0 (unwrap_logic (auth from)) (frag from) in rel (C_Some'0 auth'0) frag'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sauth] forall self: t_AuthUpdate. forall from: t_View. forall frame: t_View. op'0 from frame
  <> C_None
  /\ premise'0 self from
   -> op'0 from frame <> C_None
  /\ premise'0 self from
  /\ (forall result: (). op'0 (update'0 self from result) frame <> C_None
   -> op'0 (update'0 self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__excl__qyi10476702783314713742__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 82 4 82 60] (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 82 4 82 60
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 17 8 17 12
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 68 8 68 12
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 73 15 73 33
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 75 8 75 21
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 32
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 33 37 33 39
  let%span sexcl'6 = "../../creusot-contracts/src/logic/ra/excl.rs" 37 14 37 98
  let%span sexcl'7 = "../../creusot-contracts/src/logic/ra/excl.rs" 38 46 38 48
  
  use map.Map
  
  type t_T
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Excl t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 16 4 16 45] (self: t_Excl) (_other: t_Excl) : t_Option =
    [%#sexcl'0] C_None
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 38 4 38 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
   =
    [%#sexcl'7] ()
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'6] and_then_logic (op a b) (fun (ab: t_Excl) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Excl) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 36] (a: t_Excl) (b: t_Excl) : () =
    [%#sexcl'5] ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'4] op a b = op b a
  
  type t_ExclUpdate  =
    { t_ExclUpdate__0: t_T }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/excl.rs" 67 4 67 40] (self: t_ExclUpdate) (_1: t_Excl) =
    [%#sexcl'1] true
  
  function update [#"../../creusot-contracts/src/logic/ra/excl.rs" 74 4 74 52] (self: t_ExclUpdate) (from: t_Excl) (_2: ()) : t_Excl
  
   =
    [%#sexcl'3] { t_Excl__0 = self.t_ExclUpdate__0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sexcl] forall self: t_ExclUpdate. forall from: t_Excl. forall frame: t_Excl. op from frame <> C_None
  /\ premise self from
   -> op from frame <> C_None
  /\ premise self from
  /\ (forall result: (). op (update self from result) frame <> C_None  -> op (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__excl__qyi10476702783314713742__update__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 74 4 74 52] (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 74 4 74 52
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 68 8 68 12
  
  type t_T
  
  type t_ExclUpdate  =
    { t_ExclUpdate__0: t_T }
  
  type t_Excl  =
    { t_Excl__0: t_T }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/excl.rs" 67 4 67 40] (self: t_ExclUpdate) (_1: t_Excl) =
    [%#sexcl'0] true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sexcl] forall self: t_ExclUpdate. forall from: t_Excl. forall ch: (). premise self from
   -> premise self from
end
module M_creusot_contracts__logic__ra__option__qyi9919140421117497760__update__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 126 4 126 64] (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 126 4 126 64
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 117 8 120 9
  
  type t_U
  
  type t_OptionUpdate  =
    { t_OptionUpdate__0: t_U }
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 116 4 116 45] (self: t_OptionUpdate) (from: t_Option)
  
   =
    [%#soption'0] match from with
      | C_Some from'0 -> premise self.t_OptionUpdate__0 from'0
      | C_None -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_OptionUpdate. forall from: t_Option. forall ch: t_Choice. premise'0 self from
   -> premise'0 self from
end
module M_creusot_contracts__logic__ra__option__qyi9919140421117497760__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 137 4 137 77] (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 137 4 137 77
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 117 8 120 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 125 15 125 33
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 127 8 130 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  
  use map.Map
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'7] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option; _p2: t_Option }
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption'7] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra] and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0
  
   =
    [%#soption'6] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
   =
    [%#soption'5] match { _p0 = a; _p1 = b; _p2 = c } with
      | {_p0 = C_None} -> ()
      | {_p1 = C_None} -> ()
      | {_p2 = C_None} -> ()
      | {_p0 = C_Some aa ; _p1 = C_Some bb ; _p2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'4] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  type t_U
  
  type t_OptionUpdate  =
    { t_OptionUpdate__0: t_U }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 116 4 116 45] (self: t_OptionUpdate) (from: t_Option)
  
   =
    [%#soption'1] match from with
      | C_Some from'0 -> premise self.t_OptionUpdate__0 from'0
      | C_None -> false
      end
  
  type t_Choice
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 126 4 126 64] (self: t_OptionUpdate) (from: t_Option) (ch: t_Choice) : t_Option
  
   =
    [%#soption'3] match from with
      | C_Some from'0 -> C_Some (update self.t_OptionUpdate__0 from'0 ch)
      | C_None -> C_None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_OptionUpdate. forall from: t_Option. forall frame: t_Option. op'0 from frame
  <> C_None'0
  /\ premise'0 self from
   -> op'0 from frame <> C_None'0
  /\ premise'0 self from
  /\ (forall result: t_Choice. op'0 (update'0 self from result) frame <> C_None'0
   -> op'0 (update'0 self from result) frame <> C_None'0)
end
module M_creusot_contracts__logic__ra__prod__qyi12871785784760244066__update__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 102 4 102 77] (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 102 4 102 77
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 93 4 93 12
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate  =
    { t_ProdUpdate__0: t_U1; t_ProdUpdate__1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tuple  =
    { _p0: t_R1; _p1: t_R2 }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U1) (from: t_R1)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U2) (from: t_R2)
  
  predicate premise'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 95 4 95 44] (self: t_ProdUpdate) (from: tuple) =
    [%#sprod'0] premise self.t_ProdUpdate__0 from._p0 /\ premise'0 self.t_ProdUpdate__1 from._p1
  
  type t_Choice
  
  type t_Choice'0
  
  type tuple'0  =
    { _p0'0: t_Choice; _p1'0: t_Choice'0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall self: t_ProdUpdate. forall from: tuple. forall ch: tuple'0. premise'1 self from
   -> premise'1 self from
end
module M_creusot_contracts__logic__ra__prod__qyi12871785784760244066__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 110 4 110 78] (* <logic::ra::prod::ProdUpdate<U1, U2> as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 110 4 110 78
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 93 4 93 12
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 101 15 101 33
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 103 8 103 66
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'7 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type tuple  =
    { _p0: t_R1; _p1: t_R2 }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'0] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_R1) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_R2) -> { _p0 = x;
                                                                                                                                   _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'7] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'6] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'5] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'4] op'1 a b = op'1 b a
  
  type t_U1
  
  type t_U2
  
  type t_ProdUpdate  =
    { t_ProdUpdate__0: t_U1; t_ProdUpdate__1: t_U2 }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U1) (from: t_R1)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U2) (from: t_R2)
  
  predicate premise'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 95 4 95 44] (self: t_ProdUpdate) (from: tuple) =
    [%#sprod'1] premise self.t_ProdUpdate__0 from._p0 /\ premise'0 self.t_ProdUpdate__1 from._p1
  
  type t_Choice
  
  type t_Choice'0
  
  type tuple'0  =
    { _p0'0: t_Choice; _p1'0: t_Choice'0 }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  
  function update'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 102 4 102 77] (self: t_ProdUpdate) (from: tuple) (ch: tuple'0) : tuple
  
   =
    [%#sprod'3] { _p0 = update self.t_ProdUpdate__0 from._p0 ch._p0'0;
                  _p1 = update'0 self.t_ProdUpdate__1 from._p1 ch._p1'0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall self: t_ProdUpdate. forall from: tuple. forall frame: tuple. op'1 from frame <> C_None
  /\ premise'1 self from
   -> op'1 from frame <> C_None
  /\ premise'1 self from
  /\ (forall result: tuple'0. op'1 (update'1 self from result) frame <> C_None
   -> op'1 (update'1 self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__sum__qyi1847493758823096333__update__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 99 4 99 68] (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 99 4 99 68
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 90 8 93 9
  
  type t_U
  
  type t_SumUpdateL  =
    { t_SumUpdateL__0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R1)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 89 4 89 47] (self: t_SumUpdateL) (from: t_Sum) =
    [%#ssum'0] match from with
      | C_Left from'0 -> premise self.t_SumUpdateL__0 from'0
      | C_Right _ -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_SumUpdateL. forall from: t_Sum. forall ch: t_Choice. premise'0 self from
   -> premise'0 self from
end
module M_creusot_contracts__logic__ra__sum__qyi1847493758823096333__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 110 4 110 81] (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 110 4 110 81
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 90 8 93 9
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 98 15 98 33
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 100 8 103 9
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'7 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_R1
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_R1 t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'0
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_R1. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R2 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R2. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
   =
    [%#ssum'7] ()
  
  axiom associative_spec'1: forall a: t_Sum, b: t_Sum, c: t_Sum. [%#ssum'6] and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a: t_Sum) (b: t_Sum) : () =
    [%#ssum'5] ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. [%#ssum'4] op'1 a b = op'1 b a
  
  type t_U
  
  type t_SumUpdateL  =
    { t_SumUpdateL__0: t_U }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R1)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 89 4 89 47] (self: t_SumUpdateL) (from: t_Sum) =
    [%#ssum'1] match from with
      | C_Left from'0 -> premise self.t_SumUpdateL__0 from'0
      | C_Right _ -> false
      end
  
  type t_Choice
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 99 4 99 68] (self: t_SumUpdateL) (from: t_Sum) (ch: t_Choice) : t_Sum
  
   =
    [%#ssum'3] match from with
      | C_Left from'0 -> C_Left (update self.t_SumUpdateL__0 from'0 ch)
      | x -> x
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_SumUpdateL. forall from: t_Sum. forall frame: t_Sum. op'1 from frame <> C_None
  /\ premise'0 self from
   -> op'1 from frame <> C_None
  /\ premise'0 self from
  /\ (forall result: t_Choice. op'1 (update'0 self from result) frame <> C_None
   -> op'1 (update'0 self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__sum__qyi15765748900338894532__update__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 135 4 135 64] (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 135 4 135 64
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 126 8 129 9
  
  type t_U
  
  type t_SumUpdateR  =
    { t_SumUpdateR__0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum  =
    | C_Left t_V
    | C_Right t_R
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 125 4 125 45] (self: t_SumUpdateR) (from: t_Sum) =
    [%#ssum'0] match from with
      | C_Right from'0 -> premise self.t_SumUpdateR__0 from'0
      | C_Left _ -> false
      end
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_SumUpdateR. forall from: t_Sum. forall ch: t_Choice. premise'0 self from
   -> premise'0 self from
end
module M_creusot_contracts__logic__ra__sum__qyi15765748900338894532__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 146 4 146 77] (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 13 15 13 33
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 146 4 146 77
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 126 8 129 9
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 134 15 134 33
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 136 8 139 9
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'7 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  
  use map.Map
  
  type t_V
  
  type t_R
  
  type t_Sum  =
    | C_Left t_V
    | C_Right t_R
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R t_Sum) : t_Option
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'1: t_R) : t_Option'1
  
  axiom factor_spec'0: forall self: t_R, factor'1: t_R. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_R. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec'0: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic'1 (op'0 a b) (fun (ab: t_R) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_R) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec'0: forall a: t_R, b: t_R. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> map_logic (op x y) (fun (l: t_V) -> C_Left l)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> map_logic'0 (op'0 x y) (fun (r: t_R) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
   =
    [%#ssum'7] ()
  
  axiom associative_spec'1: forall a: t_Sum, b: t_Sum, c: t_Sum. [%#ssum'6] and_then_logic (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a: t_Sum) (b: t_Sum) : () =
    [%#ssum'5] ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. [%#ssum'4] op'1 a b = op'1 b a
  
  type t_U
  
  type t_SumUpdateR  =
    { t_SumUpdateR__0: t_U }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 10 4 10 38] (self: t_U) (from: t_R)
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 125 4 125 45] (self: t_SumUpdateR) (from: t_Sum) =
    [%#ssum'1] match from with
      | C_Right from'0 -> premise self.t_SumUpdateR__0 from'0
      | C_Left _ -> false
      end
  
  type t_Choice
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 14 4 14 52] (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 135 4 135 64] (self: t_SumUpdateR) (from: t_Sum) (ch: t_Choice) : t_Sum
  
   =
    [%#ssum'3] match from with
      | C_Right from'0 -> C_Right (update self.t_SumUpdateR__0 from'0 ch)
      | x -> x
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_SumUpdateR. forall from: t_Sum. forall frame: t_Sum. op'1 from frame <> C_None
  /\ premise'0 self from
   -> op'1 from frame <> C_None
  /\ premise'0 self from
  /\ (forall result: t_Choice. op'1 (update'0 self from result) frame <> C_None
   -> op'1 (update'0 self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__update__qyi11826117606277287715__update__refines [#"../../creusot-contracts/src/logic/ra/update.rs" 37 4 37 40] (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 37 4 37 40
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 30 12 30 66
  
  use map.Map
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 28 4 28 37] (self: t_R) (from: t_R) =
    [%#supdate'0] forall y: t_R. op from y <> C_None  -> op self y <> C_None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#supdate] forall self: t_R. forall from: t_R. forall ch: (). premise self from  -> premise self from
end
module M_creusot_contracts__logic__ra__update__qyi11826117606277287715__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/update.rs" 45 4 45 48] (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 45 4 45 48
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 30 12 30 66
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 36 15 36 33
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 38 8 38 13
  
  use map.Map
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 28 4 28 37] (self: t_R) (from: t_R) =
    [%#supdate'0] forall y: t_R. op from y <> C_None  -> op self y <> C_None
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 37 4 37 40] (self: t_R) (from: t_R) (_2: ()) : t_R
   =
    [%#supdate'2] self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#supdate] forall self: t_R. forall from: t_R. forall frame: t_R. op from frame <> C_None
  /\ premise self from
   -> op from frame <> C_None
  /\ premise self from
  /\ (forall result: (). op (update self from result) frame <> C_None  -> op (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__update__qyi5477729486377161480__update__refines [#"../../creusot-contracts/src/logic/ra/update.rs" 63 4 63 45] (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 63 4 63 45
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 55 12 56 57
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R
  
   =
    [%#smapping] Map.get self a
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 53 4 53 37] (self: Map.map t_Choice t_R) (from: t_R)
  
   =
    [%#supdate'0] forall y: t_R. op from y <> C_None  -> (exists ch: t_Choice. op (index_logic self ch) y <> C_None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#supdate] forall self: Map.map t_Choice t_R. forall from: t_R. forall ch: t_Choice. premise self from
   -> premise self from
end
module M_creusot_contracts__logic__ra__update__qyi5477729486377161480__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/update.rs" 71 4 71 58] (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 71 4 71 58
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 55 12 56 57
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 62 15 62 33
  let%span supdate'2 = "../../creusot-contracts/src/logic/ra/update.rs" 60 4 60 12
  
  use map.Map
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Choice
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R
  
   =
    [%#smapping] Map.get self a
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 53 4 53 37] (self: Map.map t_Choice t_R) (from: t_R)
  
   =
    [%#supdate'0] forall y: t_R. op from y <> C_None  -> (exists ch: t_Choice. op (index_logic self ch) y <> C_None)
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 63 4 63 45] (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R
  
   =
    [%#supdate'2] index_logic self ch
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#supdate] forall self: Map.map t_Choice t_R. forall from: t_R. forall frame: t_R. op from frame
  <> C_None
  /\ premise self from
   -> op from frame <> C_None
  /\ premise self from
  /\ (forall result: t_Choice. op (update self from result) frame <> C_None
   -> op (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__view__qyi5759646997670148869__update__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 253 4 253 57] (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 253 4 253 57
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 235 12 246 21
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'9] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'7] rel a f)  -> ([%#sview'8] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'4] rel a f1)
   -> ([%#sview'5] incl f2 f1)  -> ([%#sview'6] rel a f2)
  
  type tuple  =
    { _p0: t_Auth; _p1: t_Frag }
  
  type t_ViewUpdate  =
    { t_ViewUpdate__0: Map.map t_Choice tuple }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'10] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'1] (view self.t_View__0).t_InnerView__auth
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice tuple) (a: t_Choice) : tuple
  
   =
    [%#smapping] Map.get self a
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'3] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'2] rel (auth self) (frag self)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 233 4 233 43] (self: t_ViewUpdate) (from: t_View) =
    [%#sview'0] auth from <> C_None
    /\ (forall ch: t_Choice. rel (C_Some ((index_logic self.t_ViewUpdate__0 ch)._p0)) (index_logic self.t_ViewUpdate__0 ch)._p1)
    /\ (forall frame: t_Frag. match op (frag from) frame with
      | C_Some'0 ff -> rel (auth from) ff
      | C_None'0 -> false
      end
     -> (exists ch: t_Choice. match op (index_logic self.t_ViewUpdate__0 ch)._p1 frame with
      | C_Some'0 ff -> rel (C_Some ((index_logic self.t_ViewUpdate__0 ch)._p0)) ff
      | C_None'0 -> false
      end))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_ViewUpdate. forall from: t_View. forall ch: t_Choice. premise self from
   -> premise self from
end
module M_creusot_contracts__logic__ra__view__qyi5759646997670148869__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 261 4 261 70] (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 261 4 261 70
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 235 12 246 21
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 252 15 252 33
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 254 8 254 51
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'20] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'18] rel a f)  -> ([%#sview'19] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'15] rel a f1)
   -> ([%#sview'16] incl f2 f1)  -> ([%#sview'17] rel a f2)
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'21] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'10] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'9] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'8] rel (auth self) (frag self)
  
  type tuple'0  =
    { _p0'0: t_Option'1; _p1'0: t_Option'1; _p2: t_Option'1 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'14] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'11] rel auth'0 frag'0)
   -> ([%#sview'12] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'11] rel auth'0 frag'0)
   -> ([%#sview'13] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'1 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'7] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some'1 _ ; _p1'0 = C_None'1 ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'6] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'5] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'4] op'0 a b = op'0 b a
  
  type t_Choice
  
  type tuple'2  =
    { _p0'2: t_Auth; _p1'2: t_Frag }
  
  type t_ViewUpdate  =
    { t_ViewUpdate__0: Map.map t_Choice tuple'2 }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_Choice tuple'2) (a: t_Choice) : tuple'2
  
   =
    [%#smapping] Map.get self a
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 233 4 233 43] (self: t_ViewUpdate) (from: t_View) =
    [%#sview'1] auth from <> C_None'1
    /\ (forall ch: t_Choice. rel (C_Some'1 ((index_logic self.t_ViewUpdate__0 ch)._p0'2)) (index_logic self.t_ViewUpdate__0 ch)._p1'2)
    /\ (forall frame: t_Frag. match op (frag from) frame with
      | C_Some'0 ff -> rel (auth from) ff
      | C_None'0 -> false
      end
     -> (exists ch: t_Choice. match op (index_logic self.t_ViewUpdate__0 ch)._p1'2 frame with
      | C_Some'0 ff -> rel (C_Some'1 ((index_logic self.t_ViewUpdate__0 ch)._p0'2)) ff
      | C_None'0 -> false
      end))
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 253 4 253 57] (self: t_ViewUpdate) (from: t_View) (ch: t_Choice) : t_View
  
   =
    [%#sview'3] new (C_Some'1 ((index_logic self.t_ViewUpdate__0 ch)._p0'2)) (index_logic self.t_ViewUpdate__0 ch)._p1'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_ViewUpdate. forall from: t_View. forall frame: t_View. op'0 from frame
  <> C_None
  /\ premise self from
   -> op'0 from frame <> C_None
  /\ premise self from
  /\ (forall result: t_Choice. op'0 (update self from result) frame <> C_None
   -> op'0 (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__view__qyi7400797033094478444__update__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 288 4 288 52] (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 288 4 288 52
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 275 12 280 17
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'7] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'5] rel a f)  -> ([%#sview'6] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'2] rel a f1)
   -> ([%#sview'3] incl f2 f1)  -> ([%#sview'4] rel a f2)
  
  type t_ViewUpdateInsert  =
    { t_ViewUpdateInsert__0: t_Auth; t_ViewUpdateInsert__1: t_Frag }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'8] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'1] (view self.t_View__0).t_InnerView__auth
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 273 4 273 43] (self: t_ViewUpdateInsert) (from: t_View)
  
   =
    [%#sview'0] auth from <> C_None
    /\ (forall f: t_Frag. rel (auth from) f
     -> match op self.t_ViewUpdateInsert__1 f with
      | C_Some'0 ff -> rel (C_Some (self.t_ViewUpdateInsert__0)) ff
      | C_None'0 -> false
      end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_ViewUpdateInsert. forall from: t_View. forall ch: (). premise self from
   -> premise self from
end
module M_creusot_contracts__logic__ra__view__qyi7400797033094478444__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 296 4 296 60] (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 296 4 296 60
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 275 12 280 17
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 286 15 286 33
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 287 14 287 44
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 289 8 289 41
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'21] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'19] rel a f)  -> ([%#sview'20] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'16] rel a f1)
   -> ([%#sview'17] incl f2 f1)  -> ([%#sview'18] rel a f2)
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'22] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'11] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'10] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'9] rel (auth self) (frag self)
  
  type tuple'0  =
    { _p0'0: t_Option'1; _p1'0: t_Option'1; _p2: t_Option'1 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'15] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'12] rel auth'0 frag'0)
   -> ([%#sview'13] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'12] rel auth'0 frag'0)
   -> ([%#sview'14] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'1 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'8] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some'1 _ ; _p1'0 = C_None'1 ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'7] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'6] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'5] op'0 a b = op'0 b a
  
  type t_ViewUpdateInsert  =
    { t_ViewUpdateInsert__0: t_Auth; t_ViewUpdateInsert__1: t_Frag }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 273 4 273 43] (self: t_ViewUpdateInsert) (from: t_View)
  
   =
    [%#sview'1] auth from <> C_None'1
    /\ (forall f: t_Frag. rel (auth from) f
     -> match op self.t_ViewUpdateInsert__1 f with
      | C_Some'0 ff -> rel (C_Some'1 (self.t_ViewUpdateInsert__0)) ff
      | C_None'0 -> false
      end)
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 288 4 288 52] (self: t_ViewUpdateInsert) (from: t_View) (_2: ()) : t_View
  
   =
    [%#sview'4] new (C_Some'1 (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1
  
  axiom update_spec: forall self: t_ViewUpdateInsert, from: t_View, _2: (). ([%#sview'2] premise self from)
   -> ([%#sview'3] rel (C_Some'1 (self.t_ViewUpdateInsert__0)) self.t_ViewUpdateInsert__1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_ViewUpdateInsert. forall from: t_View. forall frame: t_View. op'0 from frame
  <> C_None
  /\ premise self from
   -> op'0 from frame <> C_None
  /\ premise self from
  /\ (forall result: (). op'0 (update self from result) frame <> C_None
   -> op'0 (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__view__qyi5746217084655472194__update__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 324 4 324 52] (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 324 4 324 52
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 310 12 316 40
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'9] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'7] rel a f)  -> ([%#sview'8] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'4] rel a f1)
   -> ([%#sview'5] incl f2 f1)  -> ([%#sview'6] rel a f2)
  
  type t_ViewUpdateRemove  =
    { t_ViewUpdateRemove__0: t_Auth }
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'10] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option =
    [%#sview'1] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'3] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'2] rel (auth self) (frag self)
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 308 4 308 43] (self: t_ViewUpdateRemove) (from: t_View)
  
   =
    [%#sview'0] auth from <> C_None
    /\ (forall f: t_Frag. match op (frag from) f with
      | C_Some'0 ff -> rel (auth from) ff
      | C_None'0 -> false
      end  -> rel (C_Some (self.t_ViewUpdateRemove__0)) f)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_ViewUpdateRemove. forall from: t_View. forall ch: (). premise self from
   -> premise self from
end
module M_creusot_contracts__logic__ra__view__qyi5746217084655472194__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 332 4 332 60] (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 332 4 332 60
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 310 12 316 40
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 322 15 322 33
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 323 14 323 52
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 325 8 325 31
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 104 8 104 46
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'13] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'4] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'14] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'15] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'12] ()
  
  axiom unit_core_spec: [%#sra'11] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'10] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'9] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'22] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'20] rel a f)  -> ([%#sview'21] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'17] rel a f1)
   -> ([%#sview'18] incl f2 f1)  -> ([%#sview'19] rel a f2)
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'23] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'11] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'10] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'9] rel (auth self) (frag self)
  
  type tuple'0  =
    { _p0'0: t_Option'1; _p1'0: t_Option'1; _p2: t_Option'1 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'15] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'12] rel auth'0 frag'0)
   -> ([%#sview'13] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'12] rel auth'0 frag'0)
   -> ([%#sview'14] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'1 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'8] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some'1 _ ; _p1'0 = C_None'1 ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'7] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'6] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'5] op'0 a b = op'0 b a
  
  type t_ViewUpdateRemove  =
    { t_ViewUpdateRemove__0: t_Auth }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/view.rs" 308 4 308 43] (self: t_ViewUpdateRemove) (from: t_View)
  
   =
    [%#sview'1] auth from <> C_None'1
    /\ (forall f: t_Frag. match op (frag from) f with
      | C_Some'0 ff -> rel (auth from) ff
      | C_None'0 -> false
      end  -> rel (C_Some'1 (self.t_ViewUpdateRemove__0)) f)
  
  function new_auth [#"../../creusot-contracts/src/logic/ra/view.rs" 103 4 103 42] (auth'0: t_Auth) : t_View =
    [%#sview'16] new (C_Some'1 auth'0) unit'
  
  function update [#"../../creusot-contracts/src/logic/ra/view.rs" 324 4 324 52] (self: t_ViewUpdateRemove) (from: t_View) (_2: ()) : t_View
  
   =
    [%#sview'4] new_auth self.t_ViewUpdateRemove__0
  
  axiom update_spec: forall self: t_ViewUpdateRemove, from: t_View, _2: (). ([%#sview'2] premise self from)
   -> ([%#sview'3] rel (C_Some'1 (self.t_ViewUpdateRemove__0)) unit')
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_ViewUpdateRemove. forall from: t_View. forall frame: t_View. op'0 from frame
  <> C_None
  /\ premise self from
   -> op'0 from frame <> C_None
  /\ premise self from
  /\ (forall result: (). op'0 (update self from result) frame <> C_None
   -> op'0 (update self from result) frame <> C_None)
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__core_is_total__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 111 4 111 26] (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 111 4 111 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 69 14 72 5
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 74 8 74 31
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 100 14 100 47
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 101 14 101 43
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 103 8 103 59
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 246 14 249 5
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'14 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'9] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'4] and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra'0] op self other = C_Some'0 comb)
   -> ([%#sra'1] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None'0} -> C_Some'1 other
      | {_p1 = C_None'0} -> C_Some'1 self
      | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'11] Map.get (view self) k
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'15] forall k: t_K [get (merge self m f) k]. match { _p0 = get self k;
                                                                                                                                         _p1 = get m k } with
    | {_p0 = C_None'0 ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None'0} -> get (merge self m f) k = x
    | {_p0 = C_Some'0 x ; _p1 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'14] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'12] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)
   -> ([%#sfmap'13] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  type tuple'1  =
    { _p0'1: t_Option; _p1'1: t_Option }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'9] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
   =
    [%#sfmap'8] match { _p0'1 = op'1 a b; _p1'1 = op'1 b c } with
      | {_p0'1 = C_Some ab ; _p1'1 = C_Some bc} -> match { _p0'1 = op'1 ab c; _p1'1 = op'1 a bc } with
        | {_p0'1 = C_Some x ; _p1'1 = C_Some y} -> let _ = () in ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'7] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : () =
    [%#sfmap'6] let _ = () in ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'5] op'1 a b = op'1 b a
  
  type tuple'2  =
    { _p0'2: t_K; _p1'2: t_V }
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'2 t_Option'0) (a: tuple'2) : t_Option'0
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 250 4 252 17] (self: t_FMap) (f: Map.map tuple'2 t_Option'0) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'2 t_Option'0. [%#sfmap'10] forall k: t_K [get (filter_map self f) k]. get (filter_map self f) k
  = match get self k with
    | C_None'0 -> C_None'0
    | C_Some'0 v -> index_logic'1 f { _p0'2 = k; _p1'2 = v }
    end
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_V) : t_Option'0
  
  axiom core_spec: forall self: t_V. [%#sra] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (self: t_FMap) : t_FMap =
    [%#sfmap'4] let r = filter_map self (fun (__0: tuple'2) -> let {_p1'2 = v} = __0 in core v) in let _ = let _ = () in () in let _ = let _ = () in () in r
  
  axiom core_total_spec: forall self: t_FMap. [%#sfmap'2] op'1 (core_total self) (core_total self)
  = C_Some (core_total self)
  
  axiom core_total_spec'0: forall self: t_FMap. [%#sfmap'3] op'1 (core_total self) self = C_Some self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 73 4 73 33] (self: t_FMap) : t_Option =
    [%#sfmap'1] C_Some (core_total self)
  
  axiom core_spec'0: forall self: t_FMap. [%#sfmap'0] match core'0 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall self: t_FMap. forall result: (). core'0 self = C_Some (core_total self)
   -> core'0 self = C_Some (core_total self)
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__unit__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 93 4 93 21] (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 93 4 93 21
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None'0} -> C_Some'1 other
      | {_p1'0 = C_None'0} -> C_Some'1 self
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'5] Map.get (view self) k
  
  type tuple'1  =
    { _p0'1: t_V; _p1'1: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. [%#sfmap'9] forall k: t_K [get (merge self m f) k]. match { _p0'0 = get self k;
                                                                                                                                        _p1'0 = get m k } with
    | {_p0'0 = C_None'0 ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None'0} -> get (merge self m f) k = x
    | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'1 = x; _p1'1 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'8] merge self other (fun (__0: tuple'1) -> let {_p0'1 = x ; _p1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'6] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'7] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'0] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
   =
    [%#sfmap'4] match { _p0 = op'1 a b; _p1 = op'1 b c } with
      | {_p0 = C_Some ab ; _p1 = C_Some bc} -> match { _p0 = op'1 ab c; _p1 = op'1 a bc } with
        | {_p0 = C_Some x ; _p1 = C_Some y} -> let _ = () in ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'3] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : () =
    [%#sfmap'2] let _ = () in ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'1] op'1 a b = op'1 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall result: t_FMap. (forall x: t_FMap [op'1 x result]. op'1 x result = C_Some x)
   -> (forall x: t_FMap [op'1 x result]. op'1 x result = C_Some x)
end
module M_creusot_contracts__logic__ra__fmap__qyi4304869425182553974__core_total__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31] (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 102 4 102 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  type t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Option'0
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_Option'0 t_Option'1) : t_Option'1
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_V t_Option'0) : t_Option'0
  
   =
    [%#soption'0] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'0
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_V. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'0) (other: t_Option'0) : t_Option'1
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None'0} -> C_Some'1 other
      | {_p1'0 = C_None'0} -> C_Some'1 self
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> map_logic (op x y) (fun (z: t_V) -> C_Some'0 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'1] and_then_logic'0 (op'0 a b) (fun (ab: t_Option'0) -> op'0 ab c)
  = and_then_logic'0 (op'0 b c) (fun (bc: t_Option'0) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'0
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'5] Map.get (view self) k
  
  type tuple'1  =
    { _p0'1: t_V; _p1'1: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. [%#sfmap'9] forall k: t_K [get (merge self m f) k]. match { _p0'0 = get self k;
                                                                                                                                        _p1'0 = get m k } with
    | {_p0'0 = C_None'0 ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None'0} -> get (merge self m f) k = x
    | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'0 y} -> get (merge self m f) k
    = C_Some'0 (index_logic f { _p0'1 = x; _p1'1 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'8] merge self other (fun (__0: tuple'1) -> let {_p0'1 = x ; _p1'1 = y} = __0 in match op x y with
      | C_Some'0 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'6] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'1)  -> ([%#sfmap'7] forall k: t_K. C_Some'1 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'0] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'1 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
   =
    [%#sfmap'4] match { _p0 = op'1 a b; _p1 = op'1 b c } with
      | {_p0 = C_Some ab ; _p1 = C_Some bc} -> match { _p0 = op'1 ab c; _p1 = op'1 a bc } with
        | {_p0 = C_Some x ; _p1 = C_Some y} -> let _ = () in ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'3] and_then_logic (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : () =
    [%#sfmap'2] let _ = () in ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'1] op'1 a b = op'1 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall self: t_FMap. forall result: t_FMap. op'1 result self = C_Some self
  /\ op'1 result result = C_Some result  -> op'1 result self = C_Some self /\ op'1 result result = C_Some result
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__core_is_total__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 106 4 106 26] (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 106 4 106 26
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 62 14 65 5
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 67 8 67 31
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 95 14 95 47
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 96 14 96 43
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 98 8 101 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'6 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'8] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'9] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'8] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'10] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'9] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'8] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'5] incl a b)
   -> ([%#sra'6] incl b c)  -> ([%#sra'7] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'1] op self other = C_Some comb)
   -> ([%#sra'2] incl self comb)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option; _p2: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'7] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
   =
    [%#soption'6] match { _p0'0 = a; _p1'0 = b; _p2 = c } with
      | {_p0'0 = C_None} -> ()
      | {_p1'0 = C_None} -> ()
      | {_p2 = C_None} -> ()
      | {_p0'0 = C_Some aa ; _p1'0 = C_Some bb ; _p2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'5] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option
  
  axiom core_spec: forall self: t_T. [%#sra] match core self with
    | C_Some c -> op c c = C_Some c /\ op c self = C_Some self
    | C_None -> true
    end
  
  function core_total [#"../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31] (self: t_Option) : t_Option =
    [%#soption'4] match self with
      | C_None -> C_None
      | C_Some x -> core x
      end
  
  axiom core_total_spec: forall self: t_Option. [%#soption'2] op'0 (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Option. [%#soption'3] op'0 (core_total self) self = C_Some'0 self
  
  function core'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 66 4 66 33] (self: t_Option) : t_Option'0 =
    [%#soption'1] C_Some'0 (core_total self)
  
  axiom core_spec'0: forall self: t_Option. [%#soption'0] match core'0 self with
    | C_Some'0 c -> op'0 c c = C_Some'0 c /\ op'0 c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_Option. forall result: (). core'0 self = C_Some'0 (core_total self)
   -> core'0 self = C_Some'0 (core_total self)
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__core_total__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31] (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 97 4 97 31
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option; _p2: t_Option }
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'4] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'3] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
   =
    [%#soption'2] match { _p0 = a; _p1 = b; _p2 = c } with
      | {_p0 = C_None} -> ()
      | {_p1 = C_None} -> ()
      | {_p2 = C_None} -> ()
      | {_p0 = C_Some aa ; _p1 = C_Some bb ; _p2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'1] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall self: t_Option. forall result: t_Option. op'0 result self = C_Some'0 self
  /\ op'0 result result = C_Some'0 result  -> op'0 result self = C_Some'0 self /\ op'0 result result = C_Some'0 result
end
module M_creusot_contracts__logic__ra__option__qyi18145756475453833322__unit__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 89 4 89 21] (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 89 4 89 21
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 49 12 56 13
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'4] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option; _p2: t_Option }
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption'4] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_T. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'2] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'0] op self other = C_Some comb)
   -> ([%#sra'1] incl self comb)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra] and_then_logic'0 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_T) -> op a bc)
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_T t_Option) : t_Option'0
  
   =
    [%#soption'3] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op x y) (fun (z: t_T) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
   =
    [%#soption'2] match { _p0 = a; _p1 = b; _p2 = c } with
      | {_p0 = C_None} -> ()
      | {_p1 = C_None} -> ()
      | {_p2 = C_None} -> ()
      | {_p0 = C_Some aa ; _p1 = C_Some bb ; _p2 = C_Some cc} -> associative aa bb cc
      end
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'1] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#soption] forall result: t_Option. (forall x: t_Option [op'0 x result]. op'0 x result = C_Some'0 x)
   -> (forall x: t_Option [op'0 x result]. op'0 x result = C_Some'0 x)
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__unit__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 68 4 68 21] (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 68 4 68 21
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'0] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                                 _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'4] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'3] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'2] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'1] op'1 a b = op'1 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall result: tuple. (forall x: tuple [op'1 x result]. op'1 x result = C_Some x)
   -> (forall x: tuple [op'1 x result]. op'1 x result = C_Some x)
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__core_total__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 76 4 76 31] (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 76 4 76 31
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'9] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'8] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra] op'0 self other = C_Some'1 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'0] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                                 _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'4] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'3] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'2] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'1] op'1 a b = op'1 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall self: tuple. forall result: tuple. op'1 result self = C_Some self
  /\ op'1 result result = C_Some result  -> op'1 result self = C_Some self /\ op'1 result result = C_Some result
end
module M_creusot_contracts__logic__ra__prod__qyi848091308440200351__core_is_total__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 82 4 82 26] (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 152 14 155 5
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'17 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 82 4 82 26
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 44 5
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 46 8 49 9
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 74 14 74 47
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 75 14 75 43
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 77 8 77 50
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'7 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'8 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  let%span sprod'9 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None
      | C_Some'0 x -> Map.get f x
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_T t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_T) (other: t_T) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_T) (factor'0: t_T) : t_Option'0
  
  axiom factor_spec: forall self: t_T, factor'0: t_T. [%#sra'17] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_T. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_T) (other: t_T) =
    [%#sra'15] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_T) (b: t_T) (c: t_T) : () =
    [%#sra'10] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_T, b: t_T, c: t_T. ([%#sra'7] incl a b)
   -> ([%#sra'8] incl b c)  -> ([%#sra'9] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'6] and_then_logic'1 (op a b) (fun (ab: t_T) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_T) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'5] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_T) (other: t_T) (comb: t_T) : () =
    [%#sra'4] ()
  
  axiom incl_op_spec: forall self: t_T, other: t_T, comb: t_T. ([%#sra'2] op self other = C_Some'0 comb)
   -> ([%#sra'3] incl self comb)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_U tuple) : t_Option
  
   =
    [%#soption'0] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_U t_Option'1) : t_Option'1
  
   =
    [%#soption] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_U) (other: t_U) : t_Option'1
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_U) (factor'1: t_U) : t_Option'1
  
  axiom factor_spec'0: forall self: t_U, factor'1: t_U. [%#sra'17] match factor'0 self factor'1 with
    | C_Some'1 c -> op'0 factor'1 c = C_Some'1 self
    | C_None'1 -> forall c: t_U. op'0 factor'1 c <> C_Some'1 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_U) (other: t_U) =
    [%#sra'15] factor'0 other self <> C_None'1
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_U) (b: t_U) (c: t_U) : () =
    [%#sra'10] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_U, b: t_U, c: t_U. ([%#sra'7] incl'0 a b)
   -> ([%#sra'8] incl'0 b c)  -> ([%#sra'9] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'6] and_then_logic'2 (op'0 a b) (fun (ab: t_U) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_U) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'5] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_U) (other: t_U) (comb: t_U) : () =
    [%#sra'4] ()
  
  axiom incl_op_spec'0: forall self: t_U, other: t_U, comb: t_U. ([%#sra'2] op'0 self other = C_Some'1 comb)
   -> ([%#sra'3] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'9] and_then_logic'0 (op self._p0 other._p0) (fun (x: t_T) -> map_logic (op'0 self._p1 other._p1) (fun (y: t_U) -> { _p0 = x;
                                                                                                                                 _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'8] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'7] and_then_logic (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'6] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'5] op'1 a b = op'1 b a
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  function core [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_T) : t_Option'0
  
  axiom core_spec: forall self: t_T. [%#sra] match core self with
    | C_Some'0 c -> op c c = C_Some'0 c /\ op c self = C_Some'0 self
    | C_None'0 -> true
    end
  
  function core'0 [#"../../creusot-contracts/src/logic/ra.rs" 156 4 156 34] (self: t_U) : t_Option'1
  
  axiom core_spec'0: forall self: t_U. [%#sra] match core'0 self with
    | C_Some'1 c -> op'0 c c = C_Some'1 c /\ op'0 c self = C_Some'1 self
    | C_None'1 -> true
    end
  
  function core'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 45 4 45 33] (self: tuple) : t_Option =
    [%#sprod'1] match { _p0'0 = core self._p0; _p1'0 = core'0 self._p1 } with
      | {_p0'0 = C_Some'0 x ; _p1'0 = C_Some'1 y} -> C_Some { _p0 = x; _p1 = y }
      | _ -> C_None
      end
  
  axiom core_spec'1: forall self: tuple. [%#sprod'0] match core'1 self with
    | C_Some c -> op'1 c c = C_Some c /\ op'1 c self = C_Some self
    | C_None -> true
    end
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_T
  
  axiom unit_spec: [%#sra'16] forall x: t_T [op x unit']. op x unit' = C_Some'0 x
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_T) : t_T
  
  axiom core_total_spec: forall self: t_T. [%#sra'0] op (core_total self) (core_total self) = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_T. [%#sra'1] op (core_total self) self = C_Some'0 self
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_T. incl x x
  
  constant unit''0 [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_U
  
  axiom unit_spec'0: [%#sra'16] forall x: t_U [op'0 x unit''0]. op'0 x unit''0 = C_Some'1 x
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_U) : t_U
  
  axiom core_total_spec'1: forall self: t_U. [%#sra'0] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some'1 (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_U. [%#sra'1] op'0 (core_total'0 self) self = C_Some'1 self
  
  constant unit_core'0: () = [%#sra'14] ()
  
  axiom unit_core_spec'0: [%#sra'13] core_total'0 unit''0 = unit''0
  
  constant incl_refl'0: () = [%#sra'12] let _ = unit''0 in ()
  
  axiom incl_refl_spec'0: [%#sra'11] forall x: t_U. incl'0 x x
  
  function core_total'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 76 4 76 31] (self: tuple) : tuple =
    [%#sprod'4] { _p0 = core_total self._p0; _p1 = core_total'0 self._p1 }
  
  axiom core_total_spec'3: forall self: tuple. [%#sprod'2] op'1 (core_total'1 self) (core_total'1 self)
  = C_Some (core_total'1 self)
  
  axiom core_total_spec'4: forall self: tuple. [%#sprod'3] op'1 (core_total'1 self) self = C_Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall self: tuple. forall result: (). core'1 self = C_Some (core_total'1 self)
   -> core'1 self = C_Some (core_total'1 self)
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__core_total__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'17] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'15] rel a f)  -> ([%#sview'16] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'12] rel a f1)
   -> ([%#sview'13] incl f2 f1)  -> ([%#sview'14] rel a f2)
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'18] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'7] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'6] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'5] rel (auth self) (frag self)
  
  type tuple'0  =
    { _p0'0: t_Option'1; _p1'0: t_Option'1; _p2: t_Option'1 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'11] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'9] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'10] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'1 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'4] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some'1 _ ; _p1'0 = C_None'1 ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'3] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'2] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'1] op'0 a b = op'0 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_View. forall result: t_View. op'0 result self = C_Some self
  /\ op'0 result result = C_Some result  -> op'0 result self = C_Some self /\ op'0 result result = C_Some result
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__unit__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 206 4 206 21] (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 206 4 206 21
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'8] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra] op self other = C_Some'0 comb)
   -> ([%#sra'0] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'9] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'17] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'15] rel a f)  -> ([%#sview'16] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'12] rel a f1)
   -> ([%#sview'13] incl f2 f1)  -> ([%#sview'14] rel a f2)
  
  type tuple  =
    { _p0: t_Option'0; _p1: t_Option'0 }
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'18] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'7] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'6] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'5] rel (auth self) (frag self)
  
  type tuple'0  =
    { _p0'0: t_Option'1; _p1'0: t_Option'1; _p2: t_Option'1 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'11] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'9] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'8] rel auth'0 frag'0)
   -> ([%#sview'10] frag (new auth'0 frag'0) = frag'0)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'0] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0'1 = auth self; _p1'1 = auth other } with
        | {_p0'1 = C_None'1 ; _p1'1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0'1 = a ; _p1'1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'4] let _ = match { _p0 = op (frag a) (frag b); _p1 = op (frag b) (frag c) } with
      | {_p0 = C_Some'0 fab ; _p1 = C_Some'0 fbc} -> match { _p0 = op fab (frag c); _p1 = op (frag a) fbc } with
        | {_p0 = C_Some'0 fabc1 ; _p1 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'0 = auth a;
                                                                                               _p1'0 = auth b;
                                                                                               _p2 = auth c } with
          | {_p0'0 = C_Some'1 _ ; _p1'0 = C_None'1 ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'0 = C_None'1 ; _p1'0 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'3] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'2] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'1] op'0 a b = op'0 b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall result: t_View. (forall x: t_View [op'0 x result]. op'0 x result = C_Some x)
   -> (forall x: t_View [op'0 x result]. op'0 x result = C_Some x)
end
module M_creusot_contracts__logic__ra__view__qyi2387369350023652154__core_is_total__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 223 4 223 26] (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 223 4 223 26
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 182 14 185 5
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 187 8 187 31
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 213 14 213 47
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 214 14 214 43
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 216 8 216 39
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 157 14 157 32
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 158 37 158 39
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 162 14 162 98
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 164 8 176 9
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 121 12 128 13
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 110 15 110 33
  let%span sview'11 = "../../creusot-contracts/src/logic/ra/view.rs" 112 8 112 29
  let%span sview'12 = "../../creusot-contracts/src/logic/ra/view.rs" 78 14 78 41
  let%span sview'13 = "../../creusot-contracts/src/logic/ra/view.rs" 80 20 80 32
  let%span sview'14 = "../../creusot-contracts/src/logic/ra/view.rs" 74 20 74 32
  let%span sview'15 = "../../creusot-contracts/src/logic/ra/view.rs" 93 15 93 33
  let%span sview'16 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 35
  let%span sview'17 = "../../creusot-contracts/src/logic/ra/view.rs" 95 14 95 35
  let%span sview'18 = "../../creusot-contracts/src/logic/ra/view.rs" 97 8 97 57
  let%span sview'19 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'20 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'21 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'22 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'23 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'24 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  let%span sview'25 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  
  use map.Map
  
  type t_Subset
  
  type t_View  =
    { t_View__0: t_Subset }
  
  type t_Option  =
    | C_None
    | C_Some t_View
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_View t_Option) : t_Option
  
   =
    [%#soption] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_Auth
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Auth
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option'1) (f: t_Frag)
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'16] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra'14] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'13] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'10] incl a b)
   -> ([%#sra'11] incl b c)  -> ([%#sra'12] incl a c)
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'9] and_then_logic'0 (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'8] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'7] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'5] op self other = C_Some'0 comb)
   -> ([%#sra'6] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'0] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'15] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'4] ()
  
  axiom unit_core_spec: [%#sra'3] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'2] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'1] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option'1) : ()
  
  axiom rel_unit_spec: forall a: t_Option'1. [%#sview'24] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option'1) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option'1, f: t_Frag. ([%#sview'22] rel a f)  -> ([%#sview'23] rel (C_None'1) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option'1) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option'1, f1: t_Frag, f2: t_Frag. ([%#sview'19] rel a f1)
   -> ([%#sview'20] incl f2 f1)  -> ([%#sview'21] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option'1; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'25] rel self.t_InnerView__auth self.t_InnerView__frag
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_InnerView
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant] invariant' (view self)
  
  function auth [#"../../creusot-contracts/src/logic/ra/view.rs" 73 4 73 40] (self: t_View) : t_Option'1 =
    [%#sview'14] (view self.t_View__0).t_InnerView__auth
  
  function frag [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 32] (self: t_View) : t_Frag =
    [%#sview'13] (view self.t_View__0).t_InnerView__frag
  
  axiom frag_spec: forall self: t_View. [%#sview'12] rel (auth self) (frag self)
  
  type tuple  =
    { _p0: t_Option'1; _p1: t_Option'1 }
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_InnerView) : t_Subset
  
  axiom new_logic_spec: forall x: t_InnerView. ([%#sinvariant'0] invariant' x)
   -> ([%#sinvariant'1] view (new_logic x) = x)
  
  function new [#"../../creusot-contracts/src/logic/ra/view.rs" 96 4 96 60] (auth'0: t_Option'1) (frag'0: t_Frag) : t_View
  
   =
    [%#sview'18] { t_View__0 = new_logic { t_InnerView__auth = auth'0; t_InnerView__frag = frag'0 } }
  
  axiom new_spec: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'15] rel auth'0 frag'0)
   -> ([%#sview'16] auth (new auth'0 frag'0) = auth'0)
  
  axiom new_spec'0: forall auth'0: t_Option'1, frag'0: t_Frag. ([%#sview'15] rel auth'0 frag'0)
   -> ([%#sview'17] frag (new auth'0 frag'0) = frag'0)
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'0 }
  
  type tuple'1  =
    { _p0'1: t_Option'1; _p1'1: t_Option'1; _p2: t_Option'1 }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 44] (self: t_View) (other: t_View) : t_Option
   =
    [%#sview'9] match op (frag self) (frag other) with
      | C_Some'0 f -> match { _p0 = auth self; _p1 = auth other } with
        | {_p0 = C_None'1 ; _p1 = a} -> if rel a f then C_Some (new a f) else C_None
        | {_p0 = a ; _p1 = C_None'1} -> if rel a f then C_Some (new a f) else C_None
        | _ -> C_None
        end
      | C_None'0 -> C_None
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 163 4 163 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
   =
    [%#sview'8] let _ = match { _p0'0 = op (frag a) (frag b); _p1'0 = op (frag b) (frag c) } with
      | {_p0'0 = C_Some'0 fab ; _p1'0 = C_Some'0 fbc} -> match { _p0'0 = op fab (frag c); _p1'0 = op (frag a) fbc } with
        | {_p0'0 = C_Some'0 fabc1 ; _p1'0 = C_Some'0 fabc2} -> let _ = let _ = () in () in match { _p0'1 = auth a;
                                                                                                   _p1'1 = auth b;
                                                                                                   _p2 = auth c } with
          | {_p0'1 = C_Some'1 _ ; _p1'1 = C_None'1 ; _p2 = C_None'1} | {_p0'1 = C_None'1 ; _p1'1 = C_Some'1 _ ; _p2 = C_None'1} | {_p0'1 = C_None'1 ; _p1'1 = C_None'1 ; _p2 = C_Some'1 _} -> ()
          | _ -> ()
          end
        | _ -> ()
        end
      | _ -> ()
      end in let _ = () in ()
  
  axiom associative_spec'0: forall a: t_View, b: t_View, c: t_View. [%#sview'7] and_then_logic (op'0 a b) (fun (ab: t_View) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_View) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 158 4 158 36] (a: t_View) (b: t_View) : () =
    [%#sview'6] ()
  
  axiom commutative_spec'0: forall a: t_View, b: t_View. [%#sview'5] op'0 a b = op'0 b a
  
  function new_frag [#"../../creusot-contracts/src/logic/ra/view.rs" 111 4 111 42] (frag'0: t_Frag) : t_View =
    [%#sview'11] new (C_None'1) frag'0
  
  function core_total'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 215 4 215 31] (self: t_View) : t_View =
    [%#sview'4] let _ = () in let _ = () in new_frag (core_total (frag self))
  
  axiom core_total_spec'1: forall self: t_View. [%#sview'2] op'0 (core_total'0 self) (core_total'0 self)
  = C_Some (core_total'0 self)
  
  axiom core_total_spec'2: forall self: t_View. [%#sview'3] op'0 (core_total'0 self) self = C_Some self
  
  function core [#"../../creusot-contracts/src/logic/ra/view.rs" 186 4 186 33] (self: t_View) : t_Option =
    [%#sview'1] C_Some (core_total'0 self)
  
  axiom core_spec: forall self: t_View. [%#sview'0] match core self with
    | C_Some c -> op'0 c c = C_Some c /\ op'0 c self = C_Some self
    | C_None -> true
    end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall self: t_View. forall result: (). core self = C_Some (core_total'0 self)
   -> core self = C_Some (core_total'0 self)
end
module M_creusot_contracts__logic__ra__fmap__qyi945878506295166927__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 149 4 154 5] (* <logic::ra::fmap::FMapInsertLocalUpdate<K, V> as logic::ra::update::LocalUpdate<logic::fmap::FMap<K, V>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 149 4 154 5
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 132 8 132 38
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 138 8 138 80
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 14 12 18 13
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 98 8 98 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 46
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 88
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 50 14 50 32
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 52 8 52 29
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 56 14 56 98
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 8 64 9
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 116 15 116 64
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 117 14 117 78
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 119 8 122 10
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 61 14 61 25
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 116 8 116 27
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 200 8 205 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  
  use map.Map
  use mach.int.Int
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_FMap
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_FMap t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Option'1
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_Option'1 t_Option'2) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option'1; _p1'0: t_Option'1 }
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_V t_Option'1) : t_Option'2
  
   =
    [%#soption'1] match self with
      | C_None'1 -> C_None'2
      | C_Some'1 x -> C_Some'2 (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_V t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_V) (other: t_V) : t_Option'1
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_V) (factor'0: t_V) : t_Option'1
  
  axiom factor_spec: forall self: t_V, factor'0: t_V. [%#sra'9] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_V. op factor'0 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_V) (other: t_V) =
    [%#sra'8] factor other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_V) (b: t_V) (c: t_V) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_V, b: t_V, c: t_V. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'3] and_then_logic'2 (op a b) (fun (ab: t_V) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_V) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_V) (other: t_V) (comb: t_V) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_V, other: t_V, comb: t_V. ([%#sra] op self other = C_Some'1 comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option'1) (other: t_Option'1) : t_Option'2
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None'1} -> C_Some'2 other
      | {_p1'0 = C_None'1} -> C_Some'2 self
      | {_p0'0 = C_Some'1 x ; _p1'0 = C_Some'1 y} -> map_logic'0 (op x y) (fun (z: t_V) -> C_Some'1 z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  
  axiom associative_spec'0: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'0] and_then_logic'1 (op'0 a b) (fun (ab: t_Option'1) -> op'0 ab c)
  = and_then_logic'1 (op'0 b c) (fun (bc: t_Option'1) -> op'0 a bc)
  
  type t_K
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 33] (self: t_FMap) : Map.map t_K t_Option'1
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 97 4 97 39] (self: t_FMap) (k: t_K) : t_Option'1
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  type tuple'1  =
    { _p0'1: t_V; _p1'1: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'1 t_V) (a: tuple'1) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 207 4 207 74] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'1 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'1 t_V. [%#sfmap'15] forall k: t_K [get (merge self m f) k]. match { _p0'0 = get self k;
                                                                                                                                         _p1'0 = get m k } with
    | {_p0'0 = C_None'1 ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None'1} -> get (merge self m f) k = x
    | {_p0'0 = C_Some'1 x ; _p1'0 = C_Some'1 y} -> get (merge self m f) k
    = C_Some'1 (index_logic f { _p0'1 = x; _p1'1 = y })
    end
  
  predicate index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map t_V bool) (a: t_V)
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that p))
  
  function total_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 118 4 118 46] (self: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'12] merge self other (fun (__0: tuple'1) -> let {_p0'1 = x ; _p1'1 = y} = __0 in match op x y with
      | C_Some'1 r -> r
      | _ -> such_that (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'10] forall k: t_K. op'0 (get self k) (get other k)
  <> C_None'2)
   -> ([%#sfmap'11] forall k: t_K. C_Some'2 (get (total_op self other) k) = op'0 (get self k) (get other k))
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 44] (self: t_FMap) (other: t_FMap) : t_Option =
    [%#sfmap'2] if forall k: t_K. op'0 (get self k) (get other k) <> C_None'2 then
      C_Some (total_op self other)
    else
      C_None
  
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 57 4 57 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
   =
    [%#sfmap'9] match { _p0 = op'1 a b; _p1 = op'1 b c } with
      | {_p0 = C_Some ab ; _p1 = C_Some bc} -> match { _p0 = op'1 ab c; _p1 = op'1 a bc } with
        | {_p0 = C_Some x ; _p1 = C_Some y} -> let _ = () in ()
        | _ -> ()
        end
      | _ -> ()
      end
  
  axiom associative_spec'1: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'8] and_then_logic'0 (op'1 a b) (fun (ab: t_FMap) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_FMap) -> op'1 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 51 4 51 36] (a: t_FMap) (b: t_FMap) : () =
    [%#sfmap'7] let _ = () in ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'6] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_FMap) -> C_Some z)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'2: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  type t_FMapInsertLocalUpdate  =
    { t_FMapInsertLocalUpdate__0: t_K; t_FMapInsertLocalUpdate__1: t_V }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/fmap.rs" 131 4 131 66] (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (_2: t_FMap)
  
   =
    [%#sfmap'0] get from_auth self.t_FMapInsertLocalUpdate__0 = C_None'1
  
  type tuple'2  =
    { _p0'2: t_FMap; _p1'2: t_FMap }
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 62 4 62 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'13] len self >= 0
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 115 4 115 39] (self: t_FMap) (k: t_K)
  
   =
    [%#sfmap'14] get self k <> C_None'1
  
  function insert [#"../../creusot-contracts/src/logic/fmap.rs" 71 4 71 43] (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'4] view (insert self k v)
  = Map.set (view self) k (C_Some'1 v)
  
  axiom insert_spec'0: forall self: t_FMap, k: t_K, v: t_V. [%#sfmap'5] len (insert self k v)
  = (if contains self k then len self else len self + 1)
  
  function update [#"../../creusot-contracts/src/logic/ra/fmap.rs" 137 4 137 93] (self: t_FMapInsertLocalUpdate) (from_auth: t_FMap) (from_frag: t_FMap) : tuple'2
  
   =
    [%#sfmap'1] { _p0'2 = insert from_auth self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1;
                  _p1'2 = insert from_frag self.t_FMapInsertLocalUpdate__0 self.t_FMapInsertLocalUpdate__1 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sfmap] forall self: t_FMapInsertLocalUpdate. forall from_auth: t_FMap. forall from_frag: t_FMap. forall frame: t_Option. op'2 (C_Some from_frag) frame
  = C_Some'0 (C_Some from_auth)
  /\ premise self from_auth from_frag
   -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
  /\ premise self from_auth from_frag
  /\ (forall result: (). (let {_p0'2 = to_auth ; _p1'2 = to_frag} = update self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth))
   -> (let {_p0'2 = to_auth ; _p1'2 = to_frag} = update self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__prod__qyi5623508861439716845__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 141 4 141 96] (* <logic::ra::prod::ProdLocalUpdate<U1, U2> as logic::ra::update::LocalUpdate<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 141 4 141 96
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 120 4 120 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 129 8 129 75
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 31 14 31 32
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 32 37 32 39
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 98
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 46 37 48
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type tuple  =
    { _p0: t_R1; _p1: t_R2 }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map tuple t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map tuple t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R1
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R1 t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> Map.get f x
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'2 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'2 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'1 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_R2
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'2) (f: Map.map t_R2 tuple) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'3 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'2
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'3 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'3 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'2 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 12 4 12 44] (self: tuple) (other: tuple) : t_Option =
    [%#sprod'2] and_then_logic'1 (op self._p0 other._p0) (fun (x: t_R1) -> map_logic'0 (op'0 self._p1 other._p1) (fun (y: t_R2) -> { _p0 = x;
                                                                                                                                     _p1 = y }))
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
   =
    [%#sprod'6] ()
  
  axiom associative_spec'1: forall a: tuple, b: tuple, c: tuple. [%#sprod'5] and_then_logic'0 (op'1 a b) (fun (ab: tuple) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: tuple) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 32 4 32 36] (a: tuple) (b: tuple) : () =
    [%#sprod'4] ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'3] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> C_Some'0 other
      | {_p1'0 = C_None} -> C_Some'0 self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> map_logic (op'1 x y) (fun (z: tuple) -> C_Some z)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'2: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  type t_U1
  
  type t_U2
  
  type t_ProdLocalUpdate  =
    { t_ProdLocalUpdate__0: t_U1; t_ProdLocalUpdate__1: t_U2 }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U1) (from_auth: t_R1) (from_frag: t_R1)
  
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U2) (from_auth: t_R2) (from_frag: t_R2)
  
  
  predicate premise'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 122 4 122 70] (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple)
  
   =
    [%#sprod'0] premise self.t_ProdLocalUpdate__0 from_auth._p0 from_frag._p0
    /\ premise'0 self.t_ProdLocalUpdate__1 from_auth._p1 from_frag._p1
  
  type tuple'1  =
    { _p0'1: tuple; _p1'1: tuple }
  
  type tuple'2  =
    { _p0'2: t_R1; _p1'2: t_R1 }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) : tuple'2
  
  
  type tuple'3  =
    { _p0'3: t_R2; _p1'3: t_R2 }
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) : tuple'3
  
  
  function update'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 128 4 128 85] (self: t_ProdLocalUpdate) (from_auth: tuple) (from_frag: tuple) : tuple'1
  
   =
    [%#sprod'1] let {_p0'2 = to_auth0 ; _p1'2 = to_frag0} = update self.t_ProdLocalUpdate__0 from_auth._p0 from_frag._p0 in let {_p0'3 = to_auth1 ; _p1'3 = to_frag1} = update'0 self.t_ProdLocalUpdate__1 from_auth._p1 from_frag._p1 in { _p0'1 = { _p0 = to_auth0;
                                                                                                                                                                                                                                                      _p1 = to_auth1 };
                                                                                                                                                                                                                                            _p1'1 = { _p0 = to_frag0;
                                                                                                                                                                                                                                                      _p1 = to_frag1 } }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sprod] forall self: t_ProdLocalUpdate. forall from_auth: tuple. forall from_frag: tuple. forall frame: t_Option. op'2 (C_Some from_frag) frame
  = C_Some'0 (C_Some from_auth)
  /\ premise'1 self from_auth from_frag
   -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
  /\ premise'1 self from_auth from_frag
  /\ (forall result: (). (let {_p0'1 = to_auth ; _p1'1 = to_frag} = update'1 self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth))
   -> (let {_p0'1 = to_auth ; _p1'1 = to_frag} = update'1 self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__sum__qyi3083214512297526849__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 186 4 191 5] (* <logic::ra::sum::SumLocalUpdateL<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 186 4 191 5
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 160 8 164 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 170 8 176 9
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Sum; _p1'0: t_Sum }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R1
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'1 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_R2
  
  function map_logic'1 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'2) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'2
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'2 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'2] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_Left x ; _p1'0 = C_Left y} -> map_logic'0 (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0'0 = C_Right x ; _p1'0 = C_Right y} -> map_logic'1 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
   =
    [%#ssum'6] ()
  
  axiom associative_spec'1: forall a: t_Sum, b: t_Sum, c: t_Sum. [%#ssum'5] and_then_logic'0 (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a: t_Sum) (b: t_Sum) : () =
    [%#ssum'4] ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. [%#ssum'3] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_Sum) -> C_Some z)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'2: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  type t_U
  
  type t_SumLocalUpdateL  =
    { t_SumLocalUpdateL__0: t_U }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U) (from_auth: t_R1) (from_frag: t_R1)
  
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 159 4 159 76] (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum)
  
   =
    [%#ssum'0] match { _p0'0 = from_auth; _p1'0 = from_frag } with
      | {_p0'0 = C_Left from_auth'0 ; _p1'0 = C_Left from_frag'0} -> premise self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0
      | {_p0'0 = C_Right _ ; _p1'0 = C_Right _} -> false
      | _ -> true
      end
  
  type tuple'1  =
    { _p0'1: t_R1; _p1'1: t_R1 }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U) (from_auth: t_R1) (from_frag: t_R1) : tuple'1
  
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 bool) (a: tuple'0)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map tuple'0 bool) : tuple'0
  
  axiom such_that_spec: forall p: Map.map tuple'0 bool. ([%#sutil] exists x: tuple'0. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 169 4 169 97] (self: t_SumLocalUpdateL) (from_auth: t_Sum) (from_frag: t_Sum) : tuple'0
  
   =
    [%#ssum'1] match { _p0'0 = from_auth; _p1'0 = from_frag } with
      | {_p0'0 = C_Left from_auth'0 ; _p1'0 = C_Left from_frag'0} -> let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self.t_SumLocalUpdateL__0 from_auth'0 from_frag'0 in { _p0'0 = C_Left to_auth;
                                                                                                                                                                             _p1'0 = C_Left to_frag }
      | _ -> such_that (fun (__0: tuple'0) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_SumLocalUpdateL. forall from_auth: t_Sum. forall from_frag: t_Sum. forall frame: t_Option. op'2 (C_Some from_frag) frame
  = C_Some'0 (C_Some from_auth)
  /\ premise'0 self from_auth from_frag
   -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
  /\ premise'0 self from_auth from_frag
  /\ (forall result: (). (let {_p0'0 = to_auth ; _p1'0 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth))
   -> (let {_p0'0 = to_auth ; _p1'0 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__sum__qyi3543961907530750261__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 236 4 241 5] (* <logic::ra::sum::SumLocalUpdateR<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 11 11 11 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 12 0 12 21
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 70 8 70 19
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 236 4 241 5
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 210 8 214 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 220 8 226 9
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 45 14 45 32
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 46 37 46 39
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 50 14 50 98
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 51 46 51 48
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum  =
    | C_Left t_R1
    | C_Right t_R2
  
  type t_Option  =
    | C_None
    | C_Some t_Sum
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_Sum t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  type tuple'0  =
    { _p0'0: t_Sum; _p1'0: t_Sum }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_R1
  
  function map_logic'0 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'1) (f: Map.map t_R1 t_Sum) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'1 -> C_None
      | C_Some'1 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'1 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'1) (f: Map.map t_R1 t_Option'1) : t_Option'1
  
   =
    [%#soption'2] match self with
      | C_None'1 -> C_None'1
      | C_Some'1 x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R1) (other: t_R1) : t_Option'1
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R1) (factor'0: t_R1) : t_Option'1
  
  axiom factor_spec: forall self: t_R1, factor'0: t_R1. [%#sra'9] match factor self factor'0 with
    | C_Some'1 c -> op factor'0 c = C_Some'1 self
    | C_None'1 -> forall c: t_R1. op factor'0 c <> C_Some'1 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R1) (other: t_R1) =
    [%#sra'8] factor other self <> C_None'1
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R1) (b: t_R1) (c: t_R1) : ()
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R1, b: t_R1, c: t_R1. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom associative_spec: forall a: t_R1, b: t_R1, c: t_R1. [%#sra'3] and_then_logic'1 (op a b) (fun (ab: t_R1) -> op ab c)
  = and_then_logic'1 (op b c) (fun (bc: t_R1) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_spec: forall a: t_R1, b: t_R1. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R1) (other: t_R1) (comb: t_R1) : ()
   =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R1, other: t_R1, comb: t_R1. ([%#sra] op self other = C_Some'1 comb)
   -> ([%#sra'0] incl self comb)
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_R2
  
  function map_logic'1 [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option'2) (f: Map.map t_R2 t_Sum) : t_Option
  
   =
    [%#soption'1] match self with
      | C_None'2 -> C_None
      | C_Some'2 x -> C_Some (Map.get f x)
      end
  
  function and_then_logic'2 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'2) (f: Map.map t_R2 t_Option'2) : t_Option'2
  
   =
    [%#soption'2] match self with
      | C_None'2 -> C_None'2
      | C_Some'2 x -> Map.get f x
      end
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R2) (other: t_R2) : t_Option'2
  
  function factor'0 [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R2) (factor'1: t_R2) : t_Option'2
  
  axiom factor_spec'0: forall self: t_R2, factor'1: t_R2. [%#sra'9] match factor'0 self factor'1 with
    | C_Some'2 c -> op'0 factor'1 c = C_Some'2 self
    | C_None'2 -> forall c: t_R2. op'0 factor'1 c <> C_Some'2 self
    end
  
  predicate incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R2) (other: t_R2) =
    [%#sra'8] factor'0 other self <> C_None'2
  
  function incl_transitive'0 [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
   =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec'0: forall a: t_R2, b: t_R2, c: t_R2. ([%#sra'4] incl'0 a b)
   -> ([%#sra'5] incl'0 b c)  -> ([%#sra'6] incl'0 a c)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom associative_spec'0: forall a: t_R2, b: t_R2, c: t_R2. [%#sra'3] and_then_logic'2 (op'0 a b) (fun (ab: t_R2) -> op'0 ab c)
  = and_then_logic'2 (op'0 b c) (fun (bc: t_R2) -> op'0 a bc)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_spec'0: forall a: t_R2, b: t_R2. [%#sra'2] op'0 a b = op'0 b a
  
  function incl_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
   =
    [%#sra'1] ()
  
  axiom incl_op_spec'0: forall self: t_R2, other: t_R2, comb: t_R2. ([%#sra] op'0 self other = C_Some'2 comb)
   -> ([%#sra'0] incl'0 self comb)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 44] (self: t_Sum) (other: t_Sum) : t_Option =
    [%#ssum'2] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_Left x ; _p1'0 = C_Left y} -> map_logic'0 (op x y) (fun (l: t_R1) -> C_Left l)
      | {_p0'0 = C_Right x ; _p1'0 = C_Right y} -> map_logic'1 (op'0 x y) (fun (r: t_R2) -> C_Right r)
      | _ -> C_None
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 51 4 51 45] (a: t_Sum) (b: t_Sum) (c: t_Sum) : ()
  
   =
    [%#ssum'6] ()
  
  axiom associative_spec'1: forall a: t_Sum, b: t_Sum, c: t_Sum. [%#ssum'5] and_then_logic'0 (op'1 a b) (fun (ab: t_Sum) -> op'1 ab c)
  = and_then_logic'0 (op'1 b c) (fun (bc: t_Sum) -> op'1 a bc)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 46 4 46 36] (a: t_Sum) (b: t_Sum) : () =
    [%#ssum'4] ()
  
  axiom commutative_spec'1: forall a: t_Sum, b: t_Sum. [%#ssum'3] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op'1 x y) (fun (z: t_Sum) -> C_Some z)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'2: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'2 a b) (fun (ab: t_Option) -> op'2 ab c)
  = and_then_logic (op'2 b c) (fun (bc: t_Option) -> op'2 a bc)
  
  type t_U
  
  type t_SumLocalUpdateR  =
    { t_SumLocalUpdateR__0: t_U }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 78 4 78 57] (self: t_U) (from_auth: t_R2) (from_frag: t_R2)
  
  
  predicate premise'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 209 4 209 76] (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum)
  
   =
    [%#ssum'0] match { _p0'0 = from_auth; _p1'0 = from_frag } with
      | {_p0'0 = C_Right from_auth'0 ; _p1'0 = C_Right from_frag'0} -> premise self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0
      | {_p0'0 = C_Left _ ; _p1'0 = C_Left _} -> false
      | _ -> true
      end
  
  type tuple'1  =
    { _p0'1: t_R2; _p1'1: t_R2 }
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 81 4 81 58] (self: t_U) (from_auth: t_R2) (from_frag: t_R2) : tuple'1
  
  
  predicate index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 69 4 69 35] (self: Map.map tuple'0 bool) (a: tuple'0)
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 13 0 13 59] (p: Map.map tuple'0 bool) : tuple'0
  
  axiom such_that_spec: forall p: Map.map tuple'0 bool. ([%#sutil] exists x: tuple'0. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function update'0 [#"../../creusot-contracts/src/logic/ra/sum.rs" 219 4 219 97] (self: t_SumLocalUpdateR) (from_auth: t_Sum) (from_frag: t_Sum) : tuple'0
  
   =
    [%#ssum'1] match { _p0'0 = from_auth; _p1'0 = from_frag } with
      | {_p0'0 = C_Right from_auth'0 ; _p1'0 = C_Right from_frag'0} -> let {_p0'1 = to_auth ; _p1'1 = to_frag} = update self.t_SumLocalUpdateR__0 from_auth'0 from_frag'0 in { _p0'0 = C_Right to_auth;
                                                                                                                                                                               _p1'0 = C_Right to_frag }
      | _ -> such_that (fun (__0: tuple'0) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#ssum] forall self: t_SumLocalUpdateR. forall from_auth: t_Sum. forall from_frag: t_Sum. forall frame: t_Option. op'2 (C_Some from_frag) frame
  = C_Some'0 (C_Some from_auth)
  /\ premise'0 self from_auth from_frag
   -> op'2 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
  /\ premise'0 self from_auth from_frag
  /\ (forall result: (). (let {_p0'0 = to_auth ; _p1'0 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth))
   -> (let {_p0'0 = to_auth ; _p1'0 = to_frag} = update'0 self from_auth from_frag in op'2 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__update__qyi10922308247021603688__frame_preserving__refines [#"../../creusot-contracts/src/logic/ra/update.rs" 118 4 118 75] (* <snapshot::Snapshot<(R, R)> as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 7 8 11 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 46 14 46 98
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 771 8 774 9
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span supdate = "../../creusot-contracts/src/logic/ra/update.rs" 118 4 118 75
  let%span supdate'0 = "../../creusot-contracts/src/logic/ra/update.rs" 98 12 100 56
  let%span supdate'1 = "../../creusot-contracts/src/logic/ra/update.rs" 107 8 107 13
  
  use map.Map
  
  type t_R
  
  type t_Option  =
    | C_None
    | C_Some t_R
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Option t_Option'0) : t_Option'0
  
   =
    [%#soption'2] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function map_logic [#"../../creusot-contracts/src/std/option.rs" 770 4 770 56] (self: t_Option) (f: Map.map t_R t_Option) : t_Option'0
  
   =
    [%#soption'1] match self with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 (Map.get f x)
      end
  
  function and_then_logic'0 [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option) (f: Map.map t_R t_Option) : t_Option
  
   =
    [%#soption'2] match self with
      | C_None -> C_None
      | C_Some x -> Map.get f x
      end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_R) (other: t_R) : t_Option
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_R) (factor'0: t_R) : t_Option
  
  axiom factor_spec: forall self: t_R, factor'0: t_R. [%#sra'9] match factor self factor'0 with
    | C_Some c -> op factor'0 c = C_Some self
    | C_None -> forall c: t_R. op factor'0 c <> C_Some self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_R) (other: t_R) =
    [%#sra'8] factor other self <> C_None
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_R) (b: t_R) (c: t_R) : () =
    [%#sra'7] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_R, b: t_R, c: t_R. ([%#sra'4] incl a b)
   -> ([%#sra'5] incl b c)  -> ([%#sra'6] incl a c)
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom associative_spec: forall a: t_R, b: t_R, c: t_R. [%#sra'3] and_then_logic'0 (op a b) (fun (ab: t_R) -> op ab c)
  = and_then_logic'0 (op b c) (fun (bc: t_R) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_R) (b: t_R) : ()
  
  axiom commutative_spec: forall a: t_R, b: t_R. [%#sra'2] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_R) (other: t_R) (comb: t_R) : () =
    [%#sra'1] ()
  
  axiom incl_op_spec: forall self: t_R, other: t_R, comb: t_R. ([%#sra] op self other = C_Some comb)
   -> ([%#sra'0] incl self comb)
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 6 4 6 44] (self: t_Option) (other: t_Option) : t_Option'0
  
   =
    [%#soption] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> C_Some'0 other
      | {_p1 = C_None} -> C_Some'0 self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> map_logic (op x y) (fun (z: t_R) -> C_Some z)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 47 4 47 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] and_then_logic (op'0 a b) (fun (ab: t_Option) -> op'0 ab c)
  = and_then_logic (op'0 b c) (fun (bc: t_Option) -> op'0 a bc)
  
  type tuple'0  =
    { _p0'0: t_R; _p1'0: t_R }
  
  predicate premise [#"../../creusot-contracts/src/logic/ra/update.rs" 96 4 96 56] (self: tuple'0) (from_auth: t_R) (from_frag: t_R)
  
   =
    [%#supdate'0] forall f: t_Option. op'0 (C_Some from_frag) f = C_Some'0 (C_Some from_auth)
     -> op'0 (C_Some (self._p1'0)) f = C_Some'0 (C_Some (self._p0'0))
  
  function update [#"../../creusot-contracts/src/logic/ra/update.rs" 106 4 106 41] (self: tuple'0) (_1: t_R) (_2: t_R) : tuple'0
  
   =
    [%#supdate'1] self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#supdate] forall self: tuple'0. forall from_auth: t_R. forall from_frag: t_R. forall frame: t_Option. op'0 (C_Some from_frag) frame
  = C_Some'0 (C_Some from_auth)
  /\ premise self from_auth from_frag
   -> op'0 (C_Some from_frag) frame = C_Some'0 (C_Some from_auth)
  /\ premise self from_auth from_frag
  /\ (forall result: (). (let {_p0'0 = to_auth ; _p1'0 = to_frag} = update self from_auth from_frag in op'0 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth))
   -> (let {_p0'0 = to_auth ; _p1'0 = to_frag} = update self from_auth from_frag in op'0 (C_Some to_frag) frame
  = C_Some'0 (C_Some to_auth)))
end
module M_creusot_contracts__logic__ra__view__qyi3129231301466035151__inhabits__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 63 4 63 25] (* <logic::ra::view::InnerView<R> as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span soption = "../../creusot-contracts/src/std/option.rs" 762 8 765 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 82 8 82 34
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 171 14 171 78
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 86 15 86 43
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 87 14 87 29
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 88 46 88 48
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 130 14 130 32
  let%span sra'5 = "../../creusot-contracts/src/logic/ra.rs" 135 14 135 98
  let%span sra'6 = "../../creusot-contracts/src/logic/ra.rs" 141 15 141 24
  let%span sra'7 = "../../creusot-contracts/src/logic/ra.rs" 142 15 142 24
  let%span sra'8 = "../../creusot-contracts/src/logic/ra.rs" 143 14 143 23
  let%span sra'9 = "../../creusot-contracts/src/logic/ra.rs" 145 8 145 34
  let%span sra'10 = "../../creusot-contracts/src/logic/ra.rs" 47 14 50 5
  let%span sra'11 = "../../creusot-contracts/src/logic/ra.rs" 175 14 175 39
  let%span sra'12 = "../../creusot-contracts/src/logic/ra.rs" 177 8 177 29
  let%span sra'13 = "../../creusot-contracts/src/logic/ra.rs" 181 14 181 55
  let%span sra'14 = "../../creusot-contracts/src/logic/ra.rs" 182 19 182 21
  let%span sra'15 = "../../creusot-contracts/src/logic/ra.rs" 186 14 186 47
  let%span sra'16 = "../../creusot-contracts/src/logic/ra.rs" 187 14 187 43
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 63 4 63 25
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 56 8 56 36
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 21 15 21 31
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 22 15 22 26
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 23 14 23 30
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 27 15 27 30
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 28 14 28 32
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 32 14 32 46
  
  use map.Map
  
  type t_Auth
  
  type t_Option  =
    | C_None
    | C_Some t_Auth
  
  type t_Frag
  
  predicate rel [#"../../creusot-contracts/src/logic/ra/view.rs" 18 4 18 57] (a: t_Option) (f: t_Frag)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 45] (self: t_Frag) (other: t_Frag) : t_Option'0
  
  function factor [#"../../creusot-contracts/src/logic/ra.rs" 51 4 51 50] (self: t_Frag) (factor'0: t_Frag) : t_Option'0
  
  axiom factor_spec: forall self: t_Frag, factor'0: t_Frag. [%#sra'10] match factor self factor'0 with
    | C_Some'0 c -> op factor'0 c = C_Some'0 self
    | C_None'0 -> forall c: t_Frag. op factor'0 c <> C_Some'0 self
    end
  
  predicate incl [#"../../creusot-contracts/src/logic/ra.rs" 81 4 81 38] (self: t_Frag) (other: t_Frag) =
    [%#sra] factor other self <> C_None'0
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 144 4 144 49] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
   =
    [%#sra'9] let _ = () in ()
  
  axiom incl_transitive_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. ([%#sra'6] incl a b)
   -> ([%#sra'7] incl b c)  -> ([%#sra'8] incl a c)
  
  function and_then_logic [#"../../creusot-contracts/src/std/option.rs" 761 4 761 69] (self: t_Option'0) (f: Map.map t_Frag t_Option'0) : t_Option'0
  
   =
    [%#soption] match self with
      | C_None'0 -> C_None'0
      | C_Some'0 x -> Map.get f x
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 136 4 136 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'5] and_then_logic (op a b) (fun (ab: t_Frag) -> op ab c)
  = and_then_logic (op b c) (fun (bc: t_Frag) -> op a bc)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 131 4 131 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'4] op a b = op b a
  
  function incl_op [#"../../creusot-contracts/src/logic/ra.rs" 88 4 88 45] (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
   =
    [%#sra'3] ()
  
  axiom incl_op_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. ([%#sra'1] op self other = C_Some'0 comb)
   -> ([%#sra'2] incl self comb)
  
  function core_total [#"../../creusot-contracts/src/logic/ra.rs" 188 4 188 31] (self: t_Frag) : t_Frag
  
  axiom core_total_spec: forall self: t_Frag. [%#sra'15] op (core_total self) (core_total self)
  = C_Some'0 (core_total self)
  
  axiom core_total_spec'0: forall self: t_Frag. [%#sra'16] op (core_total self) self = C_Some'0 self
  
  constant unit' [#"../../creusot-contracts/src/logic/ra.rs" 172 4 172 22]  : t_Frag
  
  axiom unit_spec: [%#sra'0] forall x: t_Frag [op x unit']. op x unit' = C_Some'0 x
  
  constant unit_core: () = [%#sra'14] ()
  
  axiom unit_core_spec: [%#sra'13] core_total unit' = unit'
  
  constant incl_refl: () = [%#sra'12] let _ = unit' in ()
  
  axiom incl_refl_spec: [%#sra'11] forall x: t_Frag. incl x x
  
  function rel_unit [#"../../creusot-contracts/src/logic/ra/view.rs" 33 4 33 39] (a: t_Option) : ()
  
  axiom rel_unit_spec: forall a: t_Option. [%#sview'6] rel a unit'
  
  function rel_none [#"../../creusot-contracts/src/logic/ra/view.rs" 29 4 29 54] (a: t_Option) (f: t_Frag) : ()
  
  axiom rel_none_spec: forall a: t_Option, f: t_Frag. ([%#sview'4] rel a f)  -> ([%#sview'5] rel (C_None) f)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 24 4 24 71] (a: t_Option) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Option, f1: t_Frag, f2: t_Frag. ([%#sview'1] rel a f1)
   -> ([%#sview'2] incl f2 f1)  -> ([%#sview'3] rel a f2)
  
  type t_InnerView  =
    { t_InnerView__auth: t_Option; t_InnerView__frag: t_Frag }
  
  predicate invariant' [#"../../creusot-contracts/src/logic/ra/view.rs" 55 4 55 30] (self: t_InnerView) =
    [%#sview'0] rel self.t_InnerView__auth self.t_InnerView__frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sview] forall result: t_InnerView. invariant' result  -> invariant' result
end
module M_creusot_contracts__peano__qyi18409208157518949721__cmp__refines [#"../../creusot-contracts/src/peano.rs" 96 4 96 43] (* <peano::PeanoInt as std::cmp::Ord> *)
  type namespace_other
  
  type t_Namespace  =
    | Other namespace_other
  
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'17 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'18 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'19 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'20 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'21 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'22 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'23 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'24 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'25 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'26 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'27 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'28 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'29 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'30 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'31 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'32 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'33 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'34 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span speano = "../../creusot-contracts/src/peano.rs" 96 4 96 43
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 49 4 49 12
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 44 8 44 14
  let%span speano'2 = "../../creusot-contracts/src/peano.rs" 54 4 54 12
  let%span speano'3 = "../../creusot-contracts/src/peano.rs" 59 4 59 12
  let%span speano'4 = "../../creusot-contracts/src/peano.rs" 64 4 64 12
  let%span speano'5 = "../../creusot-contracts/src/peano.rs" 69 4 69 12
  
  use creusot.int.UInt64
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'34] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'32] cmp_log x y = C_Greater)
   -> ([%#sord'33] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'30] cmp_log x y = C_Less)
   -> ([%#sord'31] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'27] cmp_log x y = o)
   -> ([%#sord'28] cmp_log y z = o)  -> ([%#sord'29] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'26] cmp_log x x = C_Equal
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'25] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'24] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'23] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'22] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/peano.rs" 51 4 51 41] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering
  
   =
    [%#speano'0] cmp_log self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'21] ()
  
  axiom eq_cmp_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'20] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'19] ()
  
  axiom antisym2_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ([%#sord'17] cmp_log'0 x y = C_Greater)
   -> ([%#sord'18] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x: t_PeanoInt) (y: t_PeanoInt) : () =
    [%#sord'16] ()
  
  axiom antisym1_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. ([%#sord'14] cmp_log'0 x y = C_Less)
   -> ([%#sord'15] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : ()
  
   =
    [%#sord'13] ()
  
  axiom trans_spec'0: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. ([%#sord'10] cmp_log'0 x y = o)
   -> ([%#sord'11] cmp_log'0 y z = o)  -> ([%#sord'12] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x: t_PeanoInt) : () =
    [%#sord'9] ()
  
  axiom refl_spec'0: forall x: t_PeanoInt. [%#sord'8] cmp_log'0 x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/peano.rs" 71 4 71 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'5] UInt64.gt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'7] ()
  
  axiom cmp_gt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'6] gt_log x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/peano.rs" 66 4 66 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'4] UInt64.ge self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'5] ()
  
  axiom cmp_ge_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'4] ge_log x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/peano.rs" 61 4 61 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'3] UInt64.lt self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'3] ()
  
  axiom cmp_lt_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'2] lt_log x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/peano.rs" 56 4 56 36] (self: t_PeanoInt) (o: t_PeanoInt) =
    [%#speano'2] UInt64.le self.t_PeanoInt__0 o.t_PeanoInt__0
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x: t_PeanoInt) (y: t_PeanoInt) : ()
   =
    [%#sord'1] ()
  
  axiom cmp_le_log_spec'0: forall x: t_PeanoInt, y: t_PeanoInt. [%#sord'0] le_log x y = (cmp_log'0 x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/peano.rs" 43 4 43 30] (self: t_PeanoInt) : UInt64.t =
    [%#speano'1] self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#speano] forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: t_Ordering. result
  = cmp_log'0 self_ rhs  -> result = cmp_log (deep_model self_) (deep_model rhs)
end
