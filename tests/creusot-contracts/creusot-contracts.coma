module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 70 14 70 45
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 71 27 71 29
  let%span sarray'1 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#sarray'1] view self = Seq.(++) visited (view o)
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (self'0: t_IntoIter) : ()
  
  goal vc_produces_refl: [%#sarray] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 75 15 75 32
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 76 15 76 32
  let%span sarray'1 = "../../creusot-contracts/src/std/array.rs" 77 14 77 42
  let%span sarray'2 = "../../creusot-contracts/src/std/array.rs" 78 91 78 93
  let%span sarray'3 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#sarray'3] view self = Seq.(++) visited (view o)
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (a'0: t_IntoIter) (ab'0: Seq.seq t_T) (b'0: t_IntoIter) (bc'0: Seq.seq t_T) (c'0: t_IntoIter) : ()
  
  
  goal vc_produces_trans: ([%#sarray] produces a ab b)
   -> ([%#sarray'0] produces b bc c)  -> ([%#sarray'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__clone__extern_spec_Clone_bool_clone_body [#"../../creusot-contracts/src/std/clone.rs" 19 8 19 31]
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 18 18 18 33
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_bool_clone_body[#"../../creusot-contracts/src/std/clone.rs" 19 8 19 31] (self_:bool) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: bool = Any.any_l () | & self_'0: bool = self_ ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_Clone_bool_clone_body ensures] [%#sclone] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__clone__extern_spec_Clone_f32_clone_body [#"../../creusot-contracts/src/std/clone.rs" 26 8 26 30]
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 25 18 25 33
  
  use creusot.float.Float32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_f32_clone_body[#"../../creusot-contracts/src/std/clone.rs" 26 8 26 30] (self_:Float32.t) (return'  (x:Float32.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Float32.t = Any.any_l () | & self_'0: Float32.t = self_ ] 
    [ return''0 (result:Float32.t)-> {[@expl:extern_spec_Clone_f32_clone_body ensures] [%#sclone] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__clone__extern_spec_Clone_f64_clone_body [#"../../creusot-contracts/src/std/clone.rs" 33 8 33 30]
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 32 18 32 33
  
  use creusot.float.Float64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_f64_clone_body[#"../../creusot-contracts/src/std/clone.rs" 33 8 33 30] (self_:Float64.t) (return'  (x:Float64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Float64.t = Any.any_l () | & self_'0: Float64.t = self_ ] 
    [ return''0 (result:Float64.t)-> {[@expl:extern_spec_Clone_f64_clone_body ensures] [%#sclone] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__clone__extern_spec_T_Cloneqy95z_ref_T_clone_body [#"../../creusot-contracts/src/std/clone.rs" 40 8 40 32]
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 39 8 39 9
  let%span sclone'0 = "../../creusot-contracts/src/std/clone.rs" 40 27 40 32
  let%span sclone'1 = "../../creusot-contracts/src/std/clone.rs" 39 18 39 33
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_T_Cloneqy95z_ref_T_clone_body[#"../../creusot-contracts/src/std/clone.rs" 40 8 40 32] (self_:t_T) (return'  (x:t_T))= {[@expl:extern_spec_T_Clone__ref_T_clone_body 'self_' type invariant] [%#sclone] inv'1 self_}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ] )
    [ & _0: t_T = Any.any_l () | & self_'0: t_T = self_ ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_T_Clone__ref_T_clone_body result type invariant] [%#sclone'0] inv'0 result}
      {[@expl:extern_spec_T_Clone__ref_T_clone_body ensures] [%#sclone'1] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 97 14 97 45
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 98 27 98 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self: t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'1
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  constant self  : t_IntoIter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (self'0: t_IntoIter'0) : ()
  
  
  goal vc_produces_refl: [%#shash_map] produces self (Seq.empty: Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 102 15 102 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 103 15 103 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 104 14 104 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 106 24 106 97
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 106 8 106 99
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self: t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'1
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq tuple'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq tuple'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (a'0: t_IntoIter'0) (ab'0: Seq.seq tuple'0) (b'0: t_IntoIter'0) (bc'0: Seq.seq tuple'0) (c'0: t_IntoIter'0) : ()
  
  
  goal vc_produces_trans: ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i: int. 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 149 14 149 45
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 150 27 150 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self: t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  constant self  : t_Iter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (self'0: t_Iter'0) : ()
  
  
  goal vc_produces_refl: [%#shash_map] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 154 15 154 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 155 15 155 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 156 14 156 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 158 24 158 97
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 158 8 158 99
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self: t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Iter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (a'0: t_Iter'0) (ab'0: Seq.seq tuple) (b'0: t_Iter'0) (bc'0: Seq.seq tuple) (c'0: t_Iter'0) : ()
  
  
  goal vc_produces_trans: ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i: int. 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 201 14 201 45
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 202 27 202 29
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self: t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0)
  
   =
    [%#shash_map'1] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  constant self  : t_IterMut'0
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (self'0: t_IterMut'0) : ()
  
  
  goal vc_produces_refl: [%#shash_map] produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 206 15 206 32
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 207 15 207 32
  let%span shash_map'1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 208 14 208 42
  let%span shash_map'2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 210 24 210 97
  let%span shash_map'3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 210 8 210 99
  let%span shash_map'4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self: t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0)
  
   =
    [%#shash_map'4] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_IterMut'0
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (a'0: t_IterMut'0) (ab'0: Seq.seq tuple) (b'0: t_IterMut'0) (bc'0: Seq.seq tuple) (c'0: t_IterMut'0) : ()
  
  
  goal vc_produces_trans: ([%#shash_map] produces a ab b)
   -> ([%#shash_map'0] produces b bc c)
   -> ([%#shash_map'2] forall i: int. 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 86 8 86 82
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 101 20 101 103
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 102 20 102 93
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_I
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/model.rs" 15 4 15 34] (self: t_I) : Fset.fset t_DeepModelTy
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_I) (visited: Seq.seq t_T) (end': t_I)
  
   =
    [%#shash_set'5] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function get [#"../../creusot-contracts/src/logic/seq.rs" 82 4 84 17] (self: Seq.seq t_T) (ix: int) : t_Option =
    [%#sseq'2] if 0 <= ix /\ ix < Seq.length self then C_Some (Seq.get self ix) else C_None
  
  constant a  : t_I
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_I
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_I
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a'0: t_I) (ab'0: Seq.seq t_T) (b'0: t_I) (bc'0: Seq.seq t_T) (c'0: t_I) : ()
  
  
  goal vc_set_produces_trans: ([%#shash_set] set_produces a ab b)
   -> ([%#shash_set'0] set_produces b bc c)
   -> ([%#sseq] forall a'0: Seq.seq t_T, b'0: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a'0 b'0) x = contains'0 a'0 x
  \/ contains'0 b'0 x)
   -> (let _ = concat_contains in ([%#shash_set'2] forall i: int, x: t_T. Seq.length ab <= i
  /\ get (Seq.(++) ab bc) i = C_Some x  -> contains'0 bc x)
  && (let _ = () in let _ = () in ([%#shash_set'3] forall i: int. 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in let _ = () in [%#shash_set'1] set_produces a (Seq.(++) ab bc) c)))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 120 14 120 45
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 121 27 121 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  constant self  : t_IntoIter'1
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (self'0: t_IntoIter'1) : ()
  
  
  goal vc_produces_refl: [%#shash_set] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 125 15 125 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 126 15 126 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 127 14 127 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 129 8 129 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a: t_IntoIter'1) (ab: Seq.seq t_T) (b: t_IntoIter'1) (bc: Seq.seq t_T) (c: t_IntoIter'1) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_IntoIter'1, ab: Seq.seq t_T, b: t_IntoIter'1, bc: Seq.seq t_T, c: t_IntoIter'1. ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  constant a  : t_IntoIter'1
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter'1
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter'1
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (a'0: t_IntoIter'1) (ab'0: Seq.seq t_T) (b'0: t_IntoIter'1) (bc'0: Seq.seq t_T) (c'0: t_IntoIter'1) : ()
  
  
  goal vc_produces_trans: ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 159 14 159 45
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 160 27 160 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  constant self  : t_Iter'1
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (self'0: t_Iter'1) : ()
  
  
  goal vc_produces_refl: [%#shash_set] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 164 15 164 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 165 15 165 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 166 14 166 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 168 8 168 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a: t_Iter'1) (ab: Seq.seq t_T) (b: t_Iter'1) (bc: Seq.seq t_T) (c: t_Iter'1) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Iter'1, ab: Seq.seq t_T, b: t_Iter'1, bc: Seq.seq t_T, c: t_Iter'1. ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  constant a  : t_Iter'1
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter'1
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter'1
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (a'0: t_Iter'1) (ab'0: Seq.seq t_T) (b'0: t_Iter'1) (bc'0: Seq.seq t_T) (c'0: t_Iter'1) : ()
  
  
  goal vc_produces_trans: ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 217 14 217 45
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 218 27 218 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  constant self  : t_Intersection
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (self'0: t_Intersection) : ()
  
  
  goal vc_produces_refl: [%#shash_set] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 222 15 222 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 223 15 223 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 224 14 224 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 226 8 226 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  constant a  : t_Intersection
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Intersection
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Intersection
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (a'0: t_Intersection) (ab'0: Seq.seq t_T) (b'0: t_Intersection) (bc'0: Seq.seq t_T) (c'0: t_Intersection) : ()
  
  
  goal vc_produces_trans: ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 245 14 245 45
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 246 27 246 29
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self: t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference)
  
   =
    [%#shash_set'2] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference)
  
   =
    [%#shash_set'1] set_produces self visited o
  
  constant self  : t_Difference
  
  function produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (self'0: t_Difference) : ()
  
  
  goal vc_produces_refl: [%#shash_set] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 250 15 250 32
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 251 15 251 32
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 252 14 252 42
  let%span shash_set'2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 254 8 254 43
  let%span shash_set'6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span shash_set'8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self: t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference)
  
   =
    [%#shash_set'8] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference)
  
   =
    [%#shash_set'6] set_produces self visited o
  
  constant concat_contains: () = [%#sseq'0] ()
  
  axiom concat_contains_spec: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 93 0 99 1] (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
  
   =
    [%#shash_set'7] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. ([%#shash_set'2] set_produces a ab b)
   -> ([%#shash_set'3] set_produces b bc c)  -> ([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
  
  constant a  : t_Difference
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Difference
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Difference
  
  function produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (a'0: t_Difference) (ab'0: Seq.seq t_T) (b'0: t_Difference) (bc'0: Seq.seq t_T) (c'0: t_Difference) : ()
  
  
  goal vc_produces_trans: ([%#shash_set] produces a ab b)
   -> ([%#shash_set'0] produces b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set'2] set_produces a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set'3] set_produces b bc c))
  /\ (([%#shash_set'4] set_produces a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans a ab b bc c in [%#shash_set'1] produces a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialEq_Rhs_ne_body [#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 17 16 17 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 18 29 18 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 17 26 17 75
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 11 16 11 17
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 12 29 12 32
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom [@rewrite]: forall x: t_Self_ [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Rhs [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Rhs [inv'4 x]. inv'4 x = invariant''2 x
  
  type t_DeepModelTy
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'2 self
  
  function deep_model'4 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'3 self
  
  let rec eq (self_:t_Self_) (rhs:t_Rhs) (return'  (x:bool))= {[@expl:eq 'self_' type invariant] [%#scmp'2] inv'1 self_}
    {[@expl:eq 'rhs' type invariant] [%#scmp'3] inv'4 rhs}
    any
    [ return''0 (result:bool)-> {[%#scmp'4] result = (deep_model'1 self_ = deep_model'4 rhs)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialEq_Rhs_ne_body[#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18] (self_:t_Self_) (rhs:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'self_' type invariant] [%#scmp] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'rhs' type invariant] [%#scmp'0] inv'3 rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq {self_'0} {rhs'0} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- not _4 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: bool = Any.any_l () | & self_'0: t_Self_ = self_ | & rhs'0: t_Rhs = rhs | & _4: bool = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body ensures] [%#scmp'1] result
      = (deep_model'0 self_ <> deep_model'3 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 39 29 39 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 38 48 38 52
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 35 16 35 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 36 29 36 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rhs [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: t_Option)
  
  
  axiom postcondition_fndef: forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_lt_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb8) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb4) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & other'0: t_Rhs = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body ensures] [%#scmp'3] result
      = lt_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_le_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 47 29 47 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 46 66 46 70
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 43 16 43 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 44 29 44 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 43 26 43 77
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rhs [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: t_Option)
  
  
  axiom postcondition_fndef: forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_le_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb8) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb4) | br1 -> {r0 = C_Equal} (! bb4) | br2 -> {r0 = C_Greater} (! bb2) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & other'0: t_Rhs = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body ensures] [%#scmp'3] result
      = le_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 55 29 55 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 54 51 54 55
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 51 16 51 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 52 29 52 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 51 26 51 76
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rhs [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: t_Option)
  
  
  axiom postcondition_fndef: forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_gt_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb8) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb2) | br2 -> {r0 = C_Greater} (! bb4) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & other'0: t_Rhs = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body ensures] [%#scmp'3] result
      = gt_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 63 29 63 34
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 62 69 62 73
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 59 16 59 17
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 60 29 60 34
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 59 26 59 77
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  type t_Self_
  
  type t_Rhs
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Rhs }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Rhs) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rhs)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rhs [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Self_ [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'0 rhs
  /\ inv'2 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: t_Option)
  
  
  axiom postcondition_fndef: forall args: tuple, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = C_Some (cmp_log (deep_model self_) (deep_model'0 rhs)))
  
  let rec partial_cmp (self_:t_Self_) (rhs:t_Rhs) (return'  (x:t_Option))= {[@expl:partial_cmp requires] precondition () { _p0 = self_;
                                                                                                                           _p1 = rhs }}
    any
    [ return''0 (result:t_Option)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Ordering))= any
    [ good (field_0:t_Ordering)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Ordering [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Rhs) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_ge_body[#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18] (self_:t_Self_) (other:t_Rhs) (return'  (x:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'self_' type invariant] [%#scmp'1] inv'2 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'other' type invariant] [%#scmp'2] inv'0 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp {self_'0} {other'0} (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None} (! bb8) | br1 (x0:t_Ordering)-> {_4 = C_Some x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some {_4}
        (fun (r0:t_Ordering) ->
          any [ br0 -> {r0 = C_Less} (! bb2) | br1 -> {r0 = C_Equal} (! bb4) | br2 -> {r0 = C_Greater} (! bb4) ] )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp'0] true ] s1 | s1 = bb6 ] 
    | bb6 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & other'0: t_Rhs = other
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body ensures] [%#scmp'3] result
      = ge_log (deep_model'1 self_) (deep_model'2 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_max_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 75 16 75 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 80 29 80 30
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 80 41 80 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 75 26 75 66
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 76 26 76 63
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 77 26 77 55
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 78 26 78 77
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 79 26 79 79
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom [@rewrite]: forall x: t_Self_ [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: bool)
  
  
  axiom postcondition_fndef: forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = le_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec le (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:le requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_max_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18] (self_:t_Self_) (o:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_max_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_max_body 'o' type invariant] [%#scmp'0] inv o}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = le {self_'0} {o'0} (fun (_ret:bool) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_8 = false} (! bb8) | br1 -> {_8} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- o'0 ] s3
      | s3 = bb9 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv o'0} s1 | s1 = -{resolve o'0}- s2 | s2 =  [ &_0 <- self_'0 ] s3 | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    ) [ & _0: t_Self_ = Any.any_l () | & self_'0: t_Self_ = self_ | & o'0: t_Self_ = o | & _8: bool = Any.any_l () ] 
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_max_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #0] [%#scmp'2] ge_log (deep_model result) (deep_model self_)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #1] [%#scmp'3] ge_log (deep_model result) (deep_model o)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #2] [%#scmp'4] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #3] [%#scmp'5] le_log (deep_model self_) (deep_model o)
       -> result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #4] [%#scmp'6] lt_log (deep_model o) (deep_model self_)
       -> result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_min_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 84 16 84 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 89 29 89 30
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 89 41 89 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 84 26 84 66
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 85 26 85 63
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 86 26 86 55
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 87 26 87 79
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 88 26 88 77
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom [@rewrite]: forall x: t_Self_ [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: bool)
  
  
  axiom postcondition_fndef: forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = lt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec lt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:lt requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_min_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18] (self_:t_Self_) (o:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_min_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_min_body 'o' type invariant] [%#scmp'0] inv o}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = lt {self_'0} {o'0} (fun (_ret:bool) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_8 = false} (! bb8) | br1 -> {_8} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv o'0} s1 | s1 = -{resolve o'0}- s2 | s2 =  [ &_0 <- self_'0 ] s3 | s3 = bb9 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- o'0 ] s3
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    ) [ & _0: t_Self_ = Any.any_l () | & self_'0: t_Self_ = self_ | & o'0: t_Self_ = o | & _8: bool = Any.any_l () ] 
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_min_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #0] [%#scmp'2] le_log (deep_model result) (deep_model self_)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #1] [%#scmp'3] le_log (deep_model result) (deep_model o)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #2] [%#scmp'4] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #3] [%#scmp'5] lt_log (deep_model self_) (deep_model o)
       -> result = self_}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #4] [%#scmp'6] le_log (deep_model o) (deep_model self_)
       -> result = o}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_clamp_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 93 16 93 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 102 31 102 34
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 102 42 102 45
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 93 27 93 63
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 102 56 102 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 94 26 94 65
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 95 26 95 65
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 96 26 96 74
  let%span scmp'7 = "../../creusot-contracts/src/std/cmp.rs" 97 26 101 41
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tuple  =
    { _p0: t_Self_; _p1: t_Self_ }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Self_) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Self_)
  
  axiom inv_axiom [@rewrite]: forall x: t_Self_ [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Self_) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Self_) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: bool)
  
  
  axiom postcondition_fndef: forall args: tuple, res: bool [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = gt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec gt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:gt requires] precondition () { _p0 = self_;
                                                                                                         _p1 = other }}
    any [ return''0 (result:bool)-> {postcondition_once () { _p0 = self_; _p1 = other } result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Self_)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef'0: forall args: tuple [precondition'0 () args]. (let {_p0 = self_ ; _p1 = other} = args in inv'0 other
  /\ inv'0 self_)  -> precondition'0 () args
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: bool)
  
  
  axiom postcondition_fndef'0: forall args: tuple, res: bool [postcondition_once'0 () args res]. postcondition_once'0 () args res
   -> (let {_p0 = self_ ; _p1 = other} = args in res = lt_log (deep_model'0 self_) (deep_model'0 other))
  
  let rec lt (self_:t_Self_) (other:t_Self_) (return'  (x:bool))= {[@expl:lt requires] precondition'0 () { _p0 = self_;
                                                                                                           _p1 = other }}
    any
    [ return''0 (result:bool)-> {postcondition_once'0 () { _p0 = self_; _p1 = other } result} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_clamp_body[#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18] (self_:t_Self_) (min:t_Self_) (max:t_Self_) (return'  (x:t_Self_))= {[@expl:extern_spec_std_cmp_Ord_clamp_body 'self_' type invariant] [%#scmp] inv self_}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'min' type invariant] [%#scmp'0] inv min}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'max' type invariant] [%#scmp'1] inv max}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body requires] [%#scmp'2] le_log (deep_model min) (deep_model max)}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = gt {self_'0} {max'0} (fun (_ret:bool) ->  [ &_9 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_9 = false} (! bb8) | br1 -> {_9} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv min'0} s1
      | s1 = -{resolve min'0}- s2
      | s2 = {[@expl:type invariant] inv self_'0} s3
      | s3 = -{resolve self_'0}- s4
      | s4 =  [ &_0 <- max'0 ] s5
      | s5 = bb13 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv max'0} s1
      | s1 = -{resolve max'0}- s2
      | s2 = lt {self_'0} {min'0} (fun (_ret:bool) ->  [ &_12 <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv self_'0} s1
      | s1 = -{resolve self_'0}- s2
      | s2 =  [ &_0 <- min'0 ] s3
      | s3 = bb12 ]
    
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv min'0} s1
      | s1 = -{resolve min'0}- s2
      | s2 =  [ &_0 <- self_'0 ] s3
      | s3 = bb12 ]
    
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0: t_Self_ = Any.any_l ()
    | & self_'0: t_Self_ = self_
    | & min'0: t_Self_ = min
    | & max'0: t_Self_ = max
    | & _9: bool = Any.any_l ()
    | & _12: bool = Any.any_l () ]
    
    [ return''0 (result:t_Self_)-> {[@expl:extern_spec_std_cmp_Ord_clamp_body result type invariant] [%#scmp'3] inv result}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #0] [%#scmp'4] ge_log (deep_model result) (deep_model min)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #1] [%#scmp'5] le_log (deep_model result) (deep_model max)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #2] [%#scmp'6] result = self_ \/ result = min \/ result = max}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #3] [%#scmp'7] if gt_log (deep_model self_) (deep_model max) then
        result = max
      else
        if lt_log (deep_model self_) (deep_model min) then result = min else result = self_
      }
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_max_body [#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66]
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 112 22 112 24
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 112 29 112 31
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 112 39 112 40
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 107 22 107 60
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 108 22 108 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 109 22 109 50
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 110 22 110 73
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 111 22 111 72
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_T
  
  type tuple  =
    { _p0: t_T; _p1: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = o} = args in inv o
  /\ inv self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: tuple, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = o} = args in (lt_log (deep_model o) (deep_model self_)  -> res = self_)
  /\ (le_log (deep_model self_) (deep_model o)  -> res = o)
  /\ (res = self_ \/ res = o)
  /\ ge_log (deep_model res) (deep_model o) /\ ge_log (deep_model res) (deep_model self_) /\ inv res)
  
  let rec max (self_:t_T) (o:t_T) (return'  (x:t_T))= {[@expl:max requires] precondition () { _p0 = self_; _p1 = o }}
    any [ return''0 (result:t_T)-> {postcondition_once () { _p0 = self_; _p1 = o } result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_max_body[#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66] (v1:t_T) (v2:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_cmp_max_body 'v1' type invariant] [%#scmp] inv v1}
    {[@expl:extern_spec_std_cmp_max_body 'v2' type invariant] [%#scmp'0] inv v2}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = max {v1'0} {v2'0} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return''0 {_0} ]
    ) [ & _0: t_T = Any.any_l () | & v1'0: t_T = v1 | & v2'0: t_T = v2 ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_cmp_max_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_max_body ensures #0] [%#scmp'2] ge_log (deep_model result) (deep_model v1)}
      {[@expl:extern_spec_std_cmp_max_body ensures #1] [%#scmp'3] ge_log (deep_model result) (deep_model v2)}
      {[@expl:extern_spec_std_cmp_max_body ensures #2] [%#scmp'4] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #3] [%#scmp'5] le_log (deep_model v1) (deep_model v2)
       -> result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #4] [%#scmp'6] lt_log (deep_model v2) (deep_model v1)
       -> result = v1}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_min_body [#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66]
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 123 22 123 24
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 123 29 123 31
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 123 39 123 40
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 118 22 118 60
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 119 22 119 60
  let%span scmp'4 = "../../creusot-contracts/src/std/cmp.rs" 120 22 120 50
  let%span scmp'5 = "../../creusot-contracts/src/std/cmp.rs" 121 22 121 72
  let%span scmp'6 = "../../creusot-contracts/src/std/cmp.rs" 122 22 122 73
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_T
  
  type tuple  =
    { _p0: t_T; _p1: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = o} = args in inv o
  /\ inv self_)  -> precondition () args
  
  type t_DeepModelTy
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: tuple) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: tuple, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = o} = args in (le_log (deep_model o) (deep_model self_)  -> res = o)
  /\ (lt_log (deep_model self_) (deep_model o)  -> res = self_)
  /\ (res = self_ \/ res = o)
  /\ le_log (deep_model res) (deep_model o) /\ le_log (deep_model res) (deep_model self_) /\ inv res)
  
  let rec min (self_:t_T) (o:t_T) (return'  (x:t_T))= {[@expl:min requires] precondition () { _p0 = self_; _p1 = o }}
    any [ return''0 (result:t_T)-> {postcondition_once () { _p0 = self_; _p1 = o } result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_min_body[#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66] (v1:t_T) (v2:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_cmp_min_body 'v1' type invariant] [%#scmp] inv v1}
    {[@expl:extern_spec_std_cmp_min_body 'v2' type invariant] [%#scmp'0] inv v2}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = min {v1'0} {v2'0} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return''0 {_0} ]
    ) [ & _0: t_T = Any.any_l () | & v1'0: t_T = v1 | & v2'0: t_T = v2 ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_cmp_min_body result type invariant] [%#scmp'1] inv result}
      {[@expl:extern_spec_std_cmp_min_body ensures #0] [%#scmp'2] le_log (deep_model result) (deep_model v1)}
      {[@expl:extern_spec_std_cmp_min_body ensures #1] [%#scmp'3] le_log (deep_model result) (deep_model v2)}
      {[@expl:extern_spec_std_cmp_min_body ensures #2] [%#scmp'4] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_min_body ensures #3] [%#scmp'5] lt_log (deep_model v1) (deep_model v2)
       -> result = v1}
      {[@expl:extern_spec_std_cmp_min_body ensures #4] [%#scmp'6] le_log (deep_model v2) (deep_model v1)
       -> result = v2}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 155 14 155 64
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 156 36 156 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Greater
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_cmp_le_log: [%#scmp] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 160 14 160 61
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 161 36 161 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Less
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_cmp_lt_log: [%#scmp] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 165 14 165 61
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 166 36 166 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Less
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_cmp_ge_log: [%#scmp] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 170 14 170 64
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 171 36 171 38
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Greater
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_cmp_gt_log: [%#scmp] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 175 14 175 45
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 176 21 176 23
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  function refl'0 [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (x'0: t_Reverse) : ()
  
  goal vc_refl: [%#scmp] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 180 15 180 32
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 181 15 181 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 182 14 182 31
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 183 53 183 55
  let%span scmp'3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'3] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  constant z  : t_Reverse
  
  constant o  : t_Ordering
  
  function trans'0 [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (x'0: t_Reverse) (y'0: t_Reverse) (z'0: t_Reverse) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#scmp] cmp_log'0 x y = o)  -> ([%#scmp'0] cmp_log'0 y z = o)  -> ([%#scmp'1] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1 [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 187 15 187 45
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 188 14 188 47
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 189 34 189 36
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'2] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function antisym1'0 [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_antisym1: ([%#scmp] cmp_log'0 x y = C_Less)  -> ([%#scmp'0] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2 [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 193 15 193 48
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 194 14 194 44
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 195 34 195 36
  let%span scmp'2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'2] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function antisym2'0 [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_antisym2: ([%#scmp] cmp_log'0 x y = C_Greater)  -> ([%#scmp'0] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 199 14 199 59
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 200 32 200 34
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'1] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  constant x  : t_Reverse
  
  constant y  : t_Reverse
  
  function eq_cmp'0 [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (x'0: t_Reverse) (y'0: t_Reverse) : ()
  
  goal vc_eq_cmp: [%#scmp] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl [#"../../creusot-contracts/src/std/deque.rs" 177 4 177 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 176 14 176 45
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 177 27 177 29
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 170 12 170 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 82 14 82 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 83 14 83 76
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'1] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'2] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 84 4 84 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. ([%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'0] forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 154 4 154 33] (self: t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 168 4 168 65] (self: t_Iter'0) (visited: Seq.seq t_T) (tl: t_Iter'0)
  
   =
    [%#sdeque'1] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  constant self  : t_Iter'0
  
  function produces_refl [#"../../creusot-contracts/src/std/deque.rs" 177 4 177 26] (self'0: t_Iter'0) : ()
  
  goal vc_produces_refl: [%#sdeque] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans [#"../../creusot-contracts/src/std/deque.rs" 184 4 184 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 181 15 181 32
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 182 15 182 32
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 183 14 183 42
  let%span sdeque'2 = "../../creusot-contracts/src/std/deque.rs" 184 91 184 93
  let%span sdeque'3 = "../../creusot-contracts/src/std/deque.rs" 170 12 170 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 82 14 82 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 83 14 83 76
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'1] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'2] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 84 4 84 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. ([%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'0] forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 154 4 154 33] (self: t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 168 4 168 65] (self: t_Iter'0) (visited: Seq.seq t_T) (tl: t_Iter'0)
  
   =
    [%#sdeque'3] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter'0
  
  function produces_trans [#"../../creusot-contracts/src/std/deque.rs" 184 4 184 90] (a'0: t_Iter'0) (ab'0: Seq.seq t_T) (b'0: t_Iter'0) (bc'0: Seq.seq t_T) (c'0: t_Iter'0) : ()
  
  
  goal vc_produces_trans: ([%#sdeque] produces a ab b)
   -> ([%#sdeque'0] produces b bc c)  -> ([%#sdeque'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_assert_unchecked_body [#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 7 23 7 27
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_assert_unchecked_body[#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1] (cond:bool) (return'  (x:()))= {[@expl:extern_spec_std_hint_assert_unchecked_body requires] [%#shint] cond}
    (! bb0 [ bb0 = return''0 {_0} ] ) [ & _0: () = Any.any_l () ]  [ return''0 (result:())-> (! return' {result}) ] 
end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_black_box_body [#"../../creusot-contracts/src/std/hint.rs" 12 12 12 42]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 12 28 12 33
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 12 41 12 42
  let%span shint'1 = "../../creusot-contracts/src/std/hint.rs" 11 22 11 37
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_black_box_body[#"../../creusot-contracts/src/std/hint.rs" 12 12 12 42] (dummy:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_hint_black_box_body 'dummy' type invariant] [%#shint] inv dummy}
    (! bb0 [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- dummy'0 ] s1 | s1 = bb2 ]  | bb2 = return''0 {_0} ] )
    [ & _0: t_T = Any.any_l () | & dummy'0: t_T = dummy ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_hint_black_box_body result type invariant] [%#shint'0] inv result}
      {[@expl:extern_spec_std_hint_black_box_body ensures] [%#shint'1] result = dummy}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_spin_loop_body [#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 17 23 17 27
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 18 22 18 26
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_spin_loop_body[#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1] (return'  (x:()))= {[@expl:extern_spec_std_hint_spin_loop_body requires] [%#shint] true}
    (! bb0 [ bb0 = return''0 {_0} ] ) [ & _0: () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_hint_spin_loop_body ensures] [%#shint'0] true}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_unreachable_unchecked_body [#"../../creusot-contracts/src/std/hint.rs" 23 12 23 50]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 81 8 81 13
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 22 23 22 28
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 23 49 23 50
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 80 4 80 30] (self: ()) =
    [%#sinvariant] false
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom [@rewrite]: forall x: () [inv x]. inv x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_unreachable_unchecked_body[#"../../creusot-contracts/src/std/hint.rs" 23 12 23 50] (return'  (x:()))= {[@expl:extern_spec_std_hint_unreachable_unchecked_body requires] [%#shint] false}
    (! bb0 [ bb0 = {false} any ] )
    [ return''0 (result:())-> {[@expl:extern_spec_std_hint_unreachable_unchecked_body result type invariant] [%#shint'0] inv result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_must_use_body [#"../../creusot-contracts/src/std/hint.rs" 30 12 30 41]
  let%span shint = "../../creusot-contracts/src/std/hint.rs" 30 27 30 32
  let%span shint'0 = "../../creusot-contracts/src/std/hint.rs" 30 40 30 41
  let%span shint'1 = "../../creusot-contracts/src/std/hint.rs" 29 22 29 37
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_must_use_body[#"../../creusot-contracts/src/std/hint.rs" 30 12 30 41] (value:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_hint_must_use_body 'value' type invariant] [%#shint] inv value}
    (! bb0 [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- value'0 ] s1 | s1 = bb2 ]  | bb2 = return''0 {_0} ] )
    [ & _0: t_T = Any.any_l () | & value'0: t_T = value ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_hint_must_use_body result type invariant] [%#shint'0] inv result}
      {[@expl:extern_spec_std_hint_must_use_body ensures] [%#shint'1] result = value}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__io__extern_spec_std_ioqy95z_print_body [#"../../creusot-contracts/src/std/io.rs" 4 0 18 1]
  let%span sio = "../../creusot-contracts/src/std/io.rs" 9 22 9 26
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use creusot.prelude.Char
  use creusot.int.UInt32
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Alignment  =
    | C_Left
    | C_Right
    | C_Center
    | C_Unknown
  
  type t_Count  =
    | C_Is UInt64.t
    | C_Param UInt64.t
    | C_Implied
  
  type t_Placeholder  =
    { t_Placeholder__position: UInt64.t;
      t_Placeholder__fill: Char.t;
      t_Placeholder__align: t_Alignment;
      t_Placeholder__flags: UInt32.t;
      t_Placeholder__precision: t_Count;
      t_Placeholder__width: t_Count }
  
  type t_Option  =
    | C_None
    | C_Some (Slice64.slice t_Placeholder)
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_ArgumentType  =
    | C_Placeholder t_NonNull Opaque.ptr ()
    | C_Count UInt64.t
  
  type t_Argument  =
    { t_Argument__ty: t_ArgumentType }
  
  type t_Arguments  =
    { t_Arguments__pieces: Slice64.slice string;
      t_Arguments__fmt: t_Option;
      t_Arguments__args: Slice64.slice t_Argument }
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_ioqy95z_print_body[#"../../creusot-contracts/src/std/io.rs" 4 0 18 1] (args:t_Arguments) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_io__print_body ensures] [%#sio] true} (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__io__extern_spec_std_ioqy95z_eprint_body [#"../../creusot-contracts/src/std/io.rs" 4 0 18 1]
  let%span sio = "../../creusot-contracts/src/std/io.rs" 14 22 14 26
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use creusot.prelude.Char
  use creusot.int.UInt32
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Alignment  =
    | C_Left
    | C_Right
    | C_Center
    | C_Unknown
  
  type t_Count  =
    | C_Is UInt64.t
    | C_Param UInt64.t
    | C_Implied
  
  type t_Placeholder  =
    { t_Placeholder__position: UInt64.t;
      t_Placeholder__fill: Char.t;
      t_Placeholder__align: t_Alignment;
      t_Placeholder__flags: UInt32.t;
      t_Placeholder__precision: t_Count;
      t_Placeholder__width: t_Count }
  
  type t_Option  =
    | C_None
    | C_Some (Slice64.slice t_Placeholder)
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_ArgumentType  =
    | C_Placeholder t_NonNull Opaque.ptr ()
    | C_Count UInt64.t
  
  type t_Argument  =
    { t_Argument__ty: t_ArgumentType }
  
  type t_Arguments  =
    { t_Arguments__pieces: Slice64.slice string;
      t_Arguments__fmt: t_Option;
      t_Arguments__args: Slice64.slice t_Argument }
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_ioqy95z_eprint_body[#"../../creusot-contracts/src/std/io.rs" 4 0 18 1] (args:t_Arguments) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_io__eprint_body ensures] [%#sio] true} (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl [#"../../creusot-contracts/src/std/iter/cloned.rs" 59 4 59 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 58 14 58 45
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 59 27 59 29
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 50 12 53 98
  let%span scloned'2 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'2] inv'0 self  -> inv (iter self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv'1 res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv'1 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv'1 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'2 self_)
   -> precondition () args
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 48 4 48 55] (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned)
  
   =
    [%#scloned'1] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  constant self  : t_Cloned
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 59 4 59 26] (self'0: t_Cloned) : ()
  
  goal vc_produces_refl: [%#scloned] produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 72] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 62 15 62 32
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 63 15 63 32
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 64 14 64 42
  let%span scloned'2 = "../../creusot-contracts/src/std/iter/cloned.rs" 65 73 65 75
  let%span scloned'3 = "../../creusot-contracts/src/std/iter/cloned.rs" 50 12 53 98
  let%span scloned'4 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'4] inv'0 self  -> inv (iter self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv'1 res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv'1 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv'1 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'2 self_)
   -> precondition () args
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 48 4 48 55] (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned)
  
   =
    [%#scloned'3] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  constant a  : t_Cloned
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Cloned
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Cloned
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 72] (a'0: t_Cloned) (ab'0: Seq.seq t_T) (b'0: t_Cloned) (bc'0: Seq.seq t_T) (c'0: t_Cloned) : ()
  
  
  goal vc_produces_trans: ([%#scloned] produces'0 a ab b)
   -> ([%#scloned'0] produces'0 b bc c)  -> ([%#scloned'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl [#"../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 58 14 58 45
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 59 27 59 29
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'2 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 48 4 48 64] (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied)
  
   =
    [%#scopied'1] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant self  : t_Copied
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 26] (self'0: t_Copied) : ()
  
  goal vc_produces_refl: [%#scopied] produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  let%span scopied'2 = "../../creusot-contracts/src/std/iter/copied.rs" 65 91 65 93
  let%span scopied'3 = "../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'4 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'4] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 48 4 48 64] (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied)
  
   =
    [%#scopied'3] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant a  : t_Copied
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Copied
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Copied
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (a'0: t_Copied) (ab'0: Seq.seq t_T) (b'0: t_Copied) (bc'0: Seq.seq t_T) (c'0: t_Copied) : ()
  
  
  goal vc_produces_trans: ([%#scopied] produces'0 a ab b)
   -> ([%#scopied'0] produces'0 b bc c)  -> ([%#scopied'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 17 14 17 45
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 18 27 18 29
  let%span sempty'1 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty)
  
   =
    [%#sempty'1] visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  constant self  : t_Empty
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (self'0: t_Empty) : ()
  
  goal vc_produces_refl: [%#sempty] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 21 15 21 32
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 22 15 22 32
  let%span sempty'1 = "../../creusot-contracts/src/std/iter/empty.rs" 23 14 23 42
  let%span sempty'2 = "../../creusot-contracts/src/std/iter/empty.rs" 24 91 24 93
  let%span sempty'3 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty)
  
   =
    [%#sempty'3] visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  constant a  : t_Empty
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Empty
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Empty
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (a'0: t_Empty) (ab'0: Seq.seq t_T) (b'0: t_Empty) (bc'0: Seq.seq t_T) (c'0: t_Empty) : ()
  
  
  goal vc_produces_trans: ([%#sempty] produces a ab b)
   -> ([%#sempty'0] produces b bc c)  -> ([%#sempty'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 82 14 82 45
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 83 27 83 29
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 73 12 77 108
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  let%span senumerate'3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 46 12 50 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self: t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'2] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 44 4 44 30] (self: t_Enumerate) =
    [%#senumerate'3] (forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i: MutBorrow.t t_I. completed i  -> produces i.current (Seq.empty: Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv'0 x]. inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 71 4 71 64] (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate)
  
   =
    [%#senumerate'1] Seq.length visited = n o - n self
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  constant self  : t_Enumerate
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (self'0: t_Enumerate) : ()
  
  goal vc_produces_refl: [%#senumerate] produces'0 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans [#"../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 86 15 86 32
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 87 15 87 32
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 88 14 88 42
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 89 91 89 93
  let%span senumerate'3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 73 12 77 108
  let%span senumerate'4 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  let%span senumerate'5 = "../../creusot-contracts/src/std/iter/enumerate.rs" 46 12 50 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self: t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'4] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 44 4 44 30] (self: t_Enumerate) =
    [%#senumerate'5] (forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i: MutBorrow.t t_I. completed i  -> produces i.current (Seq.empty: Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv'0 x]. inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 71 4 71 64] (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate)
  
   =
    [%#senumerate'3] Seq.length visited = n o - n self
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  constant a  : t_Enumerate
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Enumerate
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Enumerate
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 90] (a'0: t_Enumerate) (ab'0: Seq.seq tuple) (b'0: t_Enumerate) (bc'0: Seq.seq tuple) (c'0: t_Enumerate) : ()
  
  
  goal vc_produces_trans: ([%#senumerate] produces'0 a ab b)
   -> ([%#senumerate'0] produces'0 b bc c)  -> ([%#senumerate'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 102 14 102 45
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 103 27 103 29
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 139
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 118
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'4 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: bool) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: bool. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self: t_Filter) =
    [%#sfilter'2] forall f: t_F, i: t_Item. precondition f i
    /\ (forall f'0: t_F, g: t_F. hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1: t_F, f2: t_F, i'0: t_Item. not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Filter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Filter [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self: t_Filter) : t_F
  
  axiom func_spec: forall self: t_Filter. [%#sfilter'3] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self: t_Filter) : t_I
  
  axiom iter_spec: forall self: t_Filter. [%#sfilter'4] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter)
  
   =
    [%#sfilter'1] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  constant self  : t_Filter
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (self'0: t_Filter) : ()
  
  goal vc_produces_refl: [%#sfilter] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 106 15 106 32
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 107 15 107 32
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 108 14 108 42
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 109 91 109 93
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 139
  let%span sfilter'4 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 118
  let%span sfilter'5 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'6 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: bool) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: bool. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self: t_Filter) =
    [%#sfilter'4] forall f: t_F, i: t_Item. precondition f i
    /\ (forall f'0: t_F, g: t_F. hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1: t_F, f2: t_F, i'0: t_Item. not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Filter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Filter [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self: t_Filter) : t_F
  
  axiom func_spec: forall self: t_Filter. [%#sfilter'5] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self: t_Filter) : t_I
  
  axiom iter_spec: forall self: t_Filter. [%#sfilter'6] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter)
  
   =
    [%#sfilter'3] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  constant a  : t_Filter
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Filter
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Filter
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (a'0: t_Filter) (ab'0: Seq.seq t_Item) (b'0: t_Filter) (bc'0: Seq.seq t_Item) (c'0: t_Filter) : ()
  
  
  goal vc_produces_trans: ([%#sfilter] produces'0 a ab b)
   -> ([%#sfilter'0] produces'0 b bc c)  -> ([%#sfilter'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 102 14 102 45
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 103 27 103 29
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 143
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 49
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 53
  let%span sfilter_map'7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 130
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f: t_F) =
    [%#sfilter_map'5] forall i: t_Item. precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f: t_F) =
    [%#sfilter_map'6] forall g: t_F. hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1: t_F) =
    [%#sfilter_map'7] forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self: t_FilterMap) : t_F
  
  axiom func_spec: forall self: t_FilterMap. [%#sfilter_map'3] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self: t_FilterMap) =
    [%#sfilter_map'2] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite]: forall x: t_FilterMap [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self: t_FilterMap) : t_I
  
  axiom iter_spec: forall self: t_FilterMap. [%#sfilter_map'4] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap)
  
   =
    [%#sfilter_map'1] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j: int. 0 <= j /\ j < Seq.length s
     -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  constant self  : t_FilterMap
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (self'0: t_FilterMap) : ()
  
  
  goal vc_produces_refl: [%#sfilter_map] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 106 15 106 32
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 107 15 107 32
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 108 14 108 42
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 109 91 109 93
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 143
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 49
  let%span sfilter_map'8 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 53
  let%span sfilter_map'9 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 130
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f: t_F) =
    [%#sfilter_map'7] forall i: t_Item. precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f: t_F) =
    [%#sfilter_map'8] forall g: t_F. hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1: t_F) =
    [%#sfilter_map'9] forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self: t_FilterMap) : t_F
  
  axiom func_spec: forall self: t_FilterMap. [%#sfilter_map'5] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self: t_FilterMap) =
    [%#sfilter_map'4] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite]: forall x: t_FilterMap [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self: t_FilterMap) : t_I
  
  axiom iter_spec: forall self: t_FilterMap. [%#sfilter_map'6] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap)
  
   =
    [%#sfilter_map'3] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j: int. 0 <= j /\ j < Seq.length s
     -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  constant a  : t_FilterMap
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_FilterMap
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_FilterMap
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (a'0: t_FilterMap) (ab'0: Seq.seq t_B) (b'0: t_FilterMap) (bc'0: Seq.seq t_B) (c'0: t_FilterMap) : ()
  
  
  goal vc_produces_trans: ([%#sfilter_map] produces'0 a ab b)
   -> ([%#sfilter_map'0] produces'0 b bc c)  -> ([%#sfilter_map'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. ([%#sfuse'2] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'3] forall other: t_Fuse. view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'1] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  constant self  : t_Fuse
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self'0: t_Fuse) : ()
  
  goal vc_produces_refl: [%#sfuse] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. ([%#sfuse'4] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'5] forall other: t_Fuse. view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'3] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  constant a  : t_Fuse
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Fuse
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Fuse
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a'0: t_Fuse) (ab'0: Seq.seq t_Item) (b'0: t_Fuse) (bc'0: Seq.seq t_Item) (c'0: t_Fuse) : ()
  
  
  goal vc_produces_trans: ([%#sfuse] produces'0 a ab b)
   -> ([%#sfuse'0] produces'0 b bc c)  -> ([%#sfuse'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 63 15 63 31
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 64 15 64 44
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 65 14 65 50
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 66 63 66 65
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse'6 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'7 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'8 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'9 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'10 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'11 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'12 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. ([%#sfuse'11] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'12] forall other: t_Fuse. view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'4] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a: t_Fuse) (ab: Seq.seq t_Item) (b: t_Fuse) (bc: Seq.seq t_Item) (c: t_Fuse) : ()
  
   =
    [%#sfuse'10] ()
  
  axiom produces_trans_spec'0: forall a: t_Fuse, ab: Seq.seq t_Item, b: t_Fuse, bc: Seq.seq t_Item, c: t_Fuse. ([%#sfuse'7] produces'0 a ab b)
   -> ([%#sfuse'8] produces'0 b bc c)  -> ([%#sfuse'9] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self: t_Fuse) : () =
    [%#sfuse'6] ()
  
  axiom produces_refl_spec'0: forall self: t_Fuse. [%#sfuse'5] produces'0 self (Seq.empty: Seq.seq t_Item) self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Fuse) : t_Option =
    [%#smodel] view self.current
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self: MutBorrow.t t_Fuse) =
    [%#sfuse'3] (view'0 self = C_None
    \/ (exists it: MutBorrow.t t_I. completed it /\ view'0 self = C_Some (it.current)))
    /\ view self.final = C_None
  
  constant self  : MutBorrow.t t_Fuse
  
  constant steps  : Seq.seq t_Item
  
  constant next  : t_Fuse
  
  function is_fused [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (self'0: MutBorrow.t t_Fuse) (steps'0: Seq.seq t_Item) (next'0: t_Fuse) : ()
  
  
  goal vc_is_fused: ([%#sfuse] completed'0 self)
   -> ([%#sfuse'0] produces'0 self.final steps next)
   -> ([%#sfuse'1] steps = (Seq.empty: Seq.seq t_Item) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi306403796899090344__produces_refl [#"../../creusot-contracts/src/std/iter/map.rs" 76 4 76 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 75 14 75 45
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 76 27 76 29
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 59 12 70 75
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap'3 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'3] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 57 4 57 67] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map)
  
   =
    [%#smap'1] hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  constant self  : t_Map
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map.rs" 76 4 76 26] (self'0: t_Map) : ()
  
  goal vc_produces_refl: [%#smap] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi306403796899090344__produces_trans [#"../../creusot-contracts/src/std/iter/map.rs" 82 4 82 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 79 15 79 32
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 80 15 80 32
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 81 14 81 42
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 82 91 82 93
  let%span smap'3 = "../../creusot-contracts/src/std/iter/map.rs" 59 12 70 75
  let%span smap'4 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap'5 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'4] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'5] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 57 4 57 67] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map)
  
   =
    [%#smap'3] hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  constant a  : t_Map
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_Map
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_Map
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map.rs" 82 4 82 90] (a'0: t_Map) (ab'0: Seq.seq t_B) (b'0: t_Map) (bc'0: Seq.seq t_B) (c'0: t_Map) : ()
  
  
  goal vc_produces_trans: ([%#smap] produces'0 a ab b)
   -> ([%#smap'0] produces'0 b bc c)  -> ([%#smap'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 27 25 29
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'1] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  constant self  : t_MapInv
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self'0: t_MapInv) : ()
  
  goal vc_produces_refl: [%#smap_inv] produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'3] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  constant a  : t_MapInv
  
  constant ab  : Seq.seq t_B
  
  constant b  : t_MapInv
  
  constant bc  : Seq.seq t_B
  
  constant c  : t_MapInv
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a'0: t_MapInv) (ab'0: Seq.seq t_B) (b'0: t_MapInv) (bc'0: Seq.seq t_B) (c'0: t_MapInv) : ()
  
  
  goal vc_produces_trans: ([%#smap_inv] produces'0 a ab b)
   -> ([%#smap_inv'0] produces'0 b bc c)  -> ([%#smap_inv'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence [#"../../creusot-contracts/src/std/iter/map_inv.rs" 63 4 63 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 61 15 61 39
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 62 14 62 31
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 63 32 63 34
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 50
  
  use seq.Seq
  
  type t_I
  
  type t_F
  
  type t_B
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_B }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_MapInv) =
    match _0 with
      | {t_MapInv__iter = x0 ; t_MapInv__func = x1 ; t_MapInv__produced = x2} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 56 4 56 28] (self: t_MapInv) =
    [%#smap_inv'2] resolve'0 self.t_MapInv__iter /\ resolve self.t_MapInv__func
  
  constant self  : t_MapInv
  
  function resolve_coherence [#"../../creusot-contracts/src/std/iter/map_inv.rs" 63 4 63 31] (self'0: t_MapInv) : ()
  
  goal vc_resolve_coherence: ([%#smap_inv] structural_resolve self)  -> ([%#smap_inv'0] resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next [#"../../creusot-contracts/src/std/iter/map_inv.rs" 88 4 88 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 182 16 182 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 184 39 184 42
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 182 27 182 52
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 183 26 183 71
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'9 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 89 39 89 58
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 92 16 92 76
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 93 31 93 71
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 97 38 97 88
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 98 32 98 63
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 103 32 103 56
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 88 17 88 21
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 88 26 88 44
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 84 14 87 5
  let%span smap_inv'8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 161 15 161 31
  let%span smap_inv'9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 162 4 162 60
  let%span smap_inv'10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 163 15 163 30
  let%span smap_inv'11 = "../../creusot-contracts/src/std/iter/map_inv.rs" 164 15 164 64
  let%span smap_inv'12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 165 14 165 74
  let%span smap_inv'13 = "../../creusot-contracts/src/std/iter/map_inv.rs" 166 14 166 75
  let%span smap_inv'14 = "../../creusot-contracts/src/std/iter/map_inv.rs" 177 14 177 68
  let%span smap_inv'15 = "../../creusot-contracts/src/std/iter/map_inv.rs" 180 12 185 74
  let%span smap_inv'16 = "../../creusot-contracts/src/std/iter/map_inv.rs" 17 8 20 9
  let%span smap_inv'17 = "../../creusot-contracts/src/std/iter/map_inv.rs" 72 12 74 73
  let%span smap_inv'18 = "../../creusot-contracts/src/std/iter/map_inv.rs" 122 14 122 81
  let%span smap_inv'19 = "../../creusot-contracts/src/std/iter/map_inv.rs" 125 12 130 88
  let%span smap_inv'20 = "../../creusot-contracts/src/std/iter/map_inv.rs" 115 12 117 63
  let%span smap_inv'21 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv'22 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv'23 = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 27 25 29
  let%span smap_inv'24 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv'25 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv'26 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv'27 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span smap_inv'28 = "../../creusot-contracts/src/std/iter/map_inv.rs" 151 12 154 47
  let%span smap_inv'29 = "../../creusot-contracts/src/std/iter/map_inv.rs" 138 12 143 71
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_I
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_Option  =
    | C_None
    | C_Some t_Item
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_I) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_I)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_I [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: MutBorrow.t t_I)
  
  axiom precondition_fndef: forall args: MutBorrow.t t_I [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Item)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: MutBorrow.t t_I) (result: t_Option)
  
  
  axiom postcondition_fndef: forall args: MutBorrow.t t_I, res: t_Option [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in match res with
    | C_None -> completed self_
    | C_Some v -> produces self_.current (Seq.singleton v) self_.final
    end
  /\ inv'2 res)
  
  let rec next (self_:MutBorrow.t t_I) (return'  (x:t_Option))= {[@expl:next requires] precondition () self_}
    any [ return''0 (result:t_Option)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Item))= any
    [ good (field_0:t_Item)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Item [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: tuple)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_B
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_F) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_F)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_F [inv'4 x]. inv'4 x = invariant''0 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple [inv'5 x]. inv'5 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'1 x0)
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'9] postcondition_once'0 self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'6] hist_inv self b)
   -> ([%#sops'7] hist_inv b c)  -> ([%#sops'8] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'5] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops'3] postcondition_mut self args res_state res)
   -> ([%#sops'4] hist_inv self res_state)
  
  let rec call_mut (self_:MutBorrow.t t_F) (arg:tuple) (return'  (x:t_B))= {[@expl:call_mut 'self_' type invariant] [%#sops] inv'4 self_}
    {[@expl:call_mut 'arg' type invariant] [%#sops'0] inv'5 arg}
    {[@expl:call_mut requires] [%#sops'1] precondition'0 self_.current arg}
    any
    [ return''0 (result:t_B)-> {inv'6 result}
      {[%#sops'2] postcondition_mut self_.current arg self_.final result}
      (! return' {result}) ]
  
  
  predicate next_precondition [#"../../creusot-contracts/src/std/iter/map_inv.rs" 113 4 113 78] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'20] forall e: t_Item, i: t_I. produces iter (Seq.singleton e) i
     -> precondition'0 func { _p0 = e; _p1 = produced }
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 136 4 136 49] (iter: t_I) (func: t_F) =
    [%#smap_inv'29] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition'0 f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  predicate reinitialize [#"../../creusot-contracts/src/std/iter/map_inv.rs" 149 4 149 33]  =
    [%#smap_inv'28] forall iter: MutBorrow.t t_I, func: t_F. completed iter
     -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 123 4 123 73] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'19] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _p0 = e1; _p1 = Seq.(++) produced s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
     -> precondition'0 f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec: forall iter: t_I, func: t_F, produced: Seq.seq t_Item. [%#smap_inv'18] produced
  = (Seq.empty: Seq.seq t_Item)  -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant''1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 70 4 70 30] (self: t_MapInv) =
    [%#smap_inv'17] reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  function produces_one_invariant [#"../../creusot-contracts/src/std/iter/map_inv.rs" 167 4 167 73] (self: t_MapInv) (e: t_Item) (r: t_B) (f: MutBorrow.t t_F) (iter: t_I) : ()
  
  
  axiom produces_one_invariant_spec: forall self: t_MapInv, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter: t_I. ([%#smap_inv'8] invariant''1 self)
   -> ([%#smap_inv'9] produces self.t_MapInv__iter (Seq.singleton e) iter)
   -> ([%#smap_inv'10] f.current = self.t_MapInv__func)
   -> ([%#smap_inv'11] postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final r)
   -> ([%#smap_inv'12] preservation_inv iter f.final (Seq.snoc self.t_MapInv__produced e))
  && ([%#smap_inv'13] next_precondition iter f.final (Seq.snoc self.t_MapInv__produced e))
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'21] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _p0 = Seq.get s i;
                                               _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : ()
  
   =
    [%#smap_inv'27] ()
  
  axiom produces_trans_spec'0: forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. ([%#smap_inv'24] produces'0 a ab b)
   -> ([%#smap_inv'25] produces'0 b bc c)  -> ([%#smap_inv'26] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self: t_MapInv) : () =
    [%#smap_inv'23] ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. [%#smap_inv'22] produces'0 self (Seq.empty: Seq.seq t_B) self
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 178 4 178 57] (self: t_MapInv) (visited: t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'15] exists f: MutBorrow.t t_F, e: t_Item. f.current = self.t_MapInv__func
    /\ f.final = succ.t_MapInv__func
    /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
    /\ precondition'0 f.current { _p0 = e; _p1 = self.t_MapInv__produced }
    /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited
  
  axiom produces_one_spec: forall self: t_MapInv, visited: t_B, succ: t_MapInv. [%#smap_inv'14] produces_one self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_MapInv)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_MapInv [inv'7 x]. inv'7 x
  = (invariant''1 x
  /\ match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'3 func
    end)
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_MapInv) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_MapInv)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_MapInv [inv'8 x]. inv'8 x = invariant''2 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_MapInv) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_MapInv) =
    resolve'0 _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B
  
  predicate inv'9 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'9 x]. inv'9 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 16 4 16 35] (self: MutBorrow.t t_MapInv) =
    [%#smap_inv'16] (self.final).t_MapInv__produced = (Seq.empty: Seq.seq t_Item)
    /\ completed (MutBorrow.borrow_logic (self.current).t_MapInv__iter (self.final).t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func = (self.final).t_MapInv__func
  
  meta "compute_max_steps" 1000000
  
  let rec next'0[#"../../creusot-contracts/src/std/iter/map_inv.rs" 88 4 88 44] (self:MutBorrow.t t_MapInv) (return'  (x:t_Option'0))= {[@expl:next 'self' type invariant] [%#smap_inv'5] inv'8 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#smap_inv] self'0.current ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv (self'0.current).t_MapInv__iter}
        MutBorrow.borrow_final
          <t_I>
          {(self'0.current).t_MapInv__iter}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_I) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__iter = _ret.final } } ] 
            s1)
      | s1 = next {_6} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_5 = C_None} (! bb5) | br1 (x0:t_Item)-> {_5 = C_Some x0} (! bb4) ] 
    | bb4 = bb6
    | bb6 = s0
      [ s0 = v_Some {_5} (fun (r0:t_Item) ->  [ &v <- r0 ] s1)
      | s1 = {[@expl:assertion] [%#smap_inv'0] precondition'0 (self'0.current).t_MapInv__func { _p0 = v;
                                                                                                _p1 = (self'0.current).t_MapInv__produced }}
        s2
      | s2 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &produced <- [%#smap_inv'1] Seq.snoc (self'0.current).t_MapInv__produced v ] s1 | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = {inv'3 (self'0.current).t_MapInv__func}
        MutBorrow.borrow_final
          <t_F>
          {(self'0.current).t_MapInv__func}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t t_F) ->
             [ &_14 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__func = _ret.final } } ] 
            s1)
      | s1 =  [ &_15 <- { _p0 = v; _p1 = (self'0.current).t_MapInv__produced } ] s2
      | s2 = call_mut {_14} {_15} (fun (_ret:t_B) ->  [ &r <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__produced = produced } } ] s1
      | s1 =  [ &_19 <- [%#smap_inv'2] let _ = () in () ] s2
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = {[@expl:assertion] [%#smap_inv'3] produces_one old_self r self'0.current} s1 | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'8 self'0} s1
      | s1 = -{resolve'1 self'0}- s2
      | s2 =  [ &_0 <- C_Some'0 r ] s3
      | s3 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb17
    | bb5 = s0 [ s0 =  [ &_24 <- [%#smap_inv'4] Seq.empty: Seq.seq t_Item ] s1 | s1 = bb16 ] 
    | bb16 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_MapInv__produced = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv'8 self'0} s2
      | s2 = -{resolve'1 self'0}- s3
      | s3 =  [ &_0 <- C_None'0 ] s4
      | s4 = bb17 ]
    
    | bb17 = bb18
    | bb18 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self'0: MutBorrow.t t_MapInv = self
    | & old_self: t_MapInv = Any.any_l ()
    | & _5: t_Option = Any.any_l ()
    | & _6: MutBorrow.t t_I = Any.any_l ()
    | & v: t_Item = Any.any_l ()
    | & produced: Seq.seq t_Item = Any.any_l ()
    | & r: t_B = Any.any_l ()
    | & _14: MutBorrow.t t_F = Any.any_l ()
    | & _15: tuple = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _24: Seq.seq t_Item = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:next result type invariant] [%#smap_inv'6] inv'9 result}
      {[@expl:next ensures] [%#smap_inv'7] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces_one self.current v self.final
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 123 4 123 73] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 122 14 122 81
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 125 12 130 88
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 138 12 143 71
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  type t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: tuple)
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 136 4 136 49] (iter: t_I) (func: t_F) =
    [%#smap_inv'1] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  constant iter  : t_I
  
  constant func  : t_F
  
  constant produced  : Seq.seq t_Item
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 123 4 123 73] (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item)
  
  
  goal vc_preservation_inv: [%#smap_inv] produced = (Seq.empty: Seq.seq t_Item)
   -> ([%#smap_inv'0] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
   -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
   -> precondition f.current { _p0 = e1; _p1 = Seq.(++) produced s }
   -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
   -> precondition f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 })
  = preservation iter func
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 178 4 178 57] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 177 14 177 68
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 180 12 185 74
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 27 25 29
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'1] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : ()
  
   =
    [%#smap_inv'7] ()
  
  axiom produces_trans_spec'0: forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. ([%#smap_inv'4] produces'0 a ab b)
   -> ([%#smap_inv'5] produces'0 b bc c)  -> ([%#smap_inv'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self: t_MapInv) : () =
    [%#smap_inv'3] ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. [%#smap_inv'2] produces'0 self (Seq.empty: Seq.seq t_B) self
  
  constant self  : t_MapInv
  
  constant visited  : t_B
  
  constant succ  : t_MapInv
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 178 4 178 57] (self'0: t_MapInv) (visited'0: t_B) (succ'0: t_MapInv)
  
  
  goal vc_produces_one: [%#smap_inv] ([%#smap_inv'0] exists f: MutBorrow.t t_F, e: t_Item. f.current
  = self.t_MapInv__func
  /\ f.final = succ.t_MapInv__func
  /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
  /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
  /\ precondition f.current { _p0 = e; _p1 = self.t_MapInv__produced }
  /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited)
  = produces'0 self (Seq.singleton visited) succ
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 30 14 30 45
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 31 27 31 29
  let%span sonce'1 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self: t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self: t_Once) (visited: Seq.seq t_T) (o: t_Once)
  
   =
    [%#sonce'1] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant self  : t_Once
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (self'0: t_Once) : ()
  
  goal vc_produces_refl: [%#sonce] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 34 15 34 32
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 35 15 35 32
  let%span sonce'1 = "../../creusot-contracts/src/std/iter/once.rs" 36 14 36 42
  let%span sonce'2 = "../../creusot-contracts/src/std/iter/once.rs" 37 91 37 93
  let%span sonce'3 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self: t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self: t_Once) (visited: Seq.seq t_T) (o: t_Once)
  
   =
    [%#sonce'3] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant a  : t_Once
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Once
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Once
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (a'0: t_Once) (ab'0: Seq.seq t_T) (b'0: t_Once) (bc'0: Seq.seq t_T) (c'0: t_Once) : ()
  
  
  goal vc_produces_trans: ([%#sonce] produces a ab b)
   -> ([%#sonce'0] produces b bc c)  -> ([%#sonce'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 35 27 35 29
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'1] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  constant self  : t_Range
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (self'0: t_Range) : ()
  
  goal vc_produces_refl: [%#srange] produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 38 15 38 32
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 39 15 39 32
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 40 14 40 42
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 41 91 41 93
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'3] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  constant a  : t_Range
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_Range
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_Range
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (a'0: t_Range) (ab'0: Seq.seq t_Idx) (b'0: t_Range) (bc'0: Seq.seq t_Idx) (c'0: t_Range) : ()
  
  
  goal vc_produces_trans: ([%#srange] produces a ab b)
   -> ([%#srange'0] produces b bc c)  -> ([%#srange'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 59 14 59 50
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 60 32 60 34
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'1] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  constant self  : t_Range
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (self'0: t_Range) : ()
  
  goal vc_produces_back_refl: [%#srange] produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 63 15 63 37
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 64 15 64 37
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 65 14 65 47
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 66 96 66 98
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'3] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  constant a  : t_Range
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_Range
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_Range
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (a'0: t_Range) (ab'0: Seq.seq t_Idx) (b'0: t_Range) (bc'0: Seq.seq t_Idx) (c'0: t_Range) : ()
  
  
  goal vc_produces_back_trans: ([%#srange] produces_back a ab b)
   -> ([%#srange'0] produces_back b bc c)  -> ([%#srange'1] produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  constant r  : t_RangeInclusive
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r'0: t_RangeInclusive) : int
  
  
  goal vc_range_inclusive_len: ([%#sops] not is_empty_log r  -> deep_model (start_log r) <= deep_model (end_log r))
   -> (if is_empty_log r then
    [%#srange] is_empty_log r = (0 = 0)
  else
    [%#srange] is_empty_log r = (deep_model (end_log r) - deep_model (start_log r) + 1 = 0)
  )
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 103 14 103 45
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 104 27 104 29
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'3] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'2] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'1] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  constant self  : t_RangeInclusive
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (self'0: t_RangeInclusive) : ()
  
  goal vc_produces_refl: [%#srange] produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 108 15 108 32
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 109 15 109 32
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 110 14 110 42
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 111 91 111 93
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'4 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'5 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'5] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'4] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'3] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  constant a  : t_RangeInclusive
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_RangeInclusive
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_RangeInclusive
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (a'0: t_RangeInclusive) (ab'0: Seq.seq t_Idx) (b'0: t_RangeInclusive) (bc'0: Seq.seq t_Idx) (c'0: t_RangeInclusive) : ()
  
  
  goal vc_produces_trans: ([%#srange] produces a ab b)
   -> ([%#srange'0] produces b bc c)  -> ([%#srange'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 130 14 130 50
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 131 32 131 34
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'3] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'2] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'1] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  constant self  : t_RangeInclusive
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (self'0: t_RangeInclusive) : ()
  
  
  goal vc_produces_back_refl: [%#srange] produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 135 15 135 37
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 136 15 136 37
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 137 14 137 47
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 138 96 138 98
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'4 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'5 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'5] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'4] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'3] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  constant a  : t_RangeInclusive
  
  constant ab  : Seq.seq t_Idx
  
  constant b  : t_RangeInclusive
  
  constant bc  : Seq.seq t_Idx
  
  constant c  : t_RangeInclusive
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (a'0: t_RangeInclusive) (ab'0: Seq.seq t_Idx) (b'0: t_RangeInclusive) (bc'0: Seq.seq t_Idx) (c'0: t_RangeInclusive) : ()
  
  
  goal vc_produces_back_trans: ([%#srange] produces_back a ab b)
   -> ([%#srange'0] produces_back b bc c)  -> ([%#srange'1] produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 30 14 30 45
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 31 27 31 29
  let%span srepeat'1 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 99
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self: t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat)
  
   =
    [%#srepeat'1] self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> postcondition () (view self) (Seq.get visited i))
  
  constant self  : t_Repeat
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (self'0: t_Repeat) : ()
  
  goal vc_produces_refl: [%#srepeat] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 34 15 34 32
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 35 15 35 32
  let%span srepeat'1 = "../../creusot-contracts/src/std/iter/repeat.rs" 36 14 36 42
  let%span srepeat'2 = "../../creusot-contracts/src/std/iter/repeat.rs" 37 91 37 93
  let%span srepeat'3 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 99
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self: t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat)
  
   =
    [%#srepeat'3] self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> postcondition () (view self) (Seq.get visited i))
  
  constant a  : t_Repeat
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Repeat
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Repeat
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (a'0: t_Repeat) (ab'0: Seq.seq t_T) (b'0: t_Repeat) (bc'0: Seq.seq t_T) (c'0: t_Repeat) : ()
  
  
  goal vc_produces_trans: ([%#srepeat] produces a ab b)
   -> ([%#srepeat'0] produces b bc c)  -> ([%#srepeat'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 78 14 78 50
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 82 15 82 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 83 15 83 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 84 14 84 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 46 14 46 45
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 47 27 47 29
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'2 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 75 4 75 70] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 85 4 85 96] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_back_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 79 4 79 32] (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. [%#siter] produces_back self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rev)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rev [inv'0 x]. inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self: t_Rev) : t_I
  
  axiom iter_spec: forall self: t_Rev. [%#srev'2] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev)
  
   =
    [%#srev'1] produces_back (iter self) visited (iter o)
  
  constant self  : t_Rev
  
  function produces_refl [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (self'0: t_Rev) : ()
  
  goal vc_produces_refl: [%#srev] produces self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 78 14 78 50
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 82 15 82 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 83 15 83 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 84 14 84 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 50 15 50 32
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 51 15 51 32
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 52 14 52 42
  let%span srev'2 = "../../creusot-contracts/src/std/iter/rev.rs" 53 91 53 93
  let%span srev'3 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'4 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 75 4 75 70] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 85 4 85 96] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_back_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 79 4 79 32] (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. [%#siter] produces_back self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rev)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rev [inv'0 x]. inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self: t_Rev) : t_I
  
  axiom iter_spec: forall self: t_Rev. [%#srev'4] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev)
  
   =
    [%#srev'3] produces_back (iter self) visited (iter o)
  
  constant a  : t_Rev
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Rev
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Rev
  
  function produces_trans [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (a'0: t_Rev) (ab'0: Seq.seq t_Item) (b'0: t_Rev) (bc'0: Seq.seq t_Item) (c'0: t_Rev) : ()
  
  
  goal vc_produces_trans: ([%#srev] produces a ab b)
   -> ([%#srev'0] produces b bc c)  -> ([%#srev'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl [#"../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 74 14 74 45
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 75 27 75 29
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 64 12 69 69
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip'3 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self: t_Skip) : int
  
  axiom n_spec: forall self: t_Skip. [%#sskip'2] n self >= 0 /\ n self <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'3] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 62 4 62 64] (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip)
  
   =
    [%#sskip'1] visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  constant self  : t_Skip
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (self'0: t_Skip) : ()
  
  goal vc_produces_refl: [%#sskip] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 78 15 78 32
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 79 15 79 32
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 80 14 80 42
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 81 91 81 93
  let%span sskip'3 = "../../creusot-contracts/src/std/iter/skip.rs" 64 12 69 69
  let%span sskip'4 = "../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip'5 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self: t_Skip) : int
  
  axiom n_spec: forall self: t_Skip. [%#sskip'4] n self >= 0 /\ n self <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'5] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 62 4 62 64] (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip)
  
   =
    [%#sskip'3] visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  constant a  : t_Skip
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Skip
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Skip
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (a'0: t_Skip) (ab'0: Seq.seq t_Item) (b'0: t_Skip) (bc'0: Seq.seq t_Item) (c'0: t_Skip) : ()
  
  
  goal vc_produces_trans: ([%#sskip] produces'0 a ab b)
   -> ([%#sskip'0] produces'0 b bc c)  -> ([%#sskip'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl [#"../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 72 14 72 45
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 73 27 73 29
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 67 12 67 88
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 33 14 33 50
  let%span stake'3 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 34 4 34 21] (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. [%#stake'2] n self >= 0 /\ n self <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'3] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 65 4 65 64] (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take)
  
   =
    [%#stake'1] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  constant self  : t_Take
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (self'0: t_Take) : ()
  
  goal vc_produces_refl: [%#stake] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 76 15 76 32
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 77 15 77 32
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 78 14 78 42
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 79 91 79 93
  let%span stake'3 = "../../creusot-contracts/src/std/iter/take.rs" 67 12 67 88
  let%span stake'4 = "../../creusot-contracts/src/std/iter/take.rs" 33 14 33 50
  let%span stake'5 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 34 4 34 21] (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. [%#stake'4] n self >= 0 /\ n self <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'5] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 65 4 65 64] (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take)
  
   =
    [%#stake'3] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  constant a  : t_Take
  
  constant ab  : Seq.seq t_Item
  
  constant b  : t_Take
  
  constant bc  : Seq.seq t_Item
  
  constant c  : t_Take
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (a'0: t_Take) (ab'0: Seq.seq t_Item) (b'0: t_Take) (bc'0: Seq.seq t_Item) (c'0: t_Take) : ()
  
  
  goal vc_produces_trans: ([%#stake] produces'0 a ab b)
   -> ([%#stake'0] produces'0 b bc c)  -> ([%#stake'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 54 14 54 45
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 55 27 55 29
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'3 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Zip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip [inv'1 x]. inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self: t_Zip) : t_A
  
  axiom itera_spec: forall self: t_Zip. [%#szip'2] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  
  axiom produces_trans_spec'0: forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self: t_Zip) : t_B
  
  axiom iterb_spec: forall self: t_Zip. [%#szip'3] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip)
  
   =
    [%#szip'1] exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  constant self  : t_Zip
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (self'0: t_Zip) : ()
  
  goal vc_produces_refl: [%#szip] produces'1 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 58 15 58 32
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 59 15 59 32
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 60 14 60 42
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 61 91 61 93
  let%span szip'3 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'4 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'5 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Zip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip [inv'1 x]. inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self: t_Zip) : t_A
  
  axiom itera_spec: forall self: t_Zip. [%#szip'4] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  
  axiom produces_trans_spec'0: forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self: t_Zip) : t_B
  
  axiom iterb_spec: forall self: t_Zip. [%#szip'5] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip)
  
   =
    [%#szip'3] exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  constant a  : t_Zip
  
  constant ab  : Seq.seq tuple
  
  constant b  : t_Zip
  
  constant bc  : Seq.seq tuple
  
  constant c  : t_Zip
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (a'0: t_Zip) (ab'0: Seq.seq tuple) (b'0: t_Zip) (bc'0: Seq.seq tuple) (c'0: t_Zip) : ()
  
  
  goal vc_produces_trans: ([%#szip] produces'1 a ab b)
   -> ([%#szip'0] produces'1 b bc c)  -> ([%#szip'1] produces'1 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl [#"../../creusot-contracts/src/std/iter.rs" 231 4 231 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 230 14 230 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 231 27 231 29
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 219 20 219 64
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'5 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'3] produces a ab b)
   -> ([%#siter'4] produces b bc c)  -> ([%#siter'5] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter'2] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 218 4 218 64] (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I)
  
   =
    [%#siter'1] produces self.current visited o.current /\ self.final = o.final
  
  constant self  : MutBorrow.t t_I
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 231 4 231 26] (self'0: MutBorrow.t t_I) : ()
  
  goal vc_produces_refl: [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans [#"../../creusot-contracts/src/std/iter.rs" 238 4 238 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 235 15 235 32
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 236 15 236 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 237 14 237 42
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 238 91 238 93
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 219 20 219 64
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'5] produces a ab b)
   -> ([%#siter'6] produces b bc c)  -> ([%#siter'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter'4] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 218 4 218 64] (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I)
  
   =
    [%#siter'3] produces self.current visited o.current /\ self.final = o.final
  
  constant a  : MutBorrow.t t_I
  
  constant ab  : Seq.seq t_Item
  
  constant b  : MutBorrow.t t_I
  
  constant bc  : Seq.seq t_Item
  
  constant c  : MutBorrow.t t_I
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 238 4 238 90] (a'0: MutBorrow.t t_I) (ab'0: Seq.seq t_Item) (b'0: MutBorrow.t t_I) (bc'0: Seq.seq t_Item) (c'0: MutBorrow.t t_I) : ()
  
  
  goal vc_produces_trans: ([%#siter] produces'0 a ab b)
   -> ([%#siter'0] produces'0 b bc c)  -> ([%#siter'1] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_replace_body [#"../../creusot-contracts/src/std/mem.rs" 10 12 10 52]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 10 51 10 52
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'6 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'7 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  let rec swap (x:MutBorrow.t t_T) (y:MutBorrow.t t_T) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'4] inv'0 x}
    {[@expl:swap 'y' type invariant] [%#smem'5] inv'0 y}
    any
    [ return''0 (result:())-> {[%#smem'6] x.final = y.current} {[%#smem'7] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_replace_body[#"../../creusot-contracts/src/std/mem.rs" 10 12 10 52] (dest:MutBorrow.t t_T) (src:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_mem_replace_body 'dest' type invariant] [%#smem] inv'0 dest}
    {[@expl:extern_spec_std_mem_replace_body 'src' type invariant] [%#smem'0] inv src}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 =  [ &src'1 <- src'0 ] s1
      | s1 = {inv src'1}
        MutBorrow.borrow_mut <t_T> {src'1}
          (fun (_ret:MutBorrow.t t_T) ->  [ &_9 <- _ret ] -{inv _ret.final}-  [ &src'1 <- _ret.final ] s2)
      | s2 = {inv dest'0.current}
        MutBorrow.borrow_final <t_T> {dest'0.current} {MutBorrow.get_id dest'0}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_7 <- _ret ] 
            -{inv _ret.final}-
             [ &dest'0 <- { dest'0 with current = _ret.final } ] 
            s3)
      | s3 = {inv _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv _ret.final}-
             [ &_9 <- { _9 with current = _ret.final } ] 
            s4)
      | s4 = swap {_7} {_8} (fun (_ret:()) ->  [ &_6 <- _ret ] s5)
      | s5 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 _9} s1
      | s1 = -{resolve'0 _9}- s2
      | s2 = {[@expl:type invariant] inv'0 dest'0} s3
      | s3 = -{resolve'0 dest'0}- s4
      | s4 =  [ &_0 <- src'1 ] s5
      | s5 = bb3 ]
    
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    )
    [ & _0: t_T = Any.any_l ()
    | & dest'0: MutBorrow.t t_T = dest
    | & src'0: t_T = src
    | & src'1: t_T = Any.any_l ()
    | & _6: () = Any.any_l ()
    | & _7: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_mem_replace_body result type invariant] [%#smem'1] inv result}
      {[@expl:extern_spec_std_mem_replace_body ensures #0] [%#smem'2] dest.final = src}
      {[@expl:extern_spec_std_mem_replace_body ensures #1] [%#smem'3] result = dest.current}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_take_body [#"../../creusot-contracts/src/std/mem.rs" 23 12 23 50]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 23 49 23 50
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'6 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true)  -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: ()) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_T) (src:t_T) (return'  (x:t_T))= {[@expl:replace 'dest' type invariant] [%#smem'3] inv'0 dest}
    {[@expl:replace 'src' type invariant] [%#smem'4] inv src}
    any
    [ return''0 (result:t_T)-> {inv result}
      {[%#smem'5] dest.final = src}
      {[%#smem'6] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve _0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition () args res]. postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'1 self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_take_body[#"../../creusot-contracts/src/std/mem.rs" 23 12 23 50] (dest:MutBorrow.t t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_mem_take_body 'dest' type invariant] [%#smem] inv'0 dest}
    (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv dest'0.current}
        MutBorrow.borrow_final <t_T> {dest'0.current} {MutBorrow.get_id dest'0}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_4 <- _ret ] 
            -{inv _ret.final}-
             [ &dest'0 <- { dest'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_4} {_5} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'0 dest'0} s1 | s1 = -{resolve'0 dest'0}- s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: t_T = Any.any_l ()
    | & dest'0: MutBorrow.t t_T = dest
    | & _4: MutBorrow.t t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_mem_take_body result type invariant] [%#smem'0] inv result}
      {[@expl:extern_spec_std_mem_take_body ensures #0] [%#smem'1] result = dest.current}
      {[@expl:extern_spec_std_mem_take_body ensures #1] [%#smem'2] postcondition () () dest.final}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_drop_body [#"../../creusot-contracts/src/std/mem.rs" 4 0 40 1]
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 29 23 29 25
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 28 22 28 34
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_drop_body[#"../../creusot-contracts/src/std/mem.rs" 4 0 40 1] (_x:t_T) (return'  (x:()))= {[@expl:extern_spec_std_mem_drop_body '_x' type invariant] [%#smem] inv _x}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv _x'0} s1 | s1 = -{resolve _x'0}- s2 | s2 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () | & _x'0: t_T = _x ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_mem_drop_body ensures] [%#smem'0] resolve _x}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_forget_body [#"../../creusot-contracts/src/std/mem.rs" 4 0 40 1]
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 33 25 33 26
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 32 22 32 33
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_forget_body[#"../../creusot-contracts/src/std/mem.rs" 4 0 40 1] (t:t_T) (return'  (x:()))= {[@expl:extern_spec_std_mem_forget_body 't' type invariant] [%#smem] inv t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv t'0} s1 | s1 = -{resolve t'0}- s2 | s2 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () | & t'0: t_T = t ] 
    [ return''0 (result:())-> {[@expl:extern_spec_std_mem_forget_body ensures] [%#smem'0] resolve t}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u8_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_u8_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt8.t) (return'  (x:UInt8.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt8.t = Any.any_l () | & self_'0: UInt8.t = self_ ] 
    [ return''0 (result:UInt8.t)-> {[@expl:extern_spec_Clone_u8_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u16_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_u16_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt16.t) (return'  (x:UInt16.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt16.t = Any.any_l () | & self_'0: UInt16.t = self_ ] 
    [ return''0 (result:UInt16.t)-> {[@expl:extern_spec_Clone_u16_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u32_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_u32_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt32.t) (return'  (x:UInt32.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt32.t = Any.any_l () | & self_'0: UInt32.t = self_ ] 
    [ return''0 (result:UInt32.t)-> {[@expl:extern_spec_Clone_u32_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u64_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_u64_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt64.t) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & self_'0: UInt64.t = self_ ] 
    [ return''0 (result:UInt64.t)-> {[@expl:extern_spec_Clone_u64_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_u128_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_u128_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt128.t) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt128.t = Any.any_l () | & self_'0: UInt128.t = self_ ] 
    [ return''0 (result:UInt128.t)-> {[@expl:extern_spec_Clone_u128_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_usize_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_usize_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:UInt64.t) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & self_'0: UInt64.t = self_ ] 
    [ return''0 (result:UInt64.t)-> {[@expl:extern_spec_Clone_usize_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i8_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_i8_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int8.t) (return'  (x:Int8.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int8.t = Any.any_l () | & self_'0: Int8.t = self_ ] 
    [ return''0 (result:Int8.t)-> {[@expl:extern_spec_Clone_i8_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i16_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_i16_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int16.t) (return'  (x:Int16.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int16.t = Any.any_l () | & self_'0: Int16.t = self_ ] 
    [ return''0 (result:Int16.t)-> {[@expl:extern_spec_Clone_i16_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i32_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_i32_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int32.t) (return'  (x:Int32.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int32.t = Any.any_l () | & self_'0: Int32.t = self_ ] 
    [ return''0 (result:Int32.t)-> {[@expl:extern_spec_Clone_i32_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i64_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_i64_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int64.t) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & self_'0: Int64.t = self_ ] 
    [ return''0 (result:Int64.t)-> {[@expl:extern_spec_Clone_i64_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_i128_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_i128_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int128.t) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int128.t = Any.any_l () | & self_'0: Int128.t = self_ ] 
    [ return''0 (result:Int128.t)-> {[@expl:extern_spec_Clone_i128_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__num__extern_spec_Clone_isize_clone_body [#"../../creusot-contracts/src/std/num.rs" 9 22 36 37]
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_Clone_isize_clone_body[#"../../creusot-contracts/src/std/num.rs" 9 22 36 37] (self_:Int64.t) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Int64.t = Any.any_l () | & self_'0: Int64.t = self_ ] 
    [ return''0 (result:Int64.t)-> {[@expl:extern_spec_Clone_isize_clone_body ensures] [%#snum] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_Try_Option_T_from_output_body [#"../../creusot-contracts/src/std/ops.rs" 281 36 283 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 283 31 283 37
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 281 28 281 37
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 282 26 282 48
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_option_T_Try_Option_T_from_output_body[#"../../creusot-contracts/src/std/ops.rs" 281 36 283 18] (output:t_T) (return'  (x:t_Option))= {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body 'output' type invariant] [%#sops] inv output}
    (! bb0
    [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- C_Some output'0 ] s1 | s1 = bb2 ]  | bb2 = bb3 | bb3 = return''0 {_0} ]
    ) [ & _0: t_Option = Any.any_l () | & output'0: t_T = output ] 
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body result type invariant] [%#sops'0] inv'0 result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_from_output_body ensures] [%#sops'1] result = C_Some output}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_Try_Option_T_branch_body [#"../../creusot-contracts/src/std/ops.rs" 291 16 291 69]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 287 16 287 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 291 35 291 69
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 287 26 290 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 ()
  
  type t_ControlFlow  =
    | C_Continue t_T
    | C_Break t_Option'0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom'0 [@rewrite]: forall x: () [inv'1 x]. inv'1 x = false
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_ControlFlow)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_ControlFlow [inv'3 x]. inv'3 x
  = match x with
    | C_Continue a_0 -> inv a_0
    | C_Break a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_option_T_Try_Option_T_branch_body[#"../../creusot-contracts/src/std/ops.rs" 291 16 291 69] (self_:t_Option) (return'  (x:t_ControlFlow))= {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body 'self_' type invariant] [%#sops] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = bb5
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &v <- r0 ] s1) | s1 =  [ &_0 <- C_Continue v ] s2 | s2 = bb6 ]
    
    | bb6 = bb7
    | bb7 = bb8
    | bb4 = s0 [ s0 =  [ &_6 <- C_None'0 ] s1 | s1 =  [ &_0 <- C_Break _6 ] s2 | s2 = bb8 ] 
    | bb8 = bb9
    | bb9 = return''0 {_0} ]
    )
    [ & _0: t_ControlFlow = Any.any_l ()
    | & self_'0: t_Option = self_
    | & v: t_T = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l () ]
    
    [ return''0 (result:t_ControlFlow)-> {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body result type invariant] [%#sops'0] inv'3 result}
      {[@expl:extern_spec_core_option_T_Try_Option_T_branch_body ensures] [%#sops'1] match self_ with
        | C_Some v -> result = C_Continue v
        | C_None -> result = C_Break (C_None'0)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body [#"../../creusot-contracts/src/std/ops.rs" 299 65 301 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 301 33 301 41
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 299 57 299 66
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 300 26 300 40
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 ()
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom [@rewrite]: forall x: () [inv x]. inv x = false
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'0 x]. inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body[#"../../creusot-contracts/src/std/ops.rs" 299 65 301 18] (residual:t_Option'0) (return'  (x:t_Option))= {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body 'residual' type invariant] [%#sops] inv'0 residual}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = return''0 {_0} ]  ] ) [ & _0: t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body result type invariant] [%#sops'0] inv'2 result}
      {[@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body ensures] [%#sops'1] result
      = C_None}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_Try_Result_T_E_from_output_body [#"../../creusot-contracts/src/std/ops.rs" 311 42 313 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 313 31 313 37
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 311 31 311 43
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 312 26 312 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_from_output_body[#"../../creusot-contracts/src/std/ops.rs" 311 42 313 18] (output:t_T) (return'  (x:t_Result))= {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body 'output' type invariant] [%#sops] inv output}
    (! bb0
    [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- C_Ok output'0 ] s1 | s1 = bb2 ]  | bb2 = bb3 | bb3 = return''0 {_0} ]
    ) [ & _0: t_Result = Any.any_l () | & output'0: t_T = output ] 
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body result type invariant] [%#sops'0] inv'1 result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body ensures] [%#sops'1] result = C_Ok output}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_Try_Result_T_E_branch_body [#"../../creusot-contracts/src/std/ops.rs" 321 16 321 72]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 317 16 317 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 321 35 321 72
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 317 26 320 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_Result'0  =
    | C_Ok'0 ()
    | C_Err'0 t_E
  
  type t_ControlFlow  =
    | C_Continue t_T
    | C_Break t_Result'0
  
  let rec v_Ok (input:t_Result) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Ok field_0: t_Result]. C_Ok field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom'0 [@rewrite]: forall x: () [inv'2 x]. inv'2 x = false
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Result'0 [inv'3 x]. inv'3 x
  = match x with
    | C_Ok'0 a_0 -> inv'2 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_ControlFlow)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_ControlFlow [inv'4 x]. inv'4 x
  = match x with
    | C_Continue a_0 -> inv a_0
    | C_Break a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_branch_body[#"../../creusot-contracts/src/std/ops.rs" 321 16 321 72] (self_:t_Result) (return'  (x:t_ControlFlow))= {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body 'self_' type invariant] [%#sops] inv'1 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 (x0:t_T)-> {self_'0 = C_Ok x0} (! bb3) | br1 (x0:t_E)-> {self_'0 = C_Err x0} (! bb4) ] 
    | bb4 = s0 [ s0 = v_Err {self_'0} (fun (r0:t_E) ->  [ &e <- r0 ] s1) | s1 =  [ &_7 <- C_Err'0 e ] s2 | s2 = bb8 ] 
    | bb8 = s0 [ s0 =  [ &_0 <- C_Break _7 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb3 = bb5
    | bb5 = s0 [ s0 = v_Ok {self_'0} (fun (r0:t_T) ->  [ &v <- r0 ] s1) | s1 =  [ &_0 <- C_Continue v ] s2 | s2 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb11
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0: t_ControlFlow = Any.any_l ()
    | & self_'0: t_Result = self_
    | & v: t_T = Any.any_l ()
    | & e: t_E = Any.any_l ()
    | & _7: t_Result'0 = Any.any_l () ]
    
    [ return''0 (result:t_ControlFlow)-> {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body result type invariant] [%#sops'0] inv'4 result}
      {[@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body ensures] [%#sops'1] match self_ with
        | C_Ok v -> result = C_Continue v
        | C_Err e -> result = C_Break (C_Err'0 e)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ops__extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body [#"../../creusot-contracts/src/std/ops.rs" 329 86 334 18]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 334 33 334 41
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 329 75 329 87
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 330 26 333 17
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'9 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'10 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'11 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.prelude.Any
  
  type t_E
  
  type t_Result  =
    | C_Ok ()
    | C_Err t_E
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_E)
  
  axiom precondition_fndef: forall args: t_E [precondition () args]. (let value = args in inv value)
   -> precondition () args
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_E) (result: t_F)
  
  
  axiom postcondition_fndef: forall args: t_E, res: t_F [postcondition_once () args res]. postcondition_once () args res
   -> (let value = args in inv'0 res)
  
  let rec from (value:t_E) (return'  (x:t_F))= {[@expl:from requires] precondition () value}
    any [ return''0 (result:t_F)-> {postcondition_once () value result} (! return' {result}) ] 
  
  type t_T
  
  type t_Result'0  =
    | C_Ok'0 t_T
    | C_Err'0 t_F
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: ())
  
  axiom inv_axiom [@rewrite]: forall x: () [inv'1 x]. inv'1 x = false
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result [inv'2 x]. inv'2 x
  = match x with
    | C_Ok a_0 -> inv'1 a_0
    | C_Err a_0 -> inv a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Result'0 [inv'4 x]. inv'4 x
  = match x with
    | C_Ok'0 a_0 -> inv'3 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  type tuple  =
    { _p0: t_Result'0; _p1: t_Result }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_E) (result_state: ()) (result: t_F)
  
  
  axiom postcondition_fndef'0: forall args: t_E, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let value = args in inv'0 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_E) (res: t_F) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_E, res: t_F. [%#sops'11] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'8] hist_inv self b)
   -> ([%#sops'9] hist_inv b c)  -> ([%#sops'10] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'7] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_E) (res_state: ()) (res: t_F) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_E, res_state: (), res: t_F. ([%#sops'5] postcondition_mut self args res_state res)
   -> ([%#sops'6] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'4] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_E) (result: t_F)
  
  axiom postcondition_fndef'1: forall args: t_E, res: t_F [postcondition () args res]. postcondition () args res
   -> (let value = args in inv'0 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_E) (res: t_F) : ()
  
  axiom fn_once_spec: forall self: (), args: t_E, res: t_F. [%#sops'3] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_E) (res_state: ()) (res: t_F) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_E, res_state: (), res: t_F. [%#sops'2] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body[#"../../creusot-contracts/src/std/ops.rs" 329 86 334 18] (residual:t_Result) (return'  (x:t_Result'0))= {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body 'residual' type invariant] [%#sops] inv'2 residual}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = v_Err {residual'0} (fun (r0:t_E) ->  [ &e <- r0 ] s1)
      | s1 = from {e} (fun (_ret:t_F) ->  [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 =  [ &_0 <- C_Err'0 _4 ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = return''0 {_0} ]
    )
    [ & _0: t_Result'0 = Any.any_l ()
    | & residual'0: t_Result = residual
    | & e: t_E = Any.any_l ()
    | & _4: t_F = Any.any_l () ]
    
    [ return''0 (result:t_Result'0)-> {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body result type invariant] [%#sops'0] inv'4 result}
      {[@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body ensures] [%#sops'1] match { _p0 = result;
                                                                                                                                       _p1 = residual } with
        | {_p0 = C_Err'0 result'0 ; _p1 = C_Err residual'0} -> postcondition () residual'0 result'0
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_PartialEq_Option_T_eq_body [#"../../creusot-contracts/src/std/option.rs" 24 16 24 48]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 11 16 11 17
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 12 29 12 32
  let%span scmp'1 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span soption = "../../creusot-contracts/src/std/option.rs" 28 29 28 34
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 26 40 26 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 22 16 22 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 24 29 24 32
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  let rec eq (self_:t_T) (rhs:t_T) (return'  (x:bool))= {[@expl:eq 'self_' type invariant] [%#scmp] inv'1 self_}
    {[@expl:eq 'rhs' type invariant] [%#scmp'0] inv'1 rhs}
    any
    [ return''0 (result:bool)-> {[%#scmp'1] result = (deep_model'1 self_ = deep_model'1 rhs)} (! return' {result}) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x = invariant''1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_DeepModelTy
  
  function deep_model'2 [#"../../creusot-contracts/src/std/option.rs" 10 4 10 44] (self: t_Option) : t_Option'0 =
    [%#soption'4] match self with
      | C_Some t -> C_Some'0 (deep_model t)
      | C_None -> C_None'0
      end
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Option) : t_Option'0 =
    [%#smodel] deep_model'2 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_PartialEq_Option_T_eq_body[#"../../creusot-contracts/src/std/option.rs" 24 16 24 48] (self_:t_Option) (rhs:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body 'self_' type invariant] [%#soption'1] inv'3 self_}
    {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body 'rhs' type invariant] [%#soption'2] inv'3 rhs}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = rhs'0 } ] s1
      | s1 = any [ br0 -> {_4._p0 = C_None} (! bb2) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb4) ]  ]
    
    | bb4 = any [ br0 -> {_4._p1 = C_None} (! bb12) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb5) ] 
    | bb12 = bb1
    | bb5 = bb6
    | bb6 = s0
      [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &x <- r0 ] s1)
      | s1 = v_Some {_4._p1} (fun (r0:t_T) ->  [ &y <- r0 ] s2)
      | s2 = eq {x} {y} (fun (_ret:bool) ->  [ &_0 <- _ret ] s3)
      | s3 = bb8 ]
    
    | bb8 = bb9
    | bb2 = any [ br0 -> {_4._p1 = C_None} (! bb3) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb1) ] 
    | bb1 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb9 ] 
    | bb3 = bb7
    | bb7 = s0 [ s0 =  [ &_0 <- [%#soption'0] true ] s1 | s1 = bb9 ] 
    | bb9 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Option = self_
    | & rhs'0: t_Option = rhs
    | & _4: tuple = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & y: t_T = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body ensures] [%#soption'3] result
      = (deep_model'3 self_ = deep_model'3 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_T_Clone_Option_T_clone_body [#"../../creusot-contracts/src/std/option.rs" 41 8 41 36]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span soption = "../../creusot-contracts/src/std/option.rs" 36 8 36 9
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 41 27 41 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 36 18 40 9
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x = invariant''0 x
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_T_Clone_Option_T_clone_body[#"../../creusot-contracts/src/std/option.rs" 41 8 41 36] (self_:t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_T_Clone_Option_T_clone_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &x <- r0 ] s1)
      | s1 = clone' {x} (fun (_ret:t_T) ->  [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_0 <- C_Some _5 ] s1 | s1 = bb6 ] 
    | bb6 = bb7
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l () | & self_'0: t_Option = self_ | & x: t_T = Any.any_l () | & _5: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_T_Clone_Option_T_clone_body result type invariant] [%#soption'0] inv'1 result}
      {[@expl:extern_spec_T_Clone_Option_T_clone_body ensures] [%#soption'1] match { _p0 = self_; _p1 = result } with
        | {_p0 = C_None ; _p1 = C_None} -> true
        | {_p0 = C_Some s ; _p1 = C_Some r} -> postcondition () s r
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_some_body [#"../../creusot-contracts/src/std/option.rs" 57 16 57 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 60 35 60 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 59 32 59 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 55 16 55 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 56 26 56 51
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_some_body[#"../../creusot-contracts/src/std/option.rs" 57 16 57 41] (self_:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_some_body 'self_' type invariant] [%#soption'1] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [%#soption] true ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption'0] false ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: bool = Any.any_l () | & self_'0: t_Option = self_ ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_some_body ensures] [%#soption'2] result
      = (self_ <> C_None)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_some_and_body [#"../../creusot-contracts/src/std/option.rs" 72 16 72 71]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 178 35 178 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 74 32 74 37
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 64 16 64 17
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 72 37 72 38
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 64 27 67 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 68 26 71 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type impl_FnOnce_T_____bool
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: impl_FnOnce_T_____bool)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: impl_FnOnce_T_____bool) (args: t_T)
  
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: impl_FnOnce_T_____bool) (args: t_T) (result: bool)
  
  
  let rec call_once (self_:impl_FnOnce_T_____bool) (arg:t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: impl_FnOnce_T_____bool)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_some_and_body[#"../../creusot-contracts/src/std/option.rs" 72 16 72 71] (self_:t_Option) (f:impl_FnOnce_T_____bool) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'self_' type invariant] [%#soption'0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'f' type invariant] [%#soption'1] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body requires] [%#soption'2] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_8 <- t ] s2
      | s2 = call_once {f'0} {_8} (fun (_ret:bool) ->  [ &_0 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: impl_FnOnce_T_____bool = f
    | & t: t_T = Any.any_l ()
    | & _8: t_T = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body ensures] [%#soption'3] match self_ with
        | C_None -> result = false
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_none_body [#"../../creusot-contracts/src/std/option.rs" 81 16 81 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 84 35 84 40
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 83 32 83 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 79 16 79 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 80 26 80 51
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x = invariant' x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_none_body[#"../../creusot-contracts/src/std/option.rs" 81 16 81 41] (self_:t_Option) (return'  (x:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_none_body 'self_' type invariant] [%#soption'1] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [%#soption] false ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption'0] true ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: bool = Any.any_l () | & self_'0: t_Option = self_ ] 
    [ return''0 (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_none_body ensures] [%#soption'2] result
      = (self_ = C_None)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_ref_body [#"../../creusot-contracts/src/std/option.rs" 93 16 93 46]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 88 16 88 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 93 36 93 46
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 89 26 89 58
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 91 20 91 89
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_ref_body[#"../../creusot-contracts/src/std/option.rs" 93 16 93 46] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_as_ref_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- C_Some'0 t ] s2 | s2 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: t_Option'0 = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_ref_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #0] [%#soption'1] self_ = C_None
       -> result = C_None'0}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #1] [%#soption'2] self_ = C_None
      \/ (exists r: t_T. result = C_Some'0 r /\ self_ = C_Some r)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_mut_body [#"../../creusot-contracts/src/std/option.rs" 106 16 106 54]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 100 16 100 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 106 40 106 54
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 26 101 75
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 103 20 104 100
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve _0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Option [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_Option) =
    resolve'1 _0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_mut_body[#"../../creusot-contracts/src/std/option.rs" 106 16 106 54] (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_as_mut_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 =  [ &_0 <- C_Some'0 _6 ] s3
      | s3 = {[@expl:type invariant] inv'0 t} s4
      | s4 = -{resolve'0 t}- s5
      | s5 = bb5 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _6: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_mut_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #0] [%#soption'1] self_.current = C_None
       -> result = C_None'0 /\ self_.final = C_None}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #1] [%#soption'2] self_.current = C_None
      \/ (exists r: MutBorrow.t t_T. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_slice_body [#"../../creusot-contracts/src/std/option.rs" 118 16 118 42]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 697 20 697 91
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 386 27 386 28
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 384 22 384 40
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 385 22 385 38
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 18 20 18 30
  let%span soption = "../../creusot-contracts/src/std/option.rs" 113 16 113 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 118 38 118 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 114 26 117 17
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/logic/seq.rs" 696 4 696 30] (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'2] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'3] view self = Slice64.id self)
  
  predicate invariant''2 [#"../../creusot-contracts/src/std/slice.rs" 17 4 17 30] (self: Slice64.slice t_T) =
    [%#sslice'4] inv'2 (view self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Slice64.slice t_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Slice64.slice t_T [inv'3 x]. inv'3 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: Slice64.slice t_T) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Slice64.slice t_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: Slice64.slice t_T [inv'4 x]. inv'4 x = invariant''3 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  let rec from_ref (s:t_T) (return'  (x:Slice64.slice t_T))= {[@expl:from_ref 's' type invariant] [%#sslice] inv'0 s}
    any
    [ return''0 (result:Slice64.slice t_T)-> {inv'4 result}
      {[%#sslice'0] Seq.length (view'0 result) = 1}
      {[%#sslice'1] Seq.get (view'0 result) 0 = s}
      (! return' {result}) ]
  
  
  let rec promoted0__extern_spec_std_option_T_Option_T_as_slice_body (return'  (x:Slice64.array t_T))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array t_T)-> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0: Slice64.array t_T = Any.any_l () | & _1: Slice64.array t_T = Any.any_l () ] 
    [ return''0 (result:Slice64.array t_T)-> return' {result} ]
  
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''4 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'5 self
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option [inv'6 x]. inv'6 x = invariant''4 x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_slice_body[#"../../creusot-contracts/src/std/option.rs" 118 16 118 42] (self_:t_Option) (return'  (x:Slice64.slice t_T))= {[@expl:extern_spec_std_option_T_Option_T_as_slice_body 'self_' type invariant] [%#soption] inv'6 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = from_ref {t} (fun (_ret:Slice64.slice t_T) ->  [ &_9 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_3 <- _9 ] s1 | s1 = bb6 ] 
    | bb2 = bb4
    | bb4 = s0
      [ s0 = promoted0__extern_spec_std_option_T_Option_T_as_slice_body 
          (fun (pr0:Slice64.array t_T) ->  [ &_11 <- pr0 ] s1)
      | s1 =  [ &_6 <- _11 ] s2
      | s2 =  [ &_3 <- _6 ] s3
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- _3 ] s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0: Slice64.slice t_T = Any.any_l ()
    | & self_'0: t_Option = self_
    | & _3: Slice64.slice t_T = Any.any_l ()
    | & _6: Slice64.array t_T = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _9: Slice64.slice t_T = Any.any_l ()
    | & _11: Slice64.array t_T = Any.any_l () ]
    
    [ return''0 (result:Slice64.slice t_T)-> {[@expl:extern_spec_std_option_T_Option_T_as_slice_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_slice_body ensures] [%#soption'1] match self_ with
        | C_None -> Seq.length (view'0 result) = 0
        | C_Some t -> Seq.length (view'0 result) = 1 /\ Seq.get (view'0 result) 0 = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_mut_slice_body [#"../../creusot-contracts/src/std/option.rs" 133 16 133 54]
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 10 20 10 30
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 697 20 697 91
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 393 27 393 28
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 389 22 389 40
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 390 22 390 38
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 391 22 391 43
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 392 22 392 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 18 20 18 30
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 125 16 125 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 133 46 133 54
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 126 26 132 17
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/logic/seq.rs" 696 4 696 30] (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'4] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'5] view self = Slice64.id self)
  
  predicate invariant''2 [#"../../creusot-contracts/src/std/slice.rs" 17 4 17 30] (self: Slice64.slice t_T) =
    [%#sslice'6] inv'2 (view self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Slice64.slice t_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: Slice64.slice t_T [inv'3 x]. inv'3 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t (Slice64.slice t_T))
  
   =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t (Slice64.slice t_T))
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t (Slice64.slice t_T) [inv'4 x]. inv'4 x = invariant''3 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  let rec from_mut (s:MutBorrow.t t_T) (return'  (x:MutBorrow.t (Slice64.slice t_T)))= {[@expl:from_mut 's' type invariant] [%#sslice] inv'0 s}
    any
    [ return''0 (result:MutBorrow.t (Slice64.slice t_T))-> {inv'4 result}
      {[%#sslice'0] Seq.length (view'0 result) = 1}
      {[%#sslice'1] Seq.get (view'0 result) 0 = s.current}
      {[%#sslice'2] Seq.length (view result.final) = 1}
      {[%#sslice'3] Seq.get (view result.final) 0 = s.final}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t (Slice64.slice t_T)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t (Slice64.slice t_T)) =
    resolve _0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve'1 _0
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option [inv'5 x]. inv'5 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''4 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_Option) =
    resolve'3 _0
  
  predicate invariant''5 [#"../../creusot-contracts/src/std/array.rs" 9 4 9 30] (self: Slice64.array t_T) =
    [%#sarray] inv'2 (Slice64.id self)
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Slice64.array t_T)
  
  axiom inv_axiom'6 [@rewrite]: forall x: Slice64.array t_T [inv'7 x]. inv'7 x = invariant''5 x
  
  let rec promoted0__extern_spec_std_option_T_Option_T_as_mut_slice_body (return'  (x:MutBorrow.t (Slice64.array t_T)))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array t_T)-> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 = {inv'7 _1}
        MutBorrow.borrow_mut <Slice64.array t_T> {_1}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_0 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_1 <- _ret.final ] 
            s2)
      | s2 = return''0 {_0} ]
     ]
     [ & _0: MutBorrow.t (Slice64.array t_T) = Any.any_l () | & _1: Slice64.array t_T = Any.any_l () ] 
    [ return''0 (result:MutBorrow.t (Slice64.array t_T))-> return' {result} ]
  
  
  predicate invariant''6 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t (Slice64.array t_T))
  
   =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t (Slice64.array t_T))
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t (Slice64.array t_T) [inv'8 x]. inv'8 x = invariant''6 x
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t (Slice64.array t_T)) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t (Slice64.array t_T)) =
    resolve'5 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_mut_slice_body[#"../../creusot-contracts/src/std/option.rs" 133 16 133 54] (self_:MutBorrow.t t_Option) (return'  (x:MutBorrow.t (Slice64.slice t_T)))= {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body 'self_' type invariant] [%#soption] inv'6 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0.current = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_11 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 = from_mut {_11} (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->  [ &_10 <- _ret ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0
      [ s0 = {inv'3 _10.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_4 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_10 <- { _10 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'0 t} s4
      | s4 = -{resolve'2 t}- s5
      | s5 = bb6 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'6 self_'0} s1 | s1 = -{resolve'4 self_'0}- s2 | s2 = bb4 ] 
    | bb4 = s0
      [ s0 = promoted0__extern_spec_std_option_T_Option_T_as_mut_slice_body 
          (fun (pr0:MutBorrow.t (Slice64.array t_T)) ->  [ &_12 <- pr0 ] s1)
      | s1 = {inv'7 _12.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_7 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_12 <- { _12 with current = _ret.final } ] 
            s2)
      | s2 = {inv'7 _7.current}
        MutBorrow.borrow_final <Slice64.array t_T> {_7.current} {MutBorrow.get_id _7}
          (fun (_ret:MutBorrow.t (Slice64.array t_T)) ->
             [ &_6 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_7 <- { _7 with current = _ret.final } ] 
            s3)
      | s3 =  [ &_4 <- _6 ] s4
      | s4 = {[@expl:type invariant] inv'8 _7} s5
      | s5 = -{resolve'6 _7}- s6
      | s6 = bb8 ]
    
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'8 _12} s1 | s1 = -{resolve'6 _12}- s2 | s2 = bb6 ] 
    | bb6 = s0
      [ s0 = {inv'3 _4.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_4.current} {MutBorrow.get_id _4}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_2 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_4 <- { _4 with current = _ret.final } ] 
            s1)
      | s1 = {inv'3 _2.current}
        MutBorrow.borrow_final <Slice64.slice t_T> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret:MutBorrow.t (Slice64.slice t_T)) ->
             [ &_0 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_2 <- { _2 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 _4} s3
      | s3 = -{resolve'0 _4}- s4
      | s4 = {[@expl:type invariant] inv'4 _2} s5
      | s5 = -{resolve'0 _2}- s6
      | s6 = {[@expl:type invariant] inv'6 self_'0} s7
      | s7 = -{resolve'4 self_'0}- s8
      | s8 = return''0 {_0} ]
     ]
    )
    [ & _0: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & _2: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _4: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _6: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & _7: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _11: MutBorrow.t t_T = Any.any_l ()
    | & _12: MutBorrow.t (Slice64.array t_T) = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t (Slice64.slice t_T))-> {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body ensures] [%#soption'1] match self_.current with
        | C_None -> Seq.length (view'0 result) = 0
        | C_Some _ -> exists b: MutBorrow.t t_T. self_.current = C_Some (b.current)
        /\ self_.final = C_Some (b.final)
        /\ Seq.get (view result.current) 0 = b.current
        /\ Seq.get (view result.final) 0 = b.final
        /\ Seq.length (view result.current) = 1 /\ Seq.length (view result.final) = 1
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_expect_body [#"../../creusot-contracts/src/std/option.rs" 143 16 143 47]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 140 16 140 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 141 27 141 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 143 46 143 47
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 142 26 142 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_expect_body[#"../../creusot-contracts/src/std/option.rs" 143 16 143 47] (self_:t_Option) (msg:string) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_expect_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_expect_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return''0 {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_expect_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_expect_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_body [#"../../creusot-contracts/src/std/option.rs" 153 16 153 36]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 150 16 150 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 151 27 151 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 153 35 153 36
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 26 152 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_body[#"../../creusot-contracts/src/std/option.rs" 153 16 153 36] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return''0 {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_body [#"../../creusot-contracts/src/std/option.rs" 163 16 163 51]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 160 16 160 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 163 35 163 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 163 50 163 51
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 161 26 161 60
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 162 26 162 85
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_body[#"../../creusot-contracts/src/std/option.rs" 163 16 163 51] (self_:t_Option) (default:t_T) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'default' type invariant] [%#soption'0] inv default}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- default'0 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = return''0 {_0} ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & default'0: t_T = default | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #0] [%#soption'2] self_ = C_None
       -> result = default}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #1] [%#soption'3] self_ = C_None
      \/ self_ = C_Some result /\ resolve default}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body [#"../../creusot-contracts/src/std/option.rs" 175 16 177 36]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 170 16 170 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 175 43 175 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 170 27 170 62
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 175 52 175 53
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 171 26 174 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: ()) (result: t_T)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_T))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_T)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body[#"../../creusot-contracts/src/std/option.rs" 175 16 177 36] (self_:t_Option) (f:t_F) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body requires] [%#soption'1] self_ = C_None
     -> precondition f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb8 ]
    
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once {f'0} {_7} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0: t_T = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & _7: () = Any.any_l ()
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body result type invariant] [%#soption'2] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_default_body [#"../../creusot-contracts/src/std/option.rs" 186 16 188 30]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span soption = "../../creusot-contracts/src/std/option.rs" 184 16 184 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 186 46 186 47
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 184 26 184 79
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 185 26 185 62
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true)  -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: ()) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition () args res]. postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_default_body[#"../../creusot-contracts/src/std/option.rs" 186 16 188 30] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body 'self_' type invariant] [%#soption] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = return''0 {_0} ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body result type invariant] [%#soption'0] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #0] [%#soption'1] self_ = C_None
       -> postcondition () () result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #1] [%#soption'2] self_ = C_None
      \/ self_ = C_Some result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_unchecked_body [#"../../creusot-contracts/src/std/option.rs" 198 16 198 53]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 195 16 195 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 196 27 196 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 198 52 198 53
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 197 26 197 46
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_unchecked_body[#"../../creusot-contracts/src/std/option.rs" 198 16 198 53] (self_:t_Option) (return'  (x:t_T))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body requires] [%#soption'0] self_ <> C_None}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return''0 {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0: t_T = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_T)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body result type invariant] [%#soption'1] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body ensures] [%#soption'2] C_Some result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_body [#"../../creusot-contracts/src/std/option.rs" 213 16 215 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 178 35 178 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 205 16 205 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 213 35 213 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 205 27 208 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 213 44 213 53
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 209 26 212 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_T) (result: t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'2 result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'4 x]. inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_body[#"../../creusot-contracts/src/std/option.rs" 213 16 215 37] (self_:t_Option) (f:t_F) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_map_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_map_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_9 <- t ] s2
      | s2 = call_once {f'0} {_9} (fun (_ret:t_U) ->  [ &_7 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'0 _7 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & t: t_T = Any.any_l ()
    | & _7: t_U = Any.any_l ()
    | & _9: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_body result type invariant] [%#soption'2] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> exists r: t_U. result = C_Some'0 r /\ postcondition_once f t r
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_inspect_body [#"../../creusot-contracts/src/std/option.rs" 231 16 233 33]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 178 35 178 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 222 16 222 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 231 36 231 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 222 27 225 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 231 45 231 54
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 226 26 226 40
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 227 26 230 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_T) (result: ())
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:()))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:())-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_inspect_body[#"../../creusot-contracts/src/std/option.rs" 231 16 233 33] (self_:t_Option) (f:t_F) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = any [ br0 -> {self_'0 = C_None} (! bb5) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb6) ] 
    | bb6 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_12 <- t ] s2
      | s2 =  [ &_10 <- _12 ] s3
      | s3 = call_once {f'0} {_10} (fun (_ret:()) ->  [ &_8 <- _ret ] s4)
      | s4 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb5 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _10: t_T = Any.any_l ()
    | & _12: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_inspect_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #0] [%#soption'3] result = self_}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #1] [%#soption'4] match self_ with
        | C_None -> true
        | C_Some t -> postcondition_once f t ()
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_body [#"../../creusot-contracts/src/std/option.rs" 248 16 250 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 178 35 178 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 240 16 240 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 248 38 248 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 248 50 248 51
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 240 27 243 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 248 59 248 60
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 244 26 247 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_U
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_U)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_F
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_T) (result: t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:t_U)-> {inv result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_body[#"../../creusot-contracts/src/std/option.rs" 248 16 250 37] (self_:t_Option) (default:t_U) (f:t_F) (return'  (x:t_U))= {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'default' type invariant] [%#soption'0] inv default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'f' type invariant] [%#soption'1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body requires] [%#soption'2] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_9 <- t ] s4
      | s4 = call_once {f'0} {_9} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s5)
      | s5 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f'0} s1 | s1 = -{resolve'0 f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- default'0 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return''0 {_0} ]
    )
    [ & _0: t_U = Any.any_l ()
    | & self_'0: t_Option = self_
    | & default'0: t_U = default
    | & f'0: t_F = f
    | & t: t_T = Any.any_l ()
    | & _9: t_T = Any.any_l () ]
    
    [ return''0 (result:t_U)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_body result type invariant] [%#soption'3] inv result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_body ensures] [%#soption'4] match self_ with
        | C_None -> result = default
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_else_body [#"../../creusot-contracts/src/std/option.rs" 265 16 268 37]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 178 35 178 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 257 16 257 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 265 46 265 53
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 265 58 265 59
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 257 27 260 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 265 67 265 68
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 261 26 264 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_D
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_D)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_D)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_F
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_T)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_T) (result: t_U)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'3 result} {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_D) (args: ())
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_D) (args: ()) (result: t_U)
  
  
  let rec call_once'0 (self_:t_D) (arg:()) (return'  (x:t_U))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'1] precondition'0 self_ arg}
    any
    [ return''0 (result:t_U)-> {inv'3 result} {[%#sops'2] postcondition_once'0 self_ arg result} (! return' {result}) ]
  
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body[#"../../creusot-contracts/src/std/option.rs" 265 16 268 37] (self_:t_Option) (default:t_D) (f:t_F) (return'  (x:t_U))= {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'default' type invariant] [%#soption'0] inv default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'f' type invariant] [%#soption'1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body requires] [%#soption'2] match self_ with
      | C_None -> precondition'0 default ()
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv default'0} s1
      | s1 = -{resolve default'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_11 <- t ] s4
      | s4 = call_once {f'0} {_11} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s5)
      | s5 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f'0} s1 | s1 = -{resolve'0 f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 = call_once'0 {default'0} {_8} (fun (_ret:t_U) ->  [ &_0 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = return''0 {_0} ]
    )
    [ & _0: t_U = Any.any_l ()
    | & self_'0: t_Option = self_
    | & default'0: t_D = default
    | & f'0: t_F = f
    | & _8: () = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _11: t_T = Any.any_l () ]
    
    [ return''0 (result:t_U)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body result type invariant] [%#soption'3] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body ensures] [%#soption'4] match self_ with
        | C_None -> postcondition_once'0 default () result
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_body [#"../../creusot-contracts/src/std/option.rs" 280 16 280 57]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 275 16 275 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 280 34 280 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 280 45 280 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 276 26 279 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_E
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_E)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result [inv'2 x]. inv'2 x
  = match x with
    | C_Ok a_0 -> inv'0 a_0
    | C_Err a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_body[#"../../creusot-contracts/src/std/option.rs" 280 16 280 57] (self_:t_Option) (err:t_E) (return'  (x:t_Result))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'err' type invariant] [%#soption'0] inv err}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0 = C_None} (! bb3) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb4) ] 
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv err'0} s1
      | s1 = -{resolve err'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Ok t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb3 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- C_Err err'0 ] s1 | s1 = bb6 ] 
    | bb6 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    ) [ & _0: t_Result = Any.any_l () | & self_'0: t_Option = self_ | & err'0: t_E = err | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_body result type invariant] [%#soption'1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_body ensures] [%#soption'2] match self_ with
        | C_None -> result = C_Err err
        | C_Some t -> result = C_Ok t /\ resolve err
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_else_body [#"../../creusot-contracts/src/std/option.rs" 292 16 294 36]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 287 16 287 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 292 42 292 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 287 27 287 64
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 292 53 292 65
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 288 26 291 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: ()) (result: t_E)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_E))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_E)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result [inv'3 x]. inv'3 x
  = match x with
    | C_Ok a_0 -> inv'1 a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body[#"../../creusot-contracts/src/std/option.rs" 292 16 294 36] (self_:t_Option) (err:t_F) (return'  (x:t_Result))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'err' type invariant] [%#soption'0] inv err}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body requires] [%#soption'1] self_ = C_None
     -> precondition err ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv err'0} s1
      | s1 = -{resolve err'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Ok t ] s4
      | s4 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once {err'0} {_8} (fun (_ret:t_E) ->  [ &_6 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_Err _6 ] s1 | s1 = bb8 ] 
    | bb8 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return''0 {_0} ]
    )
    [ & _0: t_Result = Any.any_l ()
    | & self_'0: t_Option = self_
    | & err'0: t_F = err
    | & _6: t_E = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Result)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> exists r: t_E. result = C_Err r /\ postcondition_once err () r
        | C_Some t -> result = C_Ok t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_body [#"../../creusot-contracts/src/std/option.rs" 304 16 304 61]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 301 16 301 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 304 32 304 36
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 304 52 304 61
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 302 26 302 75
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 303 26 303 76
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Option) =
    resolve'0 _0
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_U)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option'0) =
    [%#sresolve] match self with
      | C_Some'0 x -> resolve'2 x
      | C_None'0 -> true
      end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Option'0) =
    resolve'3 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_body[#"../../creusot-contracts/src/std/option.rs" 304 16 304 61] (self_:t_Option) (optb:t_Option'0) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_body 'optb' type invariant] [%#soption'0] inv'2 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_'0} s1
      | s1 = -{resolve'1 self_'0}- s2
      | s2 =  [ &_0 <- optb'0 ] s3
      | s3 = bb7 ]
    
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'2 optb'0} s1
      | s1 = -{resolve'4 optb'0}- s2
      | s2 = {[@expl:type invariant] inv'0 self_'0} s3
      | s3 = -{resolve'1 self_'0}- s4
      | s4 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = return''0 {_0} ]
    ) [ & _0: t_Option'0 = Any.any_l () | & self_'0: t_Option = self_ | & optb'0: t_Option'0 = optb ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_body result type invariant] [%#soption'1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #0] [%#soption'2] self_ = C_None
       -> result = C_None'0 /\ resolve'3 optb}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #1] [%#soption'3] self_ = C_None
      \/ result = optb /\ resolve'0 self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_then_body [#"../../creusot-contracts/src/std/option.rs" 319 16 321 45]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 178 35 178 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 311 16 311 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 319 40 319 41
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 311 27 314 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 319 49 319 58
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 315 26 318 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = (let x0 = x in inv'0 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_T)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_T) (result: t_Option'0)
  
  
  let rec call_once (self_:t_F) (arg:t_T) (return'  (x:t_Option'0))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'1 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any
    [ return''0 (result:t_Option'0)-> {inv'3 result}
      {[%#sops'2] postcondition_once self_ arg result}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_then_body[#"../../creusot-contracts/src/std/option.rs" 319 16 321 45] (self_:t_Option) (f:t_F) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_8 <- t ] s2
      | s2 = call_once {f'0} {_8} (fun (_ret:t_Option'0) ->  [ &_0 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv f'0} s1 | s1 = -{resolve f'0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & t: t_T = Any.any_l ()
    | & _8: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_then_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_then_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None'0
        | C_Some t -> postcondition_once f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_filter_body [#"../../creusot-contracts/src/std/option.rs" 339 16 341 41]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 178 35 178 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 328 16 328 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 339 35 339 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 328 27 331 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 339 52 339 61
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 332 26 338 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_P
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_P)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_P) (args: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_P) (args: t_T) (result: bool)
  
  
  let rec call_once (self_:t_P) (arg:t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_P)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_filter_body[#"../../creusot-contracts/src/std/option.rs" 339 16 341 41] (self_:t_Option) (predicate':t_P) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_filter_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'predicate' type invariant] [%#soption'0] inv predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body requires] [%#soption'1] match self_ with
      | C_None -> true
      | C_Some t -> precondition predicate' t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 =  [ &_11 <- t ] s2
      | s2 =  [ &_9 <- _11 ] s3
      | s3 = call_once {predicate''0} {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s4)
      | s4 = bb7 ]
    
    | bb7 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ] 
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb9 ] 
    | bb9 = bb12
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve t}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv predicate''0} s1 | s1 = -{resolve'0 predicate''0}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb14 ] 
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & predicate''0: t_P = predicate'
    | & t: t_T = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_T = Any.any_l ()
    | & _11: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_filter_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_filter_body ensures] [%#soption'3] match self_ with
        | C_None -> result = C_None
        | C_Some t -> match result with
          | C_None -> postcondition_once predicate' t false /\ resolve t
          | C_Some r -> postcondition_once predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_body [#"../../creusot-contracts/src/std/option.rs" 351 16 351 57]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 348 16 348 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 351 28 351 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 351 48 351 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 349 26 349 57
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 350 26 350 76
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_body[#"../../creusot-contracts/src/std/option.rs" 351 16 351 57] (self_:t_Option) (optb:t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_or_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_body 'optb' type invariant] [%#soption'0] inv'0 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 optb'0} s1
      | s1 = -{resolve'1 optb'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Some t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- optb'0 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & optb'0: t_Option = optb
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_or_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #0] [%#soption'2] self_ = C_None  -> result = optb}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #1] [%#soption'3] self_ = C_None
      \/ result = self_ /\ resolve'0 optb}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_else_body [#"../../creusot-contracts/src/std/option.rs" 363 16 365 44]
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span soption = "../../creusot-contracts/src/std/option.rs" 358 16 358 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 363 36 363 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 358 27 358 62
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 363 45 363 54
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 359 26 362 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: ())
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: ()) (result: t_Option)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_Option))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_Option)-> {inv'1 result}
      {[%#sops'1] postcondition_once self_ arg result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_else_body[#"../../creusot-contracts/src/std/option.rs" 363 16 365 44] (self_:t_Option) (f:t_F) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body requires] [%#soption'1] self_ = C_None  -> precondition f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s3)
      | s3 =  [ &_0 <- C_Some t ] s4
      | s4 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once {f'0} {_7} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = bb10
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & f'0: t_F = f
    | & _7: () = Any.any_l ()
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_or_else_body result type invariant] [%#soption'2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_else_body ensures] [%#soption'3] match self_ with
        | C_None -> postcondition_once f () result
        | C_Some t -> result = C_Some t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_xor_body [#"../../creusot-contracts/src/std/option.rs" 379 16 379 58]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 372 16 372 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 379 29 379 33
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 379 49 379 58
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 373 26 378 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_xor_body[#"../../creusot-contracts/src/std/option.rs" 379 16 379 58] (self_:t_Option) (optb:t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_xor_body 'self_' type invariant] [%#soption] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_xor_body 'optb' type invariant] [%#soption'0] inv'0 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = optb'0 } ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = any [ br0 -> {_4._p0 = C_None} (! bb7) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 = any [ br0 -> {_4._p1 = C_None} (! bb6) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb25) ]  ]
    
    | bb25 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p0 = C_Some x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = bb4 ]
    
    | bb6 = bb10
    | bb10 = s0 [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 = bb11 ] 
    | bb7 = any [ br0 -> {_4._p1 = C_None} (! bb26) | br1 (x0:t_T)-> {_4._p1 = C_Some x0} (! bb8) ] 
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = C_Some x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = C_Some x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb14 ] 
    | bb8 = bb9
    | bb9 = s0 [ s0 = v_Some {_4._p1} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_Some t ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = bb17
    | bb17 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: t_Option = self_
    | & optb'0: t_Option = optb
    | & _4: tuple = Any.any_l ()
    | & t: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_xor_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_xor_body ensures] [%#soption'2] match { _p0 = self_; _p1 = optb } with
        | {_p0 = C_None ; _p1 = C_None} -> result = C_None
        | {_p0 = C_Some t1 ; _p1 = C_Some t2} -> result = C_None /\ resolve t1 /\ resolve t2
        | {_p0 = C_Some t ; _p1 = C_None} -> result = C_Some t
        | {_p0 = C_None ; _p1 = C_Some t} -> result = C_Some t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_insert_body [#"../../creusot-contracts/src/std/option.rs" 392 16 392 56]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 386 16 386 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 392 37 392 42
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 392 50 392 56
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 387 26 390 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 391 26 391 68
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve'2 _0
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Option [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_Option) =
    resolve'4 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_insert_body[#"../../creusot-contracts/src/std/option.rs" 392 16 392 56] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_insert_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_insert_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_6 <- C_Some value'0 ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _6 } ] s3
      | s3 = bb5 ]
    
    | bb5 = any [ br0 -> {self_'0.current = C_None} (! bb7) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb8) ] 
    | bb8 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &v <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv _ret.final}-
             [ &v <- { v with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 v} s3
      | s3 = -{resolve'3 v}- s4
      | s4 = {inv _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv _ret.final}-
             [ &_8 <- { _8 with current = _ret.final } ] 
            s5)
      | s5 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s6)
      | s6 = {[@expl:type invariant] inv'1 _8} s7
      | s7 = -{resolve'3 _8}- s8
      | s8 = {[@expl:type invariant] inv'1 _3} s9
      | s9 = -{resolve'3 _3}- s10
      | s10 = bb10 ]
    
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = return''0 {_0} ]
    
    | bb7 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = bb9 ] 
    | bb9 = {false} any ]
    )
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & value'0: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_insert_body result type invariant] [%#soption'1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #0] [%#soption'2] match self_.current with
        | C_Some t -> resolve t
        | C_None -> true
        end}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #1] [%#soption'3] result.current = value
      /\ self_.final = C_Some (result.final)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_body [#"../../creusot-contracts/src/std/option.rs" 405 16 405 63]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 400 16 400 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 405 44 405 49
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 405 57 405 63
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 401 26 404 17
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Option) =
    resolve'0 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve'2 _0
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Option [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve'0] self.final = self.current
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_Option) =
    resolve'4 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_body[#"../../creusot-contracts/src/std/option.rs" 405 16 405 63] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0.current = C_None} (! bb3) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb4) ] 
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv value'0} s1 | s1 = -{resolve value'0}- s2 | s2 = bb10 ] 
    | bb3 = bb5
    | bb5 = s0 [ s0 =  [ &_7 <- C_Some value'0 ] s1 | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _7 } ] s3
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = any [ br0 -> {self_'0.current = C_None} (! bb12) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb13) ] 
    | bb13 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &v <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv v.current}
        MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_9 <- _ret ] 
            -{inv _ret.final}-
             [ &v <- { v with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 v} s3
      | s3 = -{resolve'3 v}- s4
      | s4 = {inv _9.current}
        MutBorrow.borrow_final <t_T> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv _ret.final}-
             [ &_9 <- { _9 with current = _ret.final } ] 
            s5)
      | s5 = {inv _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s6)
      | s6 = {[@expl:type invariant] inv'1 _9} s7
      | s7 = -{resolve'3 _9}- s8
      | s8 = {[@expl:type invariant] inv'1 _3} s9
      | s9 = -{resolve'3 _3}- s10
      | s10 = bb15 ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = return''0 {_0} ]
    
    | bb12 = s0 [ s0 = {[@expl:type invariant] inv'2 self_'0} s1 | s1 = -{resolve'5 self_'0}- s2 | s2 = bb14 ] 
    | bb14 = {false} any ]
    )
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & value'0: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _7: t_Option = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body result type invariant] [%#soption'1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body ensures] [%#soption'2] match self_.current with
        | C_None -> result.current = value /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final) /\ resolve value
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body [#"../../creusot-contracts/src/std/option.rs" 421 16 423 36]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 416 16 416 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 421 52 421 53
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 416 27 416 63
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 421 61 421 67
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 417 26 420 17
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 100 16 100 17
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 101 26 101 75
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 103 20 104 100
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 150 16 150 17
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 151 27 151 39
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 152 26 152 46
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_F
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve'0 _0
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: ())
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: ()) (result: t_T)
  
  
  let rec call_once (self_:t_F) (arg:()) (return'  (x:t_T))= {[@expl:call_once 'self_' type invariant] [%#sops] inv self_}
    {[@expl:call_once requires] [%#sops'0] precondition self_ arg}
    any
    [ return''0 (result:t_T)-> {inv'0 result} {[%#sops'1] postcondition_once self_ arg result} (! return' {result}) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve'2 x
      | C_None -> true
      end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Option) =
    resolve'3 _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: MutBorrow.t t_Option [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'0 [inv'4 x]. inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption'4] inv'3 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'4 result}
      {[%#soption'5] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'6] self_.current = C_None
      \/ (exists r: MutBorrow.t t_T. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_T))= {[@expl:unwrap 'self_' type invariant] [%#soption'7] inv'4 self_}
    {[@expl:unwrap requires] [%#soption'8] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_T)-> {inv'1 result} {[%#soption'9] C_Some'0 result = self_} (! return' {result}) ]
  
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_Option) =
    resolve'5 _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body[#"../../creusot-contracts/src/std/option.rs" 421 16 423 36] (self_:MutBorrow.t t_Option) (f:t_F) (return'  (x:MutBorrow.t t_T))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] [%#soption] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'f' type invariant] [%#soption'0] inv f}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body requires] [%#soption'1] self_.current = C_None
     -> precondition f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0.current = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv f'0} s1
      | s1 = -{resolve f'0}- s2
      | s2 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv'0 r0}
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_'0) 1}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv'0 _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s3))
      | s3 = {inv'0 t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'1 t} s5
      | s5 = -{resolve'1 t}- s6
      | s6 = bb14 ]
    
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once {f'0} {_12} (fun (_ret:t_T) ->  [ &_10 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_9 <- C_Some _10 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self_'0 with
          | {current = x} -> inv'2 x
          | _ -> true
          end}
        s1
      | s1 = -{match self_'0 with
          | {current = x} -> resolve'4 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_'0 <- { self_'0 with current = _9 } ] s3
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {inv'2 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_15 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = as_mut {_15} (fun (_ret:t_Option'0) ->  [ &_14 <- _ret ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap {_14} (fun (_ret:MutBorrow.t t_T) ->  [ &_13 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = {inv'0 _13.current}
        MutBorrow.borrow_final <t_T> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_8 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_13 <- { _13 with current = _ret.final } ] 
            s1)
      | s1 = {inv'0 _8.current}
        MutBorrow.borrow_final <t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_6 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_8 <- { _8 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 _13} s3
      | s3 = -{resolve'1 _13}- s4
      | s4 = {[@expl:type invariant] inv'1 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'0 _6.current}
        MutBorrow.borrow_final <t_T> {_6.current} {MutBorrow.get_id _6}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_3 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_6 <- { _6 with current = _ret.final } ] 
            s1)
      | s1 = {inv'0 _3.current}
        MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_0 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_3 <- { _3 with current = _ret.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'1 _6}- s4
      | s4 = {[@expl:type invariant] inv'1 _3} s5
      | s5 = -{resolve'1 _3}- s6
      | s6 = bb15 ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'3 self_'0} s1 | s1 = -{resolve'6 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0: MutBorrow.t t_T = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & f'0: t_F = f
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _6: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_T = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _10: t_T = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & _13: MutBorrow.t t_T = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_T)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body result type invariant] [%#soption'2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body ensures] [%#soption'3] match self_.current with
        | C_None -> postcondition_once f () result.current /\ self_.final = C_Some (result.final)
        | C_Some _ -> self_.current = C_Some (result.current) /\ self_.final = C_Some (result.final)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_body [#"../../creusot-contracts/src/std/option.rs" 432 16 432 47]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span soption = "../../creusot-contracts/src/std/option.rs" 430 16 430 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 432 38 432 47
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 431 26 431 58
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Option [inv'1 x]. inv'1 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_Option) (src:t_Option) (return'  (x:t_Option))= {[@expl:replace 'dest' type invariant] [%#smem] inv'1 dest}
    {[@expl:replace 'src' type invariant] [%#smem'0] inv'0 src}
    any
    [ return''0 (result:t_Option)-> {inv'0 result}
      {[%#smem'1] dest.final = src}
      {[%#smem'2] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_Option) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_body[#"../../creusot-contracts/src/std/option.rs" 432 16 432 47] (self_:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_take_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- C_None ] s1
      | s1 = {inv'0 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_3 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s2)
      | s2 = replace {_3} {_4} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'1 self_'0} s1 | s1 = -{resolve'0 self_'0}- s2 | s2 = return''0 {_0} ]
     ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & _3: MutBorrow.t t_Option = Any.any_l ()
    | & _4: t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_take_body result type invariant] [%#soption'0] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_body ensures] [%#soption'1] result = self_.current
      /\ self_.final = C_None}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_if_body [#"../../creusot-contracts/src/std/option.rs" 450 16 452 45]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 176 16 176 17
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 178 35 178 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 176 27 176 49
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 177 26 177 62
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 436 16 436 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 450 41 450 50
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 436 27 439 17
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 450 58 450 67
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 440 26 449 17
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 430 16 430 17
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 431 26 431 58
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_P
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_P)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant' x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'2 x]. inv'2 x = (let x0 = x in inv'1 x0)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_P) (args: MutBorrow.t t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_P) (args: MutBorrow.t t_T) (result: bool)
  
  
  let rec call_once (self_:t_P) (arg:MutBorrow.t t_T) (return'  (x:bool))= {[@expl:call_once 'self_' type invariant] [%#sops] inv'0 self_}
    {[@expl:call_once 'arg' type invariant] [%#sops'0] inv'2 arg}
    {[@expl:call_once requires] [%#sops'1] precondition self_ arg}
    any [ return''0 (result:bool)-> {[%#sops'2] postcondition_once self_ arg result} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve _0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'2 [@rewrite]: forall x: MutBorrow.t t_Option [inv'4 x]. inv'4 x = invariant''0 x
  
  let rec take (self_:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:take 'self_' type invariant] [%#soption'4] inv'4 self_}
    any
    [ return''0 (result:t_Option)-> {inv'3 result}
      {[%#soption'5] result = self_.current /\ self_.final = C_None}
      (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_Option) =
    resolve'1 _0
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_P)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_if_body[#"../../creusot-contracts/src/std/option.rs" 450 16 452 45] (self_:MutBorrow.t t_Option) (predicate':t_P) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'self_' type invariant] [%#soption] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'predicate' type invariant] [%#soption'0] inv'0 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body requires] [%#soption'1] match self_.current with
      | C_None -> true
      | C_Some t -> forall b: MutBorrow.t t_T. inv'1 b /\ b.current = t  -> precondition predicate' b
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0.current = C_None} (! bb4) | br1 (x0:t_T)-> {self_'0.current = C_Some x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some {self_'0.current}
          (fun (r0:t_T) ->
            {inv r0}
            MutBorrow.borrow_mut <t_T> {r0}
              (fun (_ret:MutBorrow.t t_T) ->
                 [ &t <- _ret ] 
                -{inv _ret.final}-
                 [ &self_'0 <- { self_'0 with current = C_Some _ret.final } ] 
                s1))
      | s1 = {inv t.current}
        MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_ret:MutBorrow.t t_T) ->
             [ &_10 <- _ret ] 
            -{inv _ret.final}-
             [ &t <- { t with current = _ret.final } ] 
            s2)
      | s2 =  [ &_9 <- _10 ] s3
      | s3 = call_once {predicate''0} {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s4)
      | s4 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 = {inv'3 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_11 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = take {_11} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'4 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb12 ] 
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'4 self_'0} s1 | s1 = -{resolve'2 self_'0}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'0 predicate''0} s1
      | s1 = -{resolve'3 predicate''0}- s2
      | s2 = {[@expl:type invariant] inv'4 self_'0} s3
      | s3 = -{resolve'2 self_'0}- s4
      | s4 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb13 ] 
    | bb13 = bb14
    | bb14 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & predicate''0: t_P = predicate'
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l ()
    | & _11: MutBorrow.t t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_take_if_body result type invariant] [%#soption'2] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_if_body ensures] [%#soption'3] match self_.current with
        | C_None -> result = C_None /\ self_.final = C_None
        | C_Some cur -> exists b: MutBorrow.t t_T, res: bool. inv'1 b
        /\ cur = b.current
        /\ postcondition_once predicate' b res
        /\ (if res then
          self_.final = C_None /\ result = C_Some (b.final)
        else
          self_.final = C_Some (b.final) /\ result = C_None
        )
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_replace_body [#"../../creusot-contracts/src/std/option.rs" 461 16 461 60]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span soption = "../../creusot-contracts/src/std/option.rs" 459 16 459 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 461 38 461 43
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 461 51 461 60
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 460 26 460 65
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Option [inv'1 x]. inv'1 x = invariant' x
  
  let rec replace (dest:MutBorrow.t t_Option) (src:t_Option) (return'  (x:t_Option))= {[@expl:replace 'dest' type invariant] [%#smem] inv'1 dest}
    {[@expl:replace 'src' type invariant] [%#smem'0] inv'0 src}
    any
    [ return''0 (result:t_Option)-> {inv'0 result}
      {[%#smem'1] dest.final = src}
      {[%#smem'2] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_Option) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_replace_body[#"../../creusot-contracts/src/std/option.rs" 461 16 461 60] (self_:MutBorrow.t t_Option) (value:t_T) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_T_replace_body 'self_' type invariant] [%#soption] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_replace_body 'value' type invariant] [%#soption'0] inv value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_5 <- C_Some value'0 ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'0 self_'0.current}
        MutBorrow.borrow_final <t_Option> {self_'0.current} {MutBorrow.get_id self_'0}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_4 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &self_'0 <- { self_'0 with current = _ret.final } ] 
            s1)
      | s1 = replace {_4} {_5} (fun (_ret:t_Option) ->  [ &_0 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self_'0} s1 | s1 = -{resolve'0 self_'0}- s2 | s2 = bb4 ] 
    | bb4 = return''0 {_0} ]
    )
    [ & _0: t_Option = Any.any_l ()
    | & self_'0: MutBorrow.t t_Option = self_
    | & value'0: t_T = value
    | & _4: MutBorrow.t t_Option = Any.any_l ()
    | & _5: t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_T_replace_body result type invariant] [%#soption'1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_replace_body ensures] [%#soption'2] result = self_.current
      /\ self_.final = C_Some value}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_zip_body [#"../../creusot-contracts/src/std/option.rs" 471 16 471 67]
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 465 16 465 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 471 32 471 37
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 471 53 471 67
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 466 26 470 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_U
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_U
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option'0 [inv'0 x]. inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_U)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option'0) =
    [%#sresolve] match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Option'0) =
    resolve'0 _0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  type tuple'0  =
    { _p0'0: t_T; _p1'0: t_U }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 tuple'0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_U))= any
    [ good (field_0:t_U)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_U [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: tuple'0 [inv'3 x]. inv'3 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv'1 x0 /\ inv x1)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'1)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'1 [inv'4 x]. inv'4 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'3 a_0
    end
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve'2 x
      | C_None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_zip_body[#"../../creusot-contracts/src/std/option.rs" 471 16 471 67] (self_:t_Option) (other:t_Option'0) (return'  (x:t_Option'1))= {[@expl:extern_spec_std_option_T_Option_T_zip_body 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_zip_body 'other' type invariant] [%#soption'0] inv'0 other}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_4 <- { _p0 = self_'0; _p1 = other'0 } ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = any [ br0 -> {_4._p0 = C_None} (! bb26) | br1 (x0:t_T)-> {_4._p0 = C_Some x0} (! bb5) ] 
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = x} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = x} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {_p0 = C_Some x} -> resolve'2 x
          | _ -> true
          end}-
        s4
      | s4 = bb4 ]
    
    | bb5 = any [ br0 -> {_4._p1 = C_None'0} (! bb27) | br1 (x0:t_U)-> {_4._p1 = C_Some'0 x0} (! bb6) ] 
    | bb27 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_p1 = C_Some'0 x} -> inv x
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_p1 = C_Some'0 x} -> resolve x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {_p0 = C_Some x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {_p0 = C_Some x} -> resolve'2 x
          | _ -> true
          end}-
        s4
      | s4 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb13 ] 
    | bb6 = bb7
    | bb7 = s0
      [ s0 = v_Some {_4._p0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = v_Some'0 {_4._p1} (fun (r0:t_U) ->  [ &u <- r0 ] s2)
      | s2 =  [ &_11 <- { _p0'0 = t; _p1'0 = u } ] s3
      | s3 = bb8 ]
    
    | bb8 = bb9
    | bb9 = s0 [ s0 =  [ &_0 <- C_Some'1 _11 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0: t_Option'1 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & other'0: t_Option'0 = other
    | & _4: tuple = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _11: tuple'0 = Any.any_l () ]
    
    [ return''0 (result:t_Option'1)-> {[@expl:extern_spec_std_option_T_Option_T_zip_body result type invariant] [%#soption'1] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_zip_body ensures] [%#soption'2] match { _p0 = self_; _p1 = other } with
        | {_p0 = C_None} -> result = C_None'1 /\ resolve'0 other
        | {_p1 = C_None'0} -> result = C_None'1 /\ resolve'3 self_
        | {_p0 = C_Some t ; _p1 = C_Some'0 u} -> result = C_Some'1 { _p0'0 = t; _p1'0 = u }
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body [#"../../creusot-contracts/src/std/option.rs" 485 16 485 56]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 480 16 480 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 485 34 485 56
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 481 26 484 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  let rec v_Some (input:t_Option) (ret  (field_0:tuple))= any
    [ good (field_0:tuple)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: tuple [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_U
  
  type tuple'0  =
    { _p0'0: t_Option'0; _p1'0: t_Option'1 }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_U)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom [@rewrite]: forall x: tuple [inv'1 x]. inv'1 x = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'1)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'1 [inv'4 x]. inv'4 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'0 a_0
    end
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple'0)
  
  axiom inv_axiom'3 [@rewrite]: forall x: tuple'0 [inv'5 x]. inv'5 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv'3 x0 /\ inv'4 x1)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body[#"../../creusot-contracts/src/std/option.rs" 485 16 485 56] (self_:t_Option) (return'  (x:tuple'0))= {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0 = C_None} (! bb4) | br1 (x0:tuple)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = bb5
    | bb5 = s0
      [ s0 = v_Some {self_'0} (fun (r0:tuple) ->  [ &t <- r0._p0 ] s1)
      | s1 = v_Some {self_'0} (fun (r0:tuple) ->  [ &u <- r0._p1 ] s2)
      | s2 =  [ &_6 <- C_Some'0 t ] s3
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_8 <- C_Some'1 u ] s1 | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- { _p0'0 = _6; _p1'0 = _8 } ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = bb14
    | bb4 = s0
      [ s0 =  [ &_10 <- C_None'0 ] s1
      | s1 =  [ &_11 <- C_None'1 ] s2
      | s2 =  [ &_0 <- { _p0'0 = _10; _p1'0 = _11 } ] s3
      | s3 = bb12 ]
    
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = return''0 {_0} ]
    )
    [ & _0: tuple'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l ()
    | & _8: t_Option'1 = Any.any_l ()
    | & _10: t_Option'0 = Any.any_l ()
    | & _11: t_Option'1 = Any.any_l () ]
    
    [ return''0 (result:tuple'0)-> {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body result type invariant] [%#soption'0] inv'5 result}
      {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body ensures] [%#soption'1] match self_ with
        | C_None -> result = { _p0'0 = C_None'0; _p1'0 = C_None'1 }
        | C_Some {_p0 = t ; _p1 = u} -> result = { _p0'0 = C_Some'0 t; _p1'0 = C_Some'1 u }
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_ref_T_copied_body [#"../../creusot-contracts/src/std/option.rs" 499 16 501 27]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 494 16 494 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 499 35 499 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 495 26 498 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_copied_body[#"../../creusot-contracts/src/std/option.rs" 499 16 501 27] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1) | s1 =  [ &_0 <- C_Some'0 t ] s2 | s2 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: t_Option'0 = Any.any_l () | & self_'0: t_Option = self_ | & t: t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body ensures] [%#soption'1] match self_ with
        | C_None -> result = C_None'0
        | C_Some s -> result = C_Some'0 s
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body [#"../../creusot-contracts/src/std/option.rs" 513 16 515 28]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span soption = "../../creusot-contracts/src/std/option.rs" 508 16 508 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 513 35 513 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 508 26 512 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body[#"../../creusot-contracts/src/std/option.rs" 513 16 515 28] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_T) ->  [ &t <- r0 ] s1)
      | s1 = clone' {t} (fun (_ret:t_T) ->  [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_0 <- C_Some'0 _5 ] s1 | s1 = bb6 ] 
    | bb6 = bb7
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & t: t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body ensures] [%#soption'1] match { _p0 = self_;
                                                                                                _p1 = result } with
        | {_p0 = C_None ; _p1 = C_None'0} -> true
        | {_p0 = C_Some s ; _p1 = C_Some'0 r} -> postcondition () s r
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body [#"../../creusot-contracts/src/std/option.rs" 529 16 531 27]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 524 16 524 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 529 35 529 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 525 26 528 17
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:MutBorrow.t t_T))= any
    [ good (field_0:MutBorrow.t t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'2 x]. inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body[#"../../creusot-contracts/src/std/option.rs" 529 16 531 27] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:MutBorrow.t t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:MutBorrow.t t_T) ->  [ &t <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 t} s2
      | s2 = -{resolve'0 t}- s3
      | s3 =  [ &_0 <- C_Some'0 (t.current) ] s4
      | s4 = bb5 ]
    
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: t_Option'0 = Any.any_l () | & self_'0: t_Option = self_ | & t: MutBorrow.t t_T = Any.any_l () ] 
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body result type invariant] [%#soption'0] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body ensures] [%#soption'1] match self_ with
        | C_None -> result = C_None'0
        | C_Some s -> result = C_Some'0 (s.current) /\ s.final = s.current
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body [#"../../creusot-contracts/src/std/option.rs" 543 16 545 28]
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/std/option.rs" 538 16 538 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 543 35 543 44
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 538 26 542 17
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  let rec v_Some (input:t_Option) (ret  (field_0:MutBorrow.t t_T))= any
    [ good (field_0:MutBorrow.t t_T)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_T [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant'0] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_T) =
    resolve _0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'1 self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body[#"../../creusot-contracts/src/std/option.rs" 543 16 545 28] (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_'0 = C_None} (! bb2) | br1 (x0:MutBorrow.t t_T)-> {self_'0 = C_Some x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some {self_'0} (fun (r0:MutBorrow.t t_T) ->  [ &t <- r0 ] s1)
      | s1 = clone' {t.current} (fun (_ret:t_T) ->  [ &_5 <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 =  [ &_0 <- C_Some'0 _5 ] s3
      | s3 = bb6 ]
    
    | bb6 = bb7
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb7 ] 
    | bb7 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _5: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body result type invariant] [%#soption'0] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body ensures] [%#soption'1] match { _p0 = self_;
                                                                                                   _p1 = result } with
        | {_p0 = C_None ; _p1 = C_None'0} -> true
        | {_p0 = C_Some s ; _p1 = C_Some'0 r} -> postcondition () s.current r /\ s.final = s.current
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_E_Option_Result_T_E_transpose_body [#"../../creusot-contracts/src/std/option.rs" 560 16 560 58]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 554 16 554 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 560 38 560 58
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 555 26 559 17
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result  =
    | C_Ok t_T
    | C_Err t_E
  
  type t_Option  =
    | C_None
    | C_Some t_Result
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Result))= any
    [ good (field_0:t_Result)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Result [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  let rec v_Err (input:t_Result) (ret  (field_0:t_E))= any
    [ good (field_0:t_E)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_E [C_Err field_0: t_Result]. C_Err field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_Result'0  =
    | C_Ok'0 t_Option'0
    | C_Err'0 t_E
  
  let rec v_Ok (input:t_Result) (ret  (field_0:t_T))= any
    [ good (field_0:t_T)-> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_T [C_Ok field_0: t_Result]. C_Ok field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_E)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result [inv'1 x]. inv'1 x
  = match x with
    | C_Ok a_0 -> inv a_0
    | C_Err a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option'0 [inv'3 x]. inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Result'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Result'0 [inv'4 x]. inv'4 x
  = match x with
    | C_Ok'0 a_0 -> inv'3 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_E_Option_Result_T_E_transpose_body[#"../../creusot-contracts/src/std/option.rs" 560 16 560 58] (self_:t_Option) (return'  (x:t_Result'0))= {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body 'self_' type invariant] [%#soption] inv'2 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_'0 = C_None} (! bb3) | br1 (x0:t_Result)-> {self_'0 = C_Some x0} (! bb4) ] 
    | bb4 = v_Some {self_'0}
        (fun (r0:t_Result) -> any [ br0 (x0:t_T)-> {r0 = C_Ok x0} (! bb5) | br1 (x0:t_E)-> {r0 = C_Err x0} (! bb6) ] )
    | bb6 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_Result) -> v_Err {r0} (fun (r0'0:t_E) ->  [ &err <- r0'0 ] s1))
      | s1 =  [ &_0 <- C_Err'0 err ] s2
      | s2 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb15
    | bb5 = bb7
    | bb7 = s0
      [ s0 = v_Some {self_'0} (fun (r0:t_Result) -> v_Ok {r0} (fun (r0'0:t_T) ->  [ &ok <- r0'0 ] s1))
      | s1 =  [ &_7 <- C_Some'0 ok ] s2
      | s2 = bb10 ]
    
    | bb10 = s0 [ s0 =  [ &_0 <- C_Ok'0 _7 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb15
    | bb3 = bb8
    | bb8 = s0 [ s0 =  [ &_5 <- C_None'0 ] s1 | s1 =  [ &_0 <- C_Ok'0 _5 ] s2 | s2 = bb9 ] 
    | bb9 = bb15
    | bb15 = bb16
    | bb16 = return''0 {_0} ]
    )
    [ & _0: t_Result'0 = Any.any_l ()
    | & self_'0: t_Option = self_
    | & _5: t_Option'0 = Any.any_l ()
    | & ok: t_T = Any.any_l ()
    | & _7: t_Option'0 = Any.any_l ()
    | & err: t_E = Any.any_l () ]
    
    [ return''0 (result:t_Result'0)-> {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body result type invariant] [%#soption'0] inv'4 result}
      {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body ensures] [%#soption'1] match self_ with
        | C_None -> result = C_Ok'0 (C_None'0)
        | C_Some (C_Ok ok) -> result = C_Ok'0 (C_Some'0 ok)
        | C_Some (C_Err err) -> result = C_Err'0 err
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_Option_T_flatten_body [#"../../creusot-contracts/src/std/option.rs" 573 16 573 45]
  let%span soption = "../../creusot-contracts/src/std/option.rs" 570 16 570 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 573 36 573 45
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 571 26 571 57
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 572 26 572 62
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Option
  
  let rec v_Some (input:t_Option'0) (ret  (field_0:t_Option))= any
    [ good (field_0:t_Option)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Option [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option'0 [inv'1 x]. inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_Option_T_flatten_body[#"../../creusot-contracts/src/std/option.rs" 573 16 573 45] (self_:t_Option'0) (return'  (x:t_Option))= {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body 'self_' type invariant] [%#soption] inv'1 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_'0 = C_None'0} (! bb4) | br1 (x0:t_Option)-> {self_'0 = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some {self_'0} (fun (r0:t_Option) ->  [ &opt <- r0 ] s1) | s1 =  [ &_0 <- opt ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- C_None ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = return''0 {_0} ]
    ) [ & _0: t_Option = Any.any_l () | & self_'0: t_Option'0 = self_ | & opt: t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body result type invariant] [%#soption'0] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #0] [%#soption'1] self_ = C_None'0
       -> result = C_None}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #1] [%#soption'2] self_ = C_None'0
      \/ self_ = C_Some'0 result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_Option) (o: t_Option) =
    [%#sord'1] cmp_log'0 self o <> C_Greater
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_cmp_le_log: [%#sord] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_Option) (o: t_Option) =
    [%#sord'1] cmp_log'0 self o = C_Less
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_cmp_lt_log: [%#sord] lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_Option) (o: t_Option) =
    [%#sord'1] cmp_log'0 self o <> C_Less
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_cmp_ge_log: [%#sord] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_Option) (o: t_Option) =
    [%#sord'1] cmp_log'0 self o = C_Greater
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_cmp_gt_log: [%#sord] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: t_Option) : ()
  
  goal vc_refl: [%#sord] cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  constant z  : t_Option
  
  constant o  : t_Ordering
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: t_Option) (y'0: t_Option) (z'0: t_Option) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log'0 x y = o)  -> ([%#sord'0] cmp_log'0 y z = o)  -> ([%#sord'1] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log'0 x y = C_Less)  -> ([%#sord'0] cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log'0 x y = C_Greater)  -> ([%#sord'0] cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  constant x  : t_Option
  
  constant y  : t_Option
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: t_Option) (y'0: t_Option) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl [#"../../creusot-contracts/src/std/option.rs" 648 4 648 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 647 14 647 45
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 648 27 648 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 641 12 642 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 625 4 625 30] (self: t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 639 4 639 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#soption'1] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 648 4 648 26] (self'0: t_IntoIter) : ()
  
  goal vc_produces_refl: [%#soption] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans [#"../../creusot-contracts/src/std/option.rs" 654 4 654 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 651 15 651 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 652 15 652 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 653 14 653 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 654 91 654 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 641 12 642 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 625 4 625 30] (self: t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 639 4 639 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#soption'3] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 654 4 654 90] (a'0: t_IntoIter) (ab'0: Seq.seq t_T) (b'0: t_IntoIter) (bc'0: Seq.seq t_T) (c'0: t_IntoIter) : ()
  
  
  goal vc_produces_trans: ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_refl [#"../../creusot-contracts/src/std/option.rs" 685 4 685 26] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 684 14 684 45
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 685 27 685 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 678 12 679 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 662 4 662 34] (self: t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 676 4 676 64] (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter)
  
   =
    [%#soption'1] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant self  : t_Iter
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 685 4 685 26] (self'0: t_Iter) : ()
  
  goal vc_produces_refl: [%#soption] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_trans [#"../../creusot-contracts/src/std/option.rs" 691 4 691 90] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 688 15 688 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 689 15 689 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 690 14 690 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 691 91 691 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 678 12 679 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 662 4 662 34] (self: t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 676 4 676 64] (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter)
  
   =
    [%#soption'3] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant a  : t_Iter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 691 4 691 90] (a'0: t_Iter) (ab'0: Seq.seq t_T) (b'0: t_Iter) (bc'0: Seq.seq t_T) (c'0: t_Iter) : ()
  
  
  goal vc_produces_trans: ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_refl [#"../../creusot-contracts/src/std/option.rs" 722 4 722 26] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 721 14 721 45
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 722 27 722 29
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 715 12 716 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 699 4 699 38] (self: t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 713 4 713 64] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut)
  
   =
    [%#soption'1] visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant self  : t_IterMut
  
  function produces_refl [#"../../creusot-contracts/src/std/option.rs" 722 4 722 26] (self'0: t_IterMut) : ()
  
  goal vc_produces_refl: [%#soption] produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_trans [#"../../creusot-contracts/src/std/option.rs" 728 4 728 90] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 725 15 725 32
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 726 15 726 32
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 727 14 727 42
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 728 91 728 93
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 715 12 716 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 699 4 699 38] (self: t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 713 4 713 64] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut)
  
   =
    [%#soption'3] visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  constant a  : t_IterMut
  
  constant ab  : Seq.seq (MutBorrow.t t_T)
  
  constant b  : t_IterMut
  
  constant bc  : Seq.seq (MutBorrow.t t_T)
  
  constant c  : t_IterMut
  
  function produces_trans [#"../../creusot-contracts/src/std/option.rs" 728 4 728 90] (a'0: t_IterMut) (ab'0: Seq.seq (MutBorrow.t t_T)) (b'0: t_IterMut) (bc'0: Seq.seq (MutBorrow.t t_T)) (c'0: t_IterMut) : ()
  
  
  goal vc_produces_trans: ([%#soption] produces a ab b)
   -> ([%#soption'0] produces b bc c)  -> ([%#soption'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self: Opaque.ptr) : UInt64.t
  
  constant self  : Opaque.ptr
  
  function is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self'0: Opaque.ptr) : bool
  
  goal vc_is_null_logic: [%#sptr] (addr_logic self = (0: UInt64.t)) = (addr_logic self = (0: UInt64.t))
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 74 14 74 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 76 8 76 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 68 4 68 32] (self: Opaque.ptr) : UInt64.t
  
  constant self  : Opaque.ptr
  
  function is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (self'0: Opaque.ptr) : bool
  
  goal vc_is_null_logic: [%#sptr] (addr_logic self = (0: UInt64.t)) = (addr_logic self = (0: UInt64.t))
end
module M_creusot_contracts__stdqy35z1__ptr__extern_spec_T_Cloneqy95z_ptrmut_T_clone_body [#"../../creusot-contracts/src/std/ptr.rs" 118 8 118 33]
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 117 18 117 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_T_Cloneqy95z_ptrmut_T_clone_body[#"../../creusot-contracts/src/std/ptr.rs" 118 8 118 33] (self_:Opaque.ptr) (return'  (x:Opaque.ptr))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Opaque.ptr = Any.any_l () | & self_'0: Opaque.ptr = self_ ] 
    [ return''0 (result:Opaque.ptr)-> {[@expl:extern_spec_T_Clone__ptrmut_T_clone_body ensures] [%#sptr] result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__ptr__extern_spec_T_Cloneqy95z_ptrconst_T_clone_body [#"../../creusot-contracts/src/std/ptr.rs" 125 8 125 35]
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 124 18 124 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_T_Cloneqy95z_ptrconst_T_clone_body[#"../../creusot-contracts/src/std/ptr.rs" 125 8 125 35] (self_:Opaque.ptr) (return'  (x:Opaque.ptr))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self_'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: Opaque.ptr = Any.any_l () | & self_'0: Opaque.ptr = self_ ] 
    [ return''0 (result:Opaque.ptr)-> {[@expl:extern_spec_T_Clone__ptrconst_T_clone_body ensures] [%#sptr] result
      = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 425 14 425 45
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 426 27 426 29
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 83 14 83 76
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'4] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'5] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 84 4 84 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. ([%#sslice'2] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'3] forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 403 4 403 33] (self: t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 417 4 417 65] (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter)
  
   =
    [%#sslice'1] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  constant self  : t_Iter
  
  function produces_refl [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 26] (self'0: t_Iter) : ()
  
  goal vc_produces_refl: [%#sslice] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 430 15 430 32
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 431 15 431 32
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 432 14 432 42
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 433 91 433 93
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 83 14 83 76
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'7 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'6] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'7] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 84 4 84 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. ([%#sslice'4] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'5] forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 403 4 403 33] (self: t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 417 4 417 65] (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter)
  
   =
    [%#sslice'3] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  constant a  : t_Iter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_Iter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_Iter
  
  function produces_trans [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 90] (a'0: t_Iter) (ab'0: Seq.seq t_T) (b'0: t_Iter) (bc'0: Seq.seq t_T) (c'0: t_Iter) : ()
  
  
  goal vc_produces_trans: ([%#sslice] produces a ab b)
   -> ([%#sslice'0] produces b bc c)  -> ([%#sslice'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 479 4 479 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 478 14 478 45
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 479 27 479 29
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 472 12 472 66
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 73 14 73 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 74 14 74 80
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'5] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'6] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 76 4 76 43] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). ([%#sslice'2] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'3] forall i: int. 0 <= i /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0: forall self: t_IterMut. [%#sslice'4] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 470 4 470 65] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut)
  
   =
    [%#sslice'1] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  constant self  : t_IterMut
  
  function produces_refl [#"../../creusot-contracts/src/std/slice.rs" 479 4 479 26] (self'0: t_IterMut) : ()
  
  goal vc_produces_refl: [%#sslice] produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 486 4 486 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 483 15 483 32
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 484 15 484 32
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 485 14 485 42
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 486 91 486 93
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 472 12 472 66
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 73 14 73 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 74 14 74 80
  let%span sslice'6 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span sslice'7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'8 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'7] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'8] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 76 4 76 43] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). ([%#sslice'4] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'5] forall i: int. 0 <= i /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0: forall self: t_IterMut. [%#sslice'6] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 470 4 470 65] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut)
  
   =
    [%#sslice'3] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  constant a  : t_IterMut
  
  constant ab  : Seq.seq (MutBorrow.t t_T)
  
  constant b  : t_IterMut
  
  constant bc  : Seq.seq (MutBorrow.t t_T)
  
  constant c  : t_IterMut
  
  function produces_trans [#"../../creusot-contracts/src/std/slice.rs" 486 4 486 90] (a'0: t_IterMut) (ab'0: Seq.seq (MutBorrow.t t_T)) (b'0: t_IterMut) (bc'0: Seq.seq (MutBorrow.t t_T)) (c'0: t_IterMut) : ()
  
  
  goal vc_produces_trans: ([%#sslice] produces a ab b)
   -> ([%#sslice'0] produces b bc c)  -> ([%#sslice'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 255 14 255 45
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 256 27 256 29
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 249 12 249 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 247 4 247 57] (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter)
  
   =
    [%#svec'1] view self = Seq.(++) visited (view rhs)
  
  constant self  : t_IntoIter
  
  function produces_refl [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 26] (self'0: t_IntoIter) : ()
  
  goal vc_produces_refl: [%#svec] produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans [#"../../creusot-contracts/src/std/vec.rs" 263 4 263 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 260 15 260 32
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 261 15 261 32
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 262 14 262 42
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 263 73 263 75
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 249 12 249 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 247 4 247 57] (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter)
  
   =
    [%#svec'3] view self = Seq.(++) visited (view rhs)
  
  constant a  : t_IntoIter
  
  constant ab  : Seq.seq t_T
  
  constant b  : t_IntoIter
  
  constant bc  : Seq.seq t_T
  
  constant c  : t_IntoIter
  
  function produces_trans [#"../../creusot-contracts/src/std/vec.rs" 263 4 263 72] (a'0: t_IntoIter) (ab'0: Seq.seq t_T) (b'0: t_IntoIter) (bc'0: Seq.seq t_T) (c'0: t_IntoIter) : ()
  
  
  goal vc_produces_trans: ([%#svec] produces a ab b)
   -> ([%#svec'0] produces b bc c)  -> ([%#svec'1] produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_cmp_le_log: [%#sord] Real.(<=) x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_cmp_lt_log: [%#sord] Real.(<) x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_cmp_ge_log: [%#sord] Real.(>=) x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_cmp_gt_log: [%#sord] Real.(>) x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Real.real) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  constant z  : Real.real
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Real.real) (y'0: Real.real) (z'0: Real.real) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Real.real) (y'0: Real.real) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__fn_pure__qyi11638360339920708941__clone [#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (* <fn_pure::FnPureWrapper<F> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 30 14 30 18
  let%span sfn_pure'0 = "../../creusot-contracts/src/fn_pure.rs" 30 23 30 27
  let%span sfn_pure'1 = "../../creusot-contracts/src/fn_pure.rs" 29 14 29 58
  
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_F) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_F [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_F)
  
  axiom precondition_fndef: forall args: t_F [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_F) (result: t_F)
  
  
  axiom postcondition_fndef: forall args: t_F, res: t_F [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_F) (return'  (x:t_F))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_F)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FnPureWrapper) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FnPureWrapper [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  
  axiom postcondition_fndef'0: forall args: t_F, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_F, res: t_F. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_F, res_state: (), res: t_F. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1: forall args: t_F, res: t_F [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_spec: forall self: (), args: t_F, res: t_F. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_F, res_state: (), res: t_F. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec clone''0[#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (self:t_FnPureWrapper) (return'  (x:t_FnPureWrapper))= {[@expl:clone 'self' type invariant] [%#sfn_pure] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone' {self'0.t_FnPureWrapper__0} (fun (_ret:t_F) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_FnPureWrapper__0 = _3 } ] s1 | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0: t_FnPureWrapper = Any.any_l () | & self'0: t_FnPureWrapper = self | & _3: t_F = Any.any_l () ] 
    [ return''0 (result:t_FnPureWrapper)-> {[@expl:clone result type invariant] [%#sfn_pure'0] inv'1 result}
      {[@expl:clone ensures] [%#sfn_pure'1] postcondition () self.t_FnPureWrapper__0 result.t_FnPureWrapper__0}
      (! return' {result}) ]

end
module M_creusot_contracts__fn_pure__qyi4173004571708517458__qy95z_new [#"../../creusot-contracts/src/fn_pure.rs" 75 4 75 30] (* fn_pure::FnPureWrapper<F> *)
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 75 17 75 18
  let%span sfn_pure'0 = "../../creusot-contracts/src/fn_pure.rs" 75 26 75 30
  let%span sfn_pure'1 = "../../creusot-contracts/src/fn_pure.rs" 74 14 74 26
  let%span sfn_pure'2 = "../../creusot-contracts/src/fn_pure.rs" 83 8 83 14
  
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'0 x]. inv'0 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  function view [#"../../creusot-contracts/src/fn_pure.rs" 82 4 82 33] (self: t_FnPureWrapper) : t_F =
    [%#sfn_pure'2] self.t_FnPureWrapper__0
  
  meta "compute_max_steps" 1000000
  
  let rec qy95z_new[#"../../creusot-contracts/src/fn_pure.rs" 75 4 75 30] (f:t_F) (return'  (x:t_FnPureWrapper))= {[@expl:__new 'f' type invariant] [%#sfn_pure] inv f}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_0 <- { t_FnPureWrapper__0 = f'0 } ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = return''0 {_0} ]
    ) [ & _0: t_FnPureWrapper = Any.any_l () | & f'0: t_F = f ] 
    [ return''0 (result:t_FnPureWrapper)-> {[@expl:__new result type invariant] [%#sfn_pure'0] inv'0 result}
      {[@expl:__new ensures] [%#sfn_pure'1] view result = f}
      (! return' {result}) ]

end
module M_creusot_contracts__invariant__qyi11000281680484769800__clone [#"../../creusot-contracts/src/invariant.rs" 286 4 286 27] (* <invariant::Subset<T> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 287 8 287 36
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 285 14 285 58
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 206 15 206 30
  let%span sinvariant'2 = "../../creusot-contracts/src/invariant.rs" 207 14 207 27
  let%span sinvariant'3 = "../../creusot-contracts/src/invariant.rs" 269 23 269 36
  let%span sinvariant'4 = "../../creusot-contracts/src/invariant.rs" 268 14 268 30
  let%span sinvariant'5 = "../../creusot-contracts/src/invariant.rs" 230 15 230 16
  let%span sinvariant'6 = "../../creusot-contracts/src/invariant.rs" 229 14 229 42
  let%span sinvariant'7 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span sinvariant'8 = "../../creusot-contracts/src/invariant.rs" 184 15 184 28
  let%span sinvariant'9 = "../../creusot-contracts/src/invariant.rs" 185 14 185 26
  let%span sinvariant'10 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.prelude.Any
  
  type t_Subset
  
  type t_T
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 72 4 72 31] (self: t_T)
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'7] invariant' (view self)
  
  function view_inj [#"../../creusot-contracts/src/invariant.rs" 208 4 208 38] (self: t_Subset) (other: t_Subset) : ()
  
  axiom view_inj_spec: forall self: t_Subset, other: t_Subset. ([%#sinvariant'1] view self = view other)
   -> ([%#sinvariant'2] self = other)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom: forall x: t_T [inv x]. inv x  -> invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant'10] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Subset) : t_T =
    [%#smodel] view self
  
  let rec deref (self:t_Subset) (return'  (x:t_T))= any
    [ return''0 (result:t_T)-> {[%#sinvariant'3] inv'0 result}
      {[%#sinvariant'4] result = view'0 self}
      (! return' {result}) ]
  
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  function new_logic [#"../../creusot-contracts/src/invariant.rs" 186 4 186 34] (x: t_T) : t_Subset
  
  axiom new_logic_spec: forall x: t_T. ([%#sinvariant'8] invariant' x)  -> ([%#sinvariant'9] view (new_logic x) = x)
  
  let rec new (x:t_T) (return'  (x'0:t_Subset))= {[@expl:new 'x' type invariant] [%#sinvariant'5] inv x}
    any [ return''0 (result:t_Subset)-> {[%#sinvariant'6] result = new_logic x} (! return' {result}) ] 
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec clone''0[#"../../creusot-contracts/src/invariant.rs" 286 4 286 27] (self:t_Subset) (return'  (x:t_Subset))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- [%#sinvariant] () ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = deref {self'0} (fun (_ret:t_T) ->  [ &_7 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = clone' {_7} (fun (_ret:t_T) ->  [ &_5 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = new {_5} (fun (_ret:t_Subset) ->  [ &_0 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = return''0 {_0} ]
    )
    [ & _0: t_Subset = Any.any_l ()
    | & self'0: t_Subset = self
    | & _3: () = Any.any_l ()
    | & _5: t_T = Any.any_l ()
    | & _7: t_T = Any.any_l () ]
    
    [ return''0 (result:t_Subset)-> {[@expl:clone ensures] [%#sinvariant'0] postcondition () (view'0 self) (view result)}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__subtract [#"../../creusot-contracts/src/logic/fmap.rs" 204 4 204 46] (* logic::fmap::FMap<K, V> *)
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 196 15 196 33
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 197 14 197 36
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 198 14 198 46
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 199 14 203 5
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 181 14 185 5
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 205 8 205 33
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 155 12 155 89
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 147 19 147 71
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 164 15 164 35
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 165 14 171 5
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 172 14 172 54
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  
  use map.Map
  use mach.int.Int
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'15] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'13] Map.get (view self) k
  
  function contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self: t_FMap) (k: t_K) : bool
  
   =
    [%#sfmap'14] get_unsized self k <> C_None
  
  function subset [#"../../creusot-contracts/src/logic/fmap.rs" 153 4 153 44] (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'5] forall k: t_K. contains self k  -> get_unsized other k = get_unsized self k
  
  function disjoint [#"../../creusot-contracts/src/logic/fmap.rs" 146 4 146 46] (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'6] forall k: t_K. not contains self k \/ not contains other k
  
  function ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'9] view self = view other
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'7] ext_eq self other  -> self = other)
  && ([%#sfmap'8] (forall k: t_K. get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'16] len self >= 0
  
  function union [#"../../creusot-contracts/src/logic/fmap.rs" 173 4 173 43] (self: t_FMap) (other: t_FMap) : t_FMap
  
  axiom union_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'10] disjoint self other)
   -> ([%#sfmap'11] forall k: t_K. get_unsized (union self other) k
  = (if contains self k then get_unsized self k else if contains other k then get_unsized other k else C_None))
  && ([%#sfmap'12] len (union self other) = len self + len other)
  
  function subtract_keys [#"../../creusot-contracts/src/logic/fmap.rs" 186 4 186 51] (self: t_FMap) (other: t_FMap) : t_FMap
  
  
  axiom subtract_keys_spec: forall self: t_FMap, other: t_FMap. [%#sfmap'3] forall k: t_K. get_unsized (subtract_keys self other) k
  = (if contains other k then C_None else get_unsized self k)
  
  constant self  : t_FMap
  
  constant other  : t_FMap
  
  function subtract [#"../../creusot-contracts/src/logic/fmap.rs" 204 4 204 46] (self'0: t_FMap) (other'0: t_FMap) : t_FMap
  
  
  goal vc_subtract: ([%#sfmap] subset other self)
   -> ([%#sfmap'3] forall k: t_K. get_unsized (subtract_keys self other) k
  = (if contains other k then C_None else get_unsized self k))
   -> (let result = subtract_keys self other in ([%#sfmap'0] disjoint result other)
  && ([%#sfmap'1] ext_eq (union other result) self)
  && ([%#sfmap'2] forall k: t_K. get_unsized result k = (if contains other k then C_None else get_unsized self k)))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (* logic::fmap::FMap<K, V> *)
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'1] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  constant self  : t_FMap
  
  constant other  : t_FMap
  
  function ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self'0: t_FMap) (other'0: t_FMap) : bool
  
  goal vc_ext_eq: ([%#sfmap'1] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2)
   -> ([%#sfmap'1] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2)
   -> (let result = view self = view other in ([%#sfmap] result  -> self = other)
  && ([%#sfmap'0] (forall k: t_K. get_unsized self k = get_unsized other k)  -> result))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__contains_ghost [#"../../creusot-contracts/src/logic/fmap.rs" 356 4 356 49] (* logic::fmap::FMap<K, V> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 356 27 356 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 356 33 356 36
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 355 14 355 43
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 385 22 385 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 385 28 385 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 385 40 385 50
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 377 14 384 9
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 580 20 580 91
  let%span soption = "../../creusot-contracts/src/std/option.rs" 55 16 55 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 56 26 56 51
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  
  use map.Map
  use creusot.prelude.Any
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_FMap
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'9] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'8] Map.get (view self) k
  
  function contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self: t_FMap) (k: t_K) : bool
  
   =
    [%#sfmap'6] get_unsized self k <> C_None'0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_K)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_V)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_V) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_V [inv'1 x]. inv'1 x = invariant' x
  
  function unwrap [#"../../creusot-contracts/src/util.rs" 56 0 56 36] (op: t_Option'0) : t_V
  
  axiom unwrap_spec: forall op: t_Option'0. ([%#sutil] op <> C_None'0)  -> ([%#sutil'0] C_Some'0 (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 124 4 124 50] (self: t_FMap) (k: t_K) : t_V
  
   =
    [%#sfmap'7] unwrap (get_unsized self k)
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/fmap.rs" 579 4 579 30] (self: t_FMap) =
    [%#sfmap'10] forall k: t_K. contains self k  -> inv k /\ inv'1 (lookup_unsized self k)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMap)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FMap) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMap)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMap [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_K) =
    [%#sinvariant] inv self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_K)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_K [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_V) =
    [%#sinvariant] inv'0 self
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_V)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_V [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option [inv'6 x]. inv'6 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'5 a_0
    end
  
  let rec get_ghost (self:t_FMap) (key:t_K) (return'  (x:t_Option))= {[@expl:get_ghost 'self' type invariant] [%#sfmap'2] inv'3 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap'3] inv'4 key}
    any
    [ return''0 (result:t_Option)-> {[%#sfmap'4] inv'6 result}
      {[%#sfmap'5] if contains self key then
        match result with
          | C_None -> false
          | C_Some r -> lookup_unsized self key = r
          end
      else
        result = C_None
      }
      (! return' {result}) ]
  
  
  predicate invariant''4 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'6 self
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option [inv'7 x]. inv'7 x = invariant''4 x
  
  let rec is_some (self_:t_Option) (return'  (x:bool))= {[@expl:is_some 'self_' type invariant] [%#soption] inv'7 self_}
    any [ return''0 (result:bool)-> {[%#soption'0] result = (self_ <> C_None)} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec contains_ghost[#"../../creusot-contracts/src/logic/fmap.rs" 356 4 356 49] (self:t_FMap) (key:t_K) (return'  (x:bool))= {[@expl:contains_ghost 'self' type invariant] [%#sfmap] inv'3 self}
    {[@expl:contains_ghost 'key' type invariant] [%#sfmap'0] inv'4 key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost {self'0} {key'0} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = is_some {_5} (fun (_ret:bool) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0: bool = Any.any_l () | & self'0: t_FMap = self | & key'0: t_K = key | & _5: t_Option = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:contains_ghost ensures] [%#sfmap'1] result = contains self key}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__ext_eq [#"../../creusot-contracts/src/logic/fset.rs" 198 4 200 17] (* logic::fset::FSet<T> *)
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 197 14 197 38
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 203 12 203 63
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  constant self  : Fset.fset t_T
  
  constant other  : Fset.fset t_T
  
  predicate ext_eq [#"../../creusot-contracts/src/logic/fset.rs" 198 4 200 17] (self'0: Fset.fset t_T) (other'0: Fset.fset t_T)
  
  
  goal vc_ext_eq: [%#sfset] ([%#sfset'0] forall e: t_T. contains self e = contains other e)  -> self = other
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (* logic::fset::FSet<T> *)
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T
  
   =
    [%#sfset'2] Fset.add e self
  
  constant x  : t_T
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x'0: t_T) : Fset.fset t_T
  
  goal vc_singleton: [%#sfset] forall y: t_T. contains (insert (Fset.empty: Fset.fset t_T) x) y = (x = y)
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__unions [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (* logic::fset::FSet<T> *)
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 220 14 220 102
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 221 14 221 24
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 223 8 228 9
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  use set.Fset
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_U) (e: t_U)
  
   =
    [%#sfset'2] Fset.mem e self
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'2] Fset.mem e self
  
  function remove [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 92 4 92 37] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T
  
   =
    [%#sfset'3] Fset.remove e self
  
  constant self  : Fset.fset t_T
  
  constant f  : Map.map t_T (Fset.fset t_U)
  
  function unions [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (self'0: Fset.fset t_T) (f'0: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  
  goal vc_unions: if Fset.cardinal self = 0 then
    [%#sfset] forall y: t_U. contains (Fset.empty: Fset.fset t_U) y
    = (exists x: t_T. contains'0 self x /\ contains (Map.get f x) y)
  else
    let x = Fset.pick self in (0 <= ([%#sfset'0] Fset.cardinal self)
    /\ ([%#sfset'0] Fset.cardinal (remove self x)) < ([%#sfset'0] Fset.cardinal self))
    /\ (([%#sfset] forall y: t_U. contains (unions (remove self x) f) y
    = (exists x'0: t_T. contains'0 (remove self x) x'0 /\ contains (Map.get f x'0) y))
     -> ([%#sfset] forall y: t_U. contains (Fset.union (Map.get f x) (unions (remove self x) f)) y
    = (exists x'0: t_T. contains'0 self x'0 /\ contains (Map.get f x'0) y)))

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (* logic::fset::FSet<T> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 282 32 282 85
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 285 32 285 103
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'9] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'8] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'3] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'5] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  constant self  : Fset.fset t_T
  
  constant n  : int
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self'0: Fset.fset t_T) (n'0: int) : Fset.fset (Seq.seq t_T)
  
  
  goal vc_replicate: ([%#sfset] n >= 0)
   -> (if n = 0 then
    ([%#sfset'2] forall xs: Seq.seq t_T. Seq.length xs = 0  -> xs = (Seq.empty: Seq.seq t_T))
    && (let _ = () in let _ = () in ([%#sfset'3] forall y: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) y
    = ((Seq.empty: Seq.seq t_T) = y))
     -> ([%#sfset'0] forall xs: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) xs
    = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x))))
  else
    ([%#sfset'4] forall xs: Seq.seq t_T, i: int. 0 < i /\ i < Seq.length xs
     -> Seq.get xs i = Seq.get (tail xs) (i - 1))
    && (let _ = () in let _ = () in (([@expl:replicate requires] [%#sfset] n - 1 >= 0)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] forall xs: Seq.seq t_T. contains (replicate self (n - 1)) xs
    = (Seq.length xs = n - 1 /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
     -> ([%#sfset'5] forall xs: Seq.seq t_T. contains (cons self (replicate self (n - 1))) xs
    = (0 < Seq.length xs /\ contains'1 self (Seq.get xs 0) /\ contains (replicate self (n - 1)) (tail xs)))
     -> ([%#sfset'0] forall xs: Seq.seq t_T. contains (cons self (replicate self (n - 1))) xs
    = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))))
  )
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (* logic::fset::FSet<T> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 294 15 294 21
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 295 14 295 123
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 296 14 296 15
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 300 32 300 85
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 299 12 304 13
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'8] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'8] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'11] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'9] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'3] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'12] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. ([%#sfset'4] n >= 0)
   -> replicate self n
  = ([%#sfset'10] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty: Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. ([%#sfset'4] n >= 0)
   -> ([%#sfset'5] forall xs: Seq.seq t_T. contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
  
  constant self  : Fset.fset t_T
  
  constant n  : int
  
  function replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (self'0: Fset.fset t_T) (n'0: int) : Fset.fset (Seq.seq t_T)
  
  
  goal vc_replicate_up_to: ([%#sfset] n >= 0)
   -> (if n = 0 then
    ([%#sfset'2] forall xs: Seq.seq t_T. Seq.length xs = 0  -> xs = (Seq.empty: Seq.seq t_T))
    && (let _ = () in let _ = () in ([%#sfset'3] forall y: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) y
    = ((Seq.empty: Seq.seq t_T) = y))
     -> ([%#sfset'0] forall xs: Seq.seq t_T. contains (singleton (Seq.empty: Seq.seq t_T)) xs
    = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x))))
  else
    (([@expl:replicate_up_to requires] [%#sfset] n - 1 >= 0)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] forall xs: Seq.seq t_T. contains (replicate_up_to self (n - 1)) xs
    = (Seq.length xs <= n - 1 /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
     -> ([@expl:replicate requires] [%#sfset'4] n >= 0)
    /\ (([%#sfset'5] forall xs: Seq.seq t_T. contains (replicate self n) xs
    = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
     -> ([%#sfset'0] forall xs: Seq.seq t_T. contains (Fset.union (replicate_up_to self (n - 1)) (replicate self n)) xs
    = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))))
  )
end
module M_creusot_contracts__logic__fset__unions_union [#"../../creusot-contracts/src/logic/fset.rs" 501 0 501 27]
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 498 10 498 125
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 499 10 500 76
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 501 28 501 30
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 220 14 220 102
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 221 14 221 24
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 223 8 228 9
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_U) (e: t_U)
  
   =
    [%#sfset'5] Fset.mem e self
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'5] Fset.mem e self
  
  function remove [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 92 4 92 37] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T
  
   =
    [%#sfset'6] Fset.remove e self
  
  function unions [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  
  axiom unions_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions self f
  = ([%#sfset'4] if Fset.cardinal self = 0 then
    Fset.empty: Fset.fset t_U
  else
    let x = Fset.pick self in Fset.union (Map.get f x) (unions (remove self x) f)
  )
  
  axiom unions_spec: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). [%#sfset'2] forall y: t_U. contains (unions self f) y
  = (exists x: t_T. contains'0 self x /\ contains (Map.get f x) y)
  
  function unions_union [#"../../creusot-contracts/src/logic/fset.rs" 501 0 501 27]  : ()
  
  goal vc_unions_union: ([%#sfset] forall s1: Fset.fset t_T, s2: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions (Fset.union s1 s2) f
  = Fset.union (unions s1 f) (unions s2 f))
  && ([%#sfset'0] forall s: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U), g: Map.map t_T (Fset.fset t_U). unions s (fun (x: t_T) -> Fset.union (Map.get f x) (Map.get g x))
  = Fset.union (unions s f) (unions s g))
end
module M_creusot_contracts__logic__fset__map_union [#"../../creusot-contracts/src/logic/fset.rs" 507 0 507 24]
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 506 10 506 104
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 507 25 507 27
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 243 8 243 27
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  function map [#"../../creusot-contracts/src/logic/fset.rs" 242 4 242 52] (self: Fset.fset t_T) (f: Map.map t_T t_U) : Fset.fset t_U
  
   =
    [%#sfset'1] Fset.map f self
  
  function map_union [#"../../creusot-contracts/src/logic/fset.rs" 507 0 507 24]  : ()
  
  goal vc_map_union: [%#sfset] forall s: Fset.fset t_T, t: Fset.fset t_T, f: Map.map t_T t_U. map (Fset.union s t) f
  = Fset.union (map s f) (map t f)
end
module M_creusot_contracts__logic__fset__concat_union [#"../../creusot-contracts/src/logic/fset.rs" 516 0 516 24]
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 512 10 513 83
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 514 10 515 83
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 516 25 516 27
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'3] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'2] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_union [#"../../creusot-contracts/src/logic/fset.rs" 516 0 516 24]  : ()
  
  goal vc_concat_union: ([%#sfset] forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
  = Fset.union (concat s1 t) (concat s2 t))
  && ([%#sfset'0] forall s: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s (Fset.union t1 t2)
  = Fset.union (concat s t1) (concat s t2))
end
module M_creusot_contracts__logic__fset__cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 522 0 522 23]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 247 8 247 27
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 521 10 521 133
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 523 20 523 115
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 524 20 524 74
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 525 20 525 89
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 523 4 523 117
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'6] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'4] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'6] Fset.mem e self
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'5] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'0 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function push_front [@inline:trivial] [#"../../creusot-contracts/src/logic/seq.rs" 246 4 246 41] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T
  
   =
    [%#sseq] Seq.cons x self
  
  function cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 522 0 522 23]  : ()
  
  goal vc_cons_concat: ([%#sfset'0] forall x: t_T, xs: Seq.seq t_T, ys: Seq.seq t_T. Seq.(++) (push_front xs x) ys
  = push_front (Seq.(++) xs ys) x)
  && (let _ = () in let _ = () in ([%#sfset'1] forall x: t_T, ys: Seq.seq t_T. tail (push_front ys x) = ys)
  && (let _ = () in let _ = () in ([%#sfset'2] forall ys: Seq.seq t_T. 0 < Seq.length ys
   -> ys = push_front (tail ys) (Seq.get ys 0))
  && (let _ = () in let _ = () in [%#sfset] forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
  = cons s (concat t u))))
end
module M_creusot_contracts__logic__fset__concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 534 0 534 54]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 531 11 531 27
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 532 10 532 76
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 533 10 533 11
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 548 10 548 59
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 549 10 549 59
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 521 10 521 133
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 536 8 541 9
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 551 4 551 68
  let%span sfset'13 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'14 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'15 = "../../creusot-contracts/src/logic/fset.rs" 523 4 523 117
  let%span sfset'16 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset'17 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'11] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'11] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'17] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'14] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'13] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'16] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. ([%#sfset'2] n >= 0)
   -> replicate self n
  = ([%#sfset'9] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty: Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. ([%#sfset'2] n >= 0)
   -> ([%#sfset'3] forall xs: Seq.seq t_T. contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'10] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 550 0 550 39] (s: Fset.fset (Seq.seq t_T)) : () =
    [%#sfset'12] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty_spec: forall s: Fset.fset (Seq.seq t_T). ([%#sfset'5] concat (singleton (Seq.empty: Seq.seq t_T)) s
  = s)
  && ([%#sfset'6] concat s (singleton (Seq.empty: Seq.seq t_T)) = s)
  
  constant cons_concat: () = [%#sfset'15] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat_spec: [%#sfset'7] forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
  = cons s (concat t u)
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T
  
  function concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 534 0 534 54] (n'0: int) (m'0: int) (s'0: Fset.fset t_T) : ()
  
  
  goal vc_concat_replicate: ([%#sfset] 0 <= n /\ 0 <= m)
   -> (if n = 0 then
    ([@expl:replicate requires] [%#sfset'2] m >= 0)
    /\ (([%#sfset'3] forall xs: Seq.seq t_T. contains (replicate s m) xs
    = (Seq.length xs = m /\ (forall x: t_T. contains'0 xs x  -> contains'1 s x)))
     -> ([%#sfset'5] concat (singleton (Seq.empty: Seq.seq t_T)) (replicate s m) = replicate s m)
    && ([%#sfset'6] concat (replicate s m) (singleton (Seq.empty: Seq.seq t_T)) = replicate s m)
     -> (let _ = concat_empty (replicate s m) in [%#sfset'0] replicate s (n + m)
    = concat (replicate s n) (replicate s m)))
  else
    ([%#sfset'7] forall s'0: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s'0 t) u
    = cons s'0 (concat t u))
     -> (let _ = cons_concat in (([@expl:concat_replicate requires] [%#sfset] 0 <= n - 1 /\ 0 <= m)
    /\ 0 <= ([%#sfset'1] n) /\ ([%#sfset'1] n - 1) < ([%#sfset'1] n))
    /\ (([%#sfset'0] replicate s (n - 1 + m) = concat (replicate s (n - 1)) (replicate s m))
     -> (let _ = concat_replicate (n - 1) m s in [%#sfset'0] replicate s (n + m)
    = concat (replicate s n) (replicate s m))))
  )
end
module M_creusot_contracts__logic__fset__concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 550 0 550 39]
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 548 10 548 59
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 549 10 549 59
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 551 20 551 66
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 552 20 552 66
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 551 4 551 68
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use seq.Seq
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'7] Fset.mem e self
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'4] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'8] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'6] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'5] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  constant s  : Fset.fset (Seq.seq t_T)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 550 0 550 39] (s'0: Fset.fset (Seq.seq t_T)) : ()
  
  goal vc_concat_empty: ([%#sfset'1] forall xs: Seq.seq t_T. Seq.(++) xs (Seq.empty: Seq.seq t_T) = xs)
  && (let _ = () in let _ = () in ([%#sfset'2] forall xs: Seq.seq t_T. Seq.(++) (Seq.empty: Seq.seq t_T) xs = xs)
  && (let _ = () in let _ = () in ([%#sfset] concat (singleton (Seq.empty: Seq.seq t_T)) s = s)
  && ([%#sfset'0] concat s (singleton (Seq.empty: Seq.seq t_T)) = s)))
end
module M_creusot_contracts__logic__fset__concat_replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 562 0 562 60]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 558 11 558 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 559 10 560 67
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 561 10 561 11
  let%span sfset'2 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset'3 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset'4 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset'5 = "../../creusot-contracts/src/logic/fset.rs" 548 10 548 59
  let%span sfset'6 = "../../creusot-contracts/src/logic/fset.rs" 549 10 549 59
  let%span sfset'7 = "../../creusot-contracts/src/logic/fset.rs" 512 10 513 83
  let%span sfset'8 = "../../creusot-contracts/src/logic/fset.rs" 514 10 515 83
  let%span sfset'9 = "../../creusot-contracts/src/logic/fset.rs" 531 11 531 27
  let%span sfset'10 = "../../creusot-contracts/src/logic/fset.rs" 532 10 532 76
  let%span sfset'11 = "../../creusot-contracts/src/logic/fset.rs" 533 10 533 11
  let%span sfset'12 = "../../creusot-contracts/src/logic/fset.rs" 564 8 570 9
  let%span sfset'13 = "../../creusot-contracts/src/logic/fset.rs" 294 15 294 21
  let%span sfset'14 = "../../creusot-contracts/src/logic/fset.rs" 295 14 295 123
  let%span sfset'15 = "../../creusot-contracts/src/logic/fset.rs" 296 14 296 15
  let%span sfset'16 = "../../creusot-contracts/src/logic/fset.rs" 299 12 304 13
  let%span sfset'17 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset'18 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset'19 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'20 = "../../creusot-contracts/src/logic/fset.rs" 551 4 551 68
  let%span sfset'21 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset'22 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset'23 = "../../creusot-contracts/src/logic/fset.rs" 516 25 516 27
  let%span sfset'24 = "../../creusot-contracts/src/logic/fset.rs" 536 8 541 9
  let%span sfset'25 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset'26 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset'27 = "../../creusot-contracts/src/logic/fset.rs" 521 10 521 133
  let%span sfset'28 = "../../creusot-contracts/src/logic/fset.rs" 523 4 523 117
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T)
  
   =
    [%#sfset'19] Fset.mem e self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'19] Fset.mem e self
  
  function insert [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'26] Fset.add e self
  
  function singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T)
  
   =
    [%#sfset'22] insert (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_spec: forall x: Seq.seq t_T. [%#sfset'21] forall y: Seq.seq t_T. contains (singleton x) y = (x = y)
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'0] Seq.([..]) self 1 (Seq.length self)
  
  function cons [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom cons_spec: forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). [%#sfset'25] forall xs: Seq.seq t_T. contains (cons s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains ss (tail xs))
  
  function replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_def: forall self: Fset.fset t_T, n: int. ([%#sfset'2] n >= 0)
   -> replicate self n
  = ([%#sfset'18] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty: Seq.seq t_T)
  else
    let _ = let _ = () in () in cons self (replicate self (n - 1))
  )
  
  axiom replicate_spec: forall self: Fset.fset t_T, n: int. ([%#sfset'2] n >= 0)
   -> ([%#sfset'3] forall xs: Seq.seq t_T. contains (replicate self n) xs
  = (Seq.length xs = n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
  
  function replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  
  axiom replicate_up_to_def: forall self: Fset.fset t_T, n: int. ([%#sfset'13] n >= 0)
   -> replicate_up_to self n
  = ([%#sfset'16] if n = 0 then
    let _ = let _ = () in () in singleton (Seq.empty: Seq.seq t_T)
  else
    Fset.union (replicate_up_to self (n - 1)) (replicate self n)
  )
  
  axiom replicate_up_to_spec: forall self: Fset.fset t_T, n: int. ([%#sfset'13] n >= 0)
   -> ([%#sfset'14] forall xs: Seq.seq t_T. contains (replicate_up_to self n) xs
  = (Seq.length xs <= n /\ (forall x: t_T. contains'0 xs x  -> contains'1 self x)))
  
  function concat [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  
  axiom concat_spec: forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). [%#sfset'17] forall xs: Seq.seq t_T. contains (concat s t) xs
  = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains s ys /\ contains t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 550 0 550 39] (s: Fset.fset (Seq.seq t_T)) : () =
    [%#sfset'20] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty_spec: forall s: Fset.fset (Seq.seq t_T). ([%#sfset'5] concat (singleton (Seq.empty: Seq.seq t_T)) s
  = s)
  && ([%#sfset'6] concat s (singleton (Seq.empty: Seq.seq t_T)) = s)
  
  constant concat_union: () = [%#sfset'23] ()
  
  axiom concat_union_spec: ([%#sfset'7] forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
  = Fset.union (concat s1 t) (concat s2 t))
  && ([%#sfset'8] forall s: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s (Fset.union t1 t2)
  = Fset.union (concat s t1) (concat s t2))
  
  constant cons_concat: () = [%#sfset'28] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat_spec: [%#sfset'27] forall s: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat (cons s t) u
  = cons s (concat t u)
  
  function concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 534 0 534 54] (n: int) (m: int) (s: Fset.fset t_T) : ()
  
  
  axiom concat_replicate_def: forall n: int, m: int, s: Fset.fset t_T. ([%#sfset'9] 0 <= n /\ 0 <= m)
   -> concat_replicate n m s
  = ([%#sfset'24] if n = 0 then
    let _ = concat_empty (replicate s m) in ()
  else
    let _ = cons_concat in let _ = concat_replicate (n - 1) m s in ()
  )
  
  axiom concat_replicate_spec: forall n: int, m: int, s: Fset.fset t_T. ([%#sfset'9] 0 <= n /\ 0 <= m)
   -> ([%#sfset'10] replicate s (n + m) = concat (replicate s n) (replicate s m))
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T
  
  function concat_replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 562 0 562 60] (n'0: int) (m'0: int) (s'0: Fset.fset t_T) : ()
  
  
  goal vc_concat_replicate_up_to: ([%#sfset] 0 <= n /\ n < m)
   -> (if n + 1 = m then
    ([@expl:replicate requires] [%#sfset'2] n + 1 >= 0)
    /\ (([%#sfset'3] forall xs: Seq.seq t_T. contains (replicate s (n + 1)) xs
    = (Seq.length xs = n + 1 /\ (forall x: t_T. contains'0 xs x  -> contains'1 s x)))
     -> ([%#sfset'5] concat (singleton (Seq.empty: Seq.seq t_T)) (replicate s (n + 1)) = replicate s (n + 1))
    && ([%#sfset'6] concat (replicate s (n + 1)) (singleton (Seq.empty: Seq.seq t_T)) = replicate s (n + 1))
     -> (let _ = concat_empty (replicate s (n + 1)) in [%#sfset'0] replicate_up_to s m
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - n - 1)))))
  else
    ([%#sfset'7] forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat (Fset.union s1 s2) t
    = Fset.union (concat s1 t) (concat s2 t))
    && ([%#sfset'8] forall s'0: Fset.fset (Seq.seq t_T), t1: Fset.fset (Seq.seq t_T), t2: Fset.fset (Seq.seq t_T). concat s'0 (Fset.union t1 t2)
    = Fset.union (concat s'0 t1) (concat s'0 t2))
     -> (let _ = concat_union in ([@expl:concat_replicate requires] [%#sfset'9] 0 <= n /\ 0 <= m - n - 1)
    /\ (([%#sfset'10] replicate s (n + (m - n - 1)) = concat (replicate s n) (replicate s (m - n - 1)))
     -> (let _ = concat_replicate n (m - n - 1) s in (([@expl:concat_replicate_up_to requires] [%#sfset] 0 <= n
    /\ n < m - 1)
    /\ 0 <= ([%#sfset'1] m) /\ ([%#sfset'1] m - 1) < ([%#sfset'1] m))
    /\ (([%#sfset'0] replicate_up_to s (m - 1)
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - 1 - n - 1))))
     -> (let _ = concat_replicate_up_to n (m - 1) s in [%#sfset'0] replicate_up_to s m
    = Fset.union (replicate_up_to s n) (concat (replicate s (n + 1)) (replicate_up_to s (m - n - 1))))))))
  )
end
module M_creusot_contracts__logic__id__qyi676594641912026951__clone [#"../../creusot-contracts/src/logic/id.rs" 20 4 20 27] (* <logic::id::Id as std::clone::Clone> *)
  let%span sid = "../../creusot-contracts/src/logic/id.rs" 19 14 19 29
  
  use creusot.prelude.Any
  
  type t_Id
  
  meta "compute_max_steps" 1000000
  
  let rec clone'[#"../../creusot-contracts/src/logic/id.rs" 20 4 20 27] (self:t_Id) (return'  (x:t_Id))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_Id = Any.any_l () | & self'0: t_Id = self ] 
    [ return''0 (result:t_Id)-> {[@expl:clone ensures] [%#sid] result = self} (! return' {result}) ]

end
module M_creusot_contracts__logic__id__qyi14416423697585690270__ne [#"../../creusot-contracts/src/logic/id.rs" 37 4 37 38] (* <logic::id::Id as std::cmp::PartialEq> *)
  let%span sid = "../../creusot-contracts/src/logic/id.rs" 36 14 36 41
  let%span sid'0 = "../../creusot-contracts/src/logic/id.rs" 29 14 29 41
  
  use creusot.prelude.Any
  
  type t_Id
  
  let rec eq (self:t_Id) (other:t_Id) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sid'0] result = (self = other)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec ne[#"../../creusot-contracts/src/logic/id.rs" 37 4 37 38] (self:t_Id) (other:t_Id) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = eq {self'0} {other'0} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- not _4 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: bool = Any.any_l () | & self'0: t_Id = self | & other'0: t_Id = other | & _4: bool = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:ne ensures] [%#sid] result <> (self = other)} (! return' {result}) ]

end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: int) (y'0: int) : ()
  
  goal vc_cmp_le_log: [%#sord] (x <= y) = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: int) (y'0: int) : ()
  
  goal vc_cmp_lt_log: [%#sord] (x < y) = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: int) (y'0: int) : ()
  
  goal vc_cmp_ge_log: [%#sord] (x >= y) = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: int) (y'0: int) : ()
  
  goal vc_cmp_gt_log: [%#sord] (x > y) = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: int) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'3] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  constant z  : int
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: int) (y'0: int) (z'0: int) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'2] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: int) (y'0: int) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'2] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: int) (y'0: int) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'1] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: int) (y'0: int) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_cmp_le_log: [%#sord] UInt8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] UInt8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] UInt8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] UInt8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt8.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'3] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  constant z  : UInt8.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt8.t) (y'0: UInt8.t) (z'0: UInt8.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'2] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'2] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'1] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt8.t) (y'0: UInt8.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_cmp_le_log: [%#sord] UInt16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] UInt16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] UInt16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] UInt16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt16.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'3] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  constant z  : UInt16.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt16.t) (y'0: UInt16.t) (z'0: UInt16.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'2] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'2] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'1] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt16.t) (y'0: UInt16.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_cmp_le_log: [%#sord] UInt32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] UInt32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] UInt32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] UInt32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt32.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'3] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  constant z  : UInt32.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt32.t) (y'0: UInt32.t) (z'0: UInt32.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'2] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'2] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'1] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt32.t) (y'0: UInt32.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_le_log: [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt64.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'3] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt64.t) (y'0: UInt64.t) (z'0: UInt64.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_cmp_le_log: [%#sord] UInt128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] UInt128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] UInt128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] UInt128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt128.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'3] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  constant z  : UInt128.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt128.t) (y'0: UInt128.t) (z'0: UInt128.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'2] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'2] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'1] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt128.t) (y'0: UInt128.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_le_log: [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: UInt64.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'3] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: UInt64.t) (y'0: UInt64.t) (z'0: UInt64.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'2] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'1] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: UInt64.t) (y'0: UInt64.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_cmp_le_log: [%#sord] Int8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] Int8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] Int8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] Int8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int8.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'3] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  constant z  : Int8.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int8.t) (y'0: Int8.t) (z'0: Int8.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'2] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'2] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'1] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int8.t) (y'0: Int8.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_cmp_le_log: [%#sord] Int16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] Int16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] Int16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] Int16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int16.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'3] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  constant z  : Int16.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int16.t) (y'0: Int16.t) (z'0: Int16.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'2] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'2] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'1] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int16.t) (y'0: Int16.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_cmp_le_log: [%#sord] Int32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] Int32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] Int32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] Int32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int32.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'3] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  constant z  : Int32.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int32.t) (y'0: Int32.t) (z'0: Int32.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'2] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'2] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'1] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int32.t) (y'0: Int32.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_le_log: [%#sord] Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int64.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'3] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int64.t) (y'0: Int64.t) (z'0: Int64.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_cmp_le_log: [%#sord] Int128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] Int128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] Int128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] Int128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int128.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'3] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  constant z  : Int128.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int128.t) (y'0: Int128.t) (z'0: Int128.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'2] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'2] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'1] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int128.t) (y'0: Int128.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_le_log: [%#sord] Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Int64.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'3] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Int64.t) (y'0: Int64.t) (z'0: Int64.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'2] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'1] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Int64.t) (y'0: Int64.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_cmp_le_log: [%#sord] Char.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_cmp_lt_log: [%#sord] Char.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_cmp_ge_log: [%#sord] Char.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_cmp_gt_log: [%#sord] Char.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: Char.t) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'3] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  constant z  : Char.t
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: Char.t) (y'0: Char.t) (z'0: Char.t) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'2] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'2] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'1] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: Char.t) (y'0: Char.t) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: bool) (y'0: bool) : ()
  
  goal vc_cmp_le_log: [%#sord] Bool.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: bool) (y'0: bool) : ()
  
  goal vc_cmp_lt_log: [%#sord] Bool.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: bool) (y'0: bool) : ()
  
  goal vc_cmp_ge_log: [%#sord] Bool.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: bool) (y'0: bool) : ()
  
  goal vc_cmp_gt_log: [%#sord] Bool.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: bool) : ()
  
  goal vc_refl: [%#sord] cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'3] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  constant z  : bool
  
  constant o  : t_Ordering
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: bool) (y'0: bool) (z'0: bool) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log x y = o)  -> ([%#sord'0] cmp_log y z = o)  -> ([%#sord'1] cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'2] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: bool) (y'0: bool) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log x y = C_Less)  -> ([%#sord'0] cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'2] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: bool) (y'0: bool) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log x y = C_Greater)  -> ([%#sord'0] cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'1] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: bool) (y'0: bool) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self: tuple) (o: tuple) =
    [%#sord'1] self._p0 = o._p0 /\ le_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_cmp_le_log: [%#sord] le_log'1 x y = (cmp_log'1 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self: tuple) (o: tuple) =
    [%#sord'1] self._p0 = o._p0 /\ lt_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_cmp_lt_log: [%#sord] lt_log'1 x y = (cmp_log'1 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self: tuple) (o: tuple) =
    [%#sord'1] self._p0 = o._p0 /\ ge_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_cmp_ge_log: [%#sord] ge_log'1 x y = (cmp_log'1 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self: tuple) (o: tuple) =
    [%#sord'1] self._p0 = o._p0 /\ gt_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_cmp_gt_log: [%#sord] gt_log'1 x y = (cmp_log'1 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x'0: tuple) : ()
  
  goal vc_refl: [%#sord] cmp_log'1 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'16] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'14] cmp_log x y = C_Greater)
   -> ([%#sord'15] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'12] cmp_log x y = C_Less)
   -> ([%#sord'13] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'9] cmp_log x y = o)
   -> ([%#sord'10] cmp_log y z = o)  -> ([%#sord'11] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'8] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'7] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'6] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'5] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'4] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'16] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'14] cmp_log'0 x y = C_Greater)
   -> ([%#sord'15] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'12] cmp_log'0 x y = C_Less)
   -> ([%#sord'13] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'9] cmp_log'0 x y = o)
   -> ([%#sord'10] cmp_log'0 y z = o)  -> ([%#sord'11] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'8] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'7] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'6] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'3] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  constant z  : tuple
  
  constant o  : t_Ordering
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x'0: tuple) (y'0: tuple) (z'0: tuple) (o'0: t_Ordering) : ()
  
  
  goal vc_trans: ([%#sord] cmp_log'1 x y = o)  -> ([%#sord'0] cmp_log'1 y z = o)  -> ([%#sord'1] cmp_log'1 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_antisym1: ([%#sord] cmp_log'1 x y = C_Less)  -> ([%#sord'0] cmp_log'1 y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'15] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'13] cmp_log x y = C_Greater)
   -> ([%#sord'14] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Less)
   -> ([%#sord'12] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'8] cmp_log x y = o)
   -> ([%#sord'9] cmp_log y z = o)  -> ([%#sord'10] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'7] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'6] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'5] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'4] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'3] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'15] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'13] cmp_log'0 x y = C_Greater)
   -> ([%#sord'14] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Less)
   -> ([%#sord'12] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'8] cmp_log'0 x y = o)
   -> ([%#sord'9] cmp_log'0 y z = o)  -> ([%#sord'10] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'7] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'6] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'2] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_antisym2: ([%#sord] cmp_log'1 x y = C_Greater)  -> ([%#sord'0] cmp_log'1 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  constant x  : tuple
  
  constant y  : tuple
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x'0: tuple) (y'0: tuple) : ()
  
  goal vc_eq_cmp: [%#sord] (x = y) = (cmp_log'1 x y = C_Equal)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__idemp [#"../../creusot-contracts/src/logic/ra/agree.rs" 41 4 41 26] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 40 14 40 47
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 42 8 42 12
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  constant self  : t_Ag
  
  function idemp [#"../../creusot-contracts/src/logic/ra/agree.rs" 41 4 41 26] (self'0: t_Ag) : bool
  
  goal vc_idemp: [%#sagree] true = (op self self = self)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__incl [#"../../creusot-contracts/src/logic/ra/agree.rs" 48 4 48 38] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 47 14 47 61
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 49 8 53 9
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  constant self  : t_Ag
  
  constant other  : t_Ag
  
  function incl [#"../../creusot-contracts/src/logic/ra/agree.rs" 48 4 48 38] (self'0: t_Ag) (other'0: t_Ag) : bool
  
  goal vc_incl: match { _p0 = self; _p1 = other } with
    | {_p0 = C_Ag x ; _p1 = C_Ag y} -> [%#sagree] (x = y) = (exists c: t_Ag. op self c = other)
    | {_p1 = C_Bot} -> [%#sagree] true = (exists c: t_Ag. op self c = other)
    | {_p1 = C_Ag _} -> [%#sagree] false = (exists c: t_Ag. op self c = other)
    end
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 58 14 58 32
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 59 37 59 39
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  constant a  : t_Ag
  
  constant b  : t_Ag
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36] (a'0: t_Ag) (b'0: t_Ag) : ()
  
  goal vc_commutative: [%#sagree] op a b = op b a
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 63 14 63 44
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 64 46 64 48
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  constant a  : t_Ag
  
  constant b  : t_Ag
  
  constant c  : t_Ag
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45] (a'0: t_Ag) (b'0: t_Ag) (c'0: t_Ag) : ()
  
  
  goal vc_associative: [%#sagree] op (op a b) c = op a (op b c)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__valid_op [#"../../creusot-contracts/src/logic/ra/agree.rs" 69 4 69 30] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 68 14 68 49
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 69 31 69 33
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree'1] match self with
      | C_Ag _ -> true
      | C_Bot -> false
      end
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  constant self  : t_Ag
  
  constant b  : t_Ag
  
  function valid_op [#"../../creusot-contracts/src/logic/ra/agree.rs" 69 4 69 30] (self'0: t_Ag) (b'0: t_Ag) : ()
  
  goal vc_valid_op: [%#sagree] valid (op self b)  -> valid self
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__maximal_idemp [#"../../creusot-contracts/src/logic/ra/agree.rs" 79 4 79 26] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 73 15 73 27
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 75 8 77 67
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 79 27 79 29
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 47 14 47 61
  let%span sagree'4 = "../../creusot-contracts/src/logic/ra/agree.rs" 49 8 53 9
  let%span sagree'5 = "../../creusot-contracts/src/logic/ra/agree.rs" 40 14 40 47
  let%span sagree'6 = "../../creusot-contracts/src/logic/ra/agree.rs" 42 8 42 12
  let%span sagree'7 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree'2] match self with
      | C_Ag _ -> true
      | C_Bot -> false
      end
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'7] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  function incl [#"../../creusot-contracts/src/logic/ra/agree.rs" 48 4 48 38] (self: t_Ag) (other: t_Ag) : bool =
    [%#sagree'4] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> x = y
      | {_p1 = C_Bot} -> true
      | {_p1 = C_Ag _} -> false
      end
  
  axiom incl_spec: forall self: t_Ag, other: t_Ag. [%#sagree'3] incl self other = (exists c: t_Ag. op self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra/agree.rs" 41 4 41 26] (self: t_Ag) : bool =
    [%#sagree'6] true
  
  axiom idemp_spec: forall self: t_Ag. [%#sagree'5] idemp self = (op self self = self)
  
  constant self  : t_Ag
  
  function maximal_idemp [#"../../creusot-contracts/src/logic/ra/agree.rs" 79 4 79 26] (self'0: t_Ag) : ()
  
  goal vc_maximal_idemp: ([%#sagree] valid self)
   -> ([%#sagree'0] (forall b: t_Ag. not (incl b self /\ idemp b))
  \/ (exists b: t_Ag. incl b self /\ idemp b /\ (forall c: t_Ag. incl c self /\ idemp c  -> incl c b)))
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 62] (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 26 15 26 31
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 27 15 27 26
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 28 14 28 30
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 29 63 29 65
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 21 8 21 30
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra] incl self other = (exists c: t_T. op self c = other)
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 20 4 20 48] (a: t_T) (f: t_T) : bool =
    [%#sauth'3] incl f a /\ valid a
  
  constant a  : t_T
  
  constant f1  : t_T
  
  constant f2  : t_T
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 62] (a'0: t_T) (f1'0: t_T) (f2'0: t_T) : ()
  
  goal vc_rel_mono: ([%#sauth] rel a f1)  -> ([%#sauth'0] incl f2 f1)  -> ([%#sauth'1] rel a f2)
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__commutative [#"../../creusot-contracts/src/logic/ra/auth.rs" 77 4 77 36] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 76 14 76 32
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 77 37 77 39
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                     _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                 _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                 t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'1] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'0] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'1] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  constant a  : t_Auth
  
  constant b  : t_Auth
  
  function commutative'3 [#"../../creusot-contracts/src/logic/ra/auth.rs" 77 4 77 36] (a'0: t_Auth) (b'0: t_Auth) : ()
  
  goal vc_commutative: [%#sauth] op'5 a b = op'5 b a
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__associative [#"../../creusot-contracts/src/logic/ra/auth.rs" 82 4 82 45] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 81 14 81 44
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 82 46 82 48
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                     _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                 _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                 t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'1] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'0] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'1] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  constant a  : t_Auth
  
  constant b  : t_Auth
  
  constant c  : t_Auth
  
  function associative'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 82 4 82 45] (a'0: t_Auth) (b'0: t_Auth) (c'0: t_Auth) : ()
  
  
  goal vc_associative: [%#sauth] op'5 (op'5 a b) c = op'5 a (op'5 b c)
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__valid_op [#"../../creusot-contracts/src/logic/ra/auth.rs" 87 4 87 30] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 86 14 86 49
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 84 4 84 12
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 68 4 68 12
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 21 8 21 30
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 26 15 26 31
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 27 15 27 26
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 28 14 28 30
  let%span sauth'7 = "../../creusot-contracts/src/logic/ra/auth.rs" 29 63 29 65
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 118 14 118 49
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'1] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'3] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'2] op'4 a b = op'4 b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra'1] incl self other = (exists c: t_T. op'1 self c = other)
  
  function rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 20 4 20 48] (a: t_T) (f: t_T) : bool =
    [%#sauth'3] incl f a /\ valid a
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 62] (a: t_T) (f1: t_T) (f2: t_T) : () =
    [%#sauth'7] ()
  
  axiom rel_mono_spec: forall a: t_T, f1: t_T, f2: t_T. ([%#sauth'4] rel a f1)
   -> ([%#sauth'5] incl f2 f1)  -> ([%#sauth'6] rel a f2)
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'0] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid f /\ (exists a: t_T. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/auth.rs" 70 4 70 26] (self: t_Auth) : bool =
    [%#sauth'1] valid'0 self.t_Auth__0
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'2] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  function valid_op [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 30] (self: t_View) (b: t_View) : ()
  
  axiom valid_op_spec: forall self: t_View, b: t_View. [%#sview] valid'0 (op'4 self b)  -> valid'0 self
  
  constant self  : t_Auth
  
  constant b  : t_Auth
  
  function valid_op'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 87 4 87 30] (self'0: t_Auth) (b'0: t_Auth) : ()
  
  goal vc_valid_op: ([%#sview] valid'0 (op'4 self.t_Auth__0 b.t_Auth__0)  -> valid'0 self.t_Auth__0)
   -> ([%#sauth] valid'1 (op'5 self b)  -> valid'1 self)
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__maximal_idemp [#"../../creusot-contracts/src/logic/ra/auth.rs" 99 4 99 26] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 93 15 93 27
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 95 8 97 67
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 91 4 91 12
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 68 4 68 12
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 105 14 105 59
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 103 4 103 12
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 112 14 112 47
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 110 4 110 12
  let%span sauth'7 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sauth'8 = "../../creusot-contracts/src/logic/ra/auth.rs" 21 8 21 30
  let%span sauth'9 = "../../creusot-contracts/src/logic/ra/auth.rs" 26 15 26 31
  let%span sauth'10 = "../../creusot-contracts/src/logic/ra/auth.rs" 27 15 27 26
  let%span sauth'11 = "../../creusot-contracts/src/logic/ra/auth.rs" 28 14 28 30
  let%span sauth'12 = "../../creusot-contracts/src/logic/ra/auth.rs" 29 63 29 65
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 125 15 125 27
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 127 8 129 67
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 61
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 96 8 96 61
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 101 14 101 47
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 103 8 103 38
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'3] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'5] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'4] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'3] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'4] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'3] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'4] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'3] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'5] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'4] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'8] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'7] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'6] op'4 a b = op'4 b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra'1] incl self other = (exists c: t_T. op'1 self c = other)
  
  function rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 20 4 20 48] (a: t_T) (f: t_T) : bool =
    [%#sauth'8] incl f a /\ valid a
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 62] (a: t_T) (f1: t_T) (f2: t_T) : () =
    [%#sauth'12] ()
  
  axiom rel_mono_spec: forall a: t_T, f1: t_T, f2: t_T. ([%#sauth'9] rel a f1)
   -> ([%#sauth'10] incl f2 f1)  -> ([%#sauth'11] rel a f2)
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'1] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid f /\ (exists a: t_T. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/auth.rs" 70 4 70 26] (self: t_Auth) : bool =
    [%#sauth'2] valid'0 self.t_Auth__0
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'7] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'0] other = C_Bot
  
  axiom incl_spec'0: forall self: t_Excl, other: t_Excl. [%#sexcl] incl'0 self other
  = (exists c: t_Excl. op self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> true
      | {_p1'0 = C_None} -> false
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> x = y \/ incl'0 x y
      end
  
  axiom incl_spec'1: forall self: t_Option, other: t_Option. [%#soption] incl'1 self other
  = (exists c: t_Option. op'0 self c = other)
  
  function incl'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option'0) (other: t_Option'0) : bool
  
   =
    [%#soption'0] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> true
      | {_p1'1 = C_None'0} -> false
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'2: forall self: t_Option'0, other: t_Option'0. [%#soption] incl'2 self other
  = (exists c: t_Option'0. op'2 self c = other)
  
  function incl'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'0] incl'1 self._p0 other._p0 /\ incl'2 self._p1 other._p1
  
  axiom incl_spec'3: forall self: tuple, other: tuple. [%#sprod] incl'3 self other
  = (exists c: tuple. op'3 self c = other)
  
  function incl'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (self: t_View) (other: t_View) : bool =
    [%#sview'3] incl'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                              _p1 = other.t_View__frag }
  
  axiom incl_spec'4: forall self: t_View, other: t_View. [%#sview'2] incl'4 self other
  = (exists c: t_View. op'4 self c = other)
  
  function incl'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 106 4 106 38] (self: t_Auth) (other: t_Auth) : bool =
    [%#sauth'4] incl'4 self.t_Auth__0 other.t_Auth__0
  
  axiom incl_spec'5: forall self: t_Auth, other: t_Auth. [%#sauth'3] incl'5 self other
  = (exists c: t_Auth. op'5 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self: t_Excl) : bool =
    [%#sexcl'2] self = C_Bot
  
  axiom idemp_spec: forall self: t_Excl. [%#sexcl'1] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'2] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption'1] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec'1: forall self: t_T. [%#sra'2] idemp'1 self = (op'1 self self = self)
  
  function idemp'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option'0) : bool =
    [%#soption'2] match self with
      | C_None'0 -> true
      | C_Some'0 x -> idemp'1 x
      end
  
  axiom idemp_spec'2: forall self: t_Option'0. [%#soption'1] idemp'2 self = (op'2 self self = self)
  
  function idemp'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self: tuple) : bool =
    [%#sprod'2] idemp'0 self._p0 /\ idemp'2 self._p1
  
  axiom idemp_spec'3: forall self: tuple. [%#sprod'1] idemp'3 self = (op'3 self self = self)
  
  function idemp'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26] (self: t_View) : bool =
    [%#sview'5] idemp'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag }
  
  axiom idemp_spec'4: forall self: t_View. [%#sview'4] idemp'4 self = (op'4 self self = self)
  
  function idemp'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 113 4 113 26] (self: t_Auth) : bool =
    [%#sauth'6] idemp'4 self.t_Auth__0
  
  axiom idemp_spec'5: forall self: t_Auth. [%#sauth'5] idemp'5 self = (op'5 self self = self)
  
  function maximal_idemp [#"../../creusot-contracts/src/logic/ra/view.rs" 131 4 131 26] (self: t_View) : ()
  
  axiom maximal_idemp_spec: forall self: t_View. ([%#sview] valid'0 self)
   -> ([%#sview'0] (forall b: t_View. not (incl'4 b self /\ idemp'4 b))
  \/ (exists b: t_View. incl'4 b self /\ idemp'4 b /\ (forall c: t_View. incl'4 c self /\ idemp'4 c  -> incl'4 c b)))
  
  constant self  : t_Auth
  
  function maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra/auth.rs" 99 4 99 26] (self'0: t_Auth) : ()
  
  goal vc_maximal_idemp: ([%#sauth] valid'1 self)
   -> ([@expl:maximal_idemp requires] [%#sview] valid'0 self.t_Auth__0)
  /\ (([%#sview'0] (forall b: t_View. not (incl'4 b self.t_Auth__0 /\ idemp'4 b))
  \/ (exists b: t_View. incl'4 b self.t_Auth__0
  /\ idemp'4 b /\ (forall c: t_View. incl'4 c self.t_Auth__0 /\ idemp'4 c  -> incl'4 c b)))
   -> (let _ = maximal_idemp self.t_Auth__0 in [%#sauth'0] (forall b: t_Auth. not (incl'5 b self /\ idemp'5 b))
  \/ (exists b: t_Auth. incl'5 b self /\ idemp'5 b /\ (forall c: t_Auth. incl'5 c self /\ idemp'5 c  -> incl'5 c b))))
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__incl [#"../../creusot-contracts/src/logic/ra/auth.rs" 106 4 106 38] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 105 14 105 59
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 103 4 103 12
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 61
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 96 8 96 61
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'3] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'2] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra'0] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'2] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'3] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'2] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'1] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'3] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'2] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'1] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  function incl [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'0] other = C_Bot
  
  axiom incl_spec: forall self: t_Excl, other: t_Excl. [%#sexcl] incl self other = (exists c: t_Excl. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> true
      | {_p1'0 = C_None} -> false
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'0: forall self: t_Option, other: t_Option. [%#soption] incl'0 self other
  = (exists c: t_Option. op'0 self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec'1: forall self: t_T, other: t_T. [%#sra] incl'1 self other = (exists c: t_T. op'1 self c = other)
  
  function incl'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option'0) (other: t_Option'0) : bool
  
   =
    [%#soption'0] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> true
      | {_p1'1 = C_None'0} -> false
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> x = y \/ incl'1 x y
      end
  
  axiom incl_spec'2: forall self: t_Option'0, other: t_Option'0. [%#soption] incl'2 self other
  = (exists c: t_Option'0. op'2 self c = other)
  
  function incl'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'0] incl'0 self._p0 other._p0 /\ incl'2 self._p1 other._p1
  
  axiom incl_spec'3: forall self: tuple, other: tuple. [%#sprod] incl'3 self other
  = (exists c: tuple. op'3 self c = other)
  
  function incl'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (self: t_View) (other: t_View) : bool =
    [%#sview'0] incl'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                              _p1 = other.t_View__frag }
  
  axiom incl_spec'4: forall self: t_View, other: t_View. [%#sview] incl'4 self other
  = (exists c: t_View. op'4 self c = other)
  
  constant self  : t_Auth
  
  constant other  : t_Auth
  
  function incl'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 106 4 106 38] (self'0: t_Auth) (other'0: t_Auth) : bool
  
  
  goal vc_incl: ([%#sview] incl'4 self.t_Auth__0 other.t_Auth__0
  = (exists c: t_View. op'4 self.t_Auth__0 c = other.t_Auth__0))
   -> ([%#sauth] incl'4 self.t_Auth__0 other.t_Auth__0 = (exists c: t_Auth. op'5 self c = other))
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__idemp [#"../../creusot-contracts/src/logic/ra/auth.rs" 113 4 113 26] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 112 14 112 47
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 110 4 110 12
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 101 14 101 47
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 103 8 103 38
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'3] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'2] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra'0] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'2] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'3] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'2] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'1] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'3] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'2] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'1] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self: t_Excl) : bool =
    [%#sexcl'0] self = C_Bot
  
  axiom idemp_spec: forall self: t_Excl. [%#sexcl] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'0] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec'1: forall self: t_T. [%#sra] idemp'1 self = (op'1 self self = self)
  
  function idemp'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option'0) : bool =
    [%#soption'0] match self with
      | C_None'0 -> true
      | C_Some'0 x -> idemp'1 x
      end
  
  axiom idemp_spec'2: forall self: t_Option'0. [%#soption] idemp'2 self = (op'2 self self = self)
  
  function idemp'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self: tuple) : bool =
    [%#sprod'0] idemp'0 self._p0 /\ idemp'2 self._p1
  
  axiom idemp_spec'3: forall self: tuple. [%#sprod] idemp'3 self = (op'3 self self = self)
  
  function idemp'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26] (self: t_View) : bool =
    [%#sview'0] idemp'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag }
  
  axiom idemp_spec'4: forall self: t_View. [%#sview] idemp'4 self = (op'4 self self = self)
  
  constant self  : t_Auth
  
  function idemp'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 113 4 113 26] (self'0: t_Auth) : bool
  
  goal vc_idemp: ([%#sview] idemp'4 self.t_Auth__0 = (op'4 self.t_Auth__0 self.t_Auth__0 = self.t_Auth__0))
   -> ([%#sauth] idemp'4 self.t_Auth__0 = (op'5 self self = self))
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__incl [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  constant self  : t_Excl
  
  constant other  : t_Excl
  
  function incl [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self'0: t_Excl) (other'0: t_Excl) : bool
  
  goal vc_incl: [%#sexcl] (other = C_Bot) = (exists c: t_Excl. op self c = other)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  constant self  : t_Excl
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self'0: t_Excl) : bool
  
  goal vc_idemp: [%#sexcl] (self = C_Bot) = (op self self = self)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 47 37 47 39
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  constant a  : t_Excl
  
  constant b  : t_Excl
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a'0: t_Excl) (b'0: t_Excl) : ()
  
  goal vc_commutative: [%#sexcl] op a b = op b a
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 52 46 52 48
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  constant a  : t_Excl
  
  constant b  : t_Excl
  
  constant c  : t_Excl
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a'0: t_Excl) (b'0: t_Excl) (c'0: t_Excl) : ()
  
  
  goal vc_associative: [%#sexcl] op (op a b) c = op a (op b c)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__valid_op [#"../../creusot-contracts/src/logic/ra/excl.rs" 57 4 57 30] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 56 14 56 49
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 57 31 57 33
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 24 8 27 9
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function valid [#"../../creusot-contracts/src/logic/ra/excl.rs" 23 4 23 26] (self: t_Excl) : bool =
    [%#sexcl'1] match self with
      | C_Excl _ -> true
      | C_Bot -> false
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'2] C_Bot
  
  constant self  : t_Excl
  
  constant b  : t_Excl
  
  function valid_op [#"../../creusot-contracts/src/logic/ra/excl.rs" 57 4 57 30] (self'0: t_Excl) (b'0: t_Excl) : ()
  
  goal vc_valid_op: [%#sexcl] valid (op self b)  -> valid self
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__maximal_idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 67 4 67 26] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 61 15 61 27
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 63 8 65 67
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 67 27 67 29
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 24 8 27 9
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'6 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'7 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function valid [#"../../creusot-contracts/src/logic/ra/excl.rs" 23 4 23 26] (self: t_Excl) : bool =
    [%#sexcl'2] match self with
      | C_Excl _ -> true
      | C_Bot -> false
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'7] C_Bot
  
  function incl [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'4] other = C_Bot
  
  axiom incl_spec: forall self: t_Excl, other: t_Excl. [%#sexcl'3] incl self other
  = (exists c: t_Excl. op self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self: t_Excl) : bool =
    [%#sexcl'6] self = C_Bot
  
  axiom idemp_spec: forall self: t_Excl. [%#sexcl'5] idemp self = (op self self = self)
  
  constant self  : t_Excl
  
  function maximal_idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 67 4 67 26] (self'0: t_Excl) : ()
  
  goal vc_maximal_idemp: ([%#sexcl] valid self)
   -> ([%#sexcl'0] (forall b: t_Excl. not (incl b self /\ idemp b))
  \/ (exists b: t_Excl. incl b self /\ idemp b /\ (forall c: t_Excl. incl c self /\ idemp c  -> incl c b)))
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__incl [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 26 14 26 59
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 28 30 28 73
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 33 20 33 81
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 31 26 36 13
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 28 8 28 76
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 93 4 102 6
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 280 14 283 5
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sutil = "../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type tuple  =
    { _p0: t_V; _p1: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'13] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'10] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'7] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_V) (a: tuple) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap'11] forall k: t_K. match { _p0'0 = get self k;
                                                                                                              _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'6] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_V) (other: t_V) : bool
  
  axiom incl_spec: forall self: t_V, other: t_V. [%#sra] incl self other = (exists c: t_V. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> true
      | {_p1'0 = C_None} -> false
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'0: forall self: t_Option, other: t_Option. [%#soption] incl'0 self other
  = (exists c: t_Option. op'1 self c = other)
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  function index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'1 t_Option) (a: tuple'1) : t_Option
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 284 4 286 17] (self: t_FMap) (f: Map.map tuple'1 t_Option) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'1 t_Option. [%#sfmap'12] forall k: t_K. get (filter_map self f) k
  = match get self k with
    | C_None -> C_None
    | C_Some v -> index_logic'0 f { _p0'1 = k; _p1'1 = v }
    end
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map t_V bool) (a: t_V) : bool
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 35 0 35 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that p))
  
  function missing_part [#"../../creusot-contracts/src/logic/ra/fmap.rs" 92 0 92 76] (this: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'8] filter_map other (fun (__0: tuple'1) -> let {_p0'1 = k ; _p1'1 = vo} = __0 in match get this k with
      | C_None -> C_Some vo
      | C_Some vs -> if vs = vo then C_None else C_Some (such_that (fun (v: t_V) -> op vs v = vo))
      end)
  
  function ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'9] view self = view other
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'3] ext_eq self other  -> self = other)
  && ([%#sfmap'4] (forall k: t_K. get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  constant self  : t_FMap
  
  constant other  : t_FMap
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (self'0: t_FMap) (other'0: t_FMap) : bool
  
  goal vc_incl: let res = [%#sfmap'0] forall k: t_K. incl'0 (get self k) (get other k) in if res then
    let missing_part'0 = missing_part self other in (forall k: t_K. match { _p0'0 = get other k;
                                                                            _p1'0 = get self k } with
      | {_p0'0 = C_Some vo ; _p1'0 = C_Some vs} -> true
      | _ -> true
      end)
    /\ ([%#sfmap'2] forall k: t_K. match { _p0'0 = get other k; _p1'0 = get self k } with
      | {_p0'0 = C_Some vo ; _p1'0 = C_Some vs} -> if vo = vs then
        true
      else
        exists v: t_V. op vs v = vo /\ get missing_part'0 k = C_Some v
      
      | _ -> true
      end)
    && (let _ = () in let _ = () in ([%#sfmap'3] ext_eq (op'0 self missing_part'0) other
     -> op'0 self missing_part'0 = other)
    && ([%#sfmap'4] (forall k: t_K. get_unsized (op'0 self missing_part'0) k = get_unsized other k)
     -> ext_eq (op'0 self missing_part'0) other)
     -> ext_eq (op'0 self missing_part'0) other
    && (let _ = () in let _ = () in let _ = () in [%#sfmap] res = (exists c: t_FMap. op'0 self c = other)))
  else
    let _ = () in [%#sfmap] res = (exists c: t_FMap. op'0 self c = other)

end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__idemp [#"../../creusot-contracts/src/logic/ra/fmap.rs" 45 4 45 26] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 44 14 44 47
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 47 12 47 44
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type tuple  =
    { _p0: t_V; _p1: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'5] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'4] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'2] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_V) (a: tuple) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap'3] forall k: t_K. match { _p0'0 = get self k;
                                                                                                             _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'1] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_V) : bool
  
  axiom idemp_spec: forall self: t_V. [%#sra] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'0] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption] idemp'0 self = (op'1 self self = self)
  
  constant self  : t_FMap
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 45 4 45 26] (self'0: t_FMap) : bool
  
  goal vc_idemp: [%#sfmap] ([%#sfmap'0] forall k: t_K. idemp'0 (get self k)) = (op'0 self self = self)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__commutative [#"../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 53 14 53 32
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 54 37 54 39
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type tuple  =
    { _p0: t_V; _p1: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'5] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'4] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'3] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_V) (a: tuple) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap'2] forall k: t_K. match { _p0'0 = get self k;
                                                                                                             _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'1] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  constant a  : t_FMap
  
  constant b  : t_FMap
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36] (a'0: t_FMap) (b'0: t_FMap) : ()
  
  goal vc_commutative: [%#sfmap] op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__associative [#"../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 14 58 44
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 60 8 60 58
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type tuple  =
    { _p0: t_V; _p1: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'7] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'5] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'8] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_V) (a: tuple) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap'6] forall k: t_K. match { _p0'0 = get self k;
                                                                                                             _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'3] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  function ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'4] view self = view other
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'0] ext_eq self other  -> self = other)
  && ([%#sfmap'1] (forall k: t_K. get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  constant a  : t_FMap
  
  constant b  : t_FMap
  
  constant c  : t_FMap
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45] (a'0: t_FMap) (b'0: t_FMap) (c'0: t_FMap) : ()
  
  
  goal vc_associative: ([%#sfmap'0] ext_eq (op'0 (op'0 a b) c) (op'0 a (op'0 b c))
   -> op'0 (op'0 a b) c = op'0 a (op'0 b c))
  && ([%#sfmap'1] (forall k: t_K. get_unsized (op'0 (op'0 a b) c) k = get_unsized (op'0 a (op'0 b c)) k)
   -> ext_eq (op'0 (op'0 a b) c) (op'0 a (op'0 b c)))
   -> ext_eq (op'0 (op'0 a b) c) (op'0 a (op'0 b c))
  && (let _ = () in let _ = () in [%#sfmap] op'0 (op'0 a b) c = op'0 a (op'0 b c))
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__valid_op [#"../../creusot-contracts/src/logic/ra/fmap.rs" 66 4 66 30] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 65 14 65 49
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 67 8 67 36
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 100 14 100 49
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_V) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'6] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'5] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'3] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap) : bool =
    [%#sfmap'1] forall k: t_K. valid'0 (get self k)
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'4] forall k: t_K. match { _p0 = get self k;
                                                                                                               _p1 = get m k } with
    | {_p0 = C_None ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None} -> get (merge self m f) k = x
    | {_p0 = C_Some x ; _p1 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'2] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in op x y)
  
  function valid_op [#"../../creusot-contracts/src/logic/ra.rs" 101 4 101 31] (self: t_V) (b: t_V) : ()
  
  axiom valid_op_spec: forall self: t_V, b: t_V. [%#sra] valid (op self b)  -> valid self
  
  constant self  : t_FMap
  
  constant b  : t_FMap
  
  function valid_op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 66 4 66 30] (self'0: t_FMap) (b'0: t_FMap) : ()
  
  goal vc_valid_op: let _ = valid_op in [%#sfmap] valid'1 (op'1 self b)  -> valid'1 self
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__maximal_idemp [#"../../creusot-contracts/src/logic/ra/fmap.rs" 78 4 78 26] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 72 15 72 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 74 8 76 67
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 26 14 26 59
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 44 14 44 47
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 81 16 81 63
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 84 20 84 82
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 79 8 79 41
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 28 8 28 76
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 47 12 47 44
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 109 8 113 10
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 93 4 102 6
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 280 14 283 5
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 106 15 106 27
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 108 8 110 67
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'2] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'1] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'4] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_V) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'16] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'15] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'11] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap) : bool =
    [%#sfmap'6] forall k: t_K. valid'0 (get self k)
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'13] forall k: t_K. match { _p0 = get self k;
                                                                                                                _p1 = get m k } with
    | {_p0 = C_None ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None} -> get (merge self m f) k = x
    | {_p0 = C_Some x ; _p1 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'9] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in op x y)
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_V) (other: t_V) : bool
  
  axiom incl_spec: forall self: t_V, other: t_V. [%#sra'3] incl self other = (exists c: t_V. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> true
      | {_p1 = C_None} -> false
      | {_p0 = C_Some x ; _p1 = C_Some y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'0: forall self: t_Option, other: t_Option. [%#soption'0] incl'0 self other
  = (exists c: t_Option. op'0 self c = other)
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  function index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'1 t_Option) (a: tuple'1) : t_Option
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 284 4 286 17] (self: t_FMap) (f: Map.map tuple'1 t_Option) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'1 t_Option. [%#sfmap'14] forall k: t_K. get (filter_map self f) k
  = match get self k with
    | C_None -> C_None
    | C_Some v -> index_logic'0 f { _p0'1 = k; _p1'1 = v }
    end
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map t_V bool) (a: t_V) : bool
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 35 0 35 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that p))
  
  function missing_part [#"../../creusot-contracts/src/logic/ra/fmap.rs" 92 0 92 76] (this: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'12] filter_map other (fun (__0: tuple'1) -> let {_p0'1 = k ; _p1'1 = vo} = __0 in match get this k with
      | C_None -> C_Some vo
      | C_Some vs -> if vs = vo then C_None else C_Some (such_that (fun (v: t_V) -> op vs v = vo))
      end)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'7] let res = forall k: t_K. incl'0 (get self k) (get other k) in let _ = if res then
      let missing_part'0 = missing_part self other in let _ = let _ = () in () in let _ = let _ = () in () in ()
    else
      ()
     in res
  
  axiom incl_spec'1: forall self: t_FMap, other: t_FMap. [%#sfmap'1] incl'1 self other
  = (exists c: t_FMap. op'1 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_V) : bool
  
  axiom idemp_spec: forall self: t_V. [%#sra'4] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'3] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption'2] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 45 4 45 26] (self: t_FMap) : bool =
    [%#sfmap'8] forall k: t_K. idemp'0 (get self k)
  
  axiom idemp_spec'1: forall self: t_FMap. [%#sfmap'2] idemp'1 self = (op'1 self self = self)
  
  function maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 112 4 112 27] (self: t_V) : ()
  
  axiom maximal_idemp_spec: forall self: t_V. ([%#sra] valid self)
   -> ([%#sra'0] (forall b: t_V. not (incl b self /\ idemp b))
  \/ (exists b: t_V. incl b self /\ idemp b /\ (forall c: t_V. incl c self /\ idemp c  -> incl c b)))
  
  function maximal_idemp_part [#"../../creusot-contracts/src/logic/ra/fmap.rs" 107 0 107 63] (this: t_FMap) : t_FMap =
    [%#sfmap'10] filter_map this (fun (__0: tuple'1) -> let {_p1'1 = v} = __0 in if forall v2: t_V. not (incl v2 v
    /\ idemp v2) then
      C_None
    else
      C_Some (such_that (fun (v2: t_V) -> incl v2 v /\ idemp v2 /\ (forall c: t_V. incl c v /\ idemp c  -> incl c v2)))
    )
  
  constant self  : t_FMap
  
  function maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 78 4 78 26] (self'0: t_FMap) : ()
  
  goal vc_maximal_idemp: ([%#sfmap] valid'1 self)
   -> (let _ = maximal_idemp in if not ([%#sfmap'3] forall b: t_FMap. not (incl'1 b self /\ idemp'1 b)) then
    let included = maximal_idemp_part self in ([%#sfmap'1] incl'1 included self
    = (exists c: t_FMap. op'1 included c = self))
     -> (if incl'1 included self then
      ([%#sfmap'2] idemp'1 included = (op'1 included included = included))
       -> (if idemp'1 included then
        ([%#sfmap'4] forall c: t_FMap. incl'1 c self /\ idemp'1 c  -> incl'1 c included)
        && (let _ = () in let _ = () in [%#sfmap'0] (forall b: t_FMap. not (incl'1 b self /\ idemp'1 b))
        \/ (exists b: t_FMap. incl'1 b self
        /\ idemp'1 b /\ (forall c: t_FMap. incl'1 c self /\ idemp'1 c  -> incl'1 c b)))
      else
        false
        && (let _ = () in let _ = () in [%#sfmap'0] (forall b: t_FMap. not (incl'1 b self /\ idemp'1 b))
        \/ (exists b: t_FMap. incl'1 b self
        /\ idemp'1 b /\ (forall c: t_FMap. incl'1 c self /\ idemp'1 c  -> incl'1 c b)))
      )
    else
      false
      && (let _ = () in let _ = () in [%#sfmap'0] (forall b: t_FMap. not (incl'1 b self /\ idemp'1 b))
      \/ (exists b: t_FMap. incl'1 b self
      /\ idemp'1 b /\ (forall c: t_FMap. incl'1 c self /\ idemp'1 c  -> incl'1 c b)))
    )
  else
    [%#sfmap'0] (forall b: t_FMap. not (incl'1 b self /\ idemp'1 b))
    \/ (exists b: t_FMap. incl'1 b self /\ idemp'1 b /\ (forall c: t_FMap. incl'1 c self /\ idemp'1 c  -> incl'1 c b))
  )
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__incl [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra] incl self other = (exists c: t_T. op self c = other)
  
  constant self  : t_Option
  
  constant other  : t_Option
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self'0: t_Option) (other'0: t_Option) : bool
  
  
  goal vc_incl: match { _p0 = self; _p1 = other } with
    | {_p0 = C_None} -> [%#soption] true = (exists c: t_Option. op'0 self c = other)
    | {_p1 = C_None} -> [%#soption] false = (exists c: t_Option. op'0 self c = other)
    | {_p0 = C_Some x ; _p1 = C_Some y} -> if x = y then
      [%#soption] true = (exists c: t_Option. op'0 self c = other)
    else
      ([%#sra] incl x y = (exists c: t_T. op x c = y))
       -> ([%#soption] incl x y = (exists c: t_Option. op'0 self c = other))
    
    end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__idemp [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra] idemp self = (op self self = self)
  
  constant self  : t_Option
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self'0: t_Option) : bool
  
  goal vc_idemp: match self with
    | C_None -> [%#soption] true = (op'0 self self = self)
    | C_Some x -> ([%#sra] idemp x = (op x x = x))  -> ([%#soption] idemp x = (op'0 self self = self))
    end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__commutative [#"../../creusot-contracts/src/logic/ra/option.rs" 50 4 50 36] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 49 14 49 32
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 51 8 51 39
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  constant a  : t_Option
  
  constant b  : t_Option
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 50 4 50 36] (a'0: t_Option) (b'0: t_Option) : ()
  
  
  goal vc_commutative: let _ = commutative in [%#soption] op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__associative [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 59 12 66 13
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option; _p2: t_Option }
  
  constant a  : t_Option
  
  constant b  : t_Option
  
  constant c  : t_Option
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a'0: t_Option) (b'0: t_Option) (c'0: t_Option) : ()
  
  
  goal vc_associative: match { _p0'0 = a; _p1'0 = b; _p2 = c } with
    | {_p0'0 = C_None} -> [%#soption] op'0 (op'0 a b) c = op'0 a (op'0 b c)
    | {_p1'0 = C_None} -> [%#soption] op'0 (op'0 a b) c = op'0 a (op'0 b c)
    | {_p2 = C_None} -> [%#soption] op'0 (op'0 a b) c = op'0 a (op'0 b c)
    | {_p0'0 = C_Some aa ; _p1'0 = C_Some bb ; _p2 = C_Some cc} -> ([%#sra] op (op aa bb) cc = op aa (op bb cc))
     -> ([%#soption] op'0 (op'0 a b) c = op'0 a (op'0 b c))
    end
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__valid_op [#"../../creusot-contracts/src/logic/ra/option.rs" 73 4 73 30] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 72 14 72 49
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 74 8 74 36
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 100 14 100 49
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption'1] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function valid_op [#"../../creusot-contracts/src/logic/ra.rs" 101 4 101 31] (self: t_T) (b: t_T) : ()
  
  axiom valid_op_spec: forall self: t_T, b: t_T. [%#sra] valid (op self b)  -> valid self
  
  constant self  : t_Option
  
  constant b  : t_Option
  
  function valid_op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 73 4 73 30] (self'0: t_Option) (b'0: t_Option) : ()
  
  
  goal vc_valid_op: let _ = valid_op in [%#soption] valid'0 (op'0 self b)  -> valid'0 self
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__maximal_idemp [#"../../creusot-contracts/src/logic/ra/option.rs" 85 4 85 26] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 79 15 79 27
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 81 8 83 67
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 91 23 91 62
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 94 38 94 96
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 99 26 99 89
  let%span soption'6 = "../../creusot-contracts/src/logic/ra/option.rs" 97 38 99 89
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 87 12 103 13
  let%span soption'8 = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'9 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'10 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'11 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 106 15 106 27
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 108 8 110 67
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption'8] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'11] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra'1] incl self other = (exists c: t_T. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'9] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> true
      | {_p1 = C_None} -> false
      | {_p0 = C_Some x ; _p1 = C_Some y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'0: forall self: t_Option, other: t_Option. [%#soption'2] incl'0 self other
  = (exists c: t_Option. op'0 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra'2] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'10] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption'3] idemp'0 self = (op'0 self self = self)
  
  function maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 112 4 112 27] (self: t_T) : ()
  
  axiom maximal_idemp_spec: forall self: t_T. ([%#sra] valid self)
   -> ([%#sra'0] (forall b: t_T. not (incl b self /\ idemp b))
  \/ (exists b: t_T. incl b self /\ idemp b /\ (forall c: t_T. incl c self /\ idemp c  -> incl c b)))
  
  constant self  : t_Option
  
  function maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 85 4 85 26] (self'0: t_Option) : ()
  
  goal vc_maximal_idemp: ([%#soption] valid'0 self)
   -> match self with
    | C_None -> [%#soption'0] (forall b: t_Option. not (incl'0 b self /\ idemp'0 b))
    \/ (exists b: t_Option. incl'0 b self
    /\ idemp'0 b /\ (forall c: t_Option. incl'0 c self /\ idemp'0 c  -> incl'0 c b))
    | C_Some x -> ([@expl:maximal_idemp requires] [%#sra] valid x)
    /\ (([%#sra'0] (forall b: t_T. not (incl b x /\ idemp b))
    \/ (exists b: t_T. incl b x /\ idemp b /\ (forall c: t_T. incl c x /\ idemp c  -> incl c b)))
     -> (let _ = maximal_idemp x in if [%#soption'1] forall y: t_T. not (incl y x /\ idemp y) then
      ([%#soption'2] incl'0 (C_None) self = (exists c: t_Option. op'0 (C_None) c = self))
       -> (if incl'0 (C_None) self then
        ([%#soption'3] idemp'0 (C_None) = (op'0 (C_None) (C_None) = C_None))
         -> idemp'0 (C_None)
        && (let _ = () in let _ = () in ([%#soption'4] forall c: t_Option. incl'0 c self /\ idemp'0 c
         -> incl'0 c (C_None))
        && (let _ = () in let _ = () in [%#soption'0] (forall b: t_Option. not (incl'0 b self /\ idemp'0 b))
        \/ (exists b: t_Option. incl'0 b self
        /\ idemp'0 b /\ (forall c: t_Option. incl'0 c self /\ idemp'0 c  -> incl'0 c b))))
      else
        false
        && (let _ = () in let _ = () in ([%#soption'4] forall c: t_Option. incl'0 c self /\ idemp'0 c
         -> incl'0 c (C_None))
        && (let _ = () in let _ = () in [%#soption'0] (forall b: t_Option. not (incl'0 b self /\ idemp'0 b))
        \/ (exists b: t_Option. incl'0 b self
        /\ idemp'0 b /\ (forall c: t_Option. incl'0 c self /\ idemp'0 c  -> incl'0 c b))))
      )
    else
      ([%#soption'6] exists y: t_T. incl y x
      /\ idemp y
      /\ incl'0 (C_Some y) self
      /\ idemp'0 (C_Some y) /\ (forall c: t_Option. incl'0 c self /\ idemp'0 c  -> incl'0 c (C_Some y)))
      && (let _ = () in let _ = () in [%#soption'0] (forall b: t_Option. not (incl'0 b self /\ idemp'0 b))
      \/ (exists b: t_Option. incl'0 b self
      /\ idemp'0 b /\ (forall c: t_Option. incl'0 c self /\ idemp'0 c  -> incl'0 c b)))
    ))
    end
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__incl [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra] incl self other = (exists c: t_T. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_U) (other: t_U) : bool
  
  axiom incl_spec'0: forall self: t_U, other: t_U. [%#sra] incl'0 self other = (exists c: t_U. op'0 self c = other)
  
  constant self  : tuple
  
  constant other  : tuple
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self'0: tuple) (other'0: tuple) : bool
  
  goal vc_incl: ([%#sra] incl self._p0 other._p0 = (exists c: t_T. op self._p0 c = other._p0))
   -> (if incl self._p0 other._p0 then
    ([%#sra] incl'0 self._p1 other._p1 = (exists c: t_U. op'0 self._p1 c = other._p1))
     -> ([%#sprod] incl'0 self._p1 other._p1 = (exists c: tuple. op'1 self c = other))
  else
    [%#sprod] false = (exists c: tuple. op'1 self c = other)
  )
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__idemp [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_U) : bool
  
  axiom idemp_spec'0: forall self: t_U. [%#sra] idemp'0 self = (op'0 self self = self)
  
  constant self  : tuple
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self'0: tuple) : bool
  
  goal vc_idemp: ([%#sra] idemp self._p0 = (op self._p0 self._p0 = self._p0))
   -> (if idemp self._p0 then
    ([%#sra] idemp'0 self._p1 = (op'0 self._p1 self._p1 = self._p1))
     -> ([%#sprod] idemp'0 self._p1 = (op'1 self self = self))
  else
    [%#sprod] false = (op'1 self self = self)
  )
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__commutative [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 37 37 37 39
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  constant a  : tuple
  
  constant b  : tuple
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a'0: tuple) (b'0: tuple) : ()
  
  goal vc_commutative: [%#sprod] op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__associative [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 42 46 42 48
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  constant a  : tuple
  
  constant b  : tuple
  
  constant c  : tuple
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a'0: tuple) (b'0: tuple) (c'0: tuple) : ()
  
  
  goal vc_associative: [%#sprod] op'1 (op'1 a b) c = op'1 a (op'1 b c)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__valid_op [#"../../creusot-contracts/src/logic/ra/prod.rs" 47 4 47 30] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 100 14 100 49
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 46 14 46 49
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 44 4 44 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 14 4 14 12
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'0] op'0 a b = op'0 b a
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_U) : bool
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 16 4 16 26] (self: tuple) : bool =
    [%#sprod'1] valid self._p0 /\ valid'0 self._p1
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'2] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  function valid_op [#"../../creusot-contracts/src/logic/ra.rs" 101 4 101 31] (self: t_T) (b: t_T) : ()
  
  axiom valid_op_spec: forall self: t_T, b: t_T. [%#sra] valid (op self b)  -> valid self
  
  function valid_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 101 4 101 31] (self: t_U) (b: t_U) : ()
  
  axiom valid_op_spec'0: forall self: t_U, b: t_U. [%#sra] valid'0 (op'0 self b)  -> valid'0 self
  
  constant self  : tuple
  
  constant b  : tuple
  
  function valid_op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 47 4 47 30] (self'0: tuple) (b'0: tuple) : ()
  
  goal vc_valid_op: ([%#sra] valid (op self._p0 b._p0)  -> valid self._p0)
   -> (let _ = valid_op self._p0 b._p0 in ([%#sra] valid'0 (op'0 self._p1 b._p1)  -> valid'0 self._p1)
   -> (let _ = valid_op'0 self._p1 b._p1 in [%#sprod] valid'1 (op'1 self b)  -> valid'1 self))
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__maximal_idemp [#"../../creusot-contracts/src/logic/ra/prod.rs" 60 4 60 26] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 106 15 106 27
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 108 8 110 67
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 54 15 54 27
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 56 8 58 67
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 52 4 52 12
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 14 4 14 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'6 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'7 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'4] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'3] op'0 a b = op'0 b a
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_U) : bool
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 16 4 16 26] (self: tuple) : bool =
    [%#sprod'2] valid self._p0 /\ valid'0 self._p1
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'7] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra'1] incl self other = (exists c: t_T. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_U) (other: t_U) : bool
  
  axiom incl_spec'0: forall self: t_U, other: t_U. [%#sra'1] incl'0 self other = (exists c: t_U. op'0 self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'4] incl self._p0 other._p0 /\ incl'0 self._p1 other._p1
  
  axiom incl_spec'1: forall self: tuple, other: tuple. [%#sprod'3] incl'1 self other
  = (exists c: tuple. op'1 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra'2] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_U) : bool
  
  axiom idemp_spec'0: forall self: t_U. [%#sra'2] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self: tuple) : bool =
    [%#sprod'6] idemp self._p0 /\ idemp'0 self._p1
  
  axiom idemp_spec'1: forall self: tuple. [%#sprod'5] idemp'1 self = (op'1 self self = self)
  
  function maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 112 4 112 27] (self: t_T) : ()
  
  axiom maximal_idemp_spec: forall self: t_T. ([%#sra] valid self)
   -> ([%#sra'0] (forall b: t_T. not (incl b self /\ idemp b))
  \/ (exists b: t_T. incl b self /\ idemp b /\ (forall c: t_T. incl c self /\ idemp c  -> incl c b)))
  
  function maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 112 4 112 27] (self: t_U) : ()
  
  axiom maximal_idemp_spec'0: forall self: t_U. ([%#sra] valid'0 self)
   -> ([%#sra'0] (forall b: t_U. not (incl'0 b self /\ idemp'0 b))
  \/ (exists b: t_U. incl'0 b self /\ idemp'0 b /\ (forall c: t_U. incl'0 c self /\ idemp'0 c  -> incl'0 c b)))
  
  constant self  : tuple
  
  function maximal_idemp'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 60 4 60 26] (self'0: tuple) : ()
  
  goal vc_maximal_idemp: ([%#sprod] valid'1 self)
   -> ([@expl:maximal_idemp requires] [%#sra] valid self._p0)
  /\ (([%#sra'0] (forall b: t_T. not (incl b self._p0 /\ idemp b))
  \/ (exists b: t_T. incl b self._p0 /\ idemp b /\ (forall c: t_T. incl c self._p0 /\ idemp c  -> incl c b)))
   -> (let _ = maximal_idemp self._p0 in ([@expl:maximal_idemp requires] [%#sra] valid'0 self._p1)
  /\ (([%#sra'0] (forall b: t_U. not (incl'0 b self._p1 /\ idemp'0 b))
  \/ (exists b: t_U. incl'0 b self._p1 /\ idemp'0 b /\ (forall c: t_U. incl'0 c self._p1 /\ idemp'0 c  -> incl'0 c b)))
   -> (let _ = maximal_idemp'0 self._p1 in [%#sprod'0] (forall b: tuple. not (incl'1 b self /\ idemp'1 b))
  \/ (exists b: tuple. incl'1 b self /\ idemp'1 b /\ (forall c: tuple. incl'1 c self /\ idemp'1 c  -> incl'1 c b))))))
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__incl [#"../../creusot-contracts/src/logic/ra/sum.rs" 42 4 42 38] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 41 14 41 61
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 43 8 48 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra] incl self other = (exists c: t_T. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_U) (other: t_U) : bool
  
  axiom incl_spec'0: forall self: t_U, other: t_U. [%#sra] incl'0 self other = (exists c: t_U. op'0 self c = other)
  
  constant self  : t_Sum
  
  constant other  : t_Sum
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 42 4 42 38] (self'0: t_Sum) (other'0: t_Sum) : bool
  
  goal vc_incl: match { _p0 = self; _p1 = other } with
    | {_p0 = C_Left x ; _p1 = C_Left y} -> ([%#sra] incl x y = (exists c: t_T. op x c = y))
     -> ([%#ssum] incl x y = (exists c: t_Sum. op'1 self c = other))
    | {_p0 = C_Right x ; _p1 = C_Right y} -> ([%#sra] incl'0 x y = (exists c: t_U. op'0 x c = y))
     -> ([%#ssum] incl'0 x y = (exists c: t_Sum. op'1 self c = other))
    | {_p1 = C_Bot} -> [%#ssum] true = (exists c: t_Sum. op'1 self c = other)
    | _ -> [%#ssum] false = (exists c: t_Sum. op'1 self c = other)
    end
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__idemp [#"../../creusot-contracts/src/logic/ra/sum.rs" 54 4 54 26] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 53 14 53 47
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 55 8 59 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_U) : bool
  
  axiom idemp_spec'0: forall self: t_U. [%#sra] idemp'0 self = (op'0 self self = self)
  
  constant self  : t_Sum
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 54 4 54 26] (self'0: t_Sum) : bool
  
  goal vc_idemp: match self with
    | C_Left x -> ([%#sra] idemp x = (op x x = x))  -> ([%#ssum] idemp x = (op'1 self self = self))
    | C_Right x -> ([%#sra] idemp'0 x = (op'0 x x = x))  -> ([%#ssum] idemp'0 x = (op'1 self self = self))
    | C_Bot -> [%#ssum] true = (op'1 self self = self)
    end
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__commutative [#"../../creusot-contracts/src/logic/ra/sum.rs" 65 4 65 36] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 64 14 64 32
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 65 37 65 39
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  constant a  : t_Sum
  
  constant b  : t_Sum
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 65 4 65 36] (a'0: t_Sum) (b'0: t_Sum) : ()
  
  goal vc_commutative: [%#ssum] op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__associative [#"../../creusot-contracts/src/logic/ra/sum.rs" 70 4 70 45] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 69 14 69 44
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 70 46 70 48
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  constant a  : t_Sum
  
  constant b  : t_Sum
  
  constant c  : t_Sum
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 70 4 70 45] (a'0: t_Sum) (b'0: t_Sum) (c'0: t_Sum) : ()
  
  
  goal vc_associative: [%#ssum] op'1 (op'1 a b) c = op'1 a (op'1 b c)
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__valid_op [#"../../creusot-contracts/src/logic/ra/sum.rs" 75 4 75 30] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 100 14 100 49
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 74 14 74 49
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 76 8 76 36
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 32 8 36 9
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'0] op'0 a b = op'0 b a
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_U) : bool
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 31 4 31 26] (self: t_Sum) : bool =
    [%#ssum'1] match self with
      | C_Left x -> valid x
      | C_Right x -> valid'0 x
      | C_Bot -> false
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  function valid_op [#"../../creusot-contracts/src/logic/ra.rs" 101 4 101 31] (self: t_T) (b: t_T) : ()
  
  axiom valid_op_spec: forall self: t_T, b: t_T. [%#sra] valid (op self b)  -> valid self
  
  function valid_op'0 [#"../../creusot-contracts/src/logic/ra.rs" 101 4 101 31] (self: t_U) (b: t_U) : ()
  
  axiom valid_op_spec'0: forall self: t_U, b: t_U. [%#sra] valid'0 (op'0 self b)  -> valid'0 self
  
  constant self  : t_Sum
  
  constant b  : t_Sum
  
  function valid_op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 75 4 75 30] (self'0: t_Sum) (b'0: t_Sum) : ()
  
  goal vc_valid_op: let _ = valid_op in let _ = valid_op'0 in [%#ssum] valid'1 (op'1 self b)  -> valid'1 self
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__maximal_idemp [#"../../creusot-contracts/src/logic/ra/sum.rs" 88 4 88 26] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 106 15 106 27
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 108 8 110 67
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 82 15 82 27
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 84 8 86 67
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 89 8 93 9
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 32 8 36 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 41 14 41 61
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 43 8 48 9
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 53 14 53 47
  let%span ssum'6 = "../../creusot-contracts/src/logic/ra/sum.rs" 55 8 59 9
  let%span ssum'7 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'4] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'3] op'0 a b = op'0 b a
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_U) : bool
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 31 4 31 26] (self: t_Sum) : bool =
    [%#ssum'2] match self with
      | C_Left x -> valid x
      | C_Right x -> valid'0 x
      | C_Bot -> false
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'7] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra'1] incl self other = (exists c: t_T. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_U) (other: t_U) : bool
  
  axiom incl_spec'0: forall self: t_U, other: t_U. [%#sra'1] incl'0 self other = (exists c: t_U. op'0 self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 42 4 42 38] (self: t_Sum) (other: t_Sum) : bool =
    [%#ssum'4] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> incl x y
      | {_p0 = C_Right x ; _p1 = C_Right y} -> incl'0 x y
      | {_p1 = C_Bot} -> true
      | _ -> false
      end
  
  axiom incl_spec'1: forall self: t_Sum, other: t_Sum. [%#ssum'3] incl'1 self other
  = (exists c: t_Sum. op'1 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra'2] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_U) : bool
  
  axiom idemp_spec'0: forall self: t_U. [%#sra'2] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 54 4 54 26] (self: t_Sum) : bool =
    [%#ssum'6] match self with
      | C_Left x -> idemp x
      | C_Right x -> idemp'0 x
      | C_Bot -> true
      end
  
  axiom idemp_spec'1: forall self: t_Sum. [%#ssum'5] idemp'1 self = (op'1 self self = self)
  
  function maximal_idemp [#"../../creusot-contracts/src/logic/ra.rs" 112 4 112 27] (self: t_T) : ()
  
  axiom maximal_idemp_spec: forall self: t_T. ([%#sra] valid self)
   -> ([%#sra'0] (forall b: t_T. not (incl b self /\ idemp b))
  \/ (exists b: t_T. incl b self /\ idemp b /\ (forall c: t_T. incl c self /\ idemp c  -> incl c b)))
  
  function maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 112 4 112 27] (self: t_U) : ()
  
  axiom maximal_idemp_spec'0: forall self: t_U. ([%#sra] valid'0 self)
   -> ([%#sra'0] (forall b: t_U. not (incl'0 b self /\ idemp'0 b))
  \/ (exists b: t_U. incl'0 b self /\ idemp'0 b /\ (forall c: t_U. incl'0 c self /\ idemp'0 c  -> incl'0 c b)))
  
  constant self  : t_Sum
  
  function maximal_idemp'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 88 4 88 26] (self'0: t_Sum) : ()
  
  goal vc_maximal_idemp: ([%#ssum] valid'1 self)
   -> match self with
    | C_Left x -> ([@expl:maximal_idemp requires] [%#sra] valid x)
    /\ (([%#sra'0] (forall b: t_T. not (incl b x /\ idemp b))
    \/ (exists b: t_T. incl b x /\ idemp b /\ (forall c: t_T. incl c x /\ idemp c  -> incl c b)))
     -> ([%#ssum'0] (forall b: t_Sum. not (incl'1 b self /\ idemp'1 b))
    \/ (exists b: t_Sum. incl'1 b self /\ idemp'1 b /\ (forall c: t_Sum. incl'1 c self /\ idemp'1 c  -> incl'1 c b))))
    | C_Right x -> ([@expl:maximal_idemp requires] [%#sra] valid'0 x)
    /\ (([%#sra'0] (forall b: t_U. not (incl'0 b x /\ idemp'0 b))
    \/ (exists b: t_U. incl'0 b x /\ idemp'0 b /\ (forall c: t_U. incl'0 c x /\ idemp'0 c  -> incl'0 c b)))
     -> ([%#ssum'0] (forall b: t_Sum. not (incl'1 b self /\ idemp'1 b))
    \/ (exists b: t_Sum. incl'1 b self /\ idemp'1 b /\ (forall c: t_Sum. incl'1 c self /\ idemp'1 c  -> incl'1 c b))))
    | C_Bot -> [%#ssum'0] (forall b: t_Sum. not (incl'1 b self /\ idemp'1 b))
    \/ (exists b: t_Sum. incl'1 b self /\ idemp'1 b /\ (forall c: t_Sum. incl'1 c self /\ idemp'1 c  -> incl'1 c b))
    end
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__incl [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 61
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 96 8 96 61
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'0] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'2] rel a f1)
   -> ([%#sview'3] incl f2 f1)  -> ([%#sview'4] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'3] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'2] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'2] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'3] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'2] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'1] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'0] other = C_Bot
  
  axiom incl_spec'0: forall self: t_Excl, other: t_Excl. [%#sexcl] incl'0 self other
  = (exists c: t_Excl. op'0 self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> true
      | {_p1'0 = C_None} -> false
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> x = y \/ incl'0 x y
      end
  
  axiom incl_spec'1: forall self: t_Option, other: t_Option. [%#soption] incl'1 self other
  = (exists c: t_Option. op'1 self c = other)
  
  function incl'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option'0) (other: t_Option'0) : bool
  
   =
    [%#soption'0] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> true
      | {_p1'1 = C_None'0} -> false
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'2: forall self: t_Option'0, other: t_Option'0. [%#soption] incl'2 self other
  = (exists c: t_Option'0. op'2 self c = other)
  
  function incl'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'0] incl'1 self._p0 other._p0 /\ incl'2 self._p1 other._p1
  
  axiom incl_spec'3: forall self: tuple, other: tuple. [%#sprod] incl'3 self other
  = (exists c: tuple. op'3 self c = other)
  
  constant self  : t_View
  
  constant other  : t_View
  
  function incl'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (self'0: t_View) (other'0: t_View) : bool
  
  goal vc_incl: ([%#sprod] incl'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                         _p1 = other.t_View__frag }
  = (exists c: tuple. op'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } c
  = { _p0 = other.t_View__auth; _p1 = other.t_View__frag }))
   -> ([%#sview] incl'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                               _p1 = other.t_View__frag }
  = (exists c: t_View. op'4 self c = other))
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__idemp [#"../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 101 14 101 47
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 103 8 103 38
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'0] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra'2] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'2] rel a f1)
   -> ([%#sview'3] incl f2 f1)  -> ([%#sview'4] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'3] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'2] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'2] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'3] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'2] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'1] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self: t_Excl) : bool =
    [%#sexcl'0] self = C_Bot
  
  axiom idemp_spec: forall self: t_Excl. [%#sexcl] idemp self = (op'0 self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'0] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption] idemp'0 self = (op'1 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_Frag) : bool
  
  axiom idemp_spec'1: forall self: t_Frag. [%#sra] idemp'1 self = (op self self = self)
  
  function idemp'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option'0) : bool =
    [%#soption'0] match self with
      | C_None'0 -> true
      | C_Some'0 x -> idemp'1 x
      end
  
  axiom idemp_spec'2: forall self: t_Option'0. [%#soption] idemp'2 self = (op'2 self self = self)
  
  function idemp'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self: tuple) : bool =
    [%#sprod'0] idemp'0 self._p0 /\ idemp'2 self._p1
  
  axiom idemp_spec'3: forall self: tuple. [%#sprod] idemp'3 self = (op'3 self self = self)
  
  constant self  : t_View
  
  function idemp'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26] (self'0: t_View) : bool
  
  goal vc_idemp: ([%#sprod] idemp'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag }
  = (op'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = self.t_View__auth; _p1 = self.t_View__frag }
  = { _p0 = self.t_View__auth; _p1 = self.t_View__frag }))
   -> ([%#sview] idemp'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } = (op'4 self self = self))
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__commutative [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 109 37 109 39
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'0] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'2] rel a f1)
   -> ([%#sview'3] incl f2 f1)  -> ([%#sview'4] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'1] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  constant a  : t_View
  
  constant b  : t_View
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a'0: t_View) (b'0: t_View) : ()
  
  goal vc_commutative: [%#sview] op'4 a b = op'4 b a
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__associative [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 114 46 114 48
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'0] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'2] rel a f1)
   -> ([%#sview'3] incl f2 f1)  -> ([%#sview'4] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'1] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  constant a  : t_View
  
  constant b  : t_View
  
  constant c  : t_View
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a'0: t_View) (b'0: t_View) (c'0: t_View) : ()
  
  
  goal vc_associative: [%#sview] op'4 (op'4 a b) c = op'4 a (op'4 b c)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__valid_op [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 30] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 100 14 100 49
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 118 14 118 49
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 120 8 120 42
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'0] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra'2] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'3] rel a f1)
   -> ([%#sview'4] incl f2 f1)  -> ([%#sview'5] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_Frag) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'1] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid f /\ (exists a: t_Auth. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'2] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function valid_op [#"../../creusot-contracts/src/logic/ra.rs" 101 4 101 31] (self: t_Frag) (b: t_Frag) : ()
  
  axiom valid_op_spec: forall self: t_Frag, b: t_Frag. [%#sra] valid (op self b)  -> valid self
  
  constant self  : t_View
  
  constant b  : t_View
  
  function valid_op'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 30] (self'0: t_View) (b'0: t_View) : ()
  
  goal vc_valid_op: let _ = valid_op in [%#sview] valid'0 (op'4 self b)  -> valid'0 self
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__maximal_idemp [#"../../creusot-contracts/src/logic/ra/view.rs" 131 4 131 26] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 79 15 79 27
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 81 8 83 67
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'6 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'7 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 125 15 125 27
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 127 8 129 67
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 123 4 123 12
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 61
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 96 8 96 61
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 101 14 101 47
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 103 8 103 38
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'9 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'10 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 24 8 27 9
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  let%span sexcl'6 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'2] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra'1] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'8] rel a f1)
   -> ([%#sview'9] incl f2 f1)  -> ([%#sview'10] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_Frag) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'2] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid f /\ (exists a: t_Auth. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'6] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'5] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'4] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'7] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'6] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'7] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'6] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'3] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'5] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'4] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'7] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'1] other = C_Bot
  
  axiom incl_spec'0: forall self: t_Excl, other: t_Excl. [%#sexcl'0] incl'0 self other
  = (exists c: t_Excl. op'0 self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'3] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> true
      | {_p1'0 = C_None} -> false
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> x = y \/ incl'0 x y
      end
  
  axiom incl_spec'1: forall self: t_Option, other: t_Option. [%#soption'2] incl'1 self other
  = (exists c: t_Option. op'1 self c = other)
  
  function incl'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option'0) (other: t_Option'0) : bool
  
   =
    [%#soption'3] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> true
      | {_p1'1 = C_None'0} -> false
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'2: forall self: t_Option'0, other: t_Option'0. [%#soption'2] incl'2 self other
  = (exists c: t_Option'0. op'2 self c = other)
  
  function incl'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'0] incl'1 self._p0 other._p0 /\ incl'2 self._p1 other._p1
  
  axiom incl_spec'3: forall self: tuple, other: tuple. [%#sprod] incl'3 self other
  = (exists c: tuple. op'3 self c = other)
  
  function incl'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (self: t_View) (other: t_View) : bool =
    [%#sview'4] incl'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                              _p1 = other.t_View__frag }
  
  axiom incl_spec'4: forall self: t_View, other: t_View. [%#sview'3] incl'4 self other
  = (exists c: t_View. op'4 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self: t_Excl) : bool =
    [%#sexcl'3] self = C_Bot
  
  axiom idemp_spec: forall self: t_Excl. [%#sexcl'2] idemp self = (op'0 self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'5] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption'4] idemp'0 self = (op'1 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_Frag) : bool
  
  axiom idemp_spec'1: forall self: t_Frag. [%#sra'0] idemp'1 self = (op self self = self)
  
  function idemp'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option'0) : bool =
    [%#soption'5] match self with
      | C_None'0 -> true
      | C_Some'0 x -> idemp'1 x
      end
  
  axiom idemp_spec'2: forall self: t_Option'0. [%#soption'4] idemp'2 self = (op'2 self self = self)
  
  function idemp'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self: tuple) : bool =
    [%#sprod'2] idemp'0 self._p0 /\ idemp'2 self._p1
  
  axiom idemp_spec'3: forall self: tuple. [%#sprod'1] idemp'3 self = (op'3 self self = self)
  
  function idemp'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26] (self: t_View) : bool =
    [%#sview'6] idemp'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag }
  
  axiom idemp_spec'4: forall self: t_View. [%#sview'5] idemp'4 self = (op'4 self self = self)
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/excl.rs" 23 4 23 26] (self: t_Excl) : bool =
    [%#sexcl] match self with
      | C_Excl _ -> true
      | C_Bot -> false
      end
  
  function valid'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption'1] match self with
      | C_Some x -> valid'1 x
      | C_None -> true
      end
  
  function maximal_idemp [#"../../creusot-contracts/src/logic/ra/option.rs" 85 4 85 26] (self: t_Option) : ()
  
  axiom maximal_idemp_spec: forall self: t_Option. ([%#soption] valid'2 self)
   -> ([%#soption'0] (forall b: t_Option. not (incl'1 b self /\ idemp'0 b))
  \/ (exists b: t_Option. incl'1 b self
  /\ idemp'0 b /\ (forall c: t_Option. incl'1 c self /\ idemp'0 c  -> incl'1 c b)))
  
  function valid'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option'0) : bool =
    [%#soption'1] match self with
      | C_Some'0 x -> valid x
      | C_None'0 -> true
      end
  
  function maximal_idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 85 4 85 26] (self: t_Option'0) : ()
  
  axiom maximal_idemp_spec'0: forall self: t_Option'0. ([%#soption] valid'3 self)
   -> ([%#soption'0] (forall b: t_Option'0. not (incl'2 b self /\ idemp'2 b))
  \/ (exists b: t_Option'0. incl'2 b self
  /\ idemp'2 b /\ (forall c: t_Option'0. incl'2 c self /\ idemp'2 c  -> incl'2 c b)))
  
  constant self  : t_View
  
  function maximal_idemp'1 [#"../../creusot-contracts/src/logic/ra/view.rs" 131 4 131 26] (self'0: t_View) : ()
  
  goal vc_maximal_idemp: ([%#sview] valid'0 self)
   -> ([@expl:maximal_idemp requires] [%#soption] valid'2 self.t_View__auth)
  /\ (([%#soption'0] (forall b: t_Option. not (incl'1 b self.t_View__auth /\ idemp'0 b))
  \/ (exists b: t_Option. incl'1 b self.t_View__auth
  /\ idemp'0 b /\ (forall c: t_Option. incl'1 c self.t_View__auth /\ idemp'0 c  -> incl'1 c b)))
   -> (let _ = maximal_idemp self.t_View__auth in ([@expl:maximal_idemp requires] [%#soption] valid'3 self.t_View__frag)
  /\ (([%#soption'0] (forall b: t_Option'0. not (incl'2 b self.t_View__frag /\ idemp'2 b))
  \/ (exists b: t_Option'0. incl'2 b self.t_View__frag
  /\ idemp'2 b /\ (forall c: t_Option'0. incl'2 c self.t_View__frag /\ idemp'2 c  -> incl'2 c b)))
   -> (let _ = maximal_idemp'0 self.t_View__frag in [%#sview'0] (forall b: t_View. not (incl'4 b self /\ idemp'4 b))
  \/ (exists b: t_View. incl'4 b self /\ idemp'4 b /\ (forall c: t_View. incl'4 c self /\ idemp'4 c  -> incl'4 c b))))))
end
module M_creusot_contracts__logic__ra__incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 121 0 121 47]
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 119 11 119 33
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 120 10 120 19
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 121 48 121 50
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'3 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'4 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'4] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'3] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra'2] incl self other = (exists c: t_T. op self c = other)
  
  constant a  : t_T
  
  constant b  : t_T
  
  constant c  : t_T
  
  function incl_transitive [#"../../creusot-contracts/src/logic/ra.rs" 121 0 121 47] (a'0: t_T) (b'0: t_T) (c'0: t_T) : ()
  
  
  goal vc_incl_transitive: ([%#sra] incl a b /\ incl b c)  -> ([%#sra'0] incl a c)
end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__flat_map [#"../../creusot-contracts/src/logic/seq.rs" 292 4 292 73] (* logic::seq::Seq<T> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 291 14 291 24
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 293 8 297 9
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_T
  
  type t_U
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq t_T) : Seq.seq t_T =
    [%#sseq'1] Seq.([..]) self 1 (Seq.length self)
  
  constant self  : Seq.seq t_T
  
  constant other  : Map.map t_T (Seq.seq t_U)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 292 4 292 73] (self'0: Seq.seq t_T) (other'0: Map.map t_T (Seq.seq t_U)) : Seq.seq t_U
  
  
  goal vc_flat_map: if Seq.length self = 0 then
    true
  else
    0 <= ([%#sseq] Seq.length self) /\ ([%#sseq] Seq.length (tail self)) < ([%#sseq] Seq.length self)

end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17] (* logic::seq::Seq<T> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq'1] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  function concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 391 4 393 17]  : ()
  
  goal vc_concat_contains: [%#sseq] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains (Seq.(++) a b) x
  = contains a x
  \/ contains b x
end
module M_creusot_contracts__logic__seq__qyi16115490154402163220__flatten [#"../../creusot-contracts/src/logic/seq.rs" 402 4 402 34] (* logic::seq::Seq<logic::seq::Seq<T>> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 401 14 401 24
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 403 8 407 9
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq (Seq.seq t_T)) : Seq.seq (Seq.seq t_T)
  
   =
    [%#sseq'1] Seq.([..]) self 1 (Seq.length self)
  
  constant self  : Seq.seq (Seq.seq t_T)
  
  function flatten [#"../../creusot-contracts/src/logic/seq.rs" 402 4 402 34] (self'0: Seq.seq (Seq.seq t_T)) : Seq.seq t_T
  
  
  goal vc_flatten: if Seq.length self = 0 then
    true
  else
    0 <= ([%#sseq] Seq.length self) /\ ([%#sseq] Seq.length (tail self)) < ([%#sseq] Seq.length self)

end
module M_creusot_contracts__logic__seq__flat_map_singleton [#"../../creusot-contracts/src/logic/seq.rs" 704 0 704 33]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 703 10 703 87
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 704 34 704 36
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 291 14 291 24
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 293 8 297 9
  let%span sseq'3 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use seq.Seq
  use map.Map
  
  type t_A
  
  type t_B
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq t_A) : Seq.seq t_A =
    [%#sseq'3] Seq.([..]) self 1 (Seq.length self)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 292 4 292 73] (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  
  axiom flat_map_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map self other
  = ([%#sseq'2] if Seq.length self = 0 then
    Seq.empty: Seq.seq t_B
  else
    Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
  )
  
  function flat_map_singleton [#"../../creusot-contracts/src/logic/seq.rs" 704 0 704 33]  : ()
  
  goal vc_flat_map_singleton: [%#sseq] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.singleton x) f
  = Map.get f x
end
module M_creusot_contracts__logic__seq__flat_map_push_back [#"../../creusot-contracts/src/logic/seq.rs" 710 0 710 43]
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 708 10 708 108
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 709 10 709 18
  let%span sseq'1 = "../../creusot-contracts/src/logic/seq.rs" 713 24 713 85
  let%span sseq'2 = "../../creusot-contracts/src/logic/seq.rs" 711 4 714 5
  let%span sseq'3 = "../../creusot-contracts/src/logic/seq.rs" 291 14 291 24
  let%span sseq'4 = "../../creusot-contracts/src/logic/seq.rs" 293 8 297 9
  let%span sseq'5 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use seq.Seq
  use map.Map
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  function tail [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self: Seq.seq t_A) : Seq.seq t_A =
    [%#sseq'5] Seq.([..]) self 1 (Seq.length self)
  
  function flat_map [#"../../creusot-contracts/src/logic/seq.rs" 292 4 292 73] (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  
  axiom flat_map_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map self other
  = ([%#sseq'4] if Seq.length self = 0 then
    Seq.empty: Seq.seq t_B
  else
    Seq.(++) (Map.get other (Seq.get self 0)) (flat_map (tail self) other)
  )
  
  constant xs  : Seq.seq t_A
  
  function flat_map_push_back [#"../../creusot-contracts/src/logic/seq.rs" 710 0 710 43] (xs'0: Seq.seq t_A) : ()
  
  goal vc_flat_map_push_back: if Seq.length xs > 0 then
    (0 <= ([%#sseq'0] Seq.length xs) /\ ([%#sseq'0] Seq.length (tail xs)) < ([%#sseq'0] Seq.length xs))
    /\ (([%#sseq] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc (tail xs) x) f
    = Seq.(++) (flat_map (tail xs) f) (Map.get f x))
     -> (let _ = flat_map_push_back (tail xs) in ([%#sseq'1] forall x: t_A. Seq.snoc (tail xs) x = tail (Seq.snoc xs x))
    && (let _ = () in [%#sseq] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc xs x) f
    = Seq.(++) (flat_map xs f) (Map.get f x))))
  else
    [%#sseq] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map (Seq.snoc xs x) f
    = Seq.(++) (flat_map xs f) (Map.get f x)

end
module M_creusot_contracts__pcell__qyi14846468513926953542__take [#"../../creusot-contracts/src/pcell.rs" 267 4 267 65] (* pcell::PCell<T> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 267 24 267 28
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 267 30 267 34
  let%span spcell'1 = "../../creusot-contracts/src/pcell.rs" 263 15 263 37
  let%span spcell'2 = "../../creusot-contracts/src/pcell.rs" 267 64 267 65
  let%span spcell'3 = "../../creusot-contracts/src/pcell.rs" 264 14 264 53
  let%span spcell'4 = "../../creusot-contracts/src/pcell.rs" 265 14 265 46
  let%span spcell'5 = "../../creusot-contracts/src/pcell.rs" 266 14 266 66
  let%span spcell'6 = "../../creusot-contracts/src/pcell.rs" 140 27 140 31
  let%span spcell'7 = "../../creusot-contracts/src/pcell.rs" 140 33 140 37
  let%span spcell'8 = "../../creusot-contracts/src/pcell.rs" 140 64 140 67
  let%span spcell'9 = "../../creusot-contracts/src/pcell.rs" 136 15 136 37
  let%span spcell'10 = "../../creusot-contracts/src/pcell.rs" 140 75 140 76
  let%span spcell'11 = "../../creusot-contracts/src/pcell.rs" 137 14 137 43
  let%span spcell'12 = "../../creusot-contracts/src/pcell.rs" 138 14 138 46
  let%span spcell'13 = "../../creusot-contracts/src/pcell.rs" 139 14 139 53
  let%span spcell'14 = "../../creusot-contracts/src/pcell.rs" 36 8 36 19
  let%span spcell'15 = "../../creusot-contracts/src/pcell.rs" 61 20 61 41
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition () args]. (let () = args in true)  -> precondition () args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: ()) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: (), res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let () = args in inv res)
  
  let rec default (return'  (x:t_T))= {[@expl:default requires] precondition () ()}
    any [ return''0 (result:t_T)-> {postcondition_once () () result} (! return' {result}) ] 
  
  type t_UnsafeCell  =
    { t_UnsafeCell__value: t_T }
  
  type t_PCell  =
    { t_PCell__0: t_UnsafeCell }
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_UnsafeCell)
  
  axiom inv_axiom [@rewrite]: forall x: t_UnsafeCell [inv'0 x]. inv'0 x
  = match x with
    | {t_UnsafeCell__value = value} -> inv value
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCell)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PCell [inv'1 x]. inv'1 x
  = match x with
    | {t_PCell__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_PCell) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCell)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PCell [inv'2 x]. inv'2 x = invariant' x
  
  function val' [#"../../creusot-contracts/src/pcell.rs" 81 4 81 33] (self: t_PCellOwn) : t_T
  
  function view [#"../../creusot-contracts/src/pcell.rs" 35 4 35 33] (self: t_PCellOwn) : t_T =
    [%#spcell'14] val' self
  
  predicate invariant''0 [#"../../creusot-contracts/src/pcell.rs" 60 4 60 30] (self: t_PCellOwn) =
    [%#spcell'15] inv (view self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCellOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PCellOwn [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_PCellOwn) =
    [%#sinvariant'0] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_PCellOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_PCellOwn [inv'4 x]. inv'4 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  (MutBorrow.t t_PCellOwn)) =
    [%#sghost] inv'4 self
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  (MutBorrow.t t_PCellOwn))
  
  axiom inv_axiom'4 [@rewrite]: forall x:  (MutBorrow.t t_PCellOwn) [inv'5 x]. inv'5 x = invariant''2 x
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/pcell.rs" 225 4 225 25] (self: t_PCell) : t_Id
  
  function id'0 [#"../../creusot-contracts/src/pcell.rs" 74 4 74 25] (self: t_PCellOwn) : t_Id
  
  let rec replace (self:t_PCell) (perm: (MutBorrow.t t_PCellOwn)) (val''0:t_T) (return'  (x:t_T))= {[@expl:replace 'self' type invariant] [%#spcell'6] inv'2 self}
    {[@expl:replace 'perm' type invariant] [%#spcell'7] inv'5 perm}
    {[@expl:replace 'val' type invariant] [%#spcell'8] inv val''0}
    {[@expl:replace requires] [%#spcell'9] id self = id'0 perm.current}
    any
    [ return''0 (result:t_T)-> {[%#spcell'10] inv result}
      {[%#spcell'11] val''0 = view perm.final}
      {[%#spcell'12] result = view perm.current}
      {[%#spcell'13] id self = id'0 perm.final}
      (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: (), res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let () = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: (), res: t_T [postcondition () args res]. postcondition () args res
   -> (let () = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec take[#"../../creusot-contracts/src/pcell.rs" 267 4 267 65] (self:t_PCell) (perm: (MutBorrow.t t_PCellOwn)) (return'  (x:t_T))= {[@expl:take 'self' type invariant] [%#spcell] inv'2 self}
    {[@expl:take 'perm' type invariant] [%#spcell'0] inv'5 perm}
    {[@expl:take requires] [%#spcell'1] id self = id'0 perm.current}
    (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:t_T) ->  [ &_9 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = replace {self'0} {perm'0} {_9} (fun (_ret:t_T) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    )
    [ & _0: t_T = Any.any_l ()
    | & self'0: t_PCell = self
    | & perm'0:  (MutBorrow.t t_PCellOwn) = perm
    | & _9: t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:take result type invariant] [%#spcell'2] inv result}
      {[@expl:take ensures #0] [%#spcell'3] id self = id'0 perm.final}
      {[@expl:take ensures #1] [%#spcell'4] result = view perm.current}
      {[@expl:take ensures #2] [%#spcell'5] postcondition () () (view perm.final)}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18263836234684628832__clone [#"../../creusot-contracts/src/peano.rs" 33 9 33 14] (* <peano::PeanoInt as std::clone::Clone> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  let%span speano = "../../creusot-contracts/src/peano.rs" 34 20 34 23
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  let rec clone' (self_:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = self_} (! return' {result}) ]
  
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: UInt64.t) (result: UInt64.t)
  
   =
    let self_ = args in result = self_
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: UInt64.t) (result_state: ()) (result: UInt64.t)
  
   =
    let self_ = args in result = self_
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  
  axiom fn_mut_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: UInt64.t) (result: UInt64.t)
  
   =
    let self_ = args in result = self_
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  
  axiom fn_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec clone''0[#"../../creusot-contracts/src/peano.rs" 33 9 33 14] (self:t_PeanoInt) (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- self'0.t_PeanoInt__0 ] s1
      | s1 = clone' {_5} (fun (_ret:UInt64.t) ->  [ &_3 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = _3 } ] s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0: t_PeanoInt = Any.any_l ()
    | & self'0: t_PeanoInt = self
    | & _3: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l () ]
    
    [ return''0 (result:t_PeanoInt)-> {[@expl:clone ensures] [%#speano] postcondition () self.t_PeanoInt__0 result.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi17635635094782400840__default [#"../../creusot-contracts/src/peano.rs" 33 22 33 29] (* <peano::PeanoInt as std::default::Default> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span snum = "../../creusot-contracts/src/std/num.rs" 30 26 30 41
  let%span speano = "../../creusot-contracts/src/peano.rs" 33 22 33 29
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec default (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = (0: UInt64.t)} (! return' {result}) ]
  
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: ()) (result: UInt64.t)
  
   =
    let () = args in result = (0: UInt64.t)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: ()) (result_state: ()) (result: UInt64.t)
  
   =
    let () = args in result = (0: UInt64.t)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: ()) (res: UInt64.t) : ()
  
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: UInt64.t. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: UInt64.t. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: ()) (result: UInt64.t)
  
   =
    let () = args in result = (0: UInt64.t)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: ()) (res: UInt64.t) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: UInt64.t. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: UInt64.t. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  let rec default'0[#"../../creusot-contracts/src/peano.rs" 33 22 33 29] (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0 [ s0 = default (fun (_ret:UInt64.t) ->  [ &_2 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = _2 } ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_PeanoInt = Any.any_l () | & _2: UInt64.t = Any.any_l () ] 
    [ return''0 (result:t_PeanoInt)-> {[@expl:default ensures] [%#speano] true
      /\ postcondition () () result.t_PeanoInt__0}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__new [#"../../creusot-contracts/src/peano.rs" 48 4 48 24] (* peano::PeanoInt *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 49 13 49 14
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 47 14 47 26
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self: t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  let rec new[#"../../creusot-contracts/src/peano.rs" 48 4 48 24] (return'  (x:t_PeanoInt))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0 = ([%#speano] (0: UInt64.t)) } ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_PeanoInt = Any.any_l () ] 
    [ return''0 (result:t_PeanoInt)-> {[@expl:new ensures] [%#speano'0] view result = 0} (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u64 [#"../../creusot-contracts/src/peano.rs" 78 4 78 30] (* peano::PeanoInt *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 77 14 77 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self: t_PeanoInt) : int =
    [%#speano'0] UInt64.t'int self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  let rec to_u64[#"../../creusot-contracts/src/peano.rs" 78 4 78 30] (self:t_PeanoInt) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0.t_PeanoInt__0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: UInt64.t = Any.any_l () | & self'0: t_PeanoInt = self ] 
    [ return''0 (result:UInt64.t)-> {[@expl:to_u64 ensures] [%#speano] UInt64.t'int result = view self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u128 [#"../../creusot-contracts/src/peano.rs" 93 4 93 32] (* peano::PeanoInt *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 92 14 92 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self: t_PeanoInt) : int =
    [%#speano'0] UInt64.t'int self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  let rec to_u128[#"../../creusot-contracts/src/peano.rs" 93 4 93 32] (self:t_PeanoInt) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt128.of_int {UInt64.t'int self'0.t_PeanoInt__0} (fun (_ret_from:UInt128.t) ->  [ &_0 <- _ret_from ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: UInt128.t = Any.any_l () | & self'0: t_PeanoInt = self ] 
    [ return''0 (result:UInt128.t)-> {[@expl:to_u128 ensures] [%#speano] UInt128.t'int result = view self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_i128 [#"../../creusot-contracts/src/peano.rs" 100 4 100 32] (* peano::PeanoInt *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 99 14 99 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self: t_PeanoInt) : int =
    [%#speano'0] UInt64.t'int self.t_PeanoInt__0
  
  meta "compute_max_steps" 1000000
  
  let rec to_i128[#"../../creusot-contracts/src/peano.rs" 100 4 100 32] (self:t_PeanoInt) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int128.of_int {UInt64.t'int self'0.t_PeanoInt__0} (fun (_ret_from:Int128.t) ->  [ &_0 <- _ret_from ] s1)
      | s1 = return''0 {_0} ]
     ]
    ) [ & _0: Int128.t = Any.any_l () | & self'0: t_PeanoInt = self ] 
    [ return''0 (result:Int128.t)-> {[@expl:to_i128 ensures] [%#speano] Int128.to_int result = view self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi924939193479538090__from [#"../../creusot-contracts/src/peano.rs" 107 4 107 34] (* <u64 as std::convert::From<peano::PeanoInt>> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 106 14 106 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 77 14 77 30
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self: t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  let rec to_u64 (self:t_PeanoInt) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#speano'0] UInt64.t'int result = view self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 107 4 107 34] (val':t_PeanoInt) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 = to_u64 {val''0} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: UInt64.t = Any.any_l () | & val''0: t_PeanoInt = val' ] 
    [ return''0 (result:UInt64.t)-> {[@expl:from ensures] [%#speano] UInt64.t'int result = view val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18279771819627139730__from [#"../../creusot-contracts/src/peano.rs" 114 4 114 34] (* <i64 as std::convert::From<peano::PeanoInt>> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 113 14 113 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 85 14 85 30
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.Int64
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self: t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  let rec to_i64 (self:t_PeanoInt) (return'  (x:Int64.t))= any
    [ return''0 (result:Int64.t)-> {[%#speano'0] Int64.to_int result = view self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 114 4 114 34] (val':t_PeanoInt) (return'  (x:Int64.t))= (! bb0
    [ bb0 = s0 [ s0 = to_i64 {val''0} (fun (_ret:Int64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ]  | bb1 = return''0 {_0} ]
    ) [ & _0: Int64.t = Any.any_l () | & val''0: t_PeanoInt = val' ] 
    [ return''0 (result:Int64.t)-> {[@expl:from ensures] [%#speano] Int64.to_int result = view val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi6128796959392123454__from [#"../../creusot-contracts/src/peano.rs" 121 4 121 34] (* <u128 as std::convert::From<peano::PeanoInt>> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 120 14 120 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 92 14 92 30
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.UInt128
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self: t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  let rec to_u128 (self:t_PeanoInt) (return'  (x:UInt128.t))= any
    [ return''0 (result:UInt128.t)-> {[%#speano'0] UInt128.t'int result = view self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 121 4 121 34] (val':t_PeanoInt) (return'  (x:UInt128.t))= (! bb0
    [ bb0 = s0 [ s0 = to_u128 {val''0} (fun (_ret:UInt128.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: UInt128.t = Any.any_l () | & val''0: t_PeanoInt = val' ] 
    [ return''0 (result:UInt128.t)-> {[@expl:from ensures] [%#speano] UInt128.t'int result = view val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi11594489632978387465__from [#"../../creusot-contracts/src/peano.rs" 128 4 128 34] (* <i128 as std::convert::From<peano::PeanoInt>> *)
  let%span speano = "../../creusot-contracts/src/peano.rs" 127 14 127 29
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 99 14 99 30
  let%span speano'1 = "../../creusot-contracts/src/peano.rs" 38 4 38 12
  
  use creusot.int.Int128
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view [#"../../creusot-contracts/src/peano.rs" 39 4 39 24] (self: t_PeanoInt) : int =
    [%#speano'1] UInt64.t'int self.t_PeanoInt__0
  
  let rec to_i128 (self:t_PeanoInt) (return'  (x:Int128.t))= any
    [ return''0 (result:Int128.t)-> {[%#speano'0] Int128.to_int result = view self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from[#"../../creusot-contracts/src/peano.rs" 128 4 128 34] (val':t_PeanoInt) (return'  (x:Int128.t))= (! bb0
    [ bb0 = s0 [ s0 = to_i128 {val''0} (fun (_ret:Int128.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: Int128.t = Any.any_l () | & val''0: t_PeanoInt = val' ] 
    [ return''0 (result:Int128.t)-> {[@expl:from ensures] [%#speano] Int128.to_int result = view val'}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__new [#"../../creusot-contracts/src/ptr_own.rs" 57 4 57 53] (* ptr_own::PtrOwn<T> *)
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 57 15 57 16
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 57 24 57 53
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 56 14 56 64
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 66 20 66 23
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 66 36 66 65
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 65 14 65 67
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 35 8 35 16
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 41 8 41 16
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_T }
  
  type tuple  =
    { _p0: Opaque.ptr; _p1:  t_PtrOwn }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self: Opaque.ptr) : UInt64.t
  
  function is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr [#"../../creusot-contracts/src/ptr_own.rs" 34 4 34 34] (self: t_PtrOwn) : Opaque.ptr =
    [%#sptr_own'5] self.t_PtrOwn__ptr
  
  predicate invariant''0 [#"../../creusot-contracts/src/ptr_own.rs" 48 4 48 30] (self: t_PtrOwn) =
    [%#sptr_own'7] not is_null_logic (ptr self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'0 val'
    end)
  
  predicate invariant''1 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_PtrOwn) =
    [%#sghost] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x:  t_PtrOwn [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple [inv'3 x]. inv'3 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'2 x1)
  
  function val' [#"../../creusot-contracts/src/ptr_own.rs" 40 4 40 34] (self: t_PtrOwn) : t_T =
    [%#sptr_own'6] self.t_PtrOwn__val
  
  let rec from_box (val''0:t_T) (return'  (x:tuple))= {[@expl:from_box 'val' type invariant] [%#sptr_own'2] inv'0 val''0}
    any
    [ return''0 (result:tuple)-> {[%#sptr_own'3] inv'3 result}
      {[%#sptr_own'4] ptr result._p1 = result._p0 /\ val' result._p1 = val''0}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec new[#"../../creusot-contracts/src/ptr_own.rs" 57 4 57 53] (v:t_T) (return'  (x:tuple))= {[@expl:new 'v' type invariant] [%#sptr_own] inv v}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0 [ s0 = from_box {v'0} (fun (_ret:tuple) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    ) [ & _0: tuple = Any.any_l () | & v'0: t_T = v ] 
    [ return''0 (result:tuple)-> {[@expl:new result type invariant] [%#sptr_own'0] inv'3 result}
      {[@expl:new ensures] [%#sptr_own'1] ptr result._p1 = result._p0 /\ val' result._p1 = v}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__drop [#"../../creusot-contracts/src/ptr_own.rs" 131 4 131 61] (* ptr_own::PtrOwn<T> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 62 8 62 23
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 131 39 131 42
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 130 15 130 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 118 41 118 44
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 115 15 115 31
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 118 67 118 73
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 116 14 116 35
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 35 8 35 16
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 41 8 41 16
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_T }
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self: Opaque.ptr) : UInt64.t
  
  function is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr [#"../../creusot-contracts/src/ptr_own.rs" 34 4 34 34] (self: t_PtrOwn) : Opaque.ptr =
    [%#sptr_own'5] self.t_PtrOwn__ptr
  
  predicate invariant' [#"../../creusot-contracts/src/ptr_own.rs" 48 4 48 30] (self: t_PtrOwn) =
    [%#sptr_own'7] not is_null_logic (ptr self)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant''0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'0 val'
    end)
  
  predicate invariant''1 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_PtrOwn) =
    [%#sghost] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x:  t_PtrOwn [inv'2 x]. inv'2 x = invariant''1 x
  
  function val' [#"../../creusot-contracts/src/ptr_own.rs" 40 4 40 34] (self: t_PtrOwn) : t_T =
    [%#sptr_own'6] self.t_PtrOwn__val
  
  let rec to_box (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:t_T))= {[@expl:to_box 'own' type invariant] [%#sptr_own'1] inv'2 own}
    {[@expl:to_box requires] [%#sptr_own'2] ptr'0 = ptr own}
    any
    [ return''0 (result:t_T)-> {[%#sptr_own'3] inv'0 result} {[%#sptr_own'4] result = val' own} (! return' {result}) ]
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 28] (self: t_T) =
    [%#sresolve] resolve self
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T) =
    resolve'0 _0
  
  meta "compute_max_steps" 1000000
  
  let rec drop[#"../../creusot-contracts/src/ptr_own.rs" 131 4 131 61] (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:()))= {[@expl:drop 'own' type invariant] [%#sptr_own] inv'2 own}
    {[@expl:drop requires] [%#sptr_own'0] ptr'0 = ptr own}
    (! bb0
    [ bb0 = s0 [ s0 = to_box {ptr'1} {own'0} (fun (_ret:t_T) ->  [ &_4 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 _4} s1 | s1 = -{resolve'1 _4}- s2 | s2 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () | & ptr'1: Opaque.ptr = ptr'0 | & own'0:  t_PtrOwn = own | & _4: t_T = Any.any_l () ] 
    [ return''0 (result:())-> (! return' {result}) ]

end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 42 4 42 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 40 15 40 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 41 14 41 31
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 42 32 42 34
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 36 8 36 44
  
  type t_T1
  
  type t_T2
  
  type tuple  =
    { _p0: t_T1; _p1: t_T2 }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T2)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T1)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: tuple) =
    match _0 with
      | {_p0 = x0 ; _p1 = x1} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 35 4 35 28] (self: tuple) =
    [%#sresolve'2] resolve'0 self._p0 /\ resolve self._p1
  
  constant self  : tuple
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 42 4 42 31] (self'0: tuple) : ()
  
  goal vc_resolve_coherence: ([%#sresolve] structural_resolve self)  -> ([%#sresolve'0] resolve'1 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 55 4 55 31] (* <&mut T as resolve::Resolve> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 53 15 53 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 54 14 54 31
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 55 32 55 34
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: MutBorrow.t t_T) =
    _0.final = _0.current
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve'2] self.final = self.current
  
  constant self  : MutBorrow.t t_T
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 55 4 55 31] (self'0: MutBorrow.t t_T) : ()
  
  goal vc_resolve_coherence: ([%#sresolve] structural_resolve self)  -> ([%#sresolve'0] resolve self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 68 4 68 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 66 15 66 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 67 14 67 31
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 68 32 68 34
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 62 8 62 23
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_T) =
    resolve _0
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 28] (self: t_T) =
    [%#sresolve'2] resolve self
  
  constant self  : t_T
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 68 4 68 31] (self'0: t_T) : ()
  
  goal vc_resolve_coherence: ([%#sresolve] structural_resolve self)  -> ([%#sresolve'0] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 84 4 84 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 82 15 82 39
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 83 14 83 31
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 84 32 84 34
  let%span sresolve'2 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Option) =
    match _0 with
      | C_None -> true
      | C_Some x0 -> resolve x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve'2] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  constant self  : t_Option
  
  function resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 84 4 84 31] (self'0: t_Option) : ()
  
  goal vc_resolve_coherence: ([%#sresolve] structural_resolve self)  -> ([%#sresolve'0] resolve'0 self)
end
module M_creusot_contracts__resource__fmap_view__qyi7192378449667732088__rel_mono [#"../../creusot-contracts/src/resource/fmap_view.rs" 39 4 39 62] (* <resource::fmap_view::MapRelation<K, V> as logic::ra::view::ViewRel> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 26 14 26 59
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 53 14 53 32
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 14 58 44
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 58 14 58 32
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 63 14 63 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 35 15 35 31
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 36 15 36 26
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 37 14 37 30
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 39 63 39 65
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 25 8 31 13
  
  use map.Map
  
  type t_FMap
  
  type t_FMap'0
  
  type t_V
  
  type t_Ag  =
    | C_Ag t_V
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap'0) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap'0. [%#sfmap'7] forall m1: t_FMap'0, m2: t_FMap'0. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap'0) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'5] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap'0) (k: t_K) : t_Option
  
   =
    [%#sfmap'1] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_Ag) (a: tuple) : t_Ag
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap'0) (m: t_FMap'0) (f: Map.map tuple t_Ag) : t_FMap'0
  
  
  axiom merge_spec: forall self: t_FMap'0, m: t_FMap'0, f: Map.map tuple t_Ag. [%#sfmap'6] forall k: t_K. match { _p0'0 = get self k;
                                                                                                                  _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'2] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'1] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
   =
    [%#sfmap'4] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45] (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  
  axiom associative_spec'0: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'3] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36] (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'0: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'2] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree'0] match self with
      | C_Ag _ -> true
      | C_Bot -> false
      end
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap'0) : bool =
    [%#sfmap'0] forall k: t_K. valid'0 (get self k)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'2
  
  axiom view_spec'0: forall self: t_FMap. [%#sfmap'7] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'2
  
   =
    [%#sfmap'5] Map.get (view'0 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option'1
  
   =
    [%#sfmap'1] match get_unsized'0 self k with
      | C_None'2 -> C_None'1
      | C_Some'2 x -> C_Some'1 x
      end
  
  function rel [#"../../creusot-contracts/src/resource/fmap_view.rs" 24 4 24 48] (a: t_FMap) (f: t_FMap'0) : bool =
    [%#sfmap_view'3] valid'1 f
    /\ (forall k: t_K. match get f k with
      | C_Some (C_Ag v) -> get'0 a k = C_Some'1 v
      | _ -> true
      end)
  
  function incl [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (self: t_FMap'0) (other: t_FMap'0) : bool
  
  axiom incl_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap] incl self other
  = (exists c: t_FMap'0. op'0 self c = other)
  
  constant a  : t_FMap
  
  constant f1  : t_FMap'0
  
  constant f2  : t_FMap'0
  
  function rel_mono [#"../../creusot-contracts/src/resource/fmap_view.rs" 39 4 39 62] (a'0: t_FMap) (f1'0: t_FMap'0) (f2'0: t_FMap'0) : ()
  
  
  goal vc_rel_mono: ([%#sfmap_view] rel a f1)  -> ([%#sfmap_view'0] incl f2 f1)  -> ([%#sfmap_view'1] rel a f2)
end
module M_creusot_contracts__resource__fmap_view__qyi14545323375502517966__new [#"../../creusot-contracts/src/resource/fmap_view.rs" 114 4 114 31] (* resource::fmap_view::FMapView<K, V> *)
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 53 14 53 32
  let%span sfmap'5 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 14 58 44
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 26 14 26 59
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 58 14 58 32
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 63 14 63 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 55 8 55 54
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 183 22 183 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 183 31 183 32
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 181 14 181 29
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 164 24 164 28
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 89 8 89 22
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 115 39 115 77
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 114 20 114 31
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 111 14 111 30
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 112 14 112 31
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 113 14 113 44
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 64 8 64 33
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 75 8 75 33
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 82 8 86 9
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 25 8 31 13
  let%span sfmap_view'8 = "../../creusot-contracts/src/resource/fmap_view.rs" 35 15 35 31
  let%span sfmap_view'9 = "../../creusot-contracts/src/resource/fmap_view.rs" 36 15 36 26
  let%span sfmap_view'10 = "../../creusot-contracts/src/resource/fmap_view.rs" 37 14 37 30
  let%span sfmap_view'11 = "../../creusot-contracts/src/resource/fmap_view.rs" 39 63 39 65
  let%span sresource = "../../creusot-contracts/src/resource.rs" 88 15 88 24
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 90 36 90 47
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 89 14 89 27
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 42 8 42 18
  let%span sresource'3 = "../../creusot-contracts/src/resource.rs" 50 8 50 26
  
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Excl  =
    | C_Excl t_FMap
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap'0
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  function mkauth [#"../../creusot-contracts/src/logic/ra/view.rs" 54 4 54 37] (a: t_FMap) : t_View =
    [%#sview] { t_View__auth = C_Some (C_Excl a); t_View__frag = C_None'0 }
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'1] len self >= 0
  
  type t_K
  
  type t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'1
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 26]  : t_FMap
  
  axiom empty_spec: ([%#sfmap] len empty = 0) && ([%#sfmap'0] view empty = Const.const (C_None'1))
  
  type t_Resource  =
    { t_Resource__0: () }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  type t_Ag  =
    | C_Ag t_V
    | C_Bot'0
  
  type tuple'2  =
    { _p0'2: t_Ag; _p1'2: t_Ag }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Ag
  
  type tuple'3  =
    { _p0'3: t_Option'2; _p1'3: t_Option'2 }
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Ag
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap'0) : Map.map t_K t_Option'3
  
  axiom view_spec'0: forall self: t_FMap'0. [%#sfmap'2] forall m1: t_FMap'0, m2: t_FMap'0. m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap'0) (k: t_K) : t_Option'3
  
   =
    [%#sfmap'8] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap'0) (k: t_K) : t_Option'2
  
   =
    [%#sfmap'6] match get_unsized self k with
      | C_None'3 -> C_None'2
      | C_Some'3 x -> C_Some'2 x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'2 t_Ag) (a: tuple'2) : t_Ag
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap'0) (m: t_FMap'0) (f: Map.map tuple'2 t_Ag) : t_FMap'0
  
  
  axiom merge_spec: forall self: t_FMap'0, m: t_FMap'0, f: Map.map tuple'2 t_Ag. [%#sfmap'10] forall k: t_K. match { _p0'3 = get self k;
                                                                                                                     _p1'3 = get m k } with
    | {_p0'3 = C_None'2 ; _p1'3 = y} -> get (merge self m f) k = y
    | {_p0'3 = x ; _p1'3 = C_None'2} -> get (merge self m f) k = x
    | {_p0'3 = C_Some'2 x ; _p1'3 = C_Some'2 y} -> get (merge self m f) k
    = C_Some'2 (index_logic f { _p0'2 = x; _p1'2 = y })
    end
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'0] match { _p0'2 = self; _p1'2 = other } with
      | {_p0'2 = C_Ag x ; _p1'2 = C_Ag y} -> if x = y then C_Ag x else C_Bot'0
      | _ -> C_Bot'0
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  
  axiom associative_spec'1: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'2] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec'0: forall a: t_Ag, b: t_Ag. [%#sagree'1] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
   =
    [%#sfmap'7] merge self other (fun (__0: tuple'2) -> let {_p0'2 = x ; _p1'2 = y} = __0 in op'1 x y)
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45] (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  
  axiom associative_spec'2: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'5] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36] (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'1: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'4] op'2 a b = op'2 b a
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'2 x y)
      end
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'3: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'3 (op'3 a b) c
  = op'3 a (op'3 b c)
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'3 self._p1 other._p1 }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'4: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'2: forall a: tuple, b: tuple. [%#sprod'0] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'3] let {_p0 = auth ; _p1 = frag} = op'4 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function associative'5 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'5: forall a: t_View, b: t_View, c: t_View. [%#sview'2] op'5 (op'5 a b) c = op'5 a (op'5 b c)
  
  function commutative'3 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'3: forall a: t_View, b: t_View. [%#sview'1] op'5 a b = op'5 b a
  
  function op'6 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'2) (other: t_Option'2) : t_Option'2
  
   =
    [%#soption'1] match { _p0'3 = self; _p1'3 = other } with
      | {_p0'3 = C_None'2} -> other
      | {_p1'3 = C_None'2} -> self
      | {_p0'3 = C_Some'2 x ; _p1'3 = C_Some'2 y} -> C_Some'2 (op'1 x y)
      end
  
  function associative'6 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'2) (b: t_Option'2) (c: t_Option'2) : ()
  
  
  axiom associative_spec'6: forall a: t_Option'2, b: t_Option'2, c: t_Option'2. [%#soption'0] op'6 (op'6 a b) c
  = op'6 a (op'6 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree] match self with
      | C_Ag _ -> true
      | C_Bot'0 -> false
      end
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option'2) : bool =
    [%#soption] match self with
      | C_Some'2 x -> valid x
      | C_None'2 -> true
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap'0) : bool =
    [%#sfmap'3] forall k: t_K. valid'0 (get self k)
  
  function incl [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (self: t_FMap'0) (other: t_FMap'0) : bool
  
  axiom incl_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap'9] incl self other
  = (exists c: t_FMap'0. op'2 self c = other)
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_V
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'1
  
   =
    [%#sfmap'8] Map.get (view self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option'4
  
   =
    [%#sfmap'6] match get_unsized'0 self k with
      | C_None'1 -> C_None'4
      | C_Some'1 x -> C_Some'4 x
      end
  
  function rel [#"../../creusot-contracts/src/resource/fmap_view.rs" 24 4 24 48] (a: t_FMap) (f: t_FMap'0) : bool =
    [%#sfmap_view'7] valid'1 f
    /\ (forall k: t_K. match get f k with
      | C_Some'2 (C_Ag v) -> get'0 a k = C_Some'4 v
      | _ -> true
      end)
  
  function rel_mono [#"../../creusot-contracts/src/resource/fmap_view.rs" 39 4 39 62] (a: t_FMap) (f1: t_FMap'0) (f2: t_FMap'0) : ()
  
   =
    [%#sfmap_view'11] ()
  
  axiom rel_mono_spec: forall a: t_FMap, f1: t_FMap'0, f2: t_FMap'0. ([%#sfmap_view'8] rel a f1)
   -> ([%#sfmap_view'9] incl f2 f1)  -> ([%#sfmap_view'10] rel a f2)
  
  function valid'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'0] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid'1 f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid'1 f /\ (exists a: t_FMap. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  function val' [#"../../creusot-contracts/src/resource.rs" 78 4 78 25] (self: t_Resource) : t_View
  
  predicate invariant' [#"../../creusot-contracts/src/resource.rs" 49 4 49 30] (self: t_Resource) =
    [%#sresource'3] valid'2 (val' self)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Resource)
  
  axiom inv_axiom [@rewrite]: forall x: t_Resource [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Resource__0 = a_0} -> true
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_Resource) =
    [%#sghost'6] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_Resource)
  
  axiom inv_axiom'0 [@rewrite]: forall x:  t_Resource [inv'0 x]. inv'0 x = invariant''0 x
  
  function view'1 [#"../../creusot-contracts/src/resource.rs" 41 4 41 22] (self: t_Resource) : t_View =
    [%#sresource'2] val' self
  
  function view'2 [#"../../creusot-contracts/src/ghost.rs" 88 4 88 33] (self:  t_Resource) : t_View =
    [%#sghost'5] view'1 self
  
  let rec alloc (r:t_View) (return'  (x: t_Resource))= {[@expl:alloc requires] [%#sresource] valid'2 r}
    any
    [ return''0 (result: t_Resource)-> {[%#sresource'0] inv'0 result}
      {[%#sresource'1] view'2 result = r}
      (! return' {result}) ]
  
  
  let rec into_inner (self: t_Resource) (return'  (x:t_Resource))= {[@expl:into_inner 'self' type invariant] [%#sghost] inv'0 self}
    any [ return''0 (result:t_Resource)-> {[%#sghost'0] inv result} {[%#sghost'1] result = self} (! return' {result}) ] 
  
  type t_FMapView  =
    { t_FMapView__0: t_Resource }
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMapView)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapView [inv'1 x]. inv'1 x
  = match x with
    | {t_FMapView__0 = a_0} -> inv a_0
    end
  
  predicate invariant''1 [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_FMapView) =
    [%#sghost'6] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_FMapView)
  
  axiom inv_axiom'2 [@rewrite]: forall x:  t_FMapView [inv'2 x]. inv'2 x = invariant''1 x
  
  let rec new (x:t_FMapView) (return'  (x'0: t_FMapView))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'1 x}
    any [ return''0 (result: t_FMapView)-> {[%#sghost'3] inv'2 result} {[%#sghost'4] result = x} (! return' {result}) ] 
  
  predicate is_auth [#"../../creusot-contracts/src/resource/fmap_view.rs" 63 4 63 32] (self: t_FMapView) =
    [%#sfmap_view'4] (val' self.t_FMapView__0).t_View__auth <> C_None
  
  predicate is_frag [#"../../creusot-contracts/src/resource/fmap_view.rs" 74 4 74 32] (self: t_FMapView) =
    [%#sfmap_view'5] (val' self.t_FMapView__0).t_View__frag <> C_None'0
  
  function auth [#"../../creusot-contracts/src/resource/fmap_view.rs" 81 4 81 35] (self: t_FMapView) : t_FMap =
    [%#sfmap_view'6] match (val' self.t_FMapView__0).t_View__auth with
      | C_None -> empty
      | C_Some (C_Bot) -> empty
      | C_Some (C_Excl auth'0) -> auth'0
      end
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"../../creusot-contracts/src/resource/fmap_view.rs" 114 4 114 31] (return'  (x: t_FMapView))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sfmap_view] mkauth empty ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = alloc {_5} (fun (_ret: t_Resource) ->  [ &resource <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = into_inner {resource} (fun (_ret:t_Resource) ->  [ &_8 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 =  [ &_7 <- { t_FMapView__0 = _8 } ] s1
      | s1 = new {_7} (fun (_ret: t_FMapView) ->  [ &_0 <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = return''0 {_0} ]
    )
    [ & _0:  t_FMapView = Any.any_l ()
    | & resource:  t_Resource = Any.any_l ()
    | & _5: t_View = Any.any_l ()
    | & _7: t_FMapView = Any.any_l ()
    | & _8: t_Resource = Any.any_l () ]
    
    [ return''0 (result: t_FMapView)-> {[@expl:new result type invariant] [%#sfmap_view'0] inv'2 result}
      {[@expl:new ensures #0] [%#sfmap_view'1] is_auth result}
      {[@expl:new ensures #1] [%#sfmap_view'2] not is_frag result}
      {[@expl:new ensures #2] [%#sfmap_view'3] auth result = empty}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__fmap_view__qyi14545323375502517966__insert [#"../../creusot-contracts/src/resource/fmap_view.rs" 130 4 130 68] (* resource::fmap_view::FMapView<K, V> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 67 14 67 71
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 68 14 68 61
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 66
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 280 14 283 5
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'10 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span sfmap'12 = "../../creusot-contracts/src/logic/ra/fmap.rs" 53 14 53 32
  let%span sfmap'13 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 14 58 44
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'15 = "../../creusot-contracts/src/logic/ra/fmap.rs" 26 14 26 59
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 21 14 21 30
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 58 14 58 32
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 63 14 63 44
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 130 8 130 56
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 55 8 55 54
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 62 8 62 42
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 131 23 131 74
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 132 24 135 10
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 137 20 137 38
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 138 19 138 80
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 130 23 130 27
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 121 15 121 58
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 130 64 130 68
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 122 14 122 79
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 123 14 123 82
  let%span sfmap_view'8 = "../../creusot-contracts/src/resource/fmap_view.rs" 124 14 124 39
  let%span sfmap_view'9 = "../../creusot-contracts/src/resource/fmap_view.rs" 125 14 125 51
  let%span sfmap_view'10 = "../../creusot-contracts/src/resource/fmap_view.rs" 126 14 126 59
  let%span sfmap_view'11 = "../../creusot-contracts/src/resource/fmap_view.rs" 127 14 127 38
  let%span sfmap_view'12 = "../../creusot-contracts/src/resource/fmap_view.rs" 82 8 86 9
  let%span sfmap_view'13 = "../../creusot-contracts/src/resource/fmap_view.rs" 64 8 64 33
  let%span sfmap_view'14 = "../../creusot-contracts/src/resource/fmap_view.rs" 75 8 75 33
  let%span sfmap_view'15 = "../../creusot-contracts/src/resource/fmap_view.rs" 102 8 105 10
  let%span sfmap_view'16 = "../../creusot-contracts/src/resource/fmap_view.rs" 52 4 52 12
  let%span sfmap_view'17 = "../../creusot-contracts/src/resource/fmap_view.rs" 92 8 95 9
  let%span sfmap_view'18 = "../../creusot-contracts/src/resource/fmap_view.rs" 25 8 31 13
  let%span sfmap_view'19 = "../../creusot-contracts/src/resource/fmap_view.rs" 35 15 35 31
  let%span sfmap_view'20 = "../../creusot-contracts/src/resource/fmap_view.rs" 36 15 36 26
  let%span sfmap_view'21 = "../../creusot-contracts/src/resource/fmap_view.rs" 37 14 37 30
  let%span sfmap_view'22 = "../../creusot-contracts/src/resource/fmap_view.rs" 39 63 39 65
  let%span sresource = "../../creusot-contracts/src/resource.rs" 42 8 42 18
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 199 23 199 27
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 196 15 196 41
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 197 14 197 39
  let%span sresource'3 = "../../creusot-contracts/src/resource.rs" 198 14 198 33
  let%span sresource'4 = "../../creusot-contracts/src/resource.rs" 135 26 135 30
  let%span sresource'5 = "../../creusot-contracts/src/resource.rs" 130 15 130 32
  let%span sresource'6 = "../../creusot-contracts/src/resource.rs" 135 67 135 71
  let%span sresource'7 = "../../creusot-contracts/src/resource.rs" 131 14 131 39
  let%span sresource'8 = "../../creusot-contracts/src/resource.rs" 132 14 132 38
  let%span sresource'9 = "../../creusot-contracts/src/resource.rs" 133 14 133 28
  let%span sresource'10 = "../../creusot-contracts/src/resource.rs" 134 14 134 27
  let%span sresource'11 = "../../creusot-contracts/src/resource.rs" 50 8 50 26
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Excl  =
    | C_Excl t_FMap
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap'0
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  function mkauth [#"../../creusot-contracts/src/logic/ra/view.rs" 54 4 54 37] (a: t_FMap) : t_View =
    [%#sview] { t_View__auth = C_Some (C_Excl a); t_View__frag = C_None'0 }
  
  type t_K
  
  type t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'1
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'5] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function make_sized [#"../../creusot-contracts/src/util.rs" 22 4 22 40] (self: t_V) : t_V
  
  axiom make_sized_spec: forall self: t_V. [%#sutil] make_sized self = self
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'1
  
   =
    [%#sfmap'7] Map.get (view self) k
  
  function contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self: t_FMap) (k: t_K) : bool
  
   =
    [%#sfmap'4] get_unsized self k <> C_None'1
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'6] len self >= 0
  
  function insert [#"../../creusot-contracts/src/logic/fmap.rs" 70 4 70 43] (self: t_FMap) (k: t_K) (v: t_V) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: t_K, v: t_V. ([%#sfmap] view (insert self k v)
  = Map.set (view self) k (C_Some'1 (make_sized v)))
  && ([%#sfmap'0] contains self k  -> len (insert self k v) = len self)
  && ([%#sfmap'1] not contains self k  -> len (insert self k v) = len self + 1)
  
  type t_Resource  =
    { t_Resource__0: () }
  
  type t_FMapView  =
    { t_FMapView__0: t_Resource }
  
  function val' [#"../../creusot-contracts/src/resource.rs" 78 4 78 25] (self: t_Resource) : t_View
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 26]  : t_FMap
  
  axiom empty_spec: ([%#sfmap'2] len empty = 0) && ([%#sfmap'3] view empty = Const.const (C_None'1))
  
  function auth [#"../../creusot-contracts/src/resource/fmap_view.rs" 81 4 81 35] (self: t_FMapView) : t_FMap =
    [%#sfmap_view'12] match (val' self.t_FMapView__0).t_View__auth with
      | C_None -> empty
      | C_Some (C_Bot) -> empty
      | C_Some (C_Excl auth'0) -> auth'0
      end
  
  function view'0 [#"../../creusot-contracts/src/resource.rs" 41 4 41 22] (self: t_Resource) : t_View =
    [%#sresource] val' self
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  type t_Ag  =
    | C_Ag t_V
    | C_Bot'0
  
  type tuple'2  =
    { _p0'2: t_Ag; _p1'2: t_Ag }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Ag
  
  type tuple'3  =
    { _p0'3: t_Option'2; _p1'3: t_Option'2 }
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Ag
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap'0) : Map.map t_K t_Option'3
  
  axiom view_spec'0: forall self: t_FMap'0. [%#sfmap'5] forall m1: t_FMap'0, m2: t_FMap'0. m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap'0) (k: t_K) : t_Option'3
  
   =
    [%#sfmap'7] Map.get (view'1 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap'0) (k: t_K) : t_Option'2
  
   =
    [%#sfmap'9] match get_unsized'0 self k with
      | C_None'3 -> C_None'2
      | C_Some'3 x -> C_Some'2 x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'2 t_Ag) (a: tuple'2) : t_Ag
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap'0) (m: t_FMap'0) (f: Map.map tuple'2 t_Ag) : t_FMap'0
  
  
  axiom merge_spec: forall self: t_FMap'0, m: t_FMap'0, f: Map.map tuple'2 t_Ag. [%#sfmap'14] forall k: t_K. match { _p0'3 = get self k;
                                                                                                                     _p1'3 = get m k } with
    | {_p0'3 = C_None'2 ; _p1'3 = y} -> get (merge self m f) k = y
    | {_p0'3 = x ; _p1'3 = C_None'2} -> get (merge self m f) k = x
    | {_p0'3 = C_Some'2 x ; _p1'3 = C_Some'2 y} -> get (merge self m f) k
    = C_Some'2 (index_logic f { _p0'2 = x; _p1'2 = y })
    end
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree] match { _p0'2 = self; _p1'2 = other } with
      | {_p0'2 = C_Ag x ; _p1'2 = C_Ag y} -> if x = y then C_Ag x else C_Bot'0
      | _ -> C_Bot'0
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  
  axiom associative_spec'1: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'1] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec'0: forall a: t_Ag, b: t_Ag. [%#sagree'0] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
   =
    [%#sfmap'10] merge self other (fun (__0: tuple'2) -> let {_p0'2 = x ; _p1'2 = y} = __0 in op'1 x y)
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45] (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  
  axiom associative_spec'2: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'13] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36] (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'1: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'12] op'2 a b = op'2 b a
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'2 x y)
      end
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'3: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'3 (op'3 a b) c
  = op'3 a (op'3 b c)
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'3 self._p1 other._p1 }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'4: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'2: forall a: tuple, b: tuple. [%#sprod'0] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'0] let {_p0 = auth'0 ; _p1 = frag} = op'4 { _p0 = self.t_View__auth;
                                                         _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                     _p1 = other.t_View__frag } in { t_View__auth = auth'0;
                                                                                                                     t_View__frag = frag }
  
  function associative'5 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'5: forall a: t_View, b: t_View, c: t_View. [%#sview'3] op'5 (op'5 a b) c = op'5 a (op'5 b c)
  
  function commutative'3 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'3: forall a: t_View, b: t_View. [%#sview'2] op'5 a b = op'5 b a
  
  function mkfrag [#"../../creusot-contracts/src/logic/ra/view.rs" 61 4 61 37] (f: t_FMap'0) : t_View =
    [%#sview'1] { t_View__auth = C_None; t_View__frag = C_Some'0 f }
  
  function op'6 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'2) (other: t_Option'2) : t_Option'2
  
   =
    [%#soption] match { _p0'3 = self; _p1'3 = other } with
      | {_p0'3 = C_None'2} -> other
      | {_p1'3 = C_None'2} -> self
      | {_p0'3 = C_Some'2 x ; _p1'3 = C_Some'2 y} -> C_Some'2 (op'1 x y)
      end
  
  function associative'6 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'2) (b: t_Option'2) (c: t_Option'2) : ()
  
  
  axiom associative_spec'6: forall a: t_Option'2, b: t_Option'2, c: t_Option'2. [%#soption'0] op'6 (op'6 a b) c
  = op'6 a (op'6 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree'2] match self with
      | C_Ag _ -> true
      | C_Bot'0 -> false
      end
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option'2) : bool =
    [%#soption'1] match self with
      | C_Some'2 x -> valid x
      | C_None'2 -> true
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap'0) : bool =
    [%#sfmap'11] forall k: t_K. valid'0 (get self k)
  
  function incl [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (self: t_FMap'0) (other: t_FMap'0) : bool
  
  axiom incl_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap'15] incl self other
  = (exists c: t_FMap'0. op'2 self c = other)
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_V
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option'4
  
   =
    [%#sfmap'9] match get_unsized self k with
      | C_None'1 -> C_None'4
      | C_Some'1 x -> C_Some'4 x
      end
  
  function rel [#"../../creusot-contracts/src/resource/fmap_view.rs" 24 4 24 48] (a: t_FMap) (f: t_FMap'0) : bool =
    [%#sfmap_view'18] valid'1 f
    /\ (forall k: t_K. match get f k with
      | C_Some'2 (C_Ag v) -> get'0 a k = C_Some'4 v
      | _ -> true
      end)
  
  function rel_mono [#"../../creusot-contracts/src/resource/fmap_view.rs" 39 4 39 62] (a: t_FMap) (f1: t_FMap'0) (f2: t_FMap'0) : ()
  
   =
    [%#sfmap_view'22] ()
  
  axiom rel_mono_spec: forall a: t_FMap, f1: t_FMap'0, f2: t_FMap'0. ([%#sfmap_view'19] rel a f1)
   -> ([%#sfmap_view'20] incl f2 f1)  -> ([%#sfmap_view'21] rel a f2)
  
  function valid'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'4] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid'1 f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid'1 f /\ (exists a: t_FMap. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  predicate invariant' [#"../../creusot-contracts/src/resource.rs" 49 4 49 30] (self: t_Resource) =
    [%#sresource'11] valid'2 (val' self)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Resource)
  
  axiom inv_axiom [@rewrite]: forall x: t_Resource [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Resource__0 = a_0} -> true
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_Resource) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_Resource)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Resource [inv'0 x]. inv'0 x = invariant''0 x
  
  function update [#"../../creusot-contracts/src/logic/ra.rs" 128 0 128 40] (x: t_View) (y: t_View) : bool =
    [%#sra] forall z: t_View. valid'2 (op'5 x z)  -> valid'2 (op'5 y z)
  
  function view'2 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Resource) : t_View =
    [%#smodel] view'0 self.current
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 61 4 61 25] (self: t_Resource) : t_Id
  
  let rec update'0 (self:MutBorrow.t t_Resource) (target:t_View) (return'  (x:()))= {[@expl:update 'self' type invariant] [%#sresource'0] inv'0 self}
    {[@expl:update requires] [%#sresource'1] update (view'2 self) target}
    any
    [ return''0 (result:())-> {[%#sresource'2] id self.final = id self.current}
      {[%#sresource'3] view'0 self.final = target}
      (! return' {result}) ]
  
  
  function make_sized'0 [#"../../creusot-contracts/src/util.rs" 22 4 22 40] (self: t_Ag) : t_Ag
  
  axiom make_sized_spec'0: forall self: t_Ag. [%#sutil] make_sized'0 self = self
  
  function contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self: t_FMap'0) (k: t_K) : bool
  
   =
    [%#sfmap'4] get_unsized'0 self k <> C_None'3
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap'0) : int
  
  axiom len_spec'0: forall self: t_FMap'0. [%#sfmap'6] len'0 self >= 0
  
  function insert'0 [#"../../creusot-contracts/src/logic/fmap.rs" 70 4 70 43] (self: t_FMap'0) (k: t_K) (v: t_Ag) : t_FMap'0
  
  
  axiom insert_spec'0: forall self: t_FMap'0, k: t_K, v: t_Ag. ([%#sfmap] view'1 (insert'0 self k v)
  = Map.set (view'1 self) k (C_Some'3 (make_sized'0 v)))
  && ([%#sfmap'0] contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self)
  && ([%#sfmap'1] not contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self + 1)
  
  constant empty'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 26]  : t_FMap'0
  
  axiom empty_spec'0: ([%#sfmap'2] len'0 empty'0 = 0) && ([%#sfmap'3] view'1 empty'0 = Const.const (C_None'3))
  
  let rec split_off (self:MutBorrow.t t_Resource) (a:t_View) (b:t_View) (return'  (x:t_Resource))= {[@expl:split_off 'self' type invariant] [%#sresource'4] inv'0 self}
    {[@expl:split_off requires] [%#sresource'5] view'2 self = op'5 a b}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'6] inv result}
      {[%#sresource'7] id self.final = id self.current}
      {[%#sresource'8] id result = id self.current}
      {[%#sresource'9] view'0 self.final = a}
      {[%#sresource'10] view'0 result = b}
      (! return' {result}) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMapView)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapView [inv'1 x]. inv'1 x
  = match x with
    | {t_FMapView__0 = a_0} -> inv a_0
    end
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_FMapView) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_FMapView)
  
  axiom inv_axiom'2 [@rewrite]: forall x: MutBorrow.t t_FMapView [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_FMapView) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: MutBorrow.t t_FMapView) =
    resolve _0
  
  predicate is_auth [#"../../creusot-contracts/src/resource/fmap_view.rs" 63 4 63 32] (self: t_FMapView) =
    [%#sfmap_view'13] (val' self.t_FMapView__0).t_View__auth <> C_None
  
  predicate is_frag [#"../../creusot-contracts/src/resource/fmap_view.rs" 74 4 74 32] (self: t_FMapView) =
    [%#sfmap_view'14] (val' self.t_FMapView__0).t_View__frag <> C_None'0
  
  type tuple'4  =
    { _p0'4: t_K; _p1'4: t_Ag }
  
  function index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'4 t_Option'4) (a: tuple'4) : t_Option'4
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 284 4 286 17] (self: t_FMap'0) (f: Map.map tuple'4 t_Option'4) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap'0, f: Map.map tuple'4 t_Option'4. [%#sfmap'8] forall k: t_K. get'0 (filter_map self f) k
  = match get self k with
    | C_None'2 -> C_None'4
    | C_Some'2 v -> index_logic'0 f { _p0'4 = k; _p1'4 = v }
    end
  
  function frag_agree [#"../../creusot-contracts/src/resource/fmap_view.rs" 91 4 91 41] (self: t_FMapView) : t_FMap'0 =
    [%#sfmap_view'17] match (val' self.t_FMapView__0).t_View__frag with
      | C_None'0 -> empty'0
      | C_Some'0 frag -> frag
      end
  
  function frag [#"../../creusot-contracts/src/resource/fmap_view.rs" 101 4 101 35] (self: t_FMapView) : t_FMap =
    [%#sfmap_view'15] filter_map (frag_agree self) (fun (__0: tuple'4) -> let {_p1'4 = v} = __0 in match v with
      | C_Ag v'0 -> C_Some'4 v'0
      | C_Bot'0 -> C_None'4
      end)
  
  function id'0 [#"../../creusot-contracts/src/resource/fmap_view.rs" 54 4 54 25] (self: t_FMapView) : t_Id =
    [%#sfmap_view'16] id self.t_FMapView__0
  
  meta "compute_max_steps" 1000000
  
  let rec insert'1[#"../../creusot-contracts/src/resource/fmap_view.rs" 130 4 130 68] (self:MutBorrow.t t_FMapView) (k:t_K) (v:t_V) (return'  (x:t_FMapView))= {[@expl:insert 'self' type invariant] [%#sfmap_view'3] inv'2 self}
    {[@expl:insert requires] [%#sfmap_view'4] is_auth self.current /\ not contains (auth self.current) k}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &new_auth <- [%#sfmap_view] mkauth (insert (auth self'0.current) k'0 v'0) ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = 
        [ &new_total <- [%#sfmap_view'0] match (view'0 (self'0.current).t_FMapView__0).t_View__frag with
          | C_None'0 -> new_auth
          | C_Some'0 frag'0 -> op'5 new_auth (mkfrag frag'0)
          end ]
        
        s1
      | s1 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv (self'0.current).t_FMapView__0}
        MutBorrow.borrow_mut <t_Resource> {(self'0.current).t_FMapView__0}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_16 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = { t_FMapView__0 = _ret.final } } ] 
            s1)
      | s1 = update'0 {_16} {new_total} (fun (_ret:()) ->  [ &_15 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 =  [ &right <- [%#sfmap_view'1] view'0 (self'0.current).t_FMapView__0 ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &left <- [%#sfmap_view'2] mkfrag (insert'0 empty'0 k'0 (C_Ag v'0)) ] s1 | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = {inv (self'0.current).t_FMapView__0}
        MutBorrow.borrow_final
          <t_Resource>
          {(self'0.current).t_FMapView__0}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_Resource) ->
             [ &_23 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = { t_FMapView__0 = _ret.final } } ] 
            s1)
      | s1 = split_off {_23} {right} {left} (fun (_ret:t_Resource) ->  [ &_22 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'2 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0 <- { t_FMapView__0 = _22 } ] s3
      | s3 = return''0 {_0} ]
     ]
    )
    [ & _0: t_FMapView = Any.any_l ()
    | & self'0: MutBorrow.t t_FMapView = self
    | & k'0: t_K = k
    | & v'0: t_V = v
    | & new_auth: t_View = Any.any_l ()
    | & new_total: t_View = Any.any_l ()
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Resource = Any.any_l ()
    | & right: t_View = Any.any_l ()
    | & left: t_View = Any.any_l ()
    | & _22: t_Resource = Any.any_l ()
    | & _23: MutBorrow.t t_Resource = Any.any_l () ]
    
    [ return''0 (result:t_FMapView)-> {[@expl:insert result type invariant] [%#sfmap_view'5] inv'1 result}
      {[@expl:insert ensures #0] [%#sfmap_view'6] is_auth self.final
      /\ auth self.final = insert (auth self.current) k v}
      {[@expl:insert ensures #1] [%#sfmap_view'7] is_frag self.final = is_frag self.current
      /\ frag self.final = frag self.current}
      {[@expl:insert ensures #2] [%#sfmap_view'8] id'0 self.final = id'0 self.current}
      {[@expl:insert ensures #3] [%#sfmap_view'9] not is_auth result /\ is_frag result}
      {[@expl:insert ensures #4] [%#sfmap_view'10] frag result = insert empty k v}
      {[@expl:insert ensures #5] [%#sfmap_view'11] id'0 result = id'0 self.current}
      (! return' {result}) ]

end
module M_creusot_contracts__resource__fmap_view__qyi14545323375502517966__contains [#"../../creusot-contracts/src/resource/fmap_view.rs" 152 4 152 39] (* resource::fmap_view::FMapView<K, V> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 280 14 283 5
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 26 14 26 59
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'8 = "../../creusot-contracts/src/logic/ra/fmap.rs" 53 14 53 32
  let%span sfmap'9 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 14 58 44
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'11 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 58 14 58 32
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 63 14 63 44
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 61
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 96 8 96 61
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 154 23 157 10
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 158 23 161 10
  let%span sfmap_view'1 = "../../creusot-contracts/src/resource/fmap_view.rs" 162 22 165 9
  let%span sfmap_view'2 = "../../creusot-contracts/src/resource/fmap_view.rs" 152 21 152 25
  let%span sfmap_view'3 = "../../creusot-contracts/src/resource/fmap_view.rs" 152 27 152 31
  let%span sfmap_view'4 = "../../creusot-contracts/src/resource/fmap_view.rs" 144 15 144 37
  let%span sfmap_view'5 = "../../creusot-contracts/src/resource/fmap_view.rs" 145 15 145 47
  let%span sfmap_view'6 = "../../creusot-contracts/src/resource/fmap_view.rs" 146 14 149 9
  let%span sfmap_view'7 = "../../creusot-contracts/src/resource/fmap_view.rs" 102 8 105 10
  let%span sfmap_view'8 = "../../creusot-contracts/src/resource/fmap_view.rs" 52 4 52 12
  let%span sfmap_view'9 = "../../creusot-contracts/src/resource/fmap_view.rs" 64 8 64 33
  let%span sfmap_view'10 = "../../creusot-contracts/src/resource/fmap_view.rs" 75 8 75 33
  let%span sfmap_view'11 = "../../creusot-contracts/src/resource/fmap_view.rs" 82 8 86 9
  let%span sfmap_view'12 = "../../creusot-contracts/src/resource/fmap_view.rs" 92 8 95 9
  let%span sfmap_view'13 = "../../creusot-contracts/src/resource/fmap_view.rs" 25 8 31 13
  let%span sfmap_view'14 = "../../creusot-contracts/src/resource/fmap_view.rs" 35 15 35 31
  let%span sfmap_view'15 = "../../creusot-contracts/src/resource/fmap_view.rs" 36 15 36 26
  let%span sfmap_view'16 = "../../creusot-contracts/src/resource/fmap_view.rs" 37 14 37 30
  let%span sfmap_view'17 = "../../creusot-contracts/src/resource/fmap_view.rs" 39 63 39 65
  let%span sresource = "../../creusot-contracts/src/resource.rs" 175 31 175 35
  let%span sresource'0 = "../../creusot-contracts/src/resource.rs" 175 37 175 42
  let%span sresource'1 = "../../creusot-contracts/src/resource.rs" 172 15 172 38
  let%span sresource'2 = "../../creusot-contracts/src/resource.rs" 175 57 175 65
  let%span sresource'3 = "../../creusot-contracts/src/resource.rs" 173 14 173 38
  let%span sresource'4 = "../../creusot-contracts/src/resource.rs" 174 14 174 57
  let%span sresource'5 = "../../creusot-contracts/src/resource.rs" 42 8 42 18
  let%span sresource'6 = "../../creusot-contracts/src/resource.rs" 50 8 50 26
  
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Resource  =
    { t_Resource__0: () }
  
  type t_FMapView  =
    { t_FMapView__0: t_Resource }
  
  type t_FMap
  
  type t_Excl  =
    | C_Excl t_FMap
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_FMap'0
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'3] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'2] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'2] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  type t_V
  
  type t_Ag  =
    | C_Ag t_V
    | C_Bot'0
  
  type tuple'2  =
    { _p0'2: t_Ag; _p1'2: t_Ag }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Ag
  
  type tuple'3  =
    { _p0'3: t_Option'1; _p1'3: t_Option'1 }
  
  type t_K
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Ag
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap'0) : Map.map t_K t_Option'2
  
  axiom view_spec: forall self: t_FMap'0. [%#sfmap'3] forall m1: t_FMap'0, m2: t_FMap'0. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap'0) (k: t_K) : t_Option'2
  
   =
    [%#sfmap'4] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap'0) (k: t_K) : t_Option'1
  
   =
    [%#sfmap'1] match get_unsized self k with
      | C_None'2 -> C_None'1
      | C_Some'2 x -> C_Some'1 x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'2 t_Ag) (a: tuple'2) : t_Ag
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap'0) (m: t_FMap'0) (f: Map.map tuple'2 t_Ag) : t_FMap'0
  
  
  axiom merge_spec: forall self: t_FMap'0, m: t_FMap'0, f: Map.map tuple'2 t_Ag. [%#sfmap'10] forall k: t_K. match { _p0'3 = get self k;
                                                                                                                     _p1'3 = get m k } with
    | {_p0'3 = C_None'1 ; _p1'3 = y} -> get (merge self m f) k = y
    | {_p0'3 = x ; _p1'3 = C_None'1} -> get (merge self m f) k = x
    | {_p0'3 = C_Some'1 x ; _p1'3 = C_Some'1 y} -> get (merge self m f) k
    = C_Some'1 (index_logic f { _p0'2 = x; _p1'2 = y })
    end
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree] match { _p0'2 = self; _p1'2 = other } with
      | {_p0'2 = C_Ag x ; _p1'2 = C_Ag y} -> if x = y then C_Ag x else C_Bot'0
      | _ -> C_Bot'0
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  
  axiom associative_spec'1: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'1] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec'0: forall a: t_Ag, b: t_Ag. [%#sagree'0] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap'0) (other: t_FMap'0) : t_FMap'0
  
   =
    [%#sfmap'7] merge self other (fun (__0: tuple'2) -> let {_p0'2 = x ; _p1'2 = y} = __0 in op'1 x y)
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45] (a: t_FMap'0) (b: t_FMap'0) (c: t_FMap'0) : ()
  
  
  axiom associative_spec'2: forall a: t_FMap'0, b: t_FMap'0, c: t_FMap'0. [%#sfmap'9] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36] (a: t_FMap'0) (b: t_FMap'0) : ()
  
  axiom commutative_spec'1: forall a: t_FMap'0, b: t_FMap'0. [%#sfmap'8] op'2 a b = op'2 b a
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'1] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'2 x y)
      end
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'3: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'2] op'3 (op'3 a b) c
  = op'3 a (op'3 b c)
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op'0 self._p0 other._p0; _p1 = op'3 self._p1 other._p1 }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'4: forall a: tuple, b: tuple, c: tuple. [%#sprod'3] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'2: forall a: tuple, b: tuple. [%#sprod'2] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'3] let {_p0 = auth ; _p1 = frag} = op'4 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function associative'5 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'5: forall a: t_View, b: t_View, c: t_View. [%#sview'2] op'5 (op'5 a b) c = op'5 a (op'5 b c)
  
  function commutative'3 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'3: forall a: t_View, b: t_View. [%#sview'1] op'5 a b = op'5 b a
  
  function op'6 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'1) (other: t_Option'1) : t_Option'1
  
   =
    [%#soption'1] match { _p0'3 = self; _p1'3 = other } with
      | {_p0'3 = C_None'1} -> other
      | {_p1'3 = C_None'1} -> self
      | {_p0'3 = C_Some'1 x ; _p1'3 = C_Some'1 y} -> C_Some'1 (op'1 x y)
      end
  
  function associative'6 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'1) (b: t_Option'1) (c: t_Option'1) : ()
  
  
  axiom associative_spec'6: forall a: t_Option'1, b: t_Option'1, c: t_Option'1. [%#soption'2] op'6 (op'6 a b) c
  = op'6 a (op'6 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree'2] match self with
      | C_Ag _ -> true
      | C_Bot'0 -> false
      end
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option'1) : bool =
    [%#soption'3] match self with
      | C_Some'1 x -> valid x
      | C_None'1 -> true
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap'0) : bool =
    [%#sfmap'11] forall k: t_K. valid'0 (get self k)
  
  function incl [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (self: t_FMap'0) (other: t_FMap'0) : bool
  
  axiom incl_spec: forall self: t_FMap'0, other: t_FMap'0. [%#sfmap'6] incl self other
  = (exists c: t_FMap'0. op'2 self c = other)
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_V
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'4
  
  axiom view_spec'0: forall self: t_FMap. [%#sfmap'3] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'4
  
   =
    [%#sfmap'4] Map.get (view'0 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option'3
  
   =
    [%#sfmap'1] match get_unsized'0 self k with
      | C_None'4 -> C_None'3
      | C_Some'4 x -> C_Some'3 x
      end
  
  function rel [#"../../creusot-contracts/src/resource/fmap_view.rs" 24 4 24 48] (a: t_FMap) (f: t_FMap'0) : bool =
    [%#sfmap_view'13] valid'1 f
    /\ (forall k: t_K. match get f k with
      | C_Some'1 (C_Ag v) -> get'0 a k = C_Some'3 v
      | _ -> true
      end)
  
  function rel_mono [#"../../creusot-contracts/src/resource/fmap_view.rs" 39 4 39 62] (a: t_FMap) (f1: t_FMap'0) (f2: t_FMap'0) : ()
  
   =
    [%#sfmap_view'17] ()
  
  axiom rel_mono_spec: forall a: t_FMap, f1: t_FMap'0, f2: t_FMap'0. ([%#sfmap_view'14] rel a f1)
   -> ([%#sfmap_view'15] incl f2 f1)  -> ([%#sfmap_view'16] rel a f2)
  
  function valid'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'4] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid'1 f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid'1 f /\ (exists a: t_FMap. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  function val' [#"../../creusot-contracts/src/resource.rs" 78 4 78 25] (self: t_Resource) : t_View
  
  predicate invariant' [#"../../creusot-contracts/src/resource.rs" 49 4 49 30] (self: t_Resource) =
    [%#sresource'6] valid'2 (val' self)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Resource)
  
  axiom inv_axiom [@rewrite]: forall x: t_Resource [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Resource__0 = a_0} -> true
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Resource) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Resource)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Resource [inv'0 x]. inv'0 x = invariant''0 x
  
  type t_Id
  
  function id [#"../../creusot-contracts/src/resource.rs" 61 4 61 25] (self: t_Resource) : t_Id
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'0] other = C_Bot
  
  axiom incl_spec'0: forall self: t_Excl, other: t_Excl. [%#sexcl] incl'0 self other
  = (exists c: t_Excl. op self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> true
      | {_p1'0 = C_None} -> false
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> x = y \/ incl'0 x y
      end
  
  axiom incl_spec'1: forall self: t_Option, other: t_Option. [%#soption] incl'1 self other
  = (exists c: t_Option. op'0 self c = other)
  
  function incl'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option'0) (other: t_Option'0) : bool
  
   =
    [%#soption'0] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> true
      | {_p1'1 = C_None'0} -> false
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'2: forall self: t_Option'0, other: t_Option'0. [%#soption] incl'2 self other
  = (exists c: t_Option'0. op'3 self c = other)
  
  function incl'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'0] incl'1 self._p0 other._p0 /\ incl'2 self._p1 other._p1
  
  axiom incl_spec'3: forall self: tuple, other: tuple. [%#sprod] incl'3 self other
  = (exists c: tuple. op'4 self c = other)
  
  function incl'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (self: t_View) (other: t_View) : bool =
    [%#sview'0] incl'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                              _p1 = other.t_View__frag }
  
  axiom incl_spec'4: forall self: t_View, other: t_View. [%#sview] incl'4 self other
  = (exists c: t_View. op'5 self c = other)
  
  function view'1 [#"../../creusot-contracts/src/resource.rs" 41 4 41 22] (self: t_Resource) : t_View =
    [%#sresource'5] val' self
  
  function view'2 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: t_Resource) : t_View =
    [%#smodel] view'1 self
  
  let rec join_shared (self:t_Resource) (other:t_Resource) (return'  (x:t_Resource))= {[@expl:join_shared 'self' type invariant] [%#sresource] inv'0 self}
    {[@expl:join_shared 'other' type invariant] [%#sresource'0] inv'0 other}
    {[@expl:join_shared requires] [%#sresource'1] id self = id other}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'2] inv'0 result}
      {[%#sresource'3] id result = id self}
      {[%#sresource'4] incl'4 (view'2 self) (view'2 result) /\ incl'4 (view'2 other) (view'2 result)}
      (! return' {result}) ]
  
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. [%#sfmap'2] len self >= 0
  
  constant empty [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 26]  : t_FMap'0
  
  axiom empty_spec: ([%#sfmap] len empty = 0) && ([%#sfmap'0] view empty = Const.const (C_None'2))
  
  type tuple'4  =
    { _p0'4: t_K; _p1'4: t_Ag }
  
  function index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'4 t_Option'3) (a: tuple'4) : t_Option'3
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 284 4 286 17] (self: t_FMap'0) (f: Map.map tuple'4 t_Option'3) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap'0, f: Map.map tuple'4 t_Option'3. [%#sfmap'5] forall k: t_K. get'0 (filter_map self f) k
  = match get self k with
    | C_None'1 -> C_None'3
    | C_Some'1 v -> index_logic'0 f { _p0'4 = k; _p1'4 = v }
    end
  
  function frag_agree [#"../../creusot-contracts/src/resource/fmap_view.rs" 91 4 91 41] (self: t_FMapView) : t_FMap'0 =
    [%#sfmap_view'12] match (val' self.t_FMapView__0).t_View__frag with
      | C_None'0 -> empty
      | C_Some'0 frag -> frag
      end
  
  function frag [#"../../creusot-contracts/src/resource/fmap_view.rs" 101 4 101 35] (self: t_FMapView) : t_FMap =
    [%#sfmap_view'7] filter_map (frag_agree self) (fun (__0: tuple'4) -> let {_p1'4 = v} = __0 in match v with
      | C_Ag v'0 -> C_Some'3 v'0
      | C_Bot'0 -> C_None'3
      end)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMapView)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMapView [inv'1 x]. inv'1 x
  = match x with
    | {t_FMapView__0 = a_0} -> inv a_0
    end
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FMapView) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMapView)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMapView [inv'2 x]. inv'2 x = invariant''1 x
  
  function id'0 [#"../../creusot-contracts/src/resource/fmap_view.rs" 54 4 54 25] (self: t_FMapView) : t_Id =
    [%#sfmap_view'8] id self.t_FMapView__0
  
  predicate is_auth [#"../../creusot-contracts/src/resource/fmap_view.rs" 63 4 63 32] (self: t_FMapView) =
    [%#sfmap_view'9] (val' self.t_FMapView__0).t_View__auth <> C_None
  
  predicate is_frag [#"../../creusot-contracts/src/resource/fmap_view.rs" 74 4 74 32] (self: t_FMapView) =
    [%#sfmap_view'10] (val' self.t_FMapView__0).t_View__frag <> C_None'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec'0: forall self: t_FMap. [%#sfmap'2] len'0 self >= 0
  
  constant empty'0 [#"../../creusot-contracts/src/logic/fmap.rs" 42 4 42 26]  : t_FMap
  
  axiom empty_spec'0: ([%#sfmap] len'0 empty'0 = 0) && ([%#sfmap'0] view'0 empty'0 = Const.const (C_None'4))
  
  function auth [#"../../creusot-contracts/src/resource/fmap_view.rs" 81 4 81 35] (self: t_FMapView) : t_FMap =
    [%#sfmap_view'11] match (val' self.t_FMapView__0).t_View__auth with
      | C_None -> empty'0
      | C_Some (C_Bot) -> empty'0
      | C_Some (C_Excl auth'0) -> auth'0
      end
  
  meta "compute_max_steps" 1000000
  
  let rec contains[#"../../creusot-contracts/src/resource/fmap_view.rs" 152 4 152 39] (self:t_FMapView) (frag'0:t_FMapView) (return'  (x:()))= {[@expl:contains 'self' type invariant] [%#sfmap_view'2] inv'2 self}
    {[@expl:contains 'frag' type invariant] [%#sfmap_view'3] inv'2 frag'0}
    {[@expl:contains requires #0] [%#sfmap_view'4] id'0 self = id'0 frag'0}
    {[@expl:contains requires #1] [%#sfmap_view'5] is_auth self /\ is_frag frag'0}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_9 <- frag'1.t_FMapView__0 ] s1
      | s1 = join_shared {self'0.t_FMapView__0} {_9} (fun (_ret:t_Resource) ->  [ &new_resource <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = 
        [ &new_frag <- [%#sfmap_view] match (view'2 new_resource).t_View__frag with
          | C_None'0 -> empty
          | C_Some'0 map -> map
          end ]
        
        s1
      | s1 = bb2 ]
    
    | bb2 = s0
      [ s0 = 
        [ &old_frag <- [%#sfmap_view'0] match (view'1 frag'1.t_FMapView__0).t_View__frag with
          | C_None'0 -> empty
          | C_Some'0 map -> map
          end ]
        
        s1
      | s1 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#sfmap_view'1] forall k: t_K. match get'0 (frag frag'1) k with
          | C_Some'3 v -> get new_frag k = C_Some'1 (C_Ag v)
          | C_None'3 -> true
          end}
        s1
      | s1 = return''0 {_0} ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: t_FMapView = self
    | & frag'1: t_FMapView = frag'0
    | & new_resource: t_Resource = Any.any_l ()
    | & _9: t_Resource = Any.any_l ()
    | & new_frag: t_FMap'0 = Any.any_l ()
    | & old_frag: t_FMap'0 = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:contains ensures] [%#sfmap_view'6] forall k: t_K. match get'0 (frag frag'0) k with
        | C_Some'3 v -> get'0 (auth self) k = C_Some'3 v
        | _ -> true
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone [#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot = "../../creusot-contracts/src/snapshot.rs" 56 14 56 29
  
  use creusot.prelude.Any
  
  type t_T
  
  meta "compute_max_steps" 1000000
  
  let rec clone'[#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (self:t_T) (return'  (x:t_T))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_T = Any.any_l () | & self'0: t_T = self ] 
    [ return''0 (result:t_T)-> {[@expl:clone ensures] [%#ssnapshot] result = self} (! return' {result}) ]

end
module M_creusot_contracts__util__unwrap [#"../../creusot-contracts/src/util.rs" 56 0 56 36]
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span sutil'1 = "../../creusot-contracts/src/util.rs" 45 11 45 16
  let%span sutil'2 = "../../creusot-contracts/src/util.rs" 46 10 46 15
  let%span sutil'3 = "../../creusot-contracts/src/util.rs" 47 10 47 11
  let%span sutil'4 = "../../creusot-contracts/src/util.rs" 57 4 60 5
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  constant unreachable [#"../../creusot-contracts/src/util.rs" 48 0 48 28]  : t_T
  
  axiom unreachable_spec: ([%#sutil'1] false)  -> ([%#sutil'2] false)
  
  constant op  : t_Option
  
  function unwrap [#"../../creusot-contracts/src/util.rs" 56 0 56 36] (op'0: t_Option) : t_T
  
  goal vc_unwrap: ([%#sutil] op <> C_None)
   -> match op with
    | C_Some t -> [%#sutil'0] C_Some t = op
    | C_None -> ([@expl:unreachable requires] [%#sutil'1] false)
    /\ (([%#sutil'2] false)  -> ([%#sutil'0] C_Some unreachable = op))
    end
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl__refines [#"../../creusot-contracts/src/std/array.rs" 71 4 71 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 71 4 71 26
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#sarray'0] view self = Seq.(++) visited (view o)
  
  goal refines: [%#sarray] forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans__refines [#"../../creusot-contracts/src/std/array.rs" 78 4 78 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray = "../../creusot-contracts/src/std/array.rs" 78 4 78 90
  let%span sarray'0 = "../../creusot-contracts/src/std/array.rs" 59 20 59 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_T }
  
  type t_MaybeUninit  =
    { t_MaybeUninit__uninit: (); t_MaybeUninit__value: t_ManuallyDrop }
  
  type t_IndexRange  =
    { t_IndexRange__start: UInt64.t; t_IndexRange__end: UInt64.t }
  
  type t_IntoIter  =
    { t_IntoIter__data: Slice64.array t_MaybeUninit; t_IntoIter__alive: t_IndexRange }
  
  function view [#"../../creusot-contracts/src/std/array.rs" 50 4 50 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/array.rs" 58 4 58 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#sarray'0] view self = Seq.(++) visited (view o)
  
  goal refines: [%#sarray] forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 98 4 98 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self: t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'1
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  goal refines: [%#shash_map] forall self: t_IntoIter'0. forall result: (). produces self (Seq.empty: Seq.seq tuple'0) self
   -> produces self (Seq.empty: Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 64 4 64 33] (self: t_IntoIter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'1
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 72 4 72 64] (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view self) (deep_model k) = C_Some'0 v /\ get (view o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some'0 v
     -> get (view self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  goal refines: [%#shash_map] forall a: t_IntoIter'0. forall ab: Seq.seq tuple'0. forall b: t_IntoIter'0. forall bc: Seq.seq tuple'0. forall c: t_IntoIter'0. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self: t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  goal refines: [%#shash_map] forall a: t_Iter'0. forall ab: Seq.seq tuple. forall b: t_Iter'0. forall bc: Seq.seq tuple. forall c: t_Iter'0. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 150 4 150 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 116 4 116 33] (self: t_Iter'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 124 4 124 64] (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model'0 k) = C_Some v /\ get (view o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  goal refines: [%#shash_map] forall self: t_Iter'0. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
   -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 209 4 209 90
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self: t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  goal refines: [%#shash_map] forall a: t_IterMut'0. forall ab: Seq.seq tuple. forall b: t_IterMut'0. forall bc: Seq.seq tuple. forall c: t_IterMut'0. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map = "../../creusot-contracts/src/std/collections/hash_map.rs" 202 4 202 26
  let%span shash_map'0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  type t_FMap
  
  function len [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap] len self >= 0
  
  function view [#"../../creusot-contracts/src/std/collections/hash_map.rs" 168 4 168 33] (self: t_IterMut'0) : t_FMap
  
  predicate contains [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_V)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0
  
   =
    [%#sfmap'1] Map.get (view'0 self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_DeepModelTy) : t_Option
  
   =
    [%#sfmap'0] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_K) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_map.rs" 176 4 176 64] (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0)
  
   =
    [%#shash_map'0] len (view self) = Seq.length visited + len (view o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view self) (deep_model k) = C_Some v /\ get (view o) (deep_model k) = C_None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view o) k = C_Some v
     -> get (view self) k = C_Some v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view self) k = C_Some v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains visited { _p0 = k1; _p1 = v }) \/ get (view o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  goal refines: [%#shash_map] forall self: t_IterMut'0. forall result: (). produces self (Seq.empty: Seq.seq tuple) self
   -> produces self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 121 4 121 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines: [%#shash_set] forall self: t_IntoIter'1. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 128 4 128 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 65 4 65 33] (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model x) /\ not contains (view end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 64] (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines: [%#shash_set] forall a: t_IntoIter'1. forall ab: Seq.seq t_T. forall b: t_IntoIter'1. forall bc: Seq.seq t_T. forall c: t_IntoIter'1. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 167 4 167 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines: [%#shash_set] forall a: t_Iter'1. forall ab: Seq.seq t_T. forall b: t_Iter'1. forall bc: Seq.seq t_T. forall c: t_Iter'1. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 160 4 160 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 139 4 139 33] (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 64] (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines: [%#shash_set] forall self: t_Iter'1. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 218 4 218 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines: [%#shash_set] forall self: t_Intersection. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 225 4 225 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 186 4 186 33] (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 205 4 205 64] (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines: [%#shash_set] forall a: t_Intersection. forall ab: Seq.seq t_T. forall b: t_Intersection. forall bc: Seq.seq t_T. forall c: t_Intersection. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 246 4 246 26
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self: t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines: [%#shash_set] forall self: t_Difference. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../creusot-contracts/src/std/collections/hash_set.rs" 253 4 253 90
  let%span shash_set'0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_S
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_S; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_T
  
  type t_DeepModelTy
  
  function view [#"../../creusot-contracts/src/std/collections/hash_set.rs" 197 4 197 33] (self: t_Difference) : Fset.fset t_DeepModelTy
  
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy)
  
   =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_T) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 358 4 360 17] (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 72 0 76 9] (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference)
  
   =
    [%#shash_set'1] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces [#"../../creusot-contracts/src/std/collections/hash_set.rs" 233 4 233 64] (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference)
  
   =
    [%#shash_set'0] set_produces self visited o
  
  goal refines: [%#shash_set] forall a: t_Difference. forall ab: Seq.seq t_T. forall b: t_Difference. forall bc: Seq.seq t_T. forall c: t_Difference. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans__refines [#"../../creusot-contracts/src/std/deque.rs" 184 4 184 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 184 4 184 90
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 170 12 170 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 82 14 82 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 83 14 83 76
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'1] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'2] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 84 4 84 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. ([%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'0] forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 154 4 154 33] (self: t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 168 4 168 65] (self: t_Iter'0) (visited: Seq.seq t_T) (tl: t_Iter'0)
  
   =
    [%#sdeque'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  goal refines: [%#sdeque] forall a: t_Iter'0. forall ab: Seq.seq t_T. forall b: t_Iter'0. forall bc: Seq.seq t_T. forall c: t_Iter'0. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl__refines [#"../../creusot-contracts/src/std/deque.rs" 177 4 177 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 177 4 177 26
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 170 12 170 66
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 82 14 82 41
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 83 14 83 76
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_Iter'0  =
    { t_Iter__i1: t_Iter; t_Iter__i2: t_Iter }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'1] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'2] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 84 4 84 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. ([%#sslice] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'0] forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/deque.rs" 154 4 154 33] (self: t_Iter'0) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/deque.rs" 168 4 168 65] (self: t_Iter'0) (visited: Seq.seq t_T) (tl: t_Iter'0)
  
   =
    [%#sdeque'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  goal refines: [%#sdeque] forall self: t_Iter'0. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 72] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 72
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 50 12 53 98
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv'1 res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv'1 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv'1 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'2 self_)
   -> precondition () args
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 48 4 48 55] (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned)
  
   =
    [%#scloned'0] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  goal refines: [%#scloned] forall a: t_Cloned. forall ab: Seq.seq t_T. forall b: t_Cloned. forall bc: Seq.seq t_T. forall c: t_Cloned. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 59 4 59 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 59 4 59 26
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 50 12 53 98
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv'1 res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv'1 res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv'1 res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'2 x]. inv'2 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'2 self_)
   -> precondition () args
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 48 4 48 55] (self: t_Cloned) (visited: Seq.seq t_T) (o: t_Cloned)
  
   =
    [%#scloned'0] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> postcondition () (Seq.get s i) (Seq.get visited i))
  
  goal refines: [%#scloned] forall self: t_Cloned. forall result: (). produces'0 self (Seq.empty: Seq.seq t_T) self
   -> produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 59 4 59 26
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 48 4 48 64] (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied)
  
   =
    [%#scopied'0] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines: [%#scopied] forall self: t_Copied. forall result: (). produces'0 self (Seq.empty: Seq.seq t_T) self
   -> produces'0 self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 48 4 48 64] (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied)
  
   =
    [%#scopied'0] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines: [%#scopied] forall a: t_Copied. forall ab: Seq.seq t_T. forall b: t_Copied. forall bc: Seq.seq t_T. forall c: t_Copied. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 18 4 18 26
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty)
  
   =
    [%#sempty'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  goal refines: [%#sempty] forall self: t_Empty. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty = "../../creusot-contracts/src/std/iter/empty.rs" 24 4 24 90
  let%span sempty'0 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty  =
    { t_Empty__0: () }
  
  type t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self: t_Empty) (visited: Seq.seq t_T) (o: t_Empty)
  
   =
    [%#sempty'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  goal refines: [%#sempty] forall a: t_Empty. forall ab: Seq.seq t_T. forall b: t_Empty. forall bc: Seq.seq t_T. forall c: t_Empty. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 90
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 73 12 77 108
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 46 12 50 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self: t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 44 4 44 30] (self: t_Enumerate) =
    [%#senumerate'2] (forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i: MutBorrow.t t_I. completed i  -> produces i.current (Seq.empty: Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv'0 x]. inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 71 4 71 64] (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate)
  
   =
    [%#senumerate'0] Seq.length visited = n o - n self
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  goal refines: [%#senumerate] forall a: t_Enumerate. forall ab: Seq.seq tuple. forall b: t_Enumerate. forall bc: Seq.seq tuple. forall c: t_Enumerate. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 73 12 77 108
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  let%span senumerate'2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 46 12 50 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  type t_Item
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_Item }
  
  function n [#"../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self: t_Enumerate) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/enumerate.rs" 44 4 44 30] (self: t_Enumerate) =
    [%#senumerate'2] (forall s: Seq.seq t_Item, i: t_I [produces (iter self) s i]. produces (iter self) s i
     -> n self + Seq.length s < UInt64.t'int v_MAX)
    /\ (forall i: MutBorrow.t t_I. completed i  -> produces i.current (Seq.empty: Seq.seq t_Item) i.final)
  
  axiom inv_axiom [@rewrite]: forall x: t_Enumerate [inv'0 x]. inv'0 x
  = (invariant' x
  /\ match x with
    | {t_Enumerate__iter = iter'0 ; t_Enumerate__count = count} -> inv iter'0
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 71 4 71 64] (self: t_Enumerate) (visited: Seq.seq tuple) (o: t_Enumerate)
  
   =
    [%#senumerate'0] Seq.length visited = n o - n self
    /\ (exists s: Seq.seq t_Item. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._p0 = n self + i /\ (Seq.get visited i)._p1 = Seq.get s i))
  
  goal refines: [%#senumerate] forall self: t_Enumerate. forall result: (). produces'0 self (Seq.empty: Seq.seq tuple) self
   -> produces'0 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 103 4 103 26
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 139
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 118
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: bool) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: bool. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self: t_Filter) =
    [%#sfilter'1] forall f: t_F, i: t_Item. precondition f i
    /\ (forall f'0: t_F, g: t_F. hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1: t_F, f2: t_F, i'0: t_Item. not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Filter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Filter [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self: t_Filter) : t_F
  
  axiom func_spec: forall self: t_Filter. [%#sfilter'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self: t_Filter) : t_I
  
  axiom iter_spec: forall self: t_Filter. [%#sfilter'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter)
  
   =
    [%#sfilter'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  goal refines: [%#sfilter] forall self: t_Filter. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfilter = "../../creusot-contracts/src/std/iter/filter.rs" 109 4 109 90
  let%span sfilter'0 = "../../creusot-contracts/src/std/iter/filter.rs" 86 12 97 139
  let%span sfilter'1 = "../../creusot-contracts/src/std/iter/filter.rs" 33 12 39 118
  let%span sfilter'2 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'3 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_Filter  =
    { t_Filter__iter: t_I; t_Filter__predicate: t_F }
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: bool)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: bool) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: bool. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: bool. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter.rs" 30 4 30 30] (self: t_Filter) =
    [%#sfilter'1] forall f: t_F, i: t_Item. precondition f i
    /\ (forall f'0: t_F, g: t_F. hist_inv f'0 g  -> f'0 = g)
    /\ (forall f1: t_F, f2: t_F, i'0: t_Item. not (postcondition_mut f1 i'0 f2 true
    /\ postcondition_mut f1 i'0 f2 false))
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Filter)
  
  axiom inv_axiom [@rewrite]: forall x: t_Filter [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter ; t_Filter__predicate = predicate'} -> inv iter /\ inv'0 predicate'
    end)
  
  function func [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self: t_Filter) : t_F
  
  axiom func_spec: forall self: t_Filter. [%#sfilter'2] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self: t_Filter) : t_I
  
  axiom iter_spec: forall self: t_Filter. [%#sfilter'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 84 4 84 67] (self: t_Filter) (visited: Seq.seq t_Item) (succ: t_Filter)
  
   =
    [%#sfilter'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i: int. 0 <= i /\ i < Seq.length s
     -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  goal refines: [%#sfilter] forall a: t_Filter. forall ab: Seq.seq t_Item. forall b: t_Filter. forall bc: Seq.seq t_Item. forall c: t_Filter. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 103 4 103 26
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 143
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 49
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 53
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 130
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f: t_F) =
    [%#sfilter_map'4] forall i: t_Item. precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f: t_F) =
    [%#sfilter_map'5] forall g: t_F. hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1: t_F) =
    [%#sfilter_map'6] forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self: t_FilterMap) : t_F
  
  axiom func_spec: forall self: t_FilterMap. [%#sfilter_map'2] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self: t_FilterMap) =
    [%#sfilter_map'1] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite]: forall x: t_FilterMap [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self: t_FilterMap) : t_I
  
  axiom iter_spec: forall self: t_FilterMap. [%#sfilter_map'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap)
  
   =
    [%#sfilter_map'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j: int. 0 <= j /\ j < Seq.length s
     -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  goal refines: [%#sfilter_map] forall self: t_FilterMap. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
   -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfilter_map = "../../creusot-contracts/src/std/iter/filter_map.rs" 109 4 109 90
  let%span sfilter_map'0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 84 12 97 143
  let%span sfilter_map'1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 33 12 37 32
  let%span sfilter_map'2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 47 16 47 49
  let%span sfilter_map'5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 55 16 55 53
  let%span sfilter_map'6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 62 16 62 130
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I
  
  type t_F
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_I; t_FilterMap__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate no_precondition [#"../../creusot-contracts/src/std/iter/filter_map.rs" 46 0 46 68] (f: t_F) =
    [%#sfilter_map'4] forall i: t_Item. precondition f i
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: t_Option)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: t_Option) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_Option. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_Option. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate immutable [#"../../creusot-contracts/src/std/iter/filter_map.rs" 54 0 54 62] (f: t_F) =
    [%#sfilter_map'5] forall g: t_F. hist_inv f g  -> f = g
  
  predicate precise [#"../../creusot-contracts/src/std/iter/filter_map.rs" 61 0 61 61] (f1: t_F) =
    [%#sfilter_map'6] forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FilterMap)
  
  function func [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self: t_FilterMap) : t_F
  
  axiom func_spec: forall self: t_FilterMap. [%#sfilter_map'2] inv'1 self  -> inv'0 (func self)
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/filter_map.rs" 30 4 30 30] (self: t_FilterMap) =
    [%#sfilter_map'1] no_precondition (func self) /\ immutable (func self) /\ precise (func self)
  
  axiom inv_axiom [@rewrite]: forall x: t_FilterMap [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter ; t_FilterMap__f = f} -> inv iter /\ inv'0 f
    end)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self: t_FilterMap) : t_I
  
  axiom iter_spec: forall self: t_FilterMap. [%#sfilter_map'3] inv'1 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 82 4 82 67] (self: t_FilterMap) (visited: Seq.seq t_B) (succ: t_FilterMap)
  
   =
    [%#sfilter_map'0] invariant' self
     -> hist_inv (func self) (func succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces (iter self) s (iter succ)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j: int. 0 <= j /\ j < Seq.length s
     -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  goal refines: [%#sfilter_map] forall a: t_FilterMap. forall ab: Seq.seq t_B. forall b: t_FilterMap. forall bc: Seq.seq t_B. forall c: t_FilterMap. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. ([%#sfuse'1] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'2] forall other: t_Fuse. view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  goal refines: [%#sfuse] forall a: t_Fuse. forall ab: Seq.seq t_Item. forall b: t_Fuse. forall bc: Seq.seq t_Item. forall c: t_Fuse. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. ([%#sfuse'1] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'2] forall other: t_Fuse. view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  goal refines: [%#sfuse] forall self: t_Fuse. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi306403796899090344__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map.rs" 76 4 76 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 76 4 76 26
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 59 12 70 75
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'1] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'2] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 57 4 57 67] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map)
  
   =
    [%#smap'0] hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines: [%#smap] forall self: t_Map. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
   -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi306403796899090344__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map.rs" 82 4 82 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 82 4 82 90
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 59 12 70 75
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  type t_B
  
  type t_Item
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Item) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: t_Item) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: t_Item, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: t_Item, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'1] inv'1 self  -> inv'0 (func self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'2] inv'1 self  -> inv (iter self)
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_Item)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 57 4 57 67] (self: t_Map) (visited: Seq.seq t_B) (succ: t_Map)
  
   =
    [%#smap'0] hist_inv (func self) (func succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item [produces (iter self) s (iter succ)]. Seq.length s = Seq.length visited
    /\ produces (iter self) s (iter succ)
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func self = func succ
    else
      (Seq.get fs 0).current = func self /\ (Seq.get fs (Seq.length visited - 1)).final = func succ
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv (func self) (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines: [%#smap] forall a: t_Map. forall ab: Seq.seq t_B. forall b: t_Map. forall bc: Seq.seq t_B. forall c: t_Map. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'0] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines: [%#smap_inv] forall self: t_MapInv. forall result: (). produces'0 self (Seq.empty: Seq.seq t_B) self
   -> produces'0 self (Seq.empty: Seq.seq t_B) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  type t_B
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: tuple)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'0] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines: [%#smap_inv] forall a: t_MapInv. forall ab: Seq.seq t_B. forall b: t_MapInv. forall bc: Seq.seq t_B. forall c: t_MapInv. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans__refines [#"../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 37 4 37 90
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self: t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self: t_Once) (visited: Seq.seq t_T) (o: t_Once)
  
   =
    [%#sonce'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines: [%#sonce] forall a: t_Once. forall ab: Seq.seq t_T. forall b: t_Once. forall bc: Seq.seq t_T. forall c: t_Once. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl__refines [#"../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce = "../../creusot-contracts/src/std/iter/once.rs" 31 4 31 26
  let%span sonce'0 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  type t_Once  =
    { t_Once__inner: t_IntoIter }
  
  function view [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self: t_Once) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self: t_Once) (visited: Seq.seq t_T) (o: t_Once)
  
   =
    [%#sonce'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines: [%#sonce] forall self: t_Once. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'0] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  goal refines: [%#srange] forall self: t_Range. forall result: (). produces self (Seq.empty: Seq.seq t_Idx) self
   -> produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 41 4 41 90
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'0] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  goal refines: [%#srange] forall a: t_Range. forall ab: Seq.seq t_Idx. forall b: t_Range. forall bc: Seq.seq t_Idx. forall c: t_Range. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 111 4 111 90
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'1] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  goal refines: [%#srange] forall a: t_RangeInclusive. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 104 4 104 26
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'1] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/range.rs" 91 4 91 64] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  goal refines: [%#srange] forall self: t_RangeInclusive. forall result: (). produces self (Seq.empty: Seq.seq t_Idx) self
   -> produces self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 31 4 31 26
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 99
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self: t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat)
  
   =
    [%#srepeat'0] self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> postcondition () (view self) (Seq.get visited i))
  
  goal refines: [%#srepeat] forall self: t_Repeat. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span srepeat = "../../creusot-contracts/src/std/iter/repeat.rs" 37 4 37 90
  let%span srepeat'0 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 99
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  type t_Repeat  =
    { t_Repeat__element: t_T }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_T) (result: t_T)
  
  
  axiom postcondition_fndef: forall args: t_T, res: t_T [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  
  axiom postcondition_fndef'0: forall args: t_T, res: t_T [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_T, res_state: (), res: t_T. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1: forall args: t_T, res: t_T [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_spec: forall self: (), args: t_T, res: t_T. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_T, res_state: (), res: t_T. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition () args]. (let self_ = args in inv'0 self_)
   -> precondition () args
  
  let rec clone' (self_:t_T) (return'  (x:t_T))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_T)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  function view [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self: t_Repeat) : t_T
  
  predicate produces [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self: t_Repeat) (visited: Seq.seq t_T) (o: t_Repeat)
  
   =
    [%#srepeat'0] self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited  -> postcondition () (view self) (Seq.get visited i))
  
  goal refines: [%#srepeat] forall a: t_Repeat. forall ab: Seq.seq t_T. forall b: t_Repeat. forall bc: Seq.seq t_T. forall c: t_Repeat. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 78 14 78 50
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 82 15 82 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 83 15 83 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 84 14 84 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 47 4 47 26
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 75 4 75 70] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 85 4 85 96] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_back_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 79 4 79 32] (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. [%#siter] produces_back self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rev)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rev [inv'0 x]. inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self: t_Rev) : t_I
  
  axiom iter_spec: forall self: t_Rev. [%#srev'1] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev)
  
   =
    [%#srev'0] produces_back (iter self) visited (iter o)
  
  goal refines: [%#srev] forall self: t_Rev. forall result: (). produces self (Seq.empty: Seq.seq t_Item) self
   -> produces self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 78 14 78 50
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 82 15 82 37
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 83 15 83 37
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 84 14 84 47
  let%span srev = "../../creusot-contracts/src/std/iter/rev.rs" 53 4 53 90
  let%span srev'0 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev'1 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  
  use seq.Seq
  
  type t_I
  
  type t_Rev  =
    { t_Rev__iter: t_I }
  
  type t_Item
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter.rs" 75 4 75 70] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_back_trans [#"../../creusot-contracts/src/std/iter.rs" 85 4 85 96] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_back_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces_back a ab b)
   -> ([%#siter'1] produces_back b bc c)  -> ([%#siter'2] produces_back a (Seq.(++) ab bc) c)
  
  function produces_back_refl [#"../../creusot-contracts/src/std/iter.rs" 79 4 79 32] (self: t_I) : ()
  
  axiom produces_back_refl_spec: forall self: t_I. [%#siter] produces_back self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Rev)
  
  axiom inv_axiom [@rewrite]: forall x: t_Rev [inv'0 x]. inv'0 x
  = match x with
    | {t_Rev__iter = iter} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self: t_Rev) : t_I
  
  axiom iter_spec: forall self: t_Rev. [%#srev'1] inv'0 self  -> inv (iter self)
  
  predicate produces [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self: t_Rev) (visited: Seq.seq t_Item) (o: t_Rev)
  
   =
    [%#srev'0] produces_back (iter self) visited (iter o)
  
  goal refines: [%#srev] forall a: t_Rev. forall ab: Seq.seq t_Item. forall b: t_Rev. forall bc: Seq.seq t_Item. forall c: t_Rev. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 64 12 69 69
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self: t_Skip) : int
  
  axiom n_spec: forall self: t_Skip. [%#sskip'1] n self >= 0 /\ n self <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'2] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 62 4 62 64] (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip)
  
   =
    [%#sskip'0] visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  goal refines: [%#sskip] forall a: t_Skip. forall ab: Seq.seq t_Item. forall b: t_Skip. forall bc: Seq.seq t_Item. forall c: t_Skip. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 64 12 69 69
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip'2 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self: t_Skip) : int
  
  axiom n_spec: forall self: t_Skip. [%#sskip'1] n self >= 0 /\ n self <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'2] inv'0 self  -> inv (iter self)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_Item)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 62 4 62 64] (self: t_Skip) (visited: Seq.seq t_Item) (o: t_Skip)
  
   =
    [%#sskip'0] visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ n o = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = n self
    /\ produces (iter self) (Seq.(++) s visited) (iter o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> resolve (Seq.get s i)))
  
  goal refines: [%#sskip] forall self: t_Skip. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl__refines [#"../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 67 12 67 88
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 33 14 33 50
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 34 4 34 21] (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. [%#stake'1] n self >= 0 /\ n self <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 65 4 65 64] (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take)
  
   =
    [%#stake'0] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  goal refines: [%#stake] forall self: t_Take. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans__refines [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 67 12 67 88
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 33 14 33 50
  let%span stake'2 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  type t_Item
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function n [#"../../creusot-contracts/src/std/iter/take.rs" 34 4 34 21] (self: t_Take) : int
  
  axiom n_spec: forall self: t_Take. [%#stake'1] n self >= 0 /\ n self <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n'0} -> inv iter
    end
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'2] inv'0 self  -> inv (iter self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 65 4 65 64] (self: t_Take) (visited: Seq.seq t_Item) (o: t_Take)
  
   =
    [%#stake'0] n self = n o + Seq.length visited /\ produces (iter self) visited (iter o)
  
  goal refines: [%#stake] forall a: t_Take. forall ab: Seq.seq t_Item. forall b: t_Take. forall bc: Seq.seq t_Item. forall c: t_Take. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 61 4 61 90
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Zip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip [inv'1 x]. inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self: t_Zip) : t_A
  
  axiom itera_spec: forall self: t_Zip. [%#szip'1] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  
  axiom produces_trans_spec'0: forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self: t_Zip) : t_B
  
  axiom iterb_spec: forall self: t_Zip. [%#szip'2] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip)
  
   =
    [%#szip'0] exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  goal refines: [%#szip] forall a: t_Zip. forall ab: Seq.seq tuple. forall b: t_Zip. forall bc: Seq.seq tuple. forall c: t_Zip. produces'1 b bc c
  /\ produces'1 a ab b
   -> produces'1 b bc c
  /\ produces'1 a ab b /\ (forall result: (). produces'1 a (Seq.(++) ab bc) c  -> produces'1 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span szip = "../../creusot-contracts/src/std/iter/zip.rs" 55 4 55 26
  let%span szip'0 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip'1 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip'2 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A
  
  type t_B
  
  type t_Zip  =
    { t_Zip__a: t_A; t_Zip__b: t_B; t_Zip__index: UInt64.t; t_Zip__len: UInt64.t; t_Zip__a_len: UInt64.t }
  
  type t_Item
  
  type t_Item'0
  
  type tuple  =
    { _p0: t_Item; _p1: t_Item'0 }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  
  axiom produces_trans_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_A) : ()
  
  axiom produces_refl_spec: forall self: t_A. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Zip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Zip [inv'1 x]. inv'1 x
  = match x with
    | {t_Zip__a = a ; t_Zip__b = b ; t_Zip__index = index ; t_Zip__len = len ; t_Zip__a_len = a_len} -> inv a /\ inv'0 b
    end
  
  function itera [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self: t_Zip) : t_A
  
  axiom itera_spec: forall self: t_Zip. [%#szip'1] inv'1 self  -> inv (itera self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  
  axiom produces_trans_spec'0: forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. ([%#siter'0] produces'0 a ab b)
   -> ([%#siter'1] produces'0 b bc c)  -> ([%#siter'2] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_B) : ()
  
  axiom produces_refl_spec'0: forall self: t_B. [%#siter] produces'0 self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self: t_Zip) : t_B
  
  axiom iterb_spec: forall self: t_Zip. [%#szip'2] inv'1 self  -> inv'0 (iterb self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self: t_Zip) (visited: Seq.seq tuple) (o: t_Zip)
  
   =
    [%#szip'0] exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _p0 = Seq.get p1 i; _p1 = Seq.get p2 i })
    /\ produces (itera self) p1 (itera o) /\ produces'0 (iterb self) p2 (iterb o)
  
  goal refines: [%#szip] forall self: t_Zip. forall result: (). produces'1 self (Seq.empty: Seq.seq tuple) self
   -> produces'1 self (Seq.empty: Seq.seq tuple) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl__refines [#"../../creusot-contracts/src/std/iter.rs" 231 4 231 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 231 4 231 26
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 219 20 219 64
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'2] produces a ab b)
   -> ([%#siter'3] produces b bc c)  -> ([%#siter'4] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter'1] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 218 4 218 64] (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I)
  
   =
    [%#siter'0] produces self.current visited o.current /\ self.final = o.final
  
  goal refines: [%#siter] forall self: MutBorrow.t t_I. forall result: (). produces'0 self (Seq.empty: Seq.seq t_Item) self
   -> produces'0 self (Seq.empty: Seq.seq t_Item) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans__refines [#"../../creusot-contracts/src/std/iter.rs" 238 4 238 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 238 4 238 90
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 219 20 219 64
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'3 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'4 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'2] produces a ab b)
   -> ([%#siter'3] produces b bc c)  -> ([%#siter'4] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter'1] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 218 4 218 64] (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I)
  
   =
    [%#siter'0] produces self.current visited o.current /\ self.final = o.final
  
  goal refines: [%#siter] forall a: MutBorrow.t t_I. forall ab: Seq.seq t_Item. forall b: MutBorrow.t t_I. forall bc: Seq.seq t_Item. forall c: MutBorrow.t t_I. produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result: (). produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 648 4 648 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 648 4 648 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 641 12 642 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 625 4 625 30] (self: t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 639 4 639 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines: [%#soption] forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 654 4 654 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 654 4 654 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 641 12 642 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 625 4 625 30] (self: t_IntoIter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 639 4 639 64] (self: t_IntoIter) (visited: Seq.seq t_T) (o: t_IntoIter)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines: [%#soption] forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 691 4 691 90] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 691 4 691 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 678 12 679 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 662 4 662 34] (self: t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 676 4 676 64] (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines: [%#soption] forall a: t_Iter. forall ab: Seq.seq t_T. forall b: t_Iter. forall bc: Seq.seq t_T. forall c: t_Iter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 685 4 685 26] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 685 4 685 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 678 12 679 96
  
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_Iter  =
    { t_Iter__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 662 4 662 34] (self: t_Iter) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 676 4 676 64] (self: t_Iter) (visited: Seq.seq t_T) (o: t_Iter)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines: [%#soption] forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 722 4 722 26] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 722 4 722 26
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 715 12 716 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 699 4 699 38] (self: t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 713 4 713 64] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines: [%#soption] forall self: t_IterMut. forall result: (). produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
   -> produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 728 4 728 90] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption = "../../creusot-contracts/src/std/option.rs" 728 4 728 90
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 715 12 716 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some (MutBorrow.t t_T)
  
  type t_Item  =
    { t_Item__opt: t_Option }
  
  type t_IterMut  =
    { t_IterMut__inner: t_Item }
  
  function view [#"../../creusot-contracts/src/std/option.rs" 699 4 699 38] (self: t_IterMut) : t_Option
  
  predicate produces [#"../../creusot-contracts/src/std/option.rs" 713 4 713 64] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut)
  
   =
    [%#soption'0] visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view self = C_Some e /\ visited = Seq.singleton e /\ view o = C_None)
  
  goal refines: [%#soption] forall a: t_IterMut. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 433 4 433 90
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 83 14 83 76
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'3] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'4] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 84 4 84 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. ([%#sslice'1] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'2] forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 403 4 403 33] (self: t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 417 4 417 65] (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter)
  
   =
    [%#sslice'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  goal refines: [%#sslice] forall a: t_Iter. forall ab: Seq.seq t_T. forall b: t_Iter. forall bc: Seq.seq t_T. forall c: t_Iter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 426 4 426 26
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 82 14 82 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 83 14 83 76
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'3] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'4] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 43 4 43 33] (self: Slice64.slice t_T) : Seq.seq t_T =
    [%#smodel] view self
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_ref_seq [#"../../creusot-contracts/src/std/slice.rs" 84 4 84 35] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_spec: forall self: Slice64.slice t_T. ([%#sslice'1] Seq.length (to_ref_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'2] forall i: int. 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 403 4 403 33] (self: t_Iter) : Slice64.slice t_T
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 417 4 417 65] (self: t_Iter) (visited: Seq.seq t_T) (tl: t_Iter)
  
   =
    [%#sslice'0] to_ref_seq (view'1 self) = Seq.(++) visited (to_ref_seq (view'1 tl))
  
  goal refines: [%#sslice] forall self: t_Iter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 486 4 486 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 486 4 486 90
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 472 12 472 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 73 14 73 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 74 14 74 80
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'4] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'5] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 76 4 76 43] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). ([%#sslice'1] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'2] forall i: int. 0 <= i /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0: forall self: t_IterMut. [%#sslice'3] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 470 4 470 65] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut)
  
   =
    [%#sslice'0] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  goal refines: [%#sslice] forall a: t_IterMut. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 479 4 479 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 479 4 479 26
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 472 12 472 66
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 73 14 73 41
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 74 14 74 80
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span sslice'4 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'5 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'4] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'5] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq t_T
  
   =
    [%#smodel] view self.current
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self: Slice64.slice t_T) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  function to_mut_seq [#"../../creusot-contracts/src/std/slice.rs" 76 4 76 43] (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  
  axiom to_mut_seq_spec: forall self: MutBorrow.t (Slice64.slice t_T). ([%#sslice'1] Seq.length (to_mut_seq self)
  = Seq.length (view'0 self))
  && ([%#sslice'2] forall i: int. 0 <= i /\ i < Seq.length (to_mut_seq self)
   -> Seq.get (to_mut_seq self) i
  = MutBorrow.borrow_logic (index_logic self.current i) (index_logic self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0: forall self: t_IterMut. [%#sslice'3] Seq.length (view (view'1 self).final)
  = Seq.length (view (view'1 self).current)
  
  predicate produces [#"../../creusot-contracts/src/std/slice.rs" 470 4 470 65] (self: t_IterMut) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut)
  
   =
    [%#sslice'0] to_mut_seq (view'1 self) = Seq.(++) visited (to_mut_seq (view'1 tl))
  
  goal refines: [%#sslice] forall self: t_IterMut. forall result: (). produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
   -> produces self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans__refines [#"../../creusot-contracts/src/std/vec.rs" 263 4 263 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 263 4 263 72
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 249 12 249 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 247 4 247 57] (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter)
  
   =
    [%#svec'0] view self = Seq.(++) visited (view rhs)
  
  goal refines: [%#svec] forall a: t_IntoIter. forall ab: Seq.seq t_T. forall b: t_IntoIter. forall bc: Seq.seq t_T. forall c: t_IntoIter. produces b bc c
  /\ produces a ab b
   -> produces b bc c
  /\ produces a ab b /\ (forall result: (). produces a (Seq.(++) ab bc) c  -> produces a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl__refines [#"../../creusot-contracts/src/std/vec.rs" 256 4 256 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 256 4 256 26
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 249 12 249 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate produces [#"../../creusot-contracts/src/std/vec.rs" 247 4 247 57] (self: t_IntoIter) (visited: Seq.seq t_T) (rhs: t_IntoIter)
  
   =
    [%#svec'0] view self = Seq.(++) visited (view rhs)
  
  goal refines: [%#svec] forall self: t_IntoIter. forall result: (). produces self (Seq.empty: Seq.seq t_T) self
   -> produces self (Seq.empty: Seq.seq t_T) self
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 161 4 161 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Less
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). lt_log'0 x y
  = (cmp_log'0 x y = C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1__refines [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 189 4 189 33
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. cmp_log'0 x y = C_Less
   -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater  -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp__refines [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 200 4 200 31
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). (x = y)
  = (cmp_log'0 x y = C_Equal)  -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl__refines [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 176 4 176 20
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines: [%#scmp] forall x: t_Reverse. forall result: (). cmp_log'0 x x = C_Equal  -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans__refines [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 183 4 183 52
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall z: t_Reverse. forall o: t_Ordering. cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2__refines [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 195 4 195 33
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'7] cmp_log x y = C_Less)  -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. cmp_log'0 x y = C_Greater
   -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less  -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 156 4 156 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Greater
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). le_log'0 x y
  = (cmp_log'0 x y <> C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 166 4 166 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o <> C_Less
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). ge_log'0 x y
  = (cmp_log'0 x y <> C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 171 4 171 35
  let%span scmp'0 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T
  
  type t_Reverse  =
    { t_Reverse__0: t_T }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self: t_Reverse) (o: t_Reverse) : t_Ordering
  
   =
    [%#scmp'0] match cmp_log self.t_Reverse__0 o.t_Reverse__0 with
      | C_Equal -> C_Equal
      | C_Less -> C_Greater
      | C_Greater -> C_Less
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_Reverse) (o: t_Reverse) =
    [%#sord] cmp_log'0 self o = C_Greater
  
  goal refines: [%#scmp] forall x: t_Reverse. forall y: t_Reverse. forall result: (). gt_log'0 x y
  = (cmp_log'0 x y = C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). (x = y) = (cmp_log'0 x y = C_Equal)
   -> (x = y) = (cmp_log'0 x y = C_Equal)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_Option) (o: t_Option) =
    [%#sord'0] cmp_log'0 self o = C_Less
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). lt_log'0 x y
  = (cmp_log'0 x y = C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. cmp_log'0 x y = C_Less
   -> cmp_log'0 x y = C_Less /\ (forall result: (). cmp_log'0 y x = C_Greater  -> cmp_log'0 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_Option) (o: t_Option) =
    [%#sord'0] cmp_log'0 self o <> C_Less
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). ge_log'0 x y
  = (cmp_log'0 x y <> C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_Option) (o: t_Option) =
    [%#sord'0] cmp_log'0 self o = C_Greater
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). gt_log'0 x y
  = (cmp_log'0 x y = C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall z: t_Option. forall o: t_Ordering. cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result: (). cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines: [%#sord] forall x: t_Option. forall result: (). cmp_log'0 x x = C_Equal  -> cmp_log'0 x x = C_Equal
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_Option) (o: t_Option) =
    [%#sord'0] cmp_log'0 self o <> C_Greater
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. forall result: (). le_log'0 x y
  = (cmp_log'0 x y <> C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 609 8 614 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_spec: forall x: t_T, y: t_T. [%#sord'12] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym2_spec: forall x: t_T, y: t_T. ([%#sord'10] cmp_log x y = C_Greater)
   -> ([%#sord'11] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_T) (y: t_T) : ()
  
  axiom antisym1_spec: forall x: t_T, y: t_T. ([%#sord'8] cmp_log x y = C_Less)  -> ([%#sord'9] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. ([%#sord'5] cmp_log x y = o)
   -> ([%#sord'6] cmp_log y z = o)  -> ([%#sord'7] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_T) : ()
  
  axiom refl_spec: forall x: t_T. [%#sord'4] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_T) (o: t_T)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_spec: forall x: t_T, y: t_T. [%#sord'3] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_T) (o: t_T)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_spec: forall x: t_T, y: t_T. [%#sord'2] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_T) (o: t_T)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_spec: forall x: t_T, y: t_T. [%#sord'1] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_T) (o: t_T)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_spec: forall x: t_T, y: t_T. [%#sord'0] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 608 4 608 41] (self: t_Option) (o: t_Option) : t_Ordering
  
   =
    [%#soption] match { _p0 = self; _p1 = o } with
      | {_p0 = C_None ; _p1 = C_None} -> C_Equal
      | {_p0 = C_None ; _p1 = C_Some _} -> C_Less
      | {_p0 = C_Some _ ; _p1 = C_None} -> C_Greater
      | {_p0 = C_Some x ; _p1 = C_Some y} -> cmp_log x y
      end
  
  goal refines: [%#sord] forall x: t_Option. forall y: t_Option. cmp_log'0 x y = C_Greater
   -> cmp_log'0 x y = C_Greater /\ (forall result: (). cmp_log'0 y x = C_Less  -> cmp_log'0 y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). Real.(<=) x y
  = (cmp_log x y <> C_Greater)  -> Real.(<=) x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). Real.(<) x y
  = (cmp_log x y = C_Less)  -> Real.(<) x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). Real.(>=) x y
  = (cmp_log x y <> C_Less)  -> Real.(>=) x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall result: (). Real.(>) x y
  = (cmp_log x y = C_Greater)  -> Real.(>) x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. forall z: Real.real. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall y: Real.real. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span snum_rational = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self: Real.real) (o: Real.real) : t_Ordering
  
   =
    [%#snum_rational] if Real.(<) self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Real.real. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x >= y) = (cmp_log x y <> C_Less)
   -> (x >= y) = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall y: int. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x > y) = (cmp_log x y = C_Greater)
   -> (x > y) = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x <= y) = (cmp_log x y <> C_Greater)
   -> (x <= y) = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x < y) = (cmp_log x y = C_Less)
   -> (x < y) = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall y: int. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall y: int. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord'0] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: int. forall y: int. forall z: int. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.ge x y = (cmp_log x y <> C_Less)
   -> UInt8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.gt x y
  = (cmp_log x y = C_Greater)  -> UInt8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.lt x y = (cmp_log x y = C_Less)
   -> UInt8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.le x y
  = (cmp_log x y <> C_Greater)  -> UInt8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt8.t) (o: UInt8.t) : t_Ordering
   =
    [%#sord'0] if UInt8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt8.t. forall y: UInt8.t. forall z: UInt8.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.gt x y
  = (cmp_log x y = C_Greater)  -> UInt16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall z: UInt16.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.le x y
  = (cmp_log x y <> C_Greater)  -> UInt16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.lt x y
  = (cmp_log x y = C_Less)  -> UInt16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.ge x y
  = (cmp_log x y <> C_Less)  -> UInt16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall y: UInt16.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt16.t) (o: UInt16.t) : t_Ordering
  
   =
    [%#sord'0] if UInt16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt16.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.ge x y
  = (cmp_log x y <> C_Less)  -> UInt32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.lt x y
  = (cmp_log x y = C_Less)  -> UInt32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.le x y
  = (cmp_log x y <> C_Greater)  -> UInt32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall z: UInt32.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt32.t) (o: UInt32.t) : t_Ordering
  
   =
    [%#sord'0] if UInt32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.gt x y
  = (cmp_log x y = C_Greater)  -> UInt32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y
  = (cmp_log x y = C_Greater)  -> UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y
  = (cmp_log x y = C_Less)  -> UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y
  = (cmp_log x y <> C_Less)  -> UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y
  = (cmp_log x y <> C_Greater)  -> UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall z: UInt128.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.le x y
  = (cmp_log x y <> C_Greater)  -> UInt128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.ge x y
  = (cmp_log x y <> C_Less)  -> UInt128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.gt x y
  = (cmp_log x y = C_Greater)  -> UInt128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt128.t) (o: UInt128.t) : t_Ordering
  
   =
    [%#sord'0] if UInt128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.lt x y
  = (cmp_log x y = C_Less)  -> UInt128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y
  = (cmp_log x y <> C_Greater)  -> UInt64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y
  = (cmp_log x y <> C_Less)  -> UInt64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y
  = (cmp_log x y = C_Greater)  -> UInt64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: UInt64.t) (o: UInt64.t) : t_Ordering
  
   =
    [%#sord'0] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y
  = (cmp_log x y = C_Less)  -> UInt64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.ge x y = (cmp_log x y <> C_Less)
   -> Int8.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.le x y = (cmp_log x y <> C_Greater)
   -> Int8.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.lt x y = (cmp_log x y = C_Less)
   -> Int8.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.gt x y = (cmp_log x y = C_Greater)
   -> Int8.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall z: Int8.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall y: Int8.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int8.t) (o: Int8.t) : t_Ordering =
    [%#sord'0] if Int8.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int8.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.lt x y = (cmp_log x y = C_Less)
   -> Int16.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.ge x y = (cmp_log x y <> C_Less)
   -> Int16.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall z: Int16.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.gt x y
  = (cmp_log x y = C_Greater)  -> Int16.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int16.t) (o: Int16.t) : t_Ordering
   =
    [%#sord'0] if Int16.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.le x y
  = (cmp_log x y <> C_Greater)  -> Int16.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.ge x y = (cmp_log x y <> C_Less)
   -> Int32.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall z: Int32.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.le x y
  = (cmp_log x y <> C_Greater)  -> Int32.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.lt x y = (cmp_log x y = C_Less)
   -> Int32.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.gt x y
  = (cmp_log x y = C_Greater)  -> Int32.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int32.t) (o: Int32.t) : t_Ordering
   =
    [%#sord'0] if Int32.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int32.t. forall y: Int32.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y
  = (cmp_log x y <> C_Greater)  -> Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y
  = (cmp_log x y = C_Greater)  -> Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log x y = C_Less)
   -> Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log x y <> C_Less)
   -> Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.lt x y
  = (cmp_log x y = C_Less)  -> Int128.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall z: Int128.t. forall o: t_Ordering. cmp_log y z
  = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.gt x y
  = (cmp_log x y = C_Greater)  -> Int128.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.le x y
  = (cmp_log x y <> C_Greater)  -> Int128.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int128.t) (o: Int128.t) : t_Ordering
  
   =
    [%#sord'0] if Int128.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.ge x y
  = (cmp_log x y <> C_Less)  -> Int128.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y
  = (cmp_log x y = C_Greater)  -> Int64.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log x y <> C_Less)
   -> Int64.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log x y = C_Less)
   -> Int64.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y
  = (cmp_log x y <> C_Greater)  -> Int64.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Int64.t) (o: Int64.t) : t_Ordering
   =
    [%#sord'0] if Int64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). Char.ge x y = (cmp_log x y <> C_Less)
   -> Char.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). Char.lt x y = (cmp_log x y = C_Less)
   -> Char.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall z: Char.t. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). Char.gt x y = (cmp_log x y = C_Greater)
   -> Char.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: Char.t) (o: Char.t) : t_Ordering =
    [%#sord'0] if Char.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: Char.t. forall y: Char.t. forall result: (). Char.le x y = (cmp_log x y <> C_Greater)
   -> Char.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). Bool.le x y = (cmp_log x y <> C_Greater)
   -> Bool.le x y = (cmp_log x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall y: bool. cmp_log x y = C_Greater
   -> cmp_log x y = C_Greater /\ (forall result: (). cmp_log y x = C_Less  -> cmp_log y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall y: bool. cmp_log x y = C_Less
   -> cmp_log x y = C_Less /\ (forall result: (). cmp_log y x = C_Greater  -> cmp_log y x = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). Bool.ge x y = (cmp_log x y <> C_Less)
   -> Bool.ge x y = (cmp_log x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). Bool.lt x y = (cmp_log x y = C_Less)
   -> Bool.lt x y = (cmp_log x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall result: (). cmp_log x x = C_Equal  -> cmp_log x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall z: bool. forall o: t_Ordering. cmp_log y z = o
  /\ cmp_log x y = o  -> cmp_log y z = o /\ cmp_log x y = o /\ (forall result: (). cmp_log x z = o  -> cmp_log x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). (x = y) = (cmp_log x y = C_Equal)
   -> (x = y) = (cmp_log x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self: bool) (o: bool) : t_Ordering =
    [%#sord'0] if Bool.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  goal refines: [%#sord] forall x: bool. forall y: bool. forall result: (). Bool.gt x y = (cmp_log x y = C_Greater)
   -> Bool.gt x y = (cmp_log x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self: tuple) (o: tuple) =
    [%#sord'0] self._p0 = o._p0 /\ gt_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). gt_log'1 x y = (cmp_log'1 x y = C_Greater)
   -> gt_log'1 x y = (cmp_log'1 x y = C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self: tuple) (o: tuple) =
    [%#sord'0] self._p0 = o._p0 /\ ge_log self._p1 o._p1 \/ gt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). ge_log'1 x y = (cmp_log'1 x y <> C_Less)
   -> ge_log'1 x y = (cmp_log'1 x y <> C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. cmp_log'1 x y = C_Greater
   -> cmp_log'1 x y = C_Greater /\ (forall result: (). cmp_log'1 y x = C_Less  -> cmp_log'1 y x = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). (x = y) = (cmp_log'1 x y = C_Equal)
   -> (x = y) = (cmp_log'1 x y = C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self: tuple) (o: tuple) =
    [%#sord'0] self._p0 = o._p0 /\ le_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). le_log'1 x y
  = (cmp_log'1 x y <> C_Greater)  -> le_log'1 x y = (cmp_log'1 x y <> C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall result: (). cmp_log'1 x x = C_Equal  -> cmp_log'1 x x = C_Equal
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall z: tuple. forall o: t_Ordering. cmp_log'1 y z = o
  /\ cmp_log'1 x y = o
   -> cmp_log'1 y z = o /\ cmp_log'1 x y = o /\ (forall result: (). cmp_log'1 x z = o  -> cmp_log'1 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec: forall x: t_B, y: t_B. [%#sord'14] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec: forall x: t_B, y: t_B. ([%#sord'12] cmp_log x y = C_Greater)
   -> ([%#sord'13] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec: forall x: t_B, y: t_B. ([%#sord'10] cmp_log x y = C_Less)
   -> ([%#sord'11] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'7] cmp_log x y = o)
   -> ([%#sord'8] cmp_log y z = o)  -> ([%#sord'9] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec: forall x: t_B. [%#sord'6] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec: forall x: t_B, y: t_B. [%#sord'5] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec: forall x: t_B, y: t_B. [%#sord'4] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec: forall x: t_B, y: t_B. [%#sord'3] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec: forall x: t_B, y: t_B. [%#sord'2] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec'0: forall x: t_A, y: t_A. [%#sord'14] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec'0: forall x: t_A, y: t_A. ([%#sord'12] cmp_log'0 x y = C_Greater)
   -> ([%#sord'13] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec'0: forall x: t_A, y: t_A. ([%#sord'10] cmp_log'0 x y = C_Less)
   -> ([%#sord'11] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'7] cmp_log'0 x y = o)
   -> ([%#sord'8] cmp_log'0 y z = o)  -> ([%#sord'9] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec'0: forall x: t_A. [%#sord'6] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_A, y: t_A. [%#sord'5] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_A, y: t_A. [%#sord'4] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_A, y: t_A. [%#sord'3] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_A, y: t_A. [%#sord'2] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self: tuple) (o: tuple) =
    [%#sord'0] self._p0 = o._p0 /\ lt_log self._p1 o._p1 \/ lt_log'0 self._p0 o._p0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'1] let r = cmp_log'0 self._p0 o._p0 in if r = C_Equal then cmp_log self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. forall result: (). lt_log'1 x y = (cmp_log'1 x y = C_Less)
   -> lt_log'1 x y = (cmp_log'1 x y = C_Less)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A
  
  type t_B
  
  type tuple  =
    { _p0: t_A; _p1: t_B }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_spec: forall x: t_A, y: t_A. [%#sord'13] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym2_spec: forall x: t_A, y: t_A. ([%#sord'11] cmp_log x y = C_Greater)
   -> ([%#sord'12] cmp_log y x = C_Less)
  
  function antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_A) (y: t_A) : ()
  
  axiom antisym1_spec: forall x: t_A, y: t_A. ([%#sord'9] cmp_log x y = C_Less)
   -> ([%#sord'10] cmp_log y x = C_Greater)
  
  function trans [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  
  axiom trans_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. ([%#sord'6] cmp_log x y = o)
   -> ([%#sord'7] cmp_log y z = o)  -> ([%#sord'8] cmp_log x z = o)
  
  function refl [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_A) : ()
  
  axiom refl_spec: forall x: t_A. [%#sord'5] cmp_log x x = C_Equal
  
  predicate gt_log [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_A) (o: t_A)
  
  function cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_spec: forall x: t_A, y: t_A. [%#sord'4] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_A) (o: t_A)
  
  function cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_spec: forall x: t_A, y: t_A. [%#sord'3] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_A) (o: t_A)
  
  function cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_spec: forall x: t_A, y: t_A. [%#sord'2] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_A) (o: t_A)
  
  function cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_spec: forall x: t_A, y: t_A. [%#sord'1] le_log x y = (cmp_log x y <> C_Greater)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_spec'0: forall x: t_B, y: t_B. [%#sord'13] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym2_spec'0: forall x: t_B, y: t_B. ([%#sord'11] cmp_log'0 x y = C_Greater)
   -> ([%#sord'12] cmp_log'0 y x = C_Less)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x: t_B) (y: t_B) : ()
  
  axiom antisym1_spec'0: forall x: t_B, y: t_B. ([%#sord'9] cmp_log'0 x y = C_Less)
   -> ([%#sord'10] cmp_log'0 y x = C_Greater)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  
  axiom trans_spec'0: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. ([%#sord'6] cmp_log'0 x y = o)
   -> ([%#sord'7] cmp_log'0 y z = o)  -> ([%#sord'8] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x: t_B) : ()
  
  axiom refl_spec'0: forall x: t_B. [%#sord'5] cmp_log'0 x x = C_Equal
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self: t_B) (o: t_B)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_spec'0: forall x: t_B, y: t_B. [%#sord'4] gt_log'0 x y = (cmp_log'0 x y = C_Greater)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self: t_B) (o: t_B)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_spec'0: forall x: t_B, y: t_B. [%#sord'3] ge_log'0 x y = (cmp_log'0 x y <> C_Less)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self: t_B) (o: t_B)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_spec'0: forall x: t_B, y: t_B. [%#sord'2] lt_log'0 x y = (cmp_log'0 x y = C_Less)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self: t_B) (o: t_B)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_spec'0: forall x: t_B, y: t_B. [%#sord'1] le_log'0 x y = (cmp_log'0 x y <> C_Greater)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self: tuple) (o: tuple) : t_Ordering =
    [%#sord'0] let r = cmp_log self._p0 o._p0 in if r = C_Equal then cmp_log'0 self._p1 o._p1 else r
  
  goal refines: [%#sord] forall x: tuple. forall y: tuple. cmp_log'1 x y = C_Less
   -> cmp_log'1 x y = C_Less /\ (forall result: (). cmp_log'1 y x = C_Greater  -> cmp_log'1 y x = C_Greater)
end
module M_creusot_contracts__stdqy35z1__deque__qyi15330951746891243504__resolve_coherence__refines [#"../../creusot-contracts/src/std/deque.rs" 73 4 73 31] (* <std::collections::VecDeque<T> as resolve::Resolve> *)
  let%span sdeque = "../../creusot-contracts/src/std/deque.rs" 73 4 73 31
  let%span sdeque'0 = "../../creusot-contracts/src/std/deque.rs" 66 20 66 77
  let%span sdeque'1 = "../../creusot-contracts/src/std/deque.rs" 18 14 18 41
  let%span sdeque'2 = "../../creusot-contracts/src/std/deque.rs" 46 8 46 31
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_VecDeque  =
    { t_VecDeque__head: UInt64.t; t_VecDeque__len: UInt64.t; t_VecDeque__buf: t_RawVec }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_VecDeque) =
    match _0 with
      | {t_VecDeque__head = x0 ; t_VecDeque__len = x1 ; t_VecDeque__buf = x2} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_VecDeque)
  
  axiom inv_axiom [@rewrite]: forall x: t_VecDeque [inv x]. inv x = true
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/deque.rs" 19 4 19 27] (self: t_VecDeque) : Seq.seq t_T
  
  axiom view_spec: forall self: t_VecDeque. [%#sdeque'1] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/std/deque.rs" 45 4 45 47] (self: t_VecDeque) (ix: int) : t_T
  
   =
    [%#sdeque'2] Seq.get (view self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/deque.rs" 65 4 65 28] (self: t_VecDeque) =
    [%#sdeque'0] forall i: int. 0 <= i /\ i < Seq.length (view self)  -> resolve (index_logic self i)
  
  goal refines: [%#sdeque] forall self: t_VecDeque. structural_resolve self /\ inv self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi7712864753404203214__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 30 4 30 31] (* <std::iter::Cloned<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span scloned = "../../creusot-contracts/src/std/iter/cloned.rs" 30 4 30 31
  let%span scloned'0 = "../../creusot-contracts/src/std/iter/cloned.rs" 23 8 23 29
  let%span scloned'1 = "../../creusot-contracts/src/std/iter/cloned.rs" 13 14 13 39
  
  type t_I
  
  type t_Cloned  =
    { t_Cloned__it: t_I }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Cloned) =
    match _0 with
      | {t_Cloned__it = x0} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom [@rewrite]: forall x: t_Cloned [inv'0 x]. inv'0 x
  = match x with
    | {t_Cloned__it = it} -> inv it
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Cloned) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Cloned)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Cloned [inv'1 x]. inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/cloned.rs" 14 4 14 22] (self: t_Cloned) : t_I
  
  axiom iter_spec: forall self: t_Cloned. [%#scloned'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 22 4 22 28] (self: t_Cloned) =
    [%#scloned'0] resolve (iter self)
  
  goal refines: [%#scloned] forall self: t_Cloned. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi10817769304312191898__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 30 4 30 31] (* <std::iter::Copied<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span scopied = "../../creusot-contracts/src/std/iter/copied.rs" 30 4 30 31
  let%span scopied'0 = "../../creusot-contracts/src/std/iter/copied.rs" 23 8 23 29
  let%span scopied'1 = "../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  
  type t_I
  
  type t_Copied  =
    { t_Copied__it: t_I }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Copied) =
    match _0 with
      | {t_Copied__it = x0} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv'0 x]. inv'0 x
  = match x with
    | {t_Copied__it = it} -> inv it
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Copied) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Copied)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Copied [inv'1 x]. inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/copied.rs" 14 4 14 22] (self: t_Copied) : t_I
  
  axiom iter_spec: forall self: t_Copied. [%#scopied'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 22 4 22 28] (self: t_Copied) =
    [%#scopied'0] resolve (iter self)
  
  goal refines: [%#scopied] forall self: t_Copied. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi7229971731912667430__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 39 4 39 31] (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span senumerate = "../../creusot-contracts/src/std/iter/enumerate.rs" 39 4 39 31
  let%span senumerate'0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 32 8 32 29
  let%span senumerate'1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 16 14 16 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Enumerate  =
    { t_Enumerate__iter: t_I; t_Enumerate__count: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Enumerate) =
    match _0 with
      | {t_Enumerate__iter = x0 ; t_Enumerate__count = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  axiom inv_axiom: forall x: t_Enumerate [inv'0 x]. inv'0 x
   -> match x with
    | {t_Enumerate__iter = iter ; t_Enumerate__count = count} -> inv iter
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Enumerate) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Enumerate)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Enumerate [inv'1 x]. inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/enumerate.rs" 17 4 17 22] (self: t_Enumerate) : t_I
  
  axiom iter_spec: forall self: t_Enumerate. [%#senumerate'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 31 4 31 28] (self: t_Enumerate) =
    [%#senumerate'0] resolve (iter self)
  
  goal refines: [%#senumerate] forall self: t_Enumerate. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi7619436869179474426__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map.rs" 41 4 41 31] (* <std::iter::Map<I, F> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smap = "../../creusot-contracts/src/std/iter/map.rs" 41 4 41 31
  let%span smap'0 = "../../creusot-contracts/src/std/iter/map.rs" 34 8 34 54
  let%span smap'1 = "../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  let%span smap'2 = "../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  
  type t_I
  
  type t_F
  
  type t_Map  =
    { t_Map__iter: t_I; t_Map__f: t_F }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Map) =
    match _0 with
      | {t_Map__iter = x0 ; t_Map__f = x1} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom [@rewrite]: forall x: t_Map [inv'1 x]. inv'1 x
  = match x with
    | {t_Map__iter = iter ; t_Map__f = f} -> inv iter /\ inv'0 f
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Map) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Map)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Map [inv'2 x]. inv'2 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self: t_Map) : t_I
  
  axiom iter_spec: forall self: t_Map. [%#smap'1] inv'1 self  -> inv (iter self)
  
  function func [#"../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self: t_Map) : t_F
  
  axiom func_spec: forall self: t_Map. [%#smap'2] inv'1 self  -> inv'0 (func self)
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map.rs" 33 4 33 28] (self: t_Map) =
    [%#smap'0] resolve'0 (iter self) /\ resolve (func self)
  
  goal refines: [%#smap] forall self: t_Map. structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result: (). resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 63 4 63 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 63 4 63 31
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 50
  
  use seq.Seq
  
  type t_I
  
  type t_F
  
  type t_B
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_B }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_MapInv) =
    match _0 with
      | {t_MapInv__iter = x0 ; t_MapInv__func = x1 ; t_MapInv__produced = x2} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_MapInv)
  
  axiom inv_axiom: forall x: t_MapInv [inv'1 x]. inv'1 x
   -> match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'0 func
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_MapInv) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_MapInv)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_MapInv [inv'2 x]. inv'2 x = invariant' x
  
  predicate resolve'1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 56 4 56 28] (self: t_MapInv) =
    [%#smap_inv'0] resolve'0 self.t_MapInv__iter /\ resolve self.t_MapInv__func
  
  goal refines: [%#smap_inv] forall self: t_MapInv. structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result: (). resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi1800235112549046777__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 42 4 42 31] (* <std::iter::Skip<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sskip = "../../creusot-contracts/src/std/iter/skip.rs" 42 4 42 31
  let%span sskip'0 = "../../creusot-contracts/src/std/iter/skip.rs" 34 12 34 33
  let%span sskip'1 = "../../creusot-contracts/src/std/iter/skip.rs" 16 14 16 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Skip  =
    { t_Skip__iter: t_I; t_Skip__n: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Skip) =
    match _0 with
      | {t_Skip__iter = x0 ; t_Skip__n = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom [@rewrite]: forall x: t_Skip [inv'0 x]. inv'0 x
  = match x with
    | {t_Skip__iter = iter ; t_Skip__n = n} -> inv iter
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Skip) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Skip)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Skip [inv'1 x]. inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/skip.rs" 17 4 17 22] (self: t_Skip) : t_I
  
  axiom iter_spec: forall self: t_Skip. [%#sskip'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 32 4 32 28] (self: t_Skip) =
    [%#sskip'0] resolve (iter self)
  
  goal refines: [%#sskip] forall self: t_Skip. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi7846602308660485643__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/take.rs" 50 4 50 31] (* <std::iter::Take<I> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span stake = "../../creusot-contracts/src/std/iter/take.rs" 50 4 50 31
  let%span stake'0 = "../../creusot-contracts/src/std/iter/take.rs" 43 8 43 29
  let%span stake'1 = "../../creusot-contracts/src/std/iter/take.rs" 19 14 19 39
  
  use creusot.int.UInt64
  
  type t_I
  
  type t_Take  =
    { t_Take__iter: t_I; t_Take__n: UInt64.t }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_I)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Take) =
    match _0 with
      | {t_Take__iter = x0 ; t_Take__n = x1} -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom [@rewrite]: forall x: t_Take [inv'0 x]. inv'0 x
  = match x with
    | {t_Take__iter = iter ; t_Take__n = n} -> inv iter
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Take) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Take)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Take [inv'1 x]. inv'1 x = invariant' x
  
  function iter [#"../../creusot-contracts/src/std/iter/take.rs" 20 4 20 22] (self: t_Take) : t_I
  
  axiom iter_spec: forall self: t_Take. [%#stake'1] inv'0 self  -> inv (iter self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/take.rs" 42 4 42 28] (self: t_Take) =
    [%#stake'0] resolve (iter self)
  
  goal refines: [%#stake] forall self: t_Take. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi6798028551487775744__resolve_coherence__refines [#"../../creusot-contracts/src/std/slice.rs" 458 4 458 31] (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 458 4 458 31
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 451 20 451 36
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span sslice'2 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice'3 = "../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_IterMut  =
    { t_IterMut__ptr: t_NonNull; t_IterMut__end_or_len: Opaque.ptr; t_IterMut__qy95zmarker: () }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_IterMut) =
    match _0 with
      | {t_IterMut__ptr = x0 ; t_IterMut__end_or_len = x1 ; t_IterMut__qy95zmarker = x2} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_IterMut)
  
  axiom inv_axiom [@rewrite]: forall x: t_IterMut [inv x]. inv x = true
  
  type t_T
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom view_spec: forall self: Slice64.slice t_T. ([%#sslice'2] Seq.length (view self)
  <= UInt64.t'int (v_MAX: UInt64.t))
  && ([%#sslice'3] view self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self: t_IterMut) : MutBorrow.t (Slice64.slice t_T)
  
  
  axiom view_spec'0: forall self: t_IterMut. [%#sslice'1] Seq.length (view (view'0 self).final)
  = Seq.length (view (view'0 self).current)
  
  predicate resolve [#"../../creusot-contracts/src/std/slice.rs" 450 4 450 28] (self: t_IterMut) =
    [%#sslice'0] (view'0 self).current = (view'0 self).final
  
  goal refines: [%#sslice] forall self: t_IterMut. structural_resolve self /\ inv self
   -> structural_resolve self /\ (forall result: (). resolve self  -> resolve self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi16169840827095121464__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 53 4 53 31] (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 697 20 697 91
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 53 4 53 31
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 46 20 46 77
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_A
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: t_A }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Vec) =
    match _0 with
      | {t_Vec__buf = x0 ; t_Vec__len = x1} -> true
      end
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/seq.rs" 696 4 696 30] (self: Seq.seq t_T) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'0 (Seq.get self i)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 22 4 22 27] (self: t_Vec) : Seq.seq t_T
  
  axiom view_spec: forall self: t_Vec. [%#svec'1] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate invariant''1 [#"../../creusot-contracts/src/std/vec.rs" 62 4 62 30] (self: t_Vec) =
    [%#svec'2] inv'1 (view self)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Vec)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Vec [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate invariant''2 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Vec) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Vec)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec [inv'3 x]. inv'3 x = invariant''2 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  function index_logic [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 28 4 28 47] (self: t_Vec) (ix: int) : t_T
  
   =
    [%#sindex] Seq.get (view self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 45 4 45 28] (self: t_Vec) =
    [%#svec'0] forall i: int. 0 <= i /\ i < Seq.length (view self)  -> resolve (index_logic self i)
  
  goal refines: [%#svec] forall self: t_Vec. structural_resolve self /\ inv'3 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9945000909994515642__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 234 4 234 31] (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 234 4 234 31
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 227 20 227 78
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_A
  
  type t_ManuallyDrop  =
    { t_ManuallyDrop__value: t_A }
  
  type t_IntoIter  =
    { t_IntoIter__buf: t_NonNull;
      t_IntoIter__phantom: ();
      t_IntoIter__cap: UInt64.t;
      t_IntoIter__alloc: t_ManuallyDrop;
      t_IntoIter__ptr: t_NonNull;
      t_IntoIter__end: Opaque.ptr }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_IntoIter) =
    match _0 with
      | {t_IntoIter__buf = x0 ; t_IntoIter__phantom = x1 ; t_IntoIter__cap = x2 ; t_IntoIter__alloc = x3 ; t_IntoIter__ptr = x4 ; t_IntoIter__end = x5} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_A)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_ManuallyDrop)
  
  axiom inv_axiom [@rewrite]: forall x: t_ManuallyDrop [inv'0 x]. inv'0 x
  = match x with
    | {t_ManuallyDrop__value = value} -> inv value
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_IntoIter)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_IntoIter [inv'1 x]. inv'1 x
  = match x with
    | {t_IntoIter__buf = buf ; t_IntoIter__phantom = phantom ; t_IntoIter__cap = cap ; t_IntoIter__alloc = alloc ; t_IntoIter__ptr = ptr ; t_IntoIter__end = end'} -> inv'0 alloc
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_IntoIter) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_IntoIter)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_IntoIter [inv'2 x]. inv'2 x = invariant' x
  
  type t_T
  
  function view [#"../../creusot-contracts/src/std/vec.rs" 217 4 217 33] (self: t_IntoIter) : Seq.seq t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 226 4 226 28] (self: t_IntoIter) =
    [%#svec'0] forall i: int. 0 <= i /\ i < Seq.length (view self)  -> resolve (Seq.get (view self) i)
  
  goal refines: [%#svec] forall self: t_IntoIter. structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost__qyi8064556118965643473__resolve_coherence__refines [#"../../creusot-contracts/src/ghost.rs" 114 4 114 31] (* <ghost::Ghost<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 114 4 114 31
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 107 8 107 23
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0:  t_T)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_T) =
    [%#sghost'1] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_T)
  
  axiom inv_axiom [@rewrite]: forall x:  t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self:  t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x:  t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/ghost.rs" 106 4 106 28] (self:  t_T) =
    [%#sghost'0] resolve self
  
  goal refines: [%#sghost] forall self:  t_T. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__invariant__qyi4568223824573003996__resolve_coherence__refines [#"../../creusot-contracts/src/invariant.rs" 305 4 305 31] (* <invariant::Subset<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 305 4 305 31
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 298 20 298 37
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  
  type t_Subset
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Subset)
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Subset)
  
  axiom inv_axiom [@rewrite]: forall x: t_Subset [inv x]. inv x = true
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 72 4 72 31] (self: t_T)
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/invariant.rs" 297 4 297 28] (self: t_Subset) =
    [%#sinvariant'0] resolve (view self)
  
  goal refines: [%#sinvariant] forall self: t_Subset. structural_resolve self /\ inv self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__pcell__qyi12897409324816536085__resolve_coherence__refines [#"../../creusot-contracts/src/pcell.rs" 52 4 52 31] (* <pcell::PCellOwn<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 62 8 62 23
  let%span spcell = "../../creusot-contracts/src/pcell.rs" 52 4 52 31
  let%span spcell'0 = "../../creusot-contracts/src/pcell.rs" 44 8 44 28
  
  type t_PCellOwn  =
    { t_PCellOwn__0: () }
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_PCellOwn) =
    match _0 with
      | {t_PCellOwn__0 = x0} -> true
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCellOwn)
  
  axiom inv_axiom: forall x: t_PCellOwn [inv x]. inv x
   -> match x with
    | {t_PCellOwn__0 = a_0} -> true
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_PCellOwn) =
    [%#sinvariant] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_PCellOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PCellOwn [inv'0 x]. inv'0 x = invariant' x
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 28] (self: t_T) =
    [%#sresolve] resolve self
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T) =
    resolve'0 _0
  
  function val' [#"../../creusot-contracts/src/pcell.rs" 81 4 81 33] (self: t_PCellOwn) : t_T
  
  predicate resolve'2 [#"../../creusot-contracts/src/pcell.rs" 43 4 43 28] (self: t_PCellOwn) =
    [%#spcell'0] resolve'1 (val' self)
  
  goal refines: [%#spcell] forall self: t_PCellOwn. structural_resolve self /\ inv'0 self
   -> structural_resolve self /\ inv'0 self /\ (forall result: (). resolve'2 self  -> resolve'2 self)
end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 42 4 42 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 42 4 42 31
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 36 8 36 44
  
  type t_T1
  
  type t_T2
  
  type tuple  =
    { _p0: t_T1; _p1: t_T2 }
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T2)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T1)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: tuple) =
    match _0 with
      | {_p0 = x0 ; _p1 = x1} -> resolve x1 /\ resolve'0 x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T1)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T2)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom [@rewrite]: forall x: tuple [inv'1 x]. inv'1 x = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: tuple) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: tuple)
  
  axiom inv_axiom'0 [@rewrite]: forall x: tuple [inv'2 x]. inv'2 x = invariant' x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 35 4 35 28] (self: tuple) =
    [%#sresolve'0] resolve'0 self._p0 /\ resolve self._p1
  
  goal refines: [%#sresolve] forall self: tuple. structural_resolve self /\ inv'2 self
   -> structural_resolve self /\ (forall result: (). resolve'1 self  -> resolve'1 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 55 4 55 31] (* <&mut T as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 55 4 55 31
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: MutBorrow.t t_T) =
    _0.final = _0.current
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_T) =
    [%#sinvariant'0] inv self.current /\ inv self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom [@rewrite]: forall x: MutBorrow.t t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: MutBorrow.t t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 48 4 48 28] (self: MutBorrow.t t_T) =
    [%#sresolve'0] self.final = self.current
  
  goal refines: [%#sresolve] forall self: MutBorrow.t t_T. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve self  -> resolve self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 68 4 68 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 68 4 68 31
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 62 8 62 23
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_T) =
    resolve _0
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 28] (self: t_T) =
    [%#sresolve'0] resolve self
  
  goal refines: [%#sresolve] forall self: t_T. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 84 4 84 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 84 4 84 31
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_T)
  
  predicate structural_resolve [#"../../creusot-contracts/src/resolve.rs" 28 0 28 51] (_0: t_Option) =
    match _0 with
      | C_None -> true
      | C_Some x0 -> resolve x0
      end
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_Option) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'1 x]. inv'1 x = invariant' x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 74 4 74 28] (self: t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve x
      | C_None -> true
      end
  
  goal refines: [%#sresolve] forall self: t_Option. structural_resolve self /\ inv'1 self
   -> structural_resolve self /\ (forall result: (). resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfuse = "../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62
  let%span sfuse'0 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse'1 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse'2 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse'3 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse'4 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse'5 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse'6 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse'7 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse'8 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse'9 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I
  
  type t_Option  =
    | C_None
    | C_Some t_I
  
  type t_Fuse  =
    { t_Fuse__iter: t_Option }
  
  type t_Item
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option [inv'0 x]. inv'0 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Fuse)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Fuse [inv'1 x]. inv'1 x
  = match x with
    | {t_Fuse__iter = iter} -> inv'0 iter
    end
  
  function view [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self: t_Fuse) : t_Option
  
  axiom view_spec: forall self: t_Fuse. ([%#sfuse'8] inv'1 self  -> inv'0 (view self))
  && ([%#sfuse'9] forall other: t_Fuse. view self = view other  -> self = other)
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self: t_Fuse) (prod: Seq.seq t_Item) (other: t_Fuse)
  
   =
    [%#sfuse'0] match view self with
      | C_None -> prod = (Seq.empty: Seq.seq t_Item) /\ view other = view self
      | C_Some i -> match view other with
        | C_Some i2 -> produces i prod i2
        | C_None -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a: t_Fuse) (ab: Seq.seq t_Item) (b: t_Fuse) (bc: Seq.seq t_Item) (c: t_Fuse) : ()
  
   =
    [%#sfuse'7] ()
  
  axiom produces_trans_spec'0: forall a: t_Fuse, ab: Seq.seq t_Item, b: t_Fuse, bc: Seq.seq t_Item, c: t_Fuse. ([%#sfuse'4] produces'0 a ab b)
   -> ([%#sfuse'5] produces'0 b bc c)  -> ([%#sfuse'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self: t_Fuse) : () =
    [%#sfuse'3] ()
  
  axiom produces_refl_spec'0: forall self: t_Fuse. [%#sfuse'2] produces'0 self (Seq.empty: Seq.seq t_Item) self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 61 4 61 33] (self: MutBorrow.t t_Fuse) : t_Option =
    [%#smodel] view self.current
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self: MutBorrow.t t_Fuse) =
    [%#sfuse'1] (view'0 self = C_None
    \/ (exists it: MutBorrow.t t_I. completed it /\ view'0 self = C_Some (it.current)))
    /\ view self.final = C_None
  
  goal refines: [%#sfuse] forall self: MutBorrow.t t_Fuse. forall steps: Seq.seq t_Item. forall next: t_Fuse. produces'0 self.final steps next
  /\ completed'0 self
   -> produces'0 self.final steps next
  /\ completed'0 self
  /\ (forall result: (). steps = (Seq.empty: Seq.seq t_Item) /\ self.final = next
   -> steps = (Seq.empty: Seq.seq t_Item) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 88 4 88 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter'1 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter'2 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smap_inv = "../../creusot-contracts/src/std/iter/map_inv.rs" 88 4 88 44
  let%span smap_inv'0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 17 8 20 9
  let%span smap_inv'1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 177 14 177 68
  let%span smap_inv'2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 180 12 185 74
  let%span smap_inv'3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv'4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv'5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 25 27 25 29
  let%span smap_inv'6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv'7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv'8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv'9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span smap_inv'10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 72 12 74 73
  let%span smap_inv'11 = "../../creusot-contracts/src/std/iter/map_inv.rs" 151 12 154 47
  let%span smap_inv'12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 122 14 122 81
  let%span smap_inv'13 = "../../creusot-contracts/src/std/iter/map_inv.rs" 125 12 130 88
  let%span smap_inv'14 = "../../creusot-contracts/src/std/iter/map_inv.rs" 115 12 117 63
  let%span smap_inv'15 = "../../creusot-contracts/src/std/iter/map_inv.rs" 138 12 143 71
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv  =
    { t_MapInv__iter: t_I; t_MapInv__func: t_F; t_MapInv__produced: Seq.seq t_Item }
  
  predicate produces [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  
  function produces_trans [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  
  axiom produces_trans_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. ([%#siter'0] produces a ab b)
   -> ([%#siter'1] produces b bc c)  -> ([%#siter'2] produces a (Seq.(++) ab bc) c)
  
  function produces_refl [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self: t_I) : ()
  
  axiom produces_refl_spec: forall self: t_I. [%#siter] produces self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self: MutBorrow.t t_I)
  
  type tuple  =
    { _p0: t_Item; _p1: Seq.seq t_Item }
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: tuple)
  
  predicate next_precondition [#"../../creusot-contracts/src/std/iter/map_inv.rs" 113 4 113 78] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'14] forall e: t_Item, i: t_I. produces iter (Seq.singleton e) i
     -> precondition func { _p0 = e; _p1 = produced }
  
  type t_B
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: tuple) (result: t_B)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: tuple) (result_state: t_F) (result: t_B)
  
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: t_F) (args: tuple) (res: t_B) : ()
  
  
  axiom fn_mut_once_spec: forall self: t_F, args: tuple, res: t_B. [%#sops'5] postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_spec: forall self: t_F, b: t_F, c: t_F. ([%#sops'2] hist_inv self b)
   -> ([%#sops'3] hist_inv b c)  -> ([%#sops'4] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: t_F) : ()
  
  axiom hist_inv_refl_spec: forall self: t_F. [%#sops'1] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: t_F) (args: tuple) (res_state: t_F) (res: t_B) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: t_F, args: tuple, res_state: t_F, res: t_B. ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] hist_inv self res_state)
  
  predicate preservation [#"../../creusot-contracts/src/std/iter/map_inv.rs" 136 4 136 49] (iter: t_I) (func: t_F) =
    [%#smap_inv'15] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc s e1 }
  
  predicate reinitialize [#"../../creusot-contracts/src/std/iter/map_inv.rs" 149 4 149 33]  =
    [%#smap_inv'11] forall iter: MutBorrow.t t_I, func: t_F. completed iter
     -> next_precondition iter.final func (Seq.empty: Seq.seq t_Item) /\ preservation iter.final func
  
  predicate preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 123 4 123 73] (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
   =
    [%#smap_inv'13] forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv func f.current
     -> produces iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition f.current { _p0 = e1; _p1 = Seq.(++) produced s }
     -> postcondition_mut f.current { _p0 = e1; _p1 = Seq.(++) produced s } f.final b
     -> precondition f.final { _p0 = e2; _p1 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv_spec: forall iter: t_I, func: t_F, produced: Seq.seq t_Item. [%#smap_inv'12] produced
  = (Seq.empty: Seq.seq t_Item)  -> preservation_inv iter func produced = preservation iter func
  
  predicate invariant' [#"../../creusot-contracts/src/std/iter/map_inv.rs" 70 4 70 30] (self: t_MapInv) =
    [%#smap_inv'10] reinitialize
    /\ preservation_inv self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
    /\ next_precondition self.t_MapInv__iter self.t_MapInv__func self.t_MapInv__produced
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_MapInv)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv [inv'1 x]. inv'1 x
  = (invariant' x
  /\ match x with
    | {t_MapInv__iter = iter ; t_MapInv__func = func ; t_MapInv__produced = produced} -> inv iter /\ inv'0 func
    end)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_MapInv) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_MapInv)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_MapInv [inv'2 x]. inv'2 x = invariant''0 x
  
  type t_Option  =
    | C_None
    | C_Some t_B
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self: t_MapInv) (visited: Seq.seq t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'3] hist_inv self.t_MapInv__func succ.t_MapInv__func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
    /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
    /\ produces self.t_MapInv__iter s succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.(++) self.t_MapInv__produced s
    /\ (forall i: int. 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func = succ.t_MapInv__func
    else
      (Seq.get fs 0).current = self.t_MapInv__func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func
    )
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> hist_inv self.t_MapInv__func (Seq.get fs i).current
    /\ precondition (Seq.get fs i).current { _p0 = Seq.get s i;
                                             _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) }
    /\ postcondition_mut (Seq.get fs i).current { _p0 = Seq.get s i;
                                                  _p1 = Seq.(++) self.t_MapInv__produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a: t_MapInv) (ab: Seq.seq t_B) (b: t_MapInv) (bc: Seq.seq t_B) (c: t_MapInv) : ()
  
   =
    [%#smap_inv'9] ()
  
  axiom produces_trans_spec'0: forall a: t_MapInv, ab: Seq.seq t_B, b: t_MapInv, bc: Seq.seq t_B, c: t_MapInv. ([%#smap_inv'6] produces'0 a ab b)
   -> ([%#smap_inv'7] produces'0 b bc c)  -> ([%#smap_inv'8] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self: t_MapInv) : () =
    [%#smap_inv'5] ()
  
  axiom produces_refl_spec'0: forall self: t_MapInv. [%#smap_inv'4] produces'0 self (Seq.empty: Seq.seq t_B) self
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 16 4 16 35] (self: MutBorrow.t t_MapInv) =
    [%#smap_inv'0] (self.final).t_MapInv__produced = (Seq.empty: Seq.seq t_Item)
    /\ completed (MutBorrow.borrow_logic (self.current).t_MapInv__iter (self.final).t_MapInv__iter (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func = (self.final).t_MapInv__func
  
  predicate produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 178 4 178 57] (self: t_MapInv) (visited: t_B) (succ: t_MapInv)
  
   =
    [%#smap_inv'2] exists f: MutBorrow.t t_F, e: t_Item. f.current = self.t_MapInv__func
    /\ f.final = succ.t_MapInv__func
    /\ produces self.t_MapInv__iter (Seq.singleton e) succ.t_MapInv__iter
    /\ succ.t_MapInv__produced = Seq.snoc self.t_MapInv__produced e
    /\ precondition f.current { _p0 = e; _p1 = self.t_MapInv__produced }
    /\ postcondition_mut f.current { _p0 = e; _p1 = self.t_MapInv__produced } f.final visited
  
  axiom produces_one_spec: forall self: t_MapInv, visited: t_B, succ: t_MapInv. [%#smap_inv'1] produces_one self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_B)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  goal refines: [%#smap_inv] forall self_: MutBorrow.t t_MapInv. inv'2 self_
   -> inv'2 self_
  /\ (forall result: t_Option. match result with
    | C_None -> completed'0 self_
    | C_Some v -> produces_one self_.current v self_.final
    end
  /\ inv'4 result
   -> match result with
    | C_None -> completed'0 self_
    | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
    end
  /\ inv'4 result)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 60 4 60 31
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'0] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  goal refines: [%#srange] forall self: t_Range. forall result: (). produces_back self (Seq.empty: Seq.seq t_Idx) self
   -> produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 66 4 66 95
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 50 12 54 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_Range  =
    { t_Range__start: t_Idx; t_Range__end: t_Idx }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 48 4 48 69] (self: t_Range) (visited: Seq.seq t_Idx) (o: t_Range)
  
   =
    [%#srange'0] self.t_Range__start = o.t_Range__start
    /\ deep_model self.t_Range__end >= deep_model o.t_Range__end
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__end >= deep_model o.t_Range__start)
    /\ Seq.length visited = deep_model o.t_Range__end - deep_model self.t_Range__end
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__end - i)
  
  goal refines: [%#srange] forall a: t_Range. forall ab: Seq.seq t_Idx. forall b: t_Range. forall bc: Seq.seq t_Idx. forall c: t_Range. produces_back b bc c
  /\ produces_back a ab b
   -> produces_back b bc c
  /\ produces_back a ab b
  /\ (forall result: (). produces_back a (Seq.(++) ab bc) c  -> produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 131 4 131 31
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'1] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  goal refines: [%#srange] forall self: t_RangeInclusive. forall result: (). produces_back self (Seq.empty: Seq.seq t_Idx) self
   -> produces_back self (Seq.empty: Seq.seq t_Idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 138 4 138 95
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 120 12 124 74
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: t_Idx; t_RangeInclusive__end: t_Idx; t_RangeInclusive__exhausted: bool }
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_Idx) : int
  
  function start_log [#"../../creusot-contracts/src/std/ops.rs" 213 4 213 29] (self: t_RangeInclusive) : t_Idx
  
  function end_log [#"../../creusot-contracts/src/std/ops.rs" 219 4 219 27] (self: t_RangeInclusive) : t_Idx
  
  function is_empty_log [#"../../creusot-contracts/src/std/ops.rs" 226 4 229 35] (self: t_RangeInclusive) : bool
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  function range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 72 0 72 92] (r: t_RangeInclusive) : int
   =
    [%#srange'2] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'1] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces_back [#"../../creusot-contracts/src/std/iter/range.rs" 118 4 118 69] (self: t_RangeInclusive) (visited: Seq.seq t_Idx) (o: t_RangeInclusive)
  
   =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ start_log self = start_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (end_log self) - i)
  
  goal refines: [%#srange] forall a: t_RangeInclusive. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive. produces_back b bc c
  /\ produces_back a ab b
   -> produces_back b bc c
  /\ produces_back a ab b
  /\ (forall result: (). produces_back a (Seq.(++) ab bc) c  -> produces_back a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__hist_inv_trans__refines [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 136 4 136 45
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  goal refines: [%#sops] forall self: t_F. forall b: t_F. forall c: t_F. hist_inv b c /\ hist_inv self b
   -> hist_inv b c /\ hist_inv self b /\ (forall result: (). hist_inv self c  -> hist_inv self c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__fn_mut_once__refines [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 142 4 142 55
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Args) (result: t_Output)
  
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  goal refines: [%#sops] forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
   -> postcondition_once self args res
  = (exists res_state: t_F. postcondition_mut self args res_state res /\ resolve res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__postcondition_mut_hist_inv__refines [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 124 4 124 87
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  goal refines: [%#sops] forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. postcondition_mut self args res_state res
   -> postcondition_mut self args res_state res
  /\ (forall result: (). hist_inv self res_state  -> hist_inv self res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__hist_inv_refl__refines [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 129 4 129 26
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  goal refines: [%#sops] forall self: t_F. forall result: (). hist_inv self self  -> hist_inv self self
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_mut__refines [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (* <F as std::ops::FnExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 159 4 159 67
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: t_F) (args: t_Args) (result: t_Output)
  
  
  goal refines: [%#sops] forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. forall result: (). postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
   -> postcondition_mut self args res_state res = (postcondition self args res /\ self = res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_once__refines [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (* <F as std::ops::FnExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 164 4 164 51
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_F) (args: t_Args) (result: t_Output)
  
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: t_F) (args: t_Args) (result: t_Output)
  
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: t_F)
  
  goal refines: [%#sops] forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once self args res
  = (postcondition self args res /\ resolve self)
   -> postcondition_once self args res = (postcondition self args res /\ resolve self)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_hist_inv__refines [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (* <F as std::ops::FnExt<Args>> *)
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 4 169 41
  
  type t_F
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: t_F) (result_state: t_F)
  
  goal refines: [%#sops] forall self: t_F. forall res_state: t_F. forall result: (). hist_inv self res_state
  = (self = res_state)  -> hist_inv self res_state = (self = res_state)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 60 4 60 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 60 4 60 34
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 53 4 53 32] (self: Opaque.ptr) : UInt64.t
  
  goal refines: [%#sptr] forall self: Opaque.ptr. forall result: bool. result = (addr_logic self = (0: UInt64.t))
   -> result = (addr_logic self = (0: UInt64.t))
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 75 4 75 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 75 4 75 34
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function addr_logic [#"../../creusot-contracts/src/std/ptr.rs" 68 4 68 32] (self: Opaque.ptr) : UInt64.t
  
  goal refines: [%#sptr] forall self: Opaque.ptr. forall result: bool. result = (addr_logic self = (0: UInt64.t))
   -> result = (addr_logic self = (0: UInt64.t))
end
module M_creusot_contracts__fn_pure__qyi11638360339920708941__clone__refines [#"../../creusot-contracts/src/fn_pure.rs" 30 4 30 27] (* <fn_pure::FnPureWrapper<F> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 30 4 30 27
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'0 x]. inv'0 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FnPureWrapper) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x = invariant' x
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: ()) (args: t_F) (result: t_F)
  
  
  axiom postcondition_fndef: forall args: t_F, res: t_F [postcondition_once () args res]. postcondition_once () args res
   -> (let self_ = args in inv res)
  
  predicate resolve [#"../../creusot-contracts/src/resolve.rs" 20 0 20 40] (_0: ()) =
    true
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  
  axiom postcondition_fndef'0: forall args: t_F, res: t_F [postcondition_mut () args () res]. postcondition_mut () args () res
   -> (let self_ = args in inv res)
  
  function fn_mut_once [#"../../creusot-contracts/src/std/ops.rs" 142 4 142 55] (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: t_F, res: t_F. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [#"../../creusot-contracts/src/std/ops.rs" 116 4 116 49] (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans [#"../../creusot-contracts/src/std/ops.rs" 136 4 136 45] (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 26] (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 124 4 124 87] (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: t_F, res_state: (), res: t_F. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv [#"../../creusot-contracts/src/std/ops.rs" 169 4 169 41] (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1: forall args: t_F, res: t_F [postcondition () args res]. postcondition () args res
   -> (let self_ = args in inv res)
  
  function fn_once [#"../../creusot-contracts/src/std/ops.rs" 164 4 164 51] (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_spec: forall self: (), args: t_F, res: t_F. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut [#"../../creusot-contracts/src/std/ops.rs" 159 4 159 67] (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  
  axiom fn_mut_spec: forall self: (), args: t_F, res_state: (), res: t_F. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_F) =
    [%#sinvariant] inv self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_F [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: ()) (args: t_F)
  
  axiom precondition_fndef: forall args: t_F [precondition () args]. (let self_ = args in inv'2 self_)
   -> precondition () args
  
  let rec clone' (self_:t_F) (return'  (x:t_F))= {[@expl:clone requires] precondition () self_}
    any [ return''0 (result:t_F)-> {postcondition_once () self_ result} (! return' {result}) ] 
  
  goal refines: [%#sfn_pure] forall self_: t_FnPureWrapper. inv'1 self_
   -> inv'1 self_
  /\ (forall result: t_FnPureWrapper. postcondition () self_.t_FnPureWrapper__0 result.t_FnPureWrapper__0
  /\ inv'0 result  -> inv'0 result)
end
module M_creusot_contracts__ghost__qyi11517682701084838082__clone__refines [#"../../creusot-contracts/src/ghost.rs" 55 4 55 27] (* <ghost::Ghost<T> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 55 4 55 27
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/ghost.rs" 98 4 98 30] (self:  t_T) =
    [%#sghost'0] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_T)
  
  axiom inv_axiom [@rewrite]: forall x:  t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self:  t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0:  t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x:  t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  goal refines: [%#sghost] forall self_:  t_T. inv'1 self_
   -> inv'1 self_ /\ (forall result:  t_T. result = self_ /\ inv'0 result  -> inv'0 result)
end
module M_creusot_contracts__logic__fmap__qyi1775402764303793352__clone__refines [#"../../creusot-contracts/src/logic/fmap.rs" 566 4 566 27] (* <logic::fmap::FMap<K, V> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 566 4 566 27
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 580 20 580 91
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  
  use map.Map
  
  type t_FMap
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'4] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  function contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self: t_FMap) (k: t_K) : bool
  
   =
    [%#sfmap'1] get_unsized self k <> C_None
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_K)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_V)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_V) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_V [inv'1 x]. inv'1 x = invariant' x
  
  function unwrap [#"../../creusot-contracts/src/util.rs" 56 0 56 36] (op: t_Option) : t_V
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 124 4 124 50] (self: t_FMap) (k: t_K) : t_V
  
   =
    [%#sfmap'2] unwrap (get_unsized self k)
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/fmap.rs" 579 4 579 30] (self: t_FMap) =
    [%#sfmap'0] forall k: t_K. contains self k  -> inv k /\ inv'1 (lookup_unsized self k)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMap)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FMap) =
    [%#sinvariant] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FMap)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_FMap [inv'3 x]. inv'3 x = invariant''1 x
  
  goal refines: [%#sfmap] forall self_: t_FMap. inv'3 self_
   -> inv'3 self_ /\ (forall result: t_FMap. result = self_ /\ inv'2 result  -> inv'2 result)
end
module M_creusot_contracts__logic__fset__qyi13324666171263681189__clone__refines [#"../../creusot-contracts/src/logic/fset.rs" 475 4 475 27] (* <logic::fset::FSet<T> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 475 4 475 27
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 489 20 489 63
  let%span sfset'1 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use set.Fset
  
  type t_T
  
  predicate contains [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self: Fset.fset t_T) (e: t_T)
  
   =
    [%#sfset'1] Fset.mem e self
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/logic/fset.rs" 488 4 488 30] (self: Fset.fset t_T) =
    [%#sfset'0] forall x: t_T. contains self x  -> inv x
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Fset.fset t_T)
  
  axiom inv_axiom [@rewrite]: forall x: Fset.fset t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: Fset.fset t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Fset.fset t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Fset.fset t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  goal refines: [%#sfset] forall self_: Fset.fset t_T. inv'1 self_
   -> inv'1 self_ /\ (forall result: Fset.fset t_T. result = self_ /\ inv'0 result  -> inv'0 result)
end
module M_creusot_contracts__logic__seq__qyi7164078029063507335__clone__refines [#"../../creusot-contracts/src/logic/seq.rs" 684 4 684 27] (* <logic::seq::Seq<T> as std::clone::Clone> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 684 4 684 27
  let%span sseq'0 = "../../creusot-contracts/src/logic/seq.rs" 697 20 697 91
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  predicate invariant' [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self: t_T) =
    [%#sboxed] inv self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_T [inv'0 x]. inv'0 x = invariant' x
  
  predicate invariant''0 [#"../../creusot-contracts/src/logic/seq.rs" 696 4 696 30] (self: Seq.seq t_T) =
    [%#sseq'0] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'0 (Seq.get self i)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: Seq.seq t_T [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate invariant''1 [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: Seq.seq t_T) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: Seq.seq t_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_T [inv'2 x]. inv'2 x = invariant''1 x
  
  goal refines: [%#sseq] forall self_: Seq.seq t_T. inv'2 self_
   -> inv'2 self_ /\ (forall result: Seq.seq t_T. result = self_ /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__fn_pure__qyi15308794846353696785__call_once__refines [#"../../creusot-contracts/src/fn_pure.rs" 44 4 44 66] (* <fn_pure::FnPureWrapper<F> as std::ops::FnOnce<I>> *)
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 44 4 44 66
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_FnPureWrapper) (args: t_I) =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: t_F) (args: t_I) (result: t_Output)
  
  
  predicate postcondition_once [#"../../creusot-contracts/src/std/ops.rs" 95 4 95 73] (self: t_FnPureWrapper) (args: t_I) (result: t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Output)
  
  goal refines: [%#sfn_pure] forall self_: t_FnPureWrapper. forall arg: t_I. precondition'0 self_ arg
  /\ inv arg /\ inv'1 self_
   -> precondition'0 self_ arg
  /\ inv arg
  /\ inv'1 self_
  /\ (forall result: t_Output. postcondition_once self_ arg result /\ inv'2 result
   -> postcondition_once self_ arg result /\ inv'2 result)
end
module M_creusot_contracts__fn_pure__qyi5108156253941351966__call_mut__refines [#"../../creusot-contracts/src/fn_pure.rs" 54 4 54 70] (* <fn_pure::FnPureWrapper<F> as std::ops::FnMut<I>> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 54 4 54 70
  
  use creusot.prelude.MutBorrow
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_FnPureWrapper) (args: t_I) =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 100 4 100 30] (self: MutBorrow.t t_FnPureWrapper) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: MutBorrow.t t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_FnPureWrapper [inv'2 x]. inv'2 x = invariant' x
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: t_F) (args: t_I) (result: t_Output)
  
  
  predicate postcondition_mut [#"../../creusot-contracts/src/std/ops.rs" 107 4 107 92] (self: t_FnPureWrapper) (args: t_I) (result_state: t_FnPureWrapper) (result: t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result /\ self = result_state
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Output)
  
  goal refines: [%#sfn_pure] forall self_: MutBorrow.t t_FnPureWrapper. forall arg: t_I. precondition'0 self_.current arg
  /\ inv arg /\ inv'2 self_
   -> precondition'0 self_.current arg
  /\ inv arg
  /\ inv'2 self_
  /\ (forall result: t_Output. postcondition_mut self_.current arg self_.final result /\ inv'3 result
   -> postcondition_mut self_.current arg self_.final result /\ inv'3 result)
end
module M_creusot_contracts__fn_pure__qyi448029234342275964__call__refines [#"../../creusot-contracts/src/fn_pure.rs" 64 4 64 62] (* <fn_pure::FnPureWrapper<F> as std::ops::Fn<I>> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sfn_pure = "../../creusot-contracts/src/fn_pure.rs" 64 4 64 62
  
  type t_F
  
  type t_FnPureWrapper  =
    { t_FnPureWrapper__0: t_F }
  
  type t_I
  
  predicate precondition [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_F) (args: t_I)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 86 4 86 45] (self: t_FnPureWrapper) (args: t_I) =
    precondition self.t_FnPureWrapper__0 args
  
  predicate inv [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_I)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_F)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnPureWrapper [inv'1 x]. inv'1 x
  = match x with
    | {t_FnPureWrapper__0 = a_0} -> inv'0 a_0
    end
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 90 4 90 30] (self: t_FnPureWrapper) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_FnPureWrapper)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FnPureWrapper [inv'2 x]. inv'2 x = invariant' x
  
  type t_Output
  
  predicate postcondition [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: t_F) (args: t_I) (result: t_Output)
  
  
  predicate postcondition'0 [#"../../creusot-contracts/src/std/ops.rs" 152 4 152 68] (self: t_FnPureWrapper) (args: t_I) (result: t_Output)
  
   =
    postcondition self.t_FnPureWrapper__0 args result
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 112 0 112 35] (_0: t_Output)
  
  goal refines: [%#sfn_pure] forall self_: t_FnPureWrapper. forall arg: t_I. precondition'0 self_ arg
  /\ inv arg /\ inv'2 self_
   -> precondition'0 self_ arg
  /\ inv arg
  /\ inv'2 self_
  /\ (forall result: t_Output. postcondition'0 self_ arg result /\ inv'3 result
   -> postcondition'0 self_ arg result /\ inv'3 result)
end
module M_creusot_contracts__invariant__qyi13867431616591602486__eq__refines [#"../../creusot-contracts/src/invariant.rs" 312 4 312 36] (* <invariant::Subset<T> as std::cmp::PartialEq> *)
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 312 4 312 36
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 173 20 173 38
  let%span sinvariant'1 = "../../creusot-contracts/src/invariant.rs" 162 14 162 32
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  type t_Subset
  
  type t_DeepModelTy
  
  type t_T
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self: t_T) : t_DeepModelTy
  
  predicate invariant' [#"../../creusot-contracts/src/invariant.rs" 72 4 72 31] (self: t_T)
  
  function view [#"../../creusot-contracts/src/invariant.rs" 163 4 163 22] (self: t_Subset) : t_T
  
  axiom view_spec: forall self: t_Subset. [%#sinvariant'1] invariant' (view self)
  
  function deep_model'0 [#"../../creusot-contracts/src/invariant.rs" 172 4 172 41] (self: t_Subset) : t_DeepModelTy =
    [%#sinvariant'0] deep_model (view self)
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Subset) : t_DeepModelTy =
    [%#smodel] deep_model'0 self
  
  goal refines: [%#sinvariant] forall self_: t_Subset. forall rhs: t_Subset. forall result: bool. result
  = (deep_model'1 self_ = deep_model'1 rhs)  -> result = (deep_model'1 self_ = deep_model'1 rhs)
end
module M_creusot_contracts__logic__id__qyi14416423697585690270__ne__refines [#"../../creusot-contracts/src/logic/id.rs" 37 4 37 38] (* <logic::id::Id as std::cmp::PartialEq> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span sid = "../../creusot-contracts/src/logic/id.rs" 37 4 37 38
  let%span sid'0 = "../../creusot-contracts/src/logic/id.rs" 48 8 48 12
  
  type t_Id
  
  function deep_model [#"../../creusot-contracts/src/logic/id.rs" 47 4 47 44] (self: t_Id) : t_Id =
    [%#sid'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Id) : t_Id =
    [%#smodel] deep_model self
  
  goal refines: [%#sid] forall self_: t_Id. forall rhs: t_Id. forall result: bool. result <> (self_ = rhs)
   -> result = (deep_model'0 self_ <> deep_model'0 rhs)
end
module M_creusot_contracts__logic__id__qyi14416423697585690270__eq__refines [#"../../creusot-contracts/src/logic/id.rs" 31 4 31 38] (* <logic::id::Id as std::cmp::PartialEq> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span sid = "../../creusot-contracts/src/logic/id.rs" 31 4 31 38
  let%span sid'0 = "../../creusot-contracts/src/logic/id.rs" 48 8 48 12
  
  type t_Id
  
  function deep_model [#"../../creusot-contracts/src/logic/id.rs" 47 4 47 44] (self: t_Id) : t_Id =
    [%#sid'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: t_Id) : t_Id =
    [%#smodel] deep_model self
  
  goal refines: [%#sid] forall self_: t_Id. forall rhs: t_Id. forall result: bool. result = (self_ = rhs)
   -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_creusot_contracts__logic__int__qyi8495612394334423323__eq__refines [#"../../creusot-contracts/src/logic/int.rs" 238 4 238 38] (* <logic::int::Int as std::cmp::PartialEq> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 238 4 238 38
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  goal refines: [%#sint] forall self_: int. forall rhs: int. forall result: bool. result = (self_ = rhs)
   -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__lt__refines [#"../../creusot-contracts/src/logic/int.rs" 256 4 256 38] (* <logic::int::Int as std::cmp::PartialOrd> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 256 4 256 38
  
  use mach.int.Int
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  goal refines: [%#sint] forall self_: int. forall other: int. forall result: bool. result = (self_ < other)
   -> result = (deep_model'0 self_ < deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__gt__refines [#"../../creusot-contracts/src/logic/int.rs" 272 4 272 38] (* <logic::int::Int as std::cmp::PartialOrd> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 272 4 272 38
  
  use mach.int.Int
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  goal refines: [%#sint] forall self_: int. forall other: int. forall result: bool. result = (self_ > other)
   -> result = (deep_model'0 self_ > deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__le__refines [#"../../creusot-contracts/src/logic/int.rs" 264 4 264 38] (* <logic::int::Int as std::cmp::PartialOrd> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 264 4 264 38
  
  use mach.int.Int
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  goal refines: [%#sint] forall self_: int. forall other: int. forall result: bool. result = (self_ <= other)
   -> result = (deep_model'0 self_ <= deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__ge__refines [#"../../creusot-contracts/src/logic/int.rs" 280 4 280 38] (* <logic::int::Int as std::cmp::PartialOrd> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 280 4 280 38
  
  use mach.int.Int
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel'0] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 34 4 34 44] (self: int) : int =
    [%#smodel] deep_model self
  
  goal refines: [%#sint] forall self_: int. forall other: int. forall result: bool. result = (self_ >= other)
   -> result = (deep_model'0 self_ >= deep_model'0 other)
end
module M_creusot_contracts__logic__int__qyi8705798629725296407__partial_cmp__refines [#"../../creusot-contracts/src/logic/int.rs" 248 4 248 69] (* <logic::int::Int as std::cmp::PartialOrd> *)
  let%span smodel = "../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sint = "../../creusot-contracts/src/logic/int.rs" 248 4 248 69
  
  use mach.int.Int
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  type t_Option  =
    | C_None
    | C_Some t_Ordering
  
  function deep_model [#"../../creusot-contracts/src/model.rs" 81 4 81 44] (self: int) : int =
    [%#smodel] self
  
  goal refines: [%#sint] forall self_: int. forall rhs: int. forall result: t_Option. result
  = C_Some (cmp_log self_ rhs)  -> result = C_Some (cmp_log (deep_model self_) (deep_model rhs))
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__idemp__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 41 4 41 26] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 41 4 41 26
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  goal refines: [%#sagree] forall self: t_Ag. forall result: bool. result = (op self self = self)
   -> result = (op self self = self)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__incl__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 48 4 48 38] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 48 4 48 38
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  goal refines: [%#sagree] forall self: t_Ag. forall other: t_Ag. forall result: bool. result
  = (exists c: t_Ag. op self c = other)  -> result = (exists c: t_Ag. op self c = other)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__associative__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  goal refines: [%#sagree] forall a: t_Ag. forall b: t_Ag. forall c: t_Ag. forall result: (). op (op a b) c
  = op a (op b c)  -> op (op a b) c = op a (op b c)
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__valid_op__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 69 4 69 30] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 69 4 69 30
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree'0] match self with
      | C_Ag _ -> true
      | C_Bot -> false
      end
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  goal refines: [%#sagree] forall self: t_Ag. forall b: t_Ag. forall result: (). valid (op self b)  -> valid self
   -> valid (op self b)  -> valid self
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 79 4 79 26] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 79 4 79 26
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 47 14 47 61
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 49 8 53 9
  let%span sagree'3 = "../../creusot-contracts/src/logic/ra/agree.rs" 40 14 40 47
  let%span sagree'4 = "../../creusot-contracts/src/logic/ra/agree.rs" 42 8 42 12
  let%span sagree'5 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree'0] match self with
      | C_Ag _ -> true
      | C_Bot -> false
      end
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  function incl [#"../../creusot-contracts/src/logic/ra/agree.rs" 48 4 48 38] (self: t_Ag) (other: t_Ag) : bool =
    [%#sagree'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> x = y
      | {_p1 = C_Bot} -> true
      | {_p1 = C_Ag _} -> false
      end
  
  axiom incl_spec: forall self: t_Ag, other: t_Ag. [%#sagree'1] incl self other = (exists c: t_Ag. op self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra/agree.rs" 41 4 41 26] (self: t_Ag) : bool =
    [%#sagree'4] true
  
  axiom idemp_spec: forall self: t_Ag. [%#sagree'3] idemp self = (op self self = self)
  
  goal refines: [%#sagree] forall self: t_Ag. valid self
   -> valid self
  /\ (forall result: (). (forall b: t_Ag. not (incl b self /\ idemp b))
  \/ (exists b: t_Ag. incl b self /\ idemp b /\ (forall c: t_Ag. incl c self /\ idemp c  -> incl c b))
   -> (forall b: t_Ag. not (incl b self /\ idemp b))
  \/ (exists b: t_Ag. incl b self /\ idemp b /\ (forall c: t_Ag. incl c self /\ idemp c  -> incl c b)))
end
module M_creusot_contracts__logic__ra__agree__qyi10739070927283834367__commutative__refines [#"../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36] (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  
  type t_T
  
  type t_Ag  =
    | C_Ag t_T
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  goal refines: [%#sagree] forall a: t_Ag. forall b: t_Ag. forall result: (). op a b = op b a  -> op a b = op b a
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__idemp__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 113 4 113 26] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 113 4 113 26
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                     _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                 _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                 t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'1] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'0] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'0] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  goal refines: [%#sauth] forall self: t_Auth. forall result: bool. result = (op'5 self self = self)
   -> result = (op'5 self self = self)
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__incl__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 106 4 106 38] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 106 4 106 38
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                     _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                 _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                 t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'1] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'0] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'0] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  goal refines: [%#sauth] forall self: t_Auth. forall other: t_Auth. forall result: bool. result
  = (exists c: t_Auth. op'5 self c = other)  -> result = (exists c: t_Auth. op'5 self c = other)
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__commutative__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 77 4 77 36] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 77 4 77 36
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                     _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                 _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                 t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'1] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'0] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'0] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  goal refines: [%#sauth] forall a: t_Auth. forall b: t_Auth. forall result: (). op'5 a b = op'5 b a
   -> op'5 a b = op'5 b a
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__valid_op__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 87 4 87 30] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 87 4 87 30
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 68 4 68 12
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 21 8 21 30
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 26 15 26 31
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 27 15 27 26
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 28 14 28 30
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 29 63 29 65
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'0] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'2] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'1] op'4 a b = op'4 b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra'1] incl self other = (exists c: t_T. op'1 self c = other)
  
  function rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 20 4 20 48] (a: t_T) (f: t_T) : bool =
    [%#sauth'2] incl f a /\ valid a
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 62] (a: t_T) (f1: t_T) (f2: t_T) : () =
    [%#sauth'6] ()
  
  axiom rel_mono_spec: forall a: t_T, f1: t_T, f2: t_T. ([%#sauth'3] rel a f1)
   -> ([%#sauth'4] incl f2 f1)  -> ([%#sauth'5] rel a f2)
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid f /\ (exists a: t_T. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/auth.rs" 70 4 70 26] (self: t_Auth) : bool =
    [%#sauth'0] valid'0 self.t_Auth__0
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'1] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  goal refines: [%#sauth] forall self: t_Auth. forall b: t_Auth. forall result: (). valid'1 (op'5 self b)
   -> valid'1 self  -> valid'1 (op'5 self b)  -> valid'1 self
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__associative__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 82 4 82 45] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 82 4 82 45
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                     _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                 _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                 t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'1] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'0] op'4 a b = op'4 b a
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'0] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  goal refines: [%#sauth] forall a: t_Auth. forall b: t_Auth. forall c: t_Auth. forall result: (). op'5 (op'5 a b) c
  = op'5 a (op'5 b c)  -> op'5 (op'5 a b) c = op'5 a (op'5 b c)
end
module M_creusot_contracts__logic__ra__auth__qyi7333002769464699444__maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 99 4 99 26] (* <logic::ra::auth::Auth<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 99 4 99 26
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 68 4 68 12
  let%span sauth'1 = "../../creusot-contracts/src/logic/ra/auth.rs" 105 14 105 59
  let%span sauth'2 = "../../creusot-contracts/src/logic/ra/auth.rs" 103 4 103 12
  let%span sauth'3 = "../../creusot-contracts/src/logic/ra/auth.rs" 112 14 112 47
  let%span sauth'4 = "../../creusot-contracts/src/logic/ra/auth.rs" 110 4 110 12
  let%span sauth'5 = "../../creusot-contracts/src/logic/ra/auth.rs" 65 8 65 32
  let%span sauth'6 = "../../creusot-contracts/src/logic/ra/auth.rs" 21 8 21 30
  let%span sauth'7 = "../../creusot-contracts/src/logic/ra/auth.rs" 26 15 26 31
  let%span sauth'8 = "../../creusot-contracts/src/logic/ra/auth.rs" 27 15 27 26
  let%span sauth'9 = "../../creusot-contracts/src/logic/ra/auth.rs" 28 14 28 30
  let%span sauth'10 = "../../creusot-contracts/src/logic/ra/auth.rs" 29 63 29 65
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 61
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 96 8 96 61
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 101 14 101 47
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 103 8 103 38
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 108 14 108 32
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 113 14 113 44
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type t_Auth  =
    { t_Auth__0: t_View }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'3] C_Bot
  
  function associative [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'5] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec: forall a: t_Excl, b: t_Excl. [%#sexcl'4] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'3] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'4] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec'1: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op'1 (op'1 a b) c = op'1 a (op'1 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec'0: forall a: t_T, b: t_T. [%#sra] op'1 a b = op'1 b a
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'3] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op'1 x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'4] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'3] { _p0 = op'0 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'5] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'4] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'6] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function associative'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (a: t_View) (b: t_View) (c: t_View) : ()
  
  
  axiom associative_spec'4: forall a: t_View, b: t_View, c: t_View. [%#sview'5] op'4 (op'4 a b) c = op'4 a (op'4 b c)
  
  function commutative'2 [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (a: t_View) (b: t_View) : ()
  
  axiom commutative_spec'2: forall a: t_View, b: t_View. [%#sview'4] op'4 a b = op'4 b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra'1] incl self other = (exists c: t_T. op'1 self c = other)
  
  function rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 20 4 20 48] (a: t_T) (f: t_T) : bool =
    [%#sauth'6] incl f a /\ valid a
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 62] (a: t_T) (f1: t_T) (f2: t_T) : () =
    [%#sauth'10] ()
  
  axiom rel_mono_spec: forall a: t_T, f1: t_T, f2: t_T. ([%#sauth'7] rel a f1)
   -> ([%#sauth'8] incl f2 f1)  -> ([%#sauth'9] rel a f2)
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid f /\ (exists a: t_T. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/auth.rs" 70 4 70 26] (self: t_Auth) : bool =
    [%#sauth'0] valid'0 self.t_Auth__0
  
  function op'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 64 4 64 36] (self: t_Auth) (other: t_Auth) : t_Auth =
    [%#sauth'5] { t_Auth__0 = op'4 self.t_Auth__0 other.t_Auth__0 }
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'0] other = C_Bot
  
  axiom incl_spec'0: forall self: t_Excl, other: t_Excl. [%#sexcl] incl'0 self other
  = (exists c: t_Excl. op self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> true
      | {_p1'0 = C_None} -> false
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> x = y \/ incl'0 x y
      end
  
  axiom incl_spec'1: forall self: t_Option, other: t_Option. [%#soption] incl'1 self other
  = (exists c: t_Option. op'0 self c = other)
  
  function incl'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option'0) (other: t_Option'0) : bool
  
   =
    [%#soption'0] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> true
      | {_p1'1 = C_None'0} -> false
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'2: forall self: t_Option'0, other: t_Option'0. [%#soption] incl'2 self other
  = (exists c: t_Option'0. op'2 self c = other)
  
  function incl'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'0] incl'1 self._p0 other._p0 /\ incl'2 self._p1 other._p1
  
  axiom incl_spec'3: forall self: tuple, other: tuple. [%#sprod] incl'3 self other
  = (exists c: tuple. op'3 self c = other)
  
  function incl'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (self: t_View) (other: t_View) : bool =
    [%#sview'1] incl'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                              _p1 = other.t_View__frag }
  
  axiom incl_spec'4: forall self: t_View, other: t_View. [%#sview'0] incl'4 self other
  = (exists c: t_View. op'4 self c = other)
  
  function incl'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 106 4 106 38] (self: t_Auth) (other: t_Auth) : bool =
    [%#sauth'2] incl'4 self.t_Auth__0 other.t_Auth__0
  
  axiom incl_spec'5: forall self: t_Auth, other: t_Auth. [%#sauth'1] incl'5 self other
  = (exists c: t_Auth. op'5 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self: t_Excl) : bool =
    [%#sexcl'2] self = C_Bot
  
  axiom idemp_spec: forall self: t_Excl. [%#sexcl'1] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'2] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption'1] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec'1: forall self: t_T. [%#sra'2] idemp'1 self = (op'1 self self = self)
  
  function idemp'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option'0) : bool =
    [%#soption'2] match self with
      | C_None'0 -> true
      | C_Some'0 x -> idemp'1 x
      end
  
  axiom idemp_spec'2: forall self: t_Option'0. [%#soption'1] idemp'2 self = (op'2 self self = self)
  
  function idemp'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self: tuple) : bool =
    [%#sprod'2] idemp'0 self._p0 /\ idemp'2 self._p1
  
  axiom idemp_spec'3: forall self: tuple. [%#sprod'1] idemp'3 self = (op'3 self self = self)
  
  function idemp'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26] (self: t_View) : bool =
    [%#sview'3] idemp'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag }
  
  axiom idemp_spec'4: forall self: t_View. [%#sview'2] idemp'4 self = (op'4 self self = self)
  
  function idemp'5 [#"../../creusot-contracts/src/logic/ra/auth.rs" 113 4 113 26] (self: t_Auth) : bool =
    [%#sauth'4] idemp'4 self.t_Auth__0
  
  axiom idemp_spec'5: forall self: t_Auth. [%#sauth'3] idemp'5 self = (op'5 self self = self)
  
  goal refines: [%#sauth] forall self: t_Auth. valid'1 self
   -> valid'1 self
  /\ (forall result: (). (forall b: t_Auth. not (incl'5 b self /\ idemp'5 b))
  \/ (exists b: t_Auth. incl'5 b self /\ idemp'5 b /\ (forall c: t_Auth. incl'5 c self /\ idemp'5 c  -> incl'5 c b))
   -> (forall b: t_Auth. not (incl'5 b self /\ idemp'5 b))
  \/ (exists b: t_Auth. incl'5 b self /\ idemp'5 b /\ (forall c: t_Auth. incl'5 c self /\ idemp'5 c  -> incl'5 c b)))
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__commutative__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'0] C_Bot
  
  goal refines: [%#sexcl] forall a: t_Excl. forall b: t_Excl. forall result: (). op a b = op b a  -> op a b = op b a
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__associative__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'0] C_Bot
  
  goal refines: [%#sexcl] forall a: t_Excl. forall b: t_Excl. forall c: t_Excl. forall result: (). op (op a b) c
  = op a (op b c)  -> op (op a b) c = op a (op b c)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 67 4 67 26] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 67 4 67 26
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 24 8 27 9
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function valid [#"../../creusot-contracts/src/logic/ra/excl.rs" 23 4 23 26] (self: t_Excl) : bool =
    [%#sexcl'0] match self with
      | C_Excl _ -> true
      | C_Bot -> false
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'5] C_Bot
  
  function incl [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'2] other = C_Bot
  
  axiom incl_spec: forall self: t_Excl, other: t_Excl. [%#sexcl'1] incl self other
  = (exists c: t_Excl. op self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self: t_Excl) : bool =
    [%#sexcl'4] self = C_Bot
  
  axiom idemp_spec: forall self: t_Excl. [%#sexcl'3] idemp self = (op self self = self)
  
  goal refines: [%#sexcl] forall self: t_Excl. valid self
   -> valid self
  /\ (forall result: (). (forall b: t_Excl. not (incl b self /\ idemp b))
  \/ (exists b: t_Excl. incl b self /\ idemp b /\ (forall c: t_Excl. incl c self /\ idemp c  -> incl c b))
   -> (forall b: t_Excl. not (incl b self /\ idemp b))
  \/ (exists b: t_Excl. incl b self /\ idemp b /\ (forall c: t_Excl. incl c self /\ idemp c  -> incl c b)))
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__idemp__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'0] C_Bot
  
  goal refines: [%#sexcl] forall self: t_Excl. forall result: bool. result = (op self self = self)
   -> result = (op self self = self)
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__valid_op__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 57 4 57 30] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 57 4 57 30
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 24 8 27 9
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function valid [#"../../creusot-contracts/src/logic/ra/excl.rs" 23 4 23 26] (self: t_Excl) : bool =
    [%#sexcl'0] match self with
      | C_Excl _ -> true
      | C_Bot -> false
      end
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'1] C_Bot
  
  goal refines: [%#sexcl] forall self: t_Excl. forall b: t_Excl. forall result: (). valid (op self b)  -> valid self
   -> valid (op self b)  -> valid self
end
module M_creusot_contracts__logic__ra__excl__qyi5962752516262580308__incl__refines [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  
  type t_T
  
  type t_Excl  =
    | C_Excl t_T
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'0] C_Bot
  
  goal refines: [%#sexcl] forall self: t_Excl. forall other: t_Excl. forall result: bool. result
  = (exists c: t_Excl. op self c = other)  -> result = (exists c: t_Excl. op self c = other)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__incl__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type tuple  =
    { _p0: t_V; _p1: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'4] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'2] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_V) (a: tuple) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap'1] forall k: t_K. match { _p0'0 = get self k;
                                                                                                             _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'0] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  goal refines: [%#sfmap] forall self: t_FMap. forall other: t_FMap. forall result: bool. result
  = (exists c: t_FMap. op'0 self c = other)  -> result = (exists c: t_FMap. op'0 self c = other)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__idemp__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 45 4 45 26] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 45 4 45 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type tuple  =
    { _p0: t_V; _p1: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'4] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'2] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_V) (a: tuple) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap'1] forall k: t_K. match { _p0'0 = get self k;
                                                                                                             _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'0] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  goal refines: [%#sfmap] forall self: t_FMap. forall result: bool. result = (op'0 self self = self)
   -> result = (op'0 self self = self)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__commutative__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type tuple  =
    { _p0: t_V; _p1: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'4] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'2] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_V) (a: tuple) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap'1] forall k: t_K. match { _p0'0 = get self k;
                                                                                                             _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'0] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  goal refines: [%#sfmap] forall a: t_FMap. forall b: t_FMap. forall result: (). op'0 a b = op'0 b a
   -> op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__associative__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type tuple  =
    { _p0: t_V; _p1: t_V }
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'4] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'3] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'2] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_V) (a: tuple) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_V. [%#sfmap'1] forall k: t_K. match { _p0'0 = get self k;
                                                                                                             _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'0] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  goal refines: [%#sfmap] forall a: t_FMap. forall b: t_FMap. forall c: t_FMap. forall result: (). op'0 (op'0 a b) c
  = op'0 a (op'0 b c)  -> op'0 (op'0 a b) c = op'0 a (op'0 b c)
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__valid_op__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 66 4 66 30] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 66 4 66 30
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_V) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'5] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'4] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'2] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap) : bool =
    [%#sfmap'0] forall k: t_K. valid'0 (get self k)
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'3] forall k: t_K. match { _p0 = get self k;
                                                                                                               _p1 = get m k } with
    | {_p0 = C_None ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None} -> get (merge self m f) k = x
    | {_p0 = C_Some x ; _p1 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'1] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in op x y)
  
  goal refines: [%#sfmap] forall self: t_FMap. forall b: t_FMap. forall result: (). valid'1 (op'1 self b)
   -> valid'1 self  -> valid'1 (op'1 self b)  -> valid'1 self
end
module M_creusot_contracts__logic__ra__fmap__qyi4212043372435109977__maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/fmap.rs" 78 4 78 26] (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 78 4 78 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 26 14 26 59
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 28 8 28 76
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 44 14 44 47
  let%span sfmap'4 = "../../creusot-contracts/src/logic/ra/fmap.rs" 47 12 47 44
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'6 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'7 = "../../creusot-contracts/src/logic/ra/fmap.rs" 93 4 102 6
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 280 14 283 5
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sutil = "../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_V) (other: t_V) : t_V
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom associative_spec: forall a: t_V, b: t_V, c: t_V. [%#sra'2] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_V) (b: t_V) : ()
  
  axiom commutative_spec: forall a: t_V, b: t_V. [%#sra'1] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'0: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'4] op'0 (op'0 a b) c
  = op'0 a (op'0 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_V) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'11] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'8] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'5] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap) : bool =
    [%#sfmap'0] forall k: t_K. valid'0 (get self k)
  
  type tuple'0  =
    { _p0'0: t_V; _p1'0: t_V }
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'0 t_V) (a: tuple'0) : t_V
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple'0 t_V) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple'0 t_V. [%#sfmap'9] forall k: t_K. match { _p0 = get self k;
                                                                                                               _p1 = get m k } with
    | {_p0 = C_None ; _p1 = y} -> get (merge self m f) k = y
    | {_p0 = x ; _p1 = C_None} -> get (merge self m f) k = x
    | {_p0 = C_Some x ; _p1 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0'0 = x; _p1'0 = y })
    end
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'6] merge self other (fun (__0: tuple'0) -> let {_p0'0 = x ; _p1'0 = y} = __0 in op x y)
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_V) (other: t_V) : bool
  
  axiom incl_spec: forall self: t_V, other: t_V. [%#sra] incl self other = (exists c: t_V. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> true
      | {_p1 = C_None} -> false
      | {_p0 = C_Some x ; _p1 = C_Some y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'0: forall self: t_Option, other: t_Option. [%#soption'0] incl'0 self other
  = (exists c: t_Option. op'0 self c = other)
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  function index_logic'0 [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple'1 t_Option) (a: tuple'1) : t_Option
  
   =
    [%#smapping] Map.get self a
  
  function filter_map [#"../../creusot-contracts/src/logic/fmap.rs" 284 4 286 17] (self: t_FMap) (f: Map.map tuple'1 t_Option) : t_FMap
  
  
  axiom filter_map_spec: forall self: t_FMap, f: Map.map tuple'1 t_Option. [%#sfmap'10] forall k: t_K. get (filter_map self f) k
  = match get self k with
    | C_None -> C_None
    | C_Some v -> index_logic'0 f { _p0'1 = k; _p1'1 = v }
    end
  
  function index_logic'1 [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map t_V bool) (a: t_V) : bool
  
   =
    [%#smapping] Map.get self a
  
  function such_that [#"../../creusot-contracts/src/util.rs" 35 0 35 59] (p: Map.map t_V bool) : t_V
  
  axiom such_that_spec: forall p: Map.map t_V bool. ([%#sutil] exists x: t_V. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that p))
  
  function missing_part [#"../../creusot-contracts/src/logic/ra/fmap.rs" 92 0 92 76] (this: t_FMap) (other: t_FMap) : t_FMap
  
   =
    [%#sfmap'7] filter_map other (fun (__0: tuple'1) -> let {_p0'1 = k ; _p1'1 = vo} = __0 in match get this k with
      | C_None -> C_Some vo
      | C_Some vs -> if vs = vo then C_None else C_Some (such_that (fun (v: t_V) -> op vs v = vo))
      end)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'2] let res = forall k: t_K. incl'0 (get self k) (get other k) in let _ = if res then
      let missing_part'0 = missing_part self other in let _ = let _ = () in () in let _ = let _ = () in () in ()
    else
      ()
     in res
  
  axiom incl_spec'1: forall self: t_FMap, other: t_FMap. [%#sfmap'1] incl'1 self other
  = (exists c: t_FMap. op'1 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_V) : bool
  
  axiom idemp_spec: forall self: t_V. [%#sra'0] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'3] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption'2] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 45 4 45 26] (self: t_FMap) : bool =
    [%#sfmap'4] forall k: t_K. idemp'0 (get self k)
  
  axiom idemp_spec'1: forall self: t_FMap. [%#sfmap'3] idemp'1 self = (op'1 self self = self)
  
  goal refines: [%#sfmap] forall self: t_FMap. valid'1 self
   -> valid'1 self
  /\ (forall result: (). (forall b: t_FMap. not (incl'1 b self /\ idemp'1 b))
  \/ (exists b: t_FMap. incl'1 b self /\ idemp'1 b /\ (forall c: t_FMap. incl'1 c self /\ idemp'1 c  -> incl'1 c b))
   -> (forall b: t_FMap. not (incl'1 b self /\ idemp'1 b))
  \/ (exists b: t_FMap. incl'1 b self /\ idemp'1 b /\ (forall c: t_FMap. incl'1 c self /\ idemp'1 c  -> incl'1 c b)))
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__incl__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  goal refines: [%#soption] forall self: t_Option. forall other: t_Option. forall result: bool. result
  = (exists c: t_Option. op'0 self c = other)  -> result = (exists c: t_Option. op'0 self c = other)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__commutative__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 50 4 50 36] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 50 4 50 36
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  goal refines: [%#soption] forall a: t_Option. forall b: t_Option. forall result: (). op'0 a b = op'0 b a
   -> op'0 a b = op'0 b a
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__valid_op__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 73 4 73 30] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 73 4 73 30
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption'0] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  goal refines: [%#soption] forall self: t_Option. forall b: t_Option. forall result: (). valid'0 (op'0 self b)
   -> valid'0 self  -> valid'0 (op'0 self b)  -> valid'0 self
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__idemp__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  goal refines: [%#soption] forall self: t_Option. forall result: bool. result = (op'0 self self = self)
   -> result = (op'0 self self = self)
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 85 4 85 26] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 85 4 85 26
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'5 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'2] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'1] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption'0] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra] incl self other = (exists c: t_T. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> true
      | {_p1 = C_None} -> false
      | {_p0 = C_Some x ; _p1 = C_Some y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'0: forall self: t_Option, other: t_Option. [%#soption'1] incl'0 self other
  = (exists c: t_Option. op'0 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra'0] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'4] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption'3] idemp'0 self = (op'0 self self = self)
  
  goal refines: [%#soption] forall self: t_Option. valid'0 self
   -> valid'0 self
  /\ (forall result: (). (forall b: t_Option. not (incl'0 b self /\ idemp'0 b))
  \/ (exists b: t_Option. incl'0 b self /\ idemp'0 b /\ (forall c: t_Option. incl'0 c self /\ idemp'0 c  -> incl'0 c b))
   -> (forall b: t_Option. not (incl'0 b self /\ idemp'0 b))
  \/ (exists b: t_Option. incl'0 b self
  /\ idemp'0 b /\ (forall c: t_Option. incl'0 c self /\ idemp'0 c  -> incl'0 c b)))
end
module M_creusot_contracts__logic__ra__option__qyi16764344068516726211__associative__refines [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (* <std::option::Option<T> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  type t_Option  =
    | C_None
    | C_Some t_T
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_None} -> other
      | {_p1 = C_None} -> self
      | {_p0 = C_Some x ; _p1 = C_Some y} -> C_Some (op x y)
      end
  
  goal refines: [%#soption] forall a: t_Option. forall b: t_Option. forall c: t_Option. forall result: (). op'0 (op'0 a b) c
  = op'0 a (op'0 b c)  -> op'0 (op'0 a b) c = op'0 a (op'0 b c)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 60 4 60 26] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 60 4 60 26
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 14 4 14 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'2] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'1] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'2] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'1] op'0 a b = op'0 b a
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_U) : bool
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 16 4 16 26] (self: tuple) : bool =
    [%#sprod'0] valid self._p0 /\ valid'0 self._p1
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'5] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra] incl self other = (exists c: t_T. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_U) (other: t_U) : bool
  
  axiom incl_spec'0: forall self: t_U, other: t_U. [%#sra] incl'0 self other = (exists c: t_U. op'0 self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'2] incl self._p0 other._p0 /\ incl'0 self._p1 other._p1
  
  axiom incl_spec'1: forall self: tuple, other: tuple. [%#sprod'1] incl'1 self other
  = (exists c: tuple. op'1 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra'0] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_U) : bool
  
  axiom idemp_spec'0: forall self: t_U. [%#sra'0] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self: tuple) : bool =
    [%#sprod'4] idemp self._p0 /\ idemp'0 self._p1
  
  axiom idemp_spec'1: forall self: tuple. [%#sprod'3] idemp'1 self = (op'1 self self = self)
  
  goal refines: [%#sprod] forall self: tuple. valid'1 self
   -> valid'1 self
  /\ (forall result: (). (forall b: tuple. not (incl'1 b self /\ idemp'1 b))
  \/ (exists b: tuple. incl'1 b self /\ idemp'1 b /\ (forall c: tuple. incl'1 c self /\ idemp'1 c  -> incl'1 c b))
   -> (forall b: tuple. not (incl'1 b self /\ idemp'1 b))
  \/ (exists b: tuple. incl'1 b self /\ idemp'1 b /\ (forall c: tuple. incl'1 c self /\ idemp'1 c  -> incl'1 c b)))
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__idemp__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'0] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  goal refines: [%#sprod] forall self: tuple. forall result: bool. result = (op'1 self self = self)
   -> result = (op'1 self self = self)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__commutative__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'0] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  goal refines: [%#sprod] forall a: tuple. forall b: tuple. forall result: (). op'1 a b = op'1 b a
   -> op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__incl__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'0] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  goal refines: [%#sprod] forall self: tuple. forall other: tuple. forall result: bool. result
  = (exists c: tuple. op'1 self c = other)  -> result = (exists c: tuple. op'1 self c = other)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__associative__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'0] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  goal refines: [%#sprod] forall a: tuple. forall b: tuple. forall c: tuple. forall result: (). op'1 (op'1 a b) c
  = op'1 a (op'1 b c)  -> op'1 (op'1 a b) c = op'1 a (op'1 b c)
end
module M_creusot_contracts__logic__ra__prod__qyi15150454618874767012__valid_op__refines [#"../../creusot-contracts/src/logic/ra/prod.rs" 47 4 47 30] (* <(T, U) as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 47 4 47 30
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 14 4 14 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  
  type t_T
  
  type t_U
  
  type tuple  =
    { _p0: t_T; _p1: t_U }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_U) : bool
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 16 4 16 26] (self: tuple) : bool =
    [%#sprod'0] valid self._p0 /\ valid'0 self._p1
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'1] { _p0 = op self._p0 other._p0; _p1 = op'0 self._p1 other._p1 }
  
  goal refines: [%#sprod] forall self: tuple. forall b: tuple. forall result: (). valid'1 (op'1 self b)  -> valid'1 self
   -> valid'1 (op'1 self b)  -> valid'1 self
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__associative__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 70 4 70 45] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 70 4 70 45
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  goal refines: [%#ssum] forall a: t_Sum. forall b: t_Sum. forall c: t_Sum. forall result: (). op'1 (op'1 a b) c
  = op'1 a (op'1 b c)  -> op'1 (op'1 a b) c = op'1 a (op'1 b c)
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 88 4 88 26] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 88 4 88 26
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 32 8 36 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 41 14 41 61
  let%span ssum'2 = "../../creusot-contracts/src/logic/ra/sum.rs" 43 8 48 9
  let%span ssum'3 = "../../creusot-contracts/src/logic/ra/sum.rs" 53 14 53 47
  let%span ssum'4 = "../../creusot-contracts/src/logic/ra/sum.rs" 55 8 59 9
  let%span ssum'5 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'2] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'1] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'2] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra'1] op'0 a b = op'0 b a
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_U) : bool
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 31 4 31 26] (self: t_Sum) : bool =
    [%#ssum'0] match self with
      | C_Left x -> valid x
      | C_Right x -> valid'0 x
      | C_Bot -> false
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra] incl self other = (exists c: t_T. op self c = other)
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_U) (other: t_U) : bool
  
  axiom incl_spec'0: forall self: t_U, other: t_U. [%#sra] incl'0 self other = (exists c: t_U. op'0 self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 42 4 42 38] (self: t_Sum) (other: t_Sum) : bool =
    [%#ssum'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> incl x y
      | {_p0 = C_Right x ; _p1 = C_Right y} -> incl'0 x y
      | {_p1 = C_Bot} -> true
      | _ -> false
      end
  
  axiom incl_spec'1: forall self: t_Sum, other: t_Sum. [%#ssum'1] incl'1 self other
  = (exists c: t_Sum. op'1 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_T) : bool
  
  axiom idemp_spec: forall self: t_T. [%#sra'0] idemp self = (op self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_U) : bool
  
  axiom idemp_spec'0: forall self: t_U. [%#sra'0] idemp'0 self = (op'0 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 54 4 54 26] (self: t_Sum) : bool =
    [%#ssum'4] match self with
      | C_Left x -> idemp x
      | C_Right x -> idemp'0 x
      | C_Bot -> true
      end
  
  axiom idemp_spec'1: forall self: t_Sum. [%#ssum'3] idemp'1 self = (op'1 self self = self)
  
  goal refines: [%#ssum] forall self: t_Sum. valid'1 self
   -> valid'1 self
  /\ (forall result: (). (forall b: t_Sum. not (incl'1 b self /\ idemp'1 b))
  \/ (exists b: t_Sum. incl'1 b self /\ idemp'1 b /\ (forall c: t_Sum. incl'1 c self /\ idemp'1 c  -> incl'1 c b))
   -> (forall b: t_Sum. not (incl'1 b self /\ idemp'1 b))
  \/ (exists b: t_Sum. incl'1 b self /\ idemp'1 b /\ (forall c: t_Sum. incl'1 c self /\ idemp'1 c  -> incl'1 c b)))
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__valid_op__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 75 4 75 30] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 75 4 75 30
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 32 8 36 9
  let%span ssum'1 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_U) : bool
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 31 4 31 26] (self: t_Sum) : bool =
    [%#ssum'0] match self with
      | C_Left x -> valid x
      | C_Right x -> valid'0 x
      | C_Bot -> false
      end
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'1] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  goal refines: [%#ssum] forall self: t_Sum. forall b: t_Sum. forall result: (). valid'1 (op'1 self b)  -> valid'1 self
   -> valid'1 (op'1 self b)  -> valid'1 self
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__incl__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 42 4 42 38] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 42 4 42 38
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  goal refines: [%#ssum] forall self: t_Sum. forall other: t_Sum. forall result: bool. result
  = (exists c: t_Sum. op'1 self c = other)  -> result = (exists c: t_Sum. op'1 self c = other)
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__commutative__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 65 4 65 36] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 65 4 65 36
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  goal refines: [%#ssum] forall a: t_Sum. forall b: t_Sum. forall result: (). op'1 a b = op'1 b a
   -> op'1 a b = op'1 b a
end
module M_creusot_contracts__logic__ra__sum__qyi13068841148246426116__idemp__refines [#"../../creusot-contracts/src/logic/ra/sum.rs" 54 4 54 26] (* <logic::ra::sum::Sum<T, U> as logic::ra::RA> *)
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span ssum = "../../creusot-contracts/src/logic/ra/sum.rs" 54 4 54 26
  let%span ssum'0 = "../../creusot-contracts/src/logic/ra/sum.rs" 22 8 26 9
  
  type t_T
  
  type t_U
  
  type t_Sum  =
    | C_Left t_T
    | C_Right t_U
    | C_Bot
  
  type tuple  =
    { _p0: t_Sum; _p1: t_Sum }
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_U) (other: t_U) : t_U
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom associative_spec'0: forall a: t_U, b: t_U, c: t_U. [%#sra'0] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_U) (b: t_U) : ()
  
  axiom commutative_spec'0: forall a: t_U, b: t_U. [%#sra] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/sum.rs" 21 4 21 36] (self: t_Sum) (other: t_Sum) : t_Sum =
    [%#ssum'0] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Left x ; _p1 = C_Left y} -> C_Left (op x y)
      | {_p0 = C_Right x ; _p1 = C_Right y} -> C_Right (op'0 x y)
      | _ -> C_Bot
      end
  
  goal refines: [%#ssum] forall self: t_Sum. forall result: bool. result = (op'1 self self = self)
   -> result = (op'1 self self = self)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__valid_op__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 30] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 119 4 119 30
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra'1] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'2] rel a f1)
   -> ([%#sview'3] incl f2 f1)  -> ([%#sview'4] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_Frag) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'0] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid f /\ (exists a: t_Auth. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'1] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  goal refines: [%#sview] forall self: t_View. forall b: t_View. forall result: (). valid'0 (op'4 self b)
   -> valid'0 self  -> valid'0 (op'4 self b)  -> valid'0 self
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__idemp__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra'1] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'1] rel a f1)
   -> ([%#sview'2] incl f2 f1)  -> ([%#sview'3] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'0] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  goal refines: [%#sview] forall self: t_View. forall result: bool. result = (op'4 self self = self)
   -> result = (op'4 self self = self)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__maximal_idemp__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 131 4 131 26] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 28 14 28 61
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 30 8 34 9
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 39 14 39 47
  let%span soption'2 = "../../creusot-contracts/src/logic/ra/option.rs" 41 8 44 9
  let%span soption'3 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'4 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'2 = "../../creusot-contracts/src/logic/ra.rs" 83 14 83 47
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 131 4 131 26
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 81 12 88 13
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 94 14 94 61
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 96 8 96 61
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 101 14 101 47
  let%span sview'4 = "../../creusot-contracts/src/logic/ra/view.rs" 103 8 103 38
  let%span sview'5 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'6 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'7 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'8 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 22 14 22 61
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 20 4 20 12
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 29 14 29 47
  let%span sprod'2 = "../../creusot-contracts/src/logic/ra/prod.rs" 27 4 27 12
  let%span sprod'3 = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'4 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'5 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 32 14 32 61
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 34 8 34 26
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 39 14 39 47
  let%span sexcl'2 = "../../creusot-contracts/src/logic/ra/excl.rs" 41 8 41 25
  let%span sexcl'3 = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'4 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'5 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra'1] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'6] rel a f1)
   -> ([%#sview'7] incl f2 f1)  -> ([%#sview'8] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_Frag) : bool
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/view.rs" 79 4 79 26] (self: t_View) : bool =
    [%#sview'0] match self with
      | {t_View__auth = C_Some (C_Excl a) ; t_View__frag = C_Some'0 f} -> valid f /\ rel a f
      | {t_View__auth = C_None ; t_View__frag = C_Some'0 f} -> valid f /\ (exists a: t_Auth. rel a f)
      | {t_View__auth = C_Some (C_Excl _) ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_None ; t_View__frag = C_None'0} -> true
      | {t_View__auth = C_Some (C_Bot) ; t_View__frag = _} -> false
      end
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl'3] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'5] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'4] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'3] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'4] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption'3] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'4] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod'3] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'5] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'4] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'5] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  function incl'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 33 4 33 38] (self: t_Excl) (other: t_Excl) : bool =
    [%#sexcl'0] other = C_Bot
  
  axiom incl_spec'0: forall self: t_Excl, other: t_Excl. [%#sexcl] incl'0 self other
  = (exists c: t_Excl. op'0 self c = other)
  
  function incl'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option) (other: t_Option) : bool
  
   =
    [%#soption'0] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> true
      | {_p1'0 = C_None} -> false
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> x = y \/ incl'0 x y
      end
  
  axiom incl_spec'1: forall self: t_Option, other: t_Option. [%#soption] incl'1 self other
  = (exists c: t_Option. op'1 self c = other)
  
  function incl'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 29 4 29 38] (self: t_Option'0) (other: t_Option'0) : bool
  
   =
    [%#soption'0] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> true
      | {_p1'1 = C_None'0} -> false
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> x = y \/ incl x y
      end
  
  axiom incl_spec'2: forall self: t_Option'0, other: t_Option'0. [%#soption] incl'2 self other
  = (exists c: t_Option'0. op'2 self c = other)
  
  function incl'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 23 4 23 38] (self: tuple) (other: tuple) : bool =
    [%#sprod'0] incl'1 self._p0 other._p0 /\ incl'2 self._p1 other._p1
  
  axiom incl_spec'3: forall self: tuple, other: tuple. [%#sprod] incl'3 self other
  = (exists c: tuple. op'3 self c = other)
  
  function incl'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (self: t_View) (other: t_View) : bool =
    [%#sview'2] incl'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                              _p1 = other.t_View__frag }
  
  axiom incl_spec'4: forall self: t_View, other: t_View. [%#sview'1] incl'4 self other
  = (exists c: t_View. op'4 self c = other)
  
  function idemp [#"../../creusot-contracts/src/logic/ra/excl.rs" 40 4 40 26] (self: t_Excl) : bool =
    [%#sexcl'2] self = C_Bot
  
  axiom idemp_spec: forall self: t_Excl. [%#sexcl'1] idemp self = (op'0 self self = self)
  
  function idemp'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option) : bool =
    [%#soption'2] match self with
      | C_None -> true
      | C_Some x -> idemp x
      end
  
  axiom idemp_spec'0: forall self: t_Option. [%#soption'1] idemp'0 self = (op'1 self self = self)
  
  function idemp'1 [#"../../creusot-contracts/src/logic/ra.rs" 84 4 84 27] (self: t_Frag) : bool
  
  axiom idemp_spec'1: forall self: t_Frag. [%#sra'2] idemp'1 self = (op self self = self)
  
  function idemp'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 40 4 40 26] (self: t_Option'0) : bool =
    [%#soption'2] match self with
      | C_None'0 -> true
      | C_Some'0 x -> idemp'1 x
      end
  
  axiom idemp_spec'2: forall self: t_Option'0. [%#soption'1] idemp'2 self = (op'2 self self = self)
  
  function idemp'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 30 4 30 26] (self: tuple) : bool =
    [%#sprod'2] idemp'0 self._p0 /\ idemp'2 self._p1
  
  axiom idemp_spec'3: forall self: tuple. [%#sprod'1] idemp'3 self = (op'3 self self = self)
  
  function idemp'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 102 4 102 26] (self: t_View) : bool =
    [%#sview'4] idemp'3 { _p0 = self.t_View__auth; _p1 = self.t_View__frag }
  
  axiom idemp_spec'4: forall self: t_View. [%#sview'3] idemp'4 self = (op'4 self self = self)
  
  goal refines: [%#sview] forall self: t_View. valid'0 self
   -> valid'0 self
  /\ (forall result: (). (forall b: t_View. not (incl'4 b self /\ idemp'4 b))
  \/ (exists b: t_View. incl'4 b self /\ idemp'4 b /\ (forall c: t_View. incl'4 c self /\ idemp'4 c  -> incl'4 c b))
   -> (forall b: t_View. not (incl'4 b self /\ idemp'4 b))
  \/ (exists b: t_View. incl'4 b self /\ idemp'4 b /\ (forall c: t_View. incl'4 c self /\ idemp'4 c  -> incl'4 c b)))
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__incl__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 95 4 95 38
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra'1] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'1] rel a f1)
   -> ([%#sview'2] incl f2 f1)  -> ([%#sview'3] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'0] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  goal refines: [%#sview] forall self: t_View. forall other: t_View. forall result: bool. result
  = (exists c: t_View. op'4 self c = other)  -> result = (exists c: t_View. op'4 self c = other)
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__commutative__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 109 4 109 36
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra'1] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'1] rel a f1)
   -> ([%#sview'2] incl f2 f1)  -> ([%#sview'3] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'0] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  goal refines: [%#sview] forall a: t_View. forall b: t_View. forall result: (). op'4 a b = op'4 b a
   -> op'4 a b = op'4 b a
end
module M_creusot_contracts__logic__ra__view__qyi11070982736783244845__associative__refines [#"../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45] (* <logic::ra::view::View<R> as logic::ra::RA> *)
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sview = "../../creusot-contracts/src/logic/ra/view.rs" 114 4 114 45
  let%span sview'0 = "../../creusot-contracts/src/logic/ra/view.rs" 73 8 73 79
  let%span sview'1 = "../../creusot-contracts/src/logic/ra/view.rs" 18 15 18 31
  let%span sview'2 = "../../creusot-contracts/src/logic/ra/view.rs" 19 15 19 26
  let%span sview'3 = "../../creusot-contracts/src/logic/ra/view.rs" 20 14 20 30
  let%span sprod = "../../creusot-contracts/src/logic/ra/prod.rs" 11 8 11 48
  let%span sprod'0 = "../../creusot-contracts/src/logic/ra/prod.rs" 36 14 36 32
  let%span sprod'1 = "../../creusot-contracts/src/logic/ra/prod.rs" 41 14 41 44
  let%span sexcl = "../../creusot-contracts/src/logic/ra/excl.rs" 18 8 18 17
  let%span sexcl'0 = "../../creusot-contracts/src/logic/ra/excl.rs" 46 14 46 32
  let%span sexcl'1 = "../../creusot-contracts/src/logic/ra/excl.rs" 51 14 51 44
  
  type t_Frag
  
  type t_Auth
  
  function rel [#"../../creusot-contracts/src/logic/ra/view.rs" 15 4 15 49] (a: t_Auth) (f: t_Frag) : bool
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_Frag) (other: t_Frag) : t_Frag
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom associative_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. [%#sra'0] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_spec: forall a: t_Frag, b: t_Frag. [%#sra] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_Frag) (other: t_Frag) : bool
  
  axiom incl_spec: forall self: t_Frag, other: t_Frag. [%#sra'1] incl self other = (exists c: t_Frag. op self c = other)
  
  function rel_mono [#"../../creusot-contracts/src/logic/ra/view.rs" 21 4 21 63] (a: t_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  
  axiom rel_mono_spec: forall a: t_Auth, f1: t_Frag, f2: t_Frag. ([%#sview'1] rel a f1)
   -> ([%#sview'2] incl f2 f1)  -> ([%#sview'3] rel a f2)
  
  type t_Excl  =
    | C_Excl t_Auth
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Excl
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Frag
  
  type t_View  =
    { t_View__auth: t_Option; t_View__frag: t_Option'0 }
  
  type tuple  =
    { _p0: t_Option; _p1: t_Option'0 }
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 17 4 17 37] (self: t_Excl) (_other: t_Excl) : t_Excl =
    [%#sexcl] C_Bot
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 52 4 52 45] (a: t_Excl) (b: t_Excl) (c: t_Excl) : ()
  
  
  axiom associative_spec'0: forall a: t_Excl, b: t_Excl, c: t_Excl. [%#sexcl'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/excl.rs" 47 4 47 36] (a: t_Excl) (b: t_Excl) : ()
  
  axiom commutative_spec'0: forall a: t_Excl, b: t_Excl. [%#sexcl'0] op'0 a b = op'0 b a
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op'0 x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  type tuple'1  =
    { _p0'1: t_Option'0; _p1'1: t_Option'0 }
  
  function op'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option'0) (other: t_Option'0) : t_Option'0
  
   =
    [%#soption] match { _p0'1 = self; _p1'1 = other } with
      | {_p0'1 = C_None'0} -> other
      | {_p1'1 = C_None'0} -> self
      | {_p0'1 = C_Some'0 x ; _p1'1 = C_Some'0 y} -> C_Some'0 (op x y)
      end
  
  function associative'2 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option'0) (b: t_Option'0) (c: t_Option'0) : ()
  
  
  axiom associative_spec'2: forall a: t_Option'0, b: t_Option'0, c: t_Option'0. [%#soption'0] op'2 (op'2 a b) c
  = op'2 a (op'2 b c)
  
  function op'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 10 4 10 36] (self: tuple) (other: tuple) : tuple =
    [%#sprod] { _p0 = op'1 self._p0 other._p0; _p1 = op'2 self._p1 other._p1 }
  
  function associative'3 [#"../../creusot-contracts/src/logic/ra/prod.rs" 42 4 42 45] (a: tuple) (b: tuple) (c: tuple) : ()
  
  
  axiom associative_spec'3: forall a: tuple, b: tuple, c: tuple. [%#sprod'1] op'3 (op'3 a b) c = op'3 a (op'3 b c)
  
  function commutative'1 [#"../../creusot-contracts/src/logic/ra/prod.rs" 37 4 37 36] (a: tuple) (b: tuple) : ()
  
  axiom commutative_spec'1: forall a: tuple, b: tuple. [%#sprod'0] op'3 a b = op'3 b a
  
  function op'4 [#"../../creusot-contracts/src/logic/ra/view.rs" 72 4 72 36] (self: t_View) (other: t_View) : t_View =
    [%#sview'0] let {_p0 = auth ; _p1 = frag} = op'3 { _p0 = self.t_View__auth;
                                                       _p1 = self.t_View__frag } { _p0 = other.t_View__auth;
                                                                                   _p1 = other.t_View__frag } in { t_View__auth = auth;
                                                                                                                   t_View__frag = frag }
  
  goal refines: [%#sview] forall a: t_View. forall b: t_View. forall c: t_View. forall result: (). op'4 (op'4 a b) c
  = op'4 a (op'4 b c)  -> op'4 (op'4 a b) c = op'4 a (op'4 b c)
end
module M_creusot_contracts__logic__ra__auth__qyi8462856325058495004__rel_mono__refines [#"../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 62] (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  let%span sauth = "../../creusot-contracts/src/logic/ra/auth.rs" 29 4 29 62
  let%span sauth'0 = "../../creusot-contracts/src/logic/ra/auth.rs" 21 8 21 30
  let%span sra = "../../creusot-contracts/src/logic/ra.rs" 76 14 76 59
  let%span sra'0 = "../../creusot-contracts/src/logic/ra.rs" 90 14 90 32
  let%span sra'1 = "../../creusot-contracts/src/logic/ra.rs" 95 14 95 44
  
  type t_T
  
  function op [#"../../creusot-contracts/src/logic/ra.rs" 35 4 35 37] (self: t_T) (other: t_T) : t_T
  
  function associative [#"../../creusot-contracts/src/logic/ra.rs" 96 4 96 46] (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom associative_spec: forall a: t_T, b: t_T, c: t_T. [%#sra'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra.rs" 91 4 91 37] (a: t_T) (b: t_T) : ()
  
  axiom commutative_spec: forall a: t_T, b: t_T. [%#sra'0] op a b = op b a
  
  function incl [#"../../creusot-contracts/src/logic/ra.rs" 77 4 77 39] (self: t_T) (other: t_T) : bool
  
  axiom incl_spec: forall self: t_T, other: t_T. [%#sra] incl self other = (exists c: t_T. op self c = other)
  
  function valid [#"../../creusot-contracts/src/logic/ra.rs" 42 4 42 27] (self: t_T) : bool
  
  function rel [#"../../creusot-contracts/src/logic/ra/auth.rs" 20 4 20 48] (a: t_T) (f: t_T) : bool =
    [%#sauth'0] incl f a /\ valid a
  
  goal refines: [%#sauth] forall a: t_T. forall f1: t_T. forall f2: t_T. incl f2 f1 /\ rel a f1
   -> incl f2 f1 /\ rel a f1 /\ (forall result: (). rel a f2  -> rel a f2)
end
module M_creusot_contracts__resource__fmap_view__qyi7192378449667732088__rel_mono__refines [#"../../creusot-contracts/src/resource/fmap_view.rs" 39 4 39 62] (* <resource::fmap_view::MapRelation<K, V> as logic::ra::view::ViewRel> *)
  let%span sfmap = "../../creusot-contracts/src/logic/ra/fmap.rs" 26 14 26 59
  let%span sfmap'0 = "../../creusot-contracts/src/logic/ra/fmap.rs" 53 14 53 32
  let%span sfmap'1 = "../../creusot-contracts/src/logic/ra/fmap.rs" 58 14 58 44
  let%span sfmap'2 = "../../creusot-contracts/src/logic/ra/fmap.rs" 13 8 13 51
  let%span sfmap'3 = "../../creusot-contracts/src/logic/ra/fmap.rs" 20 12 20 44
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 227 8 232 13
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span soption = "../../creusot-contracts/src/logic/ra/option.rs" 20 8 23 9
  let%span soption'0 = "../../creusot-contracts/src/logic/ra/option.rs" 56 14 56 44
  let%span soption'1 = "../../creusot-contracts/src/logic/ra/option.rs" 10 8 14 9
  let%span sagree = "../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  let%span sagree'0 = "../../creusot-contracts/src/logic/ra/agree.rs" 58 14 58 32
  let%span sagree'1 = "../../creusot-contracts/src/logic/ra/agree.rs" 63 14 63 44
  let%span sagree'2 = "../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap_view = "../../creusot-contracts/src/resource/fmap_view.rs" 39 4 39 62
  let%span sfmap_view'0 = "../../creusot-contracts/src/resource/fmap_view.rs" 25 8 31 13
  
  use map.Map
  
  type t_FMap
  
  type t_V
  
  type t_Ag  =
    | C_Ag t_V
    | C_Bot
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  type tuple'0  =
    { _p0'0: t_Option; _p1'0: t_Option }
  
  type t_K
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ag
  
  function view [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap) : Map.map t_K t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'7] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap) (k: t_K) : t_Option'0
  
   =
    [%#sfmap'6] Map.get (view self) k
  
  function get [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap) (k: t_K) : t_Option
  
   =
    [%#sfmap'4] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function index_logic [#"../../creusot-contracts/src/logic/mapping.rs" 59 4 59 35] (self: Map.map tuple t_Ag) (a: tuple) : t_Ag
  
   =
    [%#smapping] Map.get self a
  
  function merge [#"../../creusot-contracts/src/logic/fmap.rs" 234 4 236 17] (self: t_FMap) (m: t_FMap) (f: Map.map tuple t_Ag) : t_FMap
  
  
  axiom merge_spec: forall self: t_FMap, m: t_FMap, f: Map.map tuple t_Ag. [%#sfmap'5] forall k: t_K. match { _p0'0 = get self k;
                                                                                                              _p1'0 = get m k } with
    | {_p0'0 = C_None ; _p1'0 = y} -> get (merge self m f) k = y
    | {_p0'0 = x ; _p1'0 = C_None} -> get (merge self m f) k = x
    | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> get (merge self m f) k = C_Some (index_logic f { _p0 = x; _p1 = y })
    end
  
  function op [#"../../creusot-contracts/src/logic/ra/agree.rs" 16 4 16 36] (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  function associative [#"../../creusot-contracts/src/logic/ra/agree.rs" 64 4 64 45] (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'1] op (op a b) c = op a (op b c)
  
  function commutative [#"../../creusot-contracts/src/logic/ra/agree.rs" 59 4 59 36] (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'0] op a b = op b a
  
  function op'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 12 4 12 36] (self: t_FMap) (other: t_FMap) : t_FMap =
    [%#sfmap'2] merge self other (fun (__0: tuple) -> let {_p0 = x ; _p1 = y} = __0 in op x y)
  
  function associative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 59 4 59 45] (a: t_FMap) (b: t_FMap) (c: t_FMap) : ()
  
  
  axiom associative_spec'0: forall a: t_FMap, b: t_FMap, c: t_FMap. [%#sfmap'1] op'0 (op'0 a b) c = op'0 a (op'0 b c)
  
  function commutative'0 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 54 4 54 36] (a: t_FMap) (b: t_FMap) : ()
  
  axiom commutative_spec'0: forall a: t_FMap, b: t_FMap. [%#sfmap'0] op'0 a b = op'0 b a
  
  function incl [#"../../creusot-contracts/src/logic/ra/fmap.rs" 27 4 27 38] (self: t_FMap) (other: t_FMap) : bool
  
  axiom incl_spec: forall self: t_FMap, other: t_FMap. [%#sfmap] incl self other
  = (exists c: t_FMap. op'0 self c = other)
  
  type t_FMap'0
  
  function op'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 9 4 9 36] (self: t_Option) (other: t_Option) : t_Option
  
   =
    [%#soption'1] match { _p0'0 = self; _p1'0 = other } with
      | {_p0'0 = C_None} -> other
      | {_p1'0 = C_None} -> self
      | {_p0'0 = C_Some x ; _p1'0 = C_Some y} -> C_Some (op x y)
      end
  
  function associative'1 [#"../../creusot-contracts/src/logic/ra/option.rs" 57 4 57 45] (a: t_Option) (b: t_Option) (c: t_Option) : ()
  
  
  axiom associative_spec'1: forall a: t_Option, b: t_Option, c: t_Option. [%#soption'0] op'1 (op'1 a b) c
  = op'1 a (op'1 b c)
  
  function valid [#"../../creusot-contracts/src/logic/ra/agree.rs" 31 4 31 26] (self: t_Ag) : bool =
    [%#sagree'2] match self with
      | C_Ag _ -> true
      | C_Bot -> false
      end
  
  function valid'0 [#"../../creusot-contracts/src/logic/ra/option.rs" 19 4 19 26] (self: t_Option) : bool =
    [%#soption] match self with
      | C_Some x -> valid x
      | C_None -> true
      end
  
  function valid'1 [#"../../creusot-contracts/src/logic/ra/fmap.rs" 18 4 18 26] (self: t_FMap) : bool =
    [%#sfmap'3] forall k: t_K. valid'0 (get self k)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self: t_FMap'0) : Map.map t_K t_Option'2
  
  axiom view_spec'0: forall self: t_FMap'0. [%#sfmap'7] forall m1: t_FMap'0, m2: t_FMap'0. m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self: t_FMap'0) (k: t_K) : t_Option'2
  
   =
    [%#sfmap'6] Map.get (view'0 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self: t_FMap'0) (k: t_K) : t_Option'1
  
   =
    [%#sfmap'4] match get_unsized'0 self k with
      | C_None'2 -> C_None'1
      | C_Some'2 x -> C_Some'1 x
      end
  
  function rel [#"../../creusot-contracts/src/resource/fmap_view.rs" 24 4 24 48] (a: t_FMap'0) (f: t_FMap) : bool =
    [%#sfmap_view'0] valid'1 f
    /\ (forall k: t_K. match get f k with
      | C_Some (C_Ag v) -> get'0 a k = C_Some'1 v
      | _ -> true
      end)
  
  goal refines: [%#sfmap_view] forall a: t_FMap'0. forall f1: t_FMap. forall f2: t_FMap. incl f2 f1 /\ rel a f1
   -> incl f2 f1 /\ rel a f1 /\ (forall result: (). rel a f2  -> rel a f2)
end
