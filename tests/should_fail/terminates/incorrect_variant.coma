module M_incorrect_recursion
  use creusot.int.Int32
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_i32_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log_i32 x y = Equal)
  
  function antisym2_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Greater -> cmp_log_i32 y x = Less
  
  function antisym1_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Less -> cmp_log_i32 y x = Greater
  
  function trans_i32 (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_i32_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log_i32 x y = o
      -> cmp_log_i32 y z = o -> cmp_log_i32 x z = o
  
  function refl_i32 (x: Int32.t) : ()
  
  axiom refl_i32_spec: forall x: Int32.t. cmp_log_i32 x x = Equal
  
  function cmp_gt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log_i32 x y = Greater)
  
  function cmp_ge_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log_i32 x y <> Less)
  
  function cmp_lt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log_i32 x y = Less)
  
  function cmp_le_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log_i32 x y <> Greater)
  
  predicate well_founded_relation_i32 [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec incorrect_recursion (x: Int32.t) (return (x'0: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- Int32.lt x (-10: Int32.t) ] s1 | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb13) ] ]
    | bb2 = s0
      [ s0 = [ &_6 <- Int32.gt x (10: Int32.t) ] s1 | s1 = any [ br0 -> {_6 = false} (! bb5) | br1 -> {_6} (! bb13) ] ]
    | bb5 = s0
      [ s0 = [ &_10 <- x ] s1
      | s1 = [ &_11 <- (2: Int32.t) = (0: Int32.t) ] s2
      | s2 = {[@expl:remainder by zero] not _11} s3
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_12 <- (2: Int32.t) = (-1: Int32.t) ] s1
      | s1 = [ &_13 <- _10 = (-2147483648: Int32.t) ] s2
      | s2 = [ &_14 <- Bool.bw_and _12 _13 ] s3
      | s3 = {[@expl:Rem overflow] not _14} s4
      | s4 = bb7 ]
    | bb7 = s0
      [ s0 = Int32.rem {_10} {(2: Int32.t)} (fun (_ret: Int32.t) -> [ &_9 <- _ret ] s1)
      | s1 = [ &_8 <- _9 = (0: Int32.t) ] s2
      | s2 = any [ br0 -> {_8 = false} (! bb10) | br1 -> {_8} (! bb8) ] ]
    | bb8 = s0
      [ s0 = Int32.add {x} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &_15 <- _ret ] s1)
      | s1 = incorrect_recursion {_15} (fun (_ret: ()) -> [ &_0 <- _ret ] s2)
      | s2 = bb13 ]
    | bb10 = s0
      [ s0 = Int32.sub {x} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &_17 <- _ret ] s1)
      | s1 = incorrect_recursion {_17} (fun (_ret: ()) -> [ &_0 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & x: Int32.t = x
    | & _4: bool = Any.any_l ()
    | & _6: bool = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _9: Int32.t = Any.any_l ()
    | & _10: Int32.t = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: Int32.t = Any.any_l ()
    | & _17: Int32.t = Any.any_l () ]
    [ incorrect_recursion (x: Int32.t) (_ret (_r: ())) ->
    {[@expl:function variant] well_founded_relation_i32 function_variant x}
      incorrect_recursion {x} (_ret) ] [ function_variant: Int32.t = x ]) [ return (result: ()) -> (! return {result}) ]
end
module M_incorrect_recursion_logic
  use mach.int.Int
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  function incorrect_recursion (x: int) : int
  
  goal vc_incorrect_recursion: if x = 0 then
      [@expl:incorrect_recursion_logic ensures] 0 = 0
    else
      if Int.mod x 2 = 0 then
        well_founded_relation_Int x (x + 1)
        /\ (incorrect_recursion (x + 1) = 0
        -> ([@expl:incorrect_recursion_logic ensures] incorrect_recursion (x + 1) = 0))
      else
        well_founded_relation_Int x (x - 1)
        /\ (incorrect_recursion (x - 1) = 0
        -> ([@expl:incorrect_recursion_logic ensures] incorrect_recursion (x - 1) = 0))
    

end
module M_incorrect_loop_variant
  use creusot.int.Int32
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_i32_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log_i32 x y = Equal)
  
  function antisym2_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Greater -> cmp_log_i32 y x = Less
  
  function antisym1_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Less -> cmp_log_i32 y x = Greater
  
  function trans_i32 (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_i32_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log_i32 x y = o
      -> cmp_log_i32 y z = o -> cmp_log_i32 x z = o
  
  function refl_i32 (x: Int32.t) : ()
  
  axiom refl_i32_spec: forall x: Int32.t. cmp_log_i32 x x = Equal
  
  function cmp_gt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log_i32 x y = Greater)
  
  function cmp_ge_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log_i32 x y <> Less)
  
  function cmp_lt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log_i32 x y = Less)
  
  function cmp_le_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log_i32 x y <> Greater)
  
  predicate well_founded_relation_i32 [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec incorrect_loop_variant (x: Int32.t) (return (x'0: ())) = (! bb0
    [ bb0 = bb1
    | bb1 = bb1invariant
      [ bb1 = {[@expl:loop variant] well_founded_relation_i32 variant_old_bb1 x} bb1invariant
      | bb1invariant = (! [ &variant_old_bb1 <- x ] s0
        [ s0 = bb2 ])
        [ bb2 = s0
          [ s0 = [ &_6 <- Int32.ge x (-10: Int32.t) ] s1
          | s1 = any [ br0 -> {_6 = false} (! bb12) | br1 -> {_6} (! bb3) ] ]
        | bb3 = s0
          [ s0 = [ &_8 <- Int32.le x (10: Int32.t) ] s1
          | s1 = any [ br0 -> {_8 = false} (! bb12) | br1 -> {_8} (! bb4) ] ]
        | bb4 = s0
          [ s0 = [ &_12 <- x ] s1
          | s1 = [ &_13 <- (2: Int32.t) = (0: Int32.t) ] s2
          | s2 = {[@expl:remainder by zero] not _13} s3
          | s3 = bb5 ]
        | bb5 = s0
          [ s0 = [ &_14 <- (2: Int32.t) = (-1: Int32.t) ] s1
          | s1 = [ &_15 <- _12 = (-2147483648: Int32.t) ] s2
          | s2 = [ &_16 <- Bool.bw_and _14 _15 ] s3
          | s3 = {[@expl:Rem overflow] not _16} s4
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = Int32.rem {_12} {(2: Int32.t)} (fun (_ret: Int32.t) -> [ &_11 <- _ret ] s1)
          | s1 = [ &_10 <- _11 = (0: Int32.t) ] s2
          | s2 = any [ br0 -> {_10 = false} (! bb8) | br1 -> {_10} (! bb7) ] ]
        | bb7 = s0 [ s0 = Int32.add {x} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &x <- _ret ] s1) | s1 = bb1 ]
        | bb8 = s0 [ s0 = Int32.sub {x} {(1: Int32.t)} (fun (_ret: Int32.t) -> [ &x <- _ret ] s1) | s1 = bb1 ] ] ]
    | bb12 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & x: Int32.t = x
    | & _6: bool = Any.any_l ()
    | & _8: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int32.t = Any.any_l ()
    | & _12: Int32.t = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & variant_old_bb1: Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
