module M_evil
  use int.Int
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  function evil (x: int) : int
  
  goal vc_evil: false
    -> ([@stop_split] [@expl:evil requires] false) /\ ([@expl:variant decreases] well_founded_relation_Int x (- x))
end
module M_wrong
  use int.Int
  
  function evil (x: int) : int
  
  axiom evil_def: forall x: int. false -> evil x = evil (- x) + 1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function wrong : ()
  
  goal vc_wrong: ([@stop_split] [@expl:evil requires] false)
    /\ ([@stop_split] [@expl:evil requires] false)
    /\ evil 1 = evil (- 1) + 1
    && ([@stop_split] [@expl:evil requires] false)
    /\ ([@stop_split] [@expl:evil requires] false)
    /\ evil (- 1) = evil 1 + 1 && ([@stop_split] [@expl:wrong ensures] false)
end
