module M_unsound
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  predicate resolve_refmut_Snapshot_bool [@inline:trivial] (_1: MutBorrow.t bool) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Snapshot_bool
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec unsound (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- true ] s1
      | s1 = MutBorrow.borrow_mut <bool> {x} (fun (_bor: MutBorrow.t bool) -> [ &_4 <- _bor ] [ &x <- _bor.final ] s2)
      | s2 = MutBorrow.borrow_final <bool> {_4.current} {MutBorrow.get_id _4}
          (fun (_bor: MutBorrow.t bool) -> [ &xm <- _bor ] [ &_4 <- { _4 with current = _bor.final } ] s3)
      | s3 = -{resolve_refmut_Snapshot_bool _4}- s4
      | s4 = MutBorrow.borrow_mut <bool> {xm.current}
          (fun (_bor: MutBorrow.t bool) -> [ &_6 <- _bor ] [ &xm <- { xm with current = _bor.final } ] s5)
      | s5 = MutBorrow.borrow_final <bool> {_6.current} {MutBorrow.get_id _6}
          (fun (_bor: MutBorrow.t bool) -> [ &b <- _bor ] [ &_6 <- { _6 with current = _bor.final } ] s6)
      | s6 = -{resolve_refmut_Snapshot_bool b}- s7
      | s7 = -{resolve_refmut_Snapshot_bool _6}- s8
      | s8 = [ &bg <- b ] s9
      | s9 = {[@expl:assertion] bg.current = true /\ bg.final = true} s10
      | s10 = MutBorrow.borrow_final <bool> {xm.current} {MutBorrow.get_id xm}
          (fun (_bor: MutBorrow.t bool) -> [ &_14 <- _bor ] [ &xm <- { xm with current = _bor.final } ] s11)
      | s11 = MutBorrow.borrow_final <bool> {_14.current} {MutBorrow.get_id _14}
          (fun (_bor: MutBorrow.t bool) -> [ &evil <- _bor ] [ &_14 <- { _14 with current = _bor.final } ] s12)
      | s12 = -{resolve_refmut_Snapshot_bool _14}- s13
      | s13 = {[@expl:assertion] (evil = bg) = (evil.final = true)} s14
      | s14 = [ &evil <- { evil with current = (if evil = bg then false else true) } ] s15
      | s15 = -{resolve_refmut_Snapshot_bool evil}- s16
      | s16 = -{resolve_refmut_Snapshot_bool xm}- s17
      | s17 = {[@expl:assertion] evil.current = (not evil.final)} s18
      | s18 = {[@expl:assertion] evil.current = (not evil.current)} s19
      | s19 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & x: bool = Any.any_l ()
    | & xm: MutBorrow.t bool = Any.any_l ()
    | & _4: MutBorrow.t bool = Any.any_l ()
    | & b: MutBorrow.t bool = Any.any_l ()
    | & _6: MutBorrow.t bool = Any.any_l ()
    | & bg: MutBorrow.t bool = Any.any_l ()
    | & evil: MutBorrow.t bool = Any.any_l ()
    | & _14: MutBorrow.t bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
