module M_mk_s
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int32
  use creusot.prelude.Any
  
  predicate is_null_ptr_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  let rec null_T (return (x: Opaque.ptr)) = any
    [ return (result: Opaque.ptr) -> {is_null_ptr_T result} (! return {result}) ]
  
  type t_S_T = { f0: Int32.t; f1: Opaque.ptr }
  
  predicate inv_S_T (_1: t_S_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec mk_s_T (t: Int32.t) (return (x: t_S_T)) = (! bb0
    [ bb0 = s0
      [ s0 = null_T (fun (_x: Opaque.ptr) -> [ &_6 <- _x ] s1)
      | s1 = [ &_ret <- { f0 = t; f1 = _6 } ] s2
      | s2 = return {_ret} ] ] [ & _ret: t_S_T = Any.any_l () | & t: Int32.t = t | & _6: Opaque.ptr = Any.any_l () ])
    [ return (result: t_S_T) -> {[@expl:mk_s result type invariant] inv_S_T result}
      {[@expl:mk_s ensures] result.f0 = t}
      (! return {result}) ]
end
module M_evil
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_S_i32 = { f0: Int32.t; f1: Opaque.ptr }
  
  predicate invariant_S_i32 (self: t_S_i32) = Int32.to_int self.f0 = 0
  
  predicate inv_S_i32 (_1: t_S_i32)
  
  axiom inv_axiom [@rewrite]: forall x: t_S_i32 [inv_S_i32 x]. inv_S_i32 x = invariant_S_i32 x
  
  let rec mk_s_i32 (t: Int32.t) (return (x: t_S_i32)) = any
    [ return (result: t_S_i32) -> {inv_S_i32 result} {result.f0 = t} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec evil (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = mk_s_i32 {(1: Int32.t)} (fun (_x: t_S_i32) -> [ &_s <- _x ] s1)
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_S_i32 _s} any) ]
      | s2 = {[@expl:assertion] false} s3
      | s3 = return {_ret} ] ] [ & _ret: () = Any.any_l () | & _s: t_S_i32 = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
