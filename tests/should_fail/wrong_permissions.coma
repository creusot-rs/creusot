module M_unknown_permcell_permission
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_PermCell_i32
  
  type t_PermCellOwn_i32
  
  type t_Id
  
  function id_i32 (self: t_PermCell_i32) : t_Id
  
  function id_i32'0 (self: t_PermCellOwn_i32) : t_Id
  
  function val_i32 (self: t_PermCellOwn_i32) : Int32.t
  
  function view_PermCellOwn_i32 [@inline:trivial] (self: t_PermCellOwn_i32) : Int32.t = val_i32 self
  
  meta "rewrite_def" function view_PermCellOwn_i32
  
  let rec borrow_i32 (self: t_PermCell_i32) (perm: t_PermCellOwn_i32) (return (x: Int32.t)) =
    {[@expl:borrow requires] id_i32 self = id_i32'0 perm}
    any [ return (result: Int32.t) -> {result = view_PermCellOwn_i32 perm} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec unknown_permcell_permission (cell: t_PermCell_i32) (perm: t_PermCellOwn_i32) (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = borrow_i32 {cell} {perm} (fun (_ret: Int32.t) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & cell: t_PermCell_i32 = cell
    | & perm: t_PermCellOwn_i32 = perm
    | & _3: Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_wrong_permcell_permission
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_PermCell_i32
  
  type t_PermCellOwn_i32
  
  type tup2_PermCell_i32_Ghost_PermCellOwn_i32 = { f0: t_PermCell_i32; f1: t_PermCellOwn_i32 }
  
  type t_Id
  
  function id_i32 (self: t_PermCell_i32) : t_Id
  
  function id_i32'0 (self: t_PermCellOwn_i32) : t_Id
  
  function val_i32 (self: t_PermCellOwn_i32) : Int32.t
  
  function view_PermCellOwn_i32 [@inline:trivial] (self: t_PermCellOwn_i32) : Int32.t = val_i32 self
  
  meta "rewrite_def" function view_PermCellOwn_i32
  
  let rec new_i32 (value: Int32.t) (return (x: tup2_PermCell_i32_Ghost_PermCellOwn_i32)) = any
    [ return (result: tup2_PermCell_i32_Ghost_PermCellOwn_i32) -> {id_i32 result.f0 = id_i32'0 result.f1}
      {view_PermCellOwn_i32 result.f1 = value}
      (! return {result}) ]
  
  predicate resolve_PermCell_i32 (_1: t_PermCell_i32)
  
  let rec borrow_PermCellOwn_i32 (self: t_PermCellOwn_i32) (return (x: t_PermCellOwn_i32)) = any
    [ return (result: t_PermCellOwn_i32) -> {result = self} (! return {result}) ]
  
  let rec borrow_i32 (self: t_PermCell_i32) (perm: t_PermCellOwn_i32) (return (x: Int32.t)) =
    {[@expl:borrow requires] id_i32 self = id_i32'0 perm}
    any [ return (result: Int32.t) -> {result = view_PermCellOwn_i32 perm} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec wrong_permcell_permission (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = new_i32 {(1: Int32.t)} (fun (_ret: tup2_PermCell_i32_Ghost_PermCellOwn_i32) -> [ &_2 <- _ret ] s1)
      | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &cell <- _2.f0 ] s1
      | s1 = new_i32 {(1: Int32.t)} (fun (_ret: tup2_PermCell_i32_Ghost_PermCellOwn_i32) -> [ &_4 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = -{resolve_PermCell_i32 _4.f0}- s1
      | s1 = [ &perm <- _4.f1 ] s2
      | s2 = -{resolve_PermCell_i32 cell}- s3
      | s3 = borrow_PermCellOwn_i32 {perm} (fun (_ret: t_PermCellOwn_i32) -> [ &_7 <- _ret ] s4)
      | s4 = bb3 ]
    | bb3 = s0 [ s0 = borrow_i32 {cell} {_7} (fun (_ret: Int32.t) -> [ &_5 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & cell: t_PermCell_i32 = Any.any_l ()
    | & _2: tup2_PermCell_i32_Ghost_PermCellOwn_i32 = Any.any_l ()
    | & perm: t_PermCellOwn_i32 = Any.any_l ()
    | & _4: tup2_PermCell_i32_Ghost_PermCellOwn_i32 = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _7: t_PermCellOwn_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_unknown_ptr_own_permission
  use creusot.prelude.Opaque
  use creusot.int.Int32
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PtrOwn_i32
  
  predicate is_null_ptr_i32 (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_i32 (self: t_PtrOwn_i32) : Opaque.ptr
  
  predicate metadata_matches_i32 [@inline:trivial] (_value: Int32.t) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_i32
  
  function val_i32 (self: t_PtrOwn_i32) : Int32.t
  
  function metadata_i32 (_1: Opaque.ptr) : ()
  
  predicate inv_ref_i32 [@inline:trivial] (_1: Int32.t) = true
  
  meta "rewrite_def" predicate inv_ref_i32
  
  predicate invariant_PtrOwn_i32 (self: t_PtrOwn_i32) =
    not is_null_ptr_i32 (ptr_i32 self)
    /\ metadata_matches_i32 (val_i32 self) (metadata_i32 (ptr_i32 self)) /\ inv_ref_i32 (val_i32 self)
  
  predicate inv_PtrOwn_i32 (_1: t_PtrOwn_i32)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_i32 [inv_PtrOwn_i32 x]. inv_PtrOwn_i32 x = invariant_PtrOwn_i32 x
  
  predicate invariant_ref_PtrOwn_i32 [@inline:trivial] (self: t_PtrOwn_i32) = inv_PtrOwn_i32 self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_i32
  
  predicate inv_ref_PtrOwn_i32 [@inline:trivial] (_1: t_PtrOwn_i32) = invariant_ref_PtrOwn_i32 _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_i32
  
  predicate invariant_Ghost_ref_PtrOwn_i32 [@inline:trivial] (self: t_PtrOwn_i32) = inv_ref_PtrOwn_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_i32
  
  predicate inv_Ghost_ref_PtrOwn_i32 [@inline:trivial] (_1: t_PtrOwn_i32) = invariant_Ghost_ref_PtrOwn_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_i32
  
  let rec as_ref_i32 (ptr: Opaque.ptr) (own: t_PtrOwn_i32) (return (x: Int32.t)) =
    {[@expl:as_ref 'own' type invariant] inv_Ghost_ref_PtrOwn_i32 own}
    {[@expl:as_ref requires] ptr = ptr_i32 own}
    any [ return (result: Int32.t) -> {result = val_i32 own} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec unknown_ptr_own_permission (ptr: Opaque.ptr) (perm: t_PtrOwn_i32) (return (x: ())) =
    {[@expl:unknown_ptr_own_permission 'perm' type invariant] inv_Ghost_ref_PtrOwn_i32 perm}
    (! bb0
    [ bb0 = s0 [ s0 = as_ref_i32 {ptr} {perm} (fun (_ret: Int32.t) -> [ &_3 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ]
    [ & _0: () = Any.any_l () | & ptr: Opaque.ptr = ptr | & perm: t_PtrOwn_i32 = perm | & _3: Int32.t = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_wrong_ptr_own_permission
  use creusot.int.Int32
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PtrOwn_i32
  
  type tup2_ptr_i32_Ghost_PtrOwn_i32 = { f0: Opaque.ptr; f1: t_PtrOwn_i32 }
  
  predicate is_null_ptr_i32 (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_i32 (self: t_PtrOwn_i32) : Opaque.ptr
  
  predicate metadata_matches_i32 [@inline:trivial] (_value: Int32.t) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_i32
  
  function val_i32 (self: t_PtrOwn_i32) : Int32.t
  
  function metadata_i32 (_1: Opaque.ptr) : ()
  
  predicate inv_ref_i32 [@inline:trivial] (_1: Int32.t) = true
  
  meta "rewrite_def" predicate inv_ref_i32
  
  predicate invariant_PtrOwn_i32 (self: t_PtrOwn_i32) =
    not is_null_ptr_i32 (ptr_i32 self)
    /\ metadata_matches_i32 (val_i32 self) (metadata_i32 (ptr_i32 self)) /\ inv_ref_i32 (val_i32 self)
  
  predicate inv_PtrOwn_i32 (_1: t_PtrOwn_i32)
  
  axiom inv_axiom [@rewrite]: forall x: t_PtrOwn_i32 [inv_PtrOwn_i32 x]. inv_PtrOwn_i32 x = invariant_PtrOwn_i32 x
  
  predicate invariant_Ghost_PtrOwn_i32 [@inline:trivial] (self: t_PtrOwn_i32) = inv_PtrOwn_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_PtrOwn_i32
  
  predicate inv_Ghost_PtrOwn_i32 [@inline:trivial] (_1: t_PtrOwn_i32) = invariant_Ghost_PtrOwn_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_PtrOwn_i32
  
  predicate inv_tup2_ptr_i32_Ghost_PtrOwn_i32 [@inline:trivial] (_1: tup2_ptr_i32_Ghost_PtrOwn_i32) =
    inv_Ghost_PtrOwn_i32 _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_i32_Ghost_PtrOwn_i32
  
  let rec new_i32 (v: Int32.t) (return (x: tup2_ptr_i32_Ghost_PtrOwn_i32)) = any
    [ return (result: tup2_ptr_i32_Ghost_PtrOwn_i32) -> {inv_tup2_ptr_i32_Ghost_PtrOwn_i32 result}
      {ptr_i32 result.f1 = result.f0 /\ val_i32 result.f1 = v}
      (! return {result}) ]
  
  predicate resolve_PtrOwn_i32 (_1: t_PtrOwn_i32)
  
  predicate resolve_Ghost_PtrOwn_i32 [@inline:trivial] (_1: t_PtrOwn_i32) = resolve_PtrOwn_i32 _1
  
  meta "rewrite_def" predicate resolve_Ghost_PtrOwn_i32
  
  predicate resolve_tup2_ptr_i32_Ghost_PtrOwn_i32 [@inline:trivial] (_1: tup2_ptr_i32_Ghost_PtrOwn_i32) =
    resolve_Ghost_PtrOwn_i32 _1.f1
  
  meta "rewrite_def" predicate resolve_tup2_ptr_i32_Ghost_PtrOwn_i32
  
  predicate invariant_ref_Ghost_PtrOwn_i32 [@inline:trivial] (self: t_PtrOwn_i32) = inv_Ghost_PtrOwn_i32 self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_PtrOwn_i32
  
  predicate inv_ref_Ghost_PtrOwn_i32 [@inline:trivial] (_1: t_PtrOwn_i32) = invariant_ref_Ghost_PtrOwn_i32 _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_PtrOwn_i32
  
  predicate invariant_ref_PtrOwn_i32 [@inline:trivial] (self: t_PtrOwn_i32) = inv_PtrOwn_i32 self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_i32
  
  predicate inv_ref_PtrOwn_i32 [@inline:trivial] (_1: t_PtrOwn_i32) = invariant_ref_PtrOwn_i32 _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_i32
  
  predicate invariant_Ghost_ref_PtrOwn_i32 [@inline:trivial] (self: t_PtrOwn_i32) = inv_ref_PtrOwn_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_i32
  
  predicate inv_Ghost_ref_PtrOwn_i32 [@inline:trivial] (_1: t_PtrOwn_i32) = invariant_Ghost_ref_PtrOwn_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_i32
  
  let rec borrow_PtrOwn_i32 (self: t_PtrOwn_i32) (return (x: t_PtrOwn_i32)) =
    {[@expl:borrow 'self' type invariant] inv_ref_Ghost_PtrOwn_i32 self}
    any [ return (result: t_PtrOwn_i32) -> {inv_Ghost_ref_PtrOwn_i32 result} {result = self} (! return {result}) ]
  
  let rec as_ref_i32 (ptr: Opaque.ptr) (own: t_PtrOwn_i32) (return (x: Int32.t)) =
    {[@expl:as_ref 'own' type invariant] inv_Ghost_ref_PtrOwn_i32 own}
    {[@expl:as_ref requires] ptr = ptr_i32 own}
    any [ return (result: Int32.t) -> {result = val_i32 own} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec wrong_ptr_own_permission (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = new_i32 {(1: Int32.t)} (fun (_ret: tup2_ptr_i32_Ghost_PtrOwn_i32) -> [ &_2 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_tup2_ptr_i32_Ghost_PtrOwn_i32 _2} s1
      | s1 = -{resolve_tup2_ptr_i32_Ghost_PtrOwn_i32 _2}- s2
      | s2 = [ &ptr <- _2.f0 ] s3
      | s3 = new_i32 {(1: Int32.t)} (fun (_ret: tup2_ptr_i32_Ghost_PtrOwn_i32) -> [ &_4 <- _ret ] s4)
      | s4 = bb2 ]
    | bb2 = s0
      [ s0 = [ &perm <- _4.f1 ] s1
      | s1 = {[@expl:type invariant] inv_Ghost_PtrOwn_i32 perm} s2
      | s2 = -{resolve_Ghost_PtrOwn_i32 perm}- s3
      | s3 = borrow_PtrOwn_i32 {perm} (fun (_ret: t_PtrOwn_i32) -> [ &_8 <- _ret ] s4)
      | s4 = bb3 ]
    | bb3 = s0 [ s0 = as_ref_i32 {ptr} {_8} (fun (_ret: Int32.t) -> [ &_5 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & ptr: Opaque.ptr = Any.any_l ()
    | & _2: tup2_ptr_i32_Ghost_PtrOwn_i32 = Any.any_l ()
    | & perm: t_PtrOwn_i32 = Any.any_l ()
    | & _4: tup2_ptr_i32_Ghost_PtrOwn_i32 = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _8: t_PtrOwn_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
