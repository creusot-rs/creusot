(* Why3 Logical Types *)
module Mapping
  function from_fn (f : 'a -> 'b) : ('a -> 'b) = f
end

module Seq
  use export seq.Seq

  function to_owned (a : 'a) : 'a = a
end

module Int
  use export mach.int.Int
end

module Intrinsic
  function any_l (a :'a) : 'b
end

(* Rust primitive types *)

module Opaque
  type opaque_ptr
  type dyn
  type foreign
end

module Bool
  let eq (a : bool) (b : bool) (ret (result : bool) { a = b}) = any
  function eq (a : bool) (b : bool) : bool = (a = b)

  let ne (a : bool) (b : bool) (ret (result : bool) { a <> b}) = any
  function ne (a : bool) (b : bool) : bool = a <> b

  function to_int (b : bool) : int =
    if b then 1 else 0
(*
  function to_BV256 (x: t) : BV256.t = if b then toBig 1 else toBig 0
  function of_BV256 (x: BV256.t) : t = if b  =  0 then false else true
  *)
end

module Borrow
  type borrowed 'a = { current : 'a; final : 'a; id : int }

  function ( *_ ) (x : borrowed 'a) : 'a = x.current
  function ( ^_ ) (x : borrowed 'a) : 'a = x.final

  let borrow_final < 'a > (a : 'a) (id : int) (ret (result : borrowed 'a)) =
    any [ ret' (fin : 'a) -> (! ret { { current = a; final = fin; id = id } })]

  let borrow_mut < 'a > (a : 'a) (ret (result : borrowed 'a)) =
    any [ ret (fin : 'a) (id: int) -> (! ret { { current = a; final = fin; id = id } })]

  function borrow_logic (cur fin : 'a) (id : int) : borrowed 'a = { current = cur; final = fin; id = id }

  function get_id (x : borrowed 'a) : int = x.id
  function inherit_id (old_id inherit_path: int) : int
end

module Real
    use real.Real
end

(* Int *)
module UInt8
  use export prelude.int.UInt8
end
module UInt16
  use export prelude.int.UInt16
end
module UInt32
  use export prelude.int.UInt32
end
module UInt64
  use export prelude.int.UInt64
end
module UInt128
  use export prelude.int.UInt128
end
module Int8
  use export prelude.int.Int8
end
module Int16
  use export prelude.int.Int16
end
module Int32
  use export prelude.int.Int32
end
module Int64
  use export prelude.int.Int64
end
module Int128
  use export prelude.int.Int128
end

(* Floats *)
module Float32
  use export prelude.float.Float32
end
module Float64
  use export prelude.float.Float64
end

module Char
  (* utf8 characters (not glyphs)
      highly restricted until Why3 supports Unicode strings
  *)
  use int.Int

  type char

  function code char : int

  axiom code: forall c. 0 <= code c < 0x10FFFF

  function chr (n: int) : char

  let chr (n : int) { 0 <= n < 0x10FFFF }
    (ret (result : char) {code result = n}) = any

  axiom code_chr: forall n. 0 <= n < 0x10FFFF -> code (chr n) = n

  axiom chr_code: forall c. chr (code c) = c
end

module Snapshot
  type snap_ty 't

  function new (x : 't) : snap_ty 't
  function inner (x : snap_ty 't) : 't

  axiom new_spec [@rewrite] : forall x: 't [new x]. inner (new x) = x
  axiom inner_spec [@rewrite]: forall x: snap_ty 't [inner x]. new (inner x) = x
end


module Slice64
  use seq.Seq
  use UInt64
  use int.Int

  type slice 'a =
    { elts : seq 'a }
    invariant { Seq.length elts <= UInt64.to_int UInt64.max_uint }
  axiom slice_ext :
    forall x y: slice 'a. x.elts = y.elts -> x = y

  type array 'a = slice 'a

  function length (s : slice 'a) : UInt64.t
  axiom spec : forall s : slice 'a . (UInt64.to_int (length s)) = Seq.length s.elts


  let get < 'a > (s : slice 'a) (ix : UInt64.t) (ret (res : 'a)) =
    { UInt64.to_int ix < Seq.length s.elts }
    ret {Seq.get s.elts (to_int ix)}


  let set < 'a > (s : slice 'a) (ix : UInt64.t) (v : 'a)
    { 0 <= UInt64.to_int ix < Seq.length s.elts }
    (ret (result : slice 'a)
      { Seq.length result.elts = Seq.length s.elts }
      { result.elts[UInt64.to_int ix] = v }
      { forall j. 0 <= j < Seq.length s.elts /\ j <> UInt64.to_int ix -> result.elts[j] = s.elts[j] }
    ) = any


  let create < 'a > (len : UInt64.t) (f : int -> 'a)
    { 0 <= UInt64.to_int len }
  (ret (result : slice 'a )
    { Seq.length result.elts = UInt64.to_int len }
    { forall i . 0 <= i < UInt64.to_int len -> result.elts[i] = f i }
  ) = any

  function id (s : slice 'a) : seq 'a = s.elts
end
