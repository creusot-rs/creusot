(* Why3 Logical Types *)
module Mapping
  let function from_fn (f : 'a -> 'b) : ('a -> 'b) = f
end

module Seq
  use export seq.Seq

  function to_owned (a : 'a) : 'a = a
end

(* Rust primitive types *)

module Opaque
  type opaque_ptr
  type dyn
  type foreign
end

module Bool
  let function eqb (a : bool) (b : bool) : bool =
    ensures { result <-> a = b  }
    match a, b with
    | True, True -> True
    | False, False -> True
    | _ -> False
    end

  let neqb (a : bool) (b : bool) : bool =
    ensures { result <-> a <> b  }
    not (eqb a b)


  function eq [@inline:trivial] (a b : 'a) : bool = a = b
  function ne [@inline:trivial] (a b : 'a) : bool = a <> b

  function and (a b : bool) : bool = a /\ b
  function and2 (a b : bool) : bool = a && b
  function or  (a b : bool) : bool = a || b
  function or2 (a b : bool) : bool = a || b


  let to_int (b : bool) : int =
    if b then 1 else 0

  use int.Int

  let of_int (i : int) : bool =
    i = 1
end
module Borrow
  type borrowed 'a = { current : 'a ; final : 'a; }
  let function ( *_ ) x = x.current
  let function ( ^_ ) x = x.final
  val borrow_mut (a : 'a) : borrowed 'a
  ensures { *result = a }
end

module Real


end

module Int
  use export mach.int.Int

  let function add [@inline:trivial] (a b : int) : int = a + b
  let function sub [@inline:trivial] (a b : int) : int = a - b
  let function mul [@inline:trivial] (a b : int) : int = a * b

  let function rem [@inline:trivial] (a b : int) : int
    requires { b <> 0 }
    = a % b

  let predicate lt [@inline:trivial] (a b : int) : bool = a < b
  let predicate le [@inline:trivial] (a b : int) : bool = a <= b
  let predicate gt [@inline:trivial] (a b : int) : bool = a > b
  let predicate ge [@inline:trivial] (a b : int) : bool = a >= b
  let predicate eq [@inline:trivial] (a b : int) : bool = a = b
  let predicate ne [@inline:trivial] (a b : int) : bool = not (a = b)
end

(* Signed Integer *)
module Int8
  use int.Int

  type int8 = < range -0x80 0x7f >

  let constant min_int8 : int = - 0x80
  let constant max_int8 : int =   0x7f
  function to_int (x : int8) : int = int8'int x

  clone export numeric.BoundedInt with
    type t = int8,
    constant min = int8'minInt,
    constant max = int8'maxInt,
    function to_int = int8'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

module Int16
  use int.Int

  type int16 = < range -0x8000 0x7fff >

  let constant min_int16 : int = - 0x8000
  let constant max_int16 : int =   0x7fff
  function to_int (x : int16) : int = int16'int x

  clone export numeric.BoundedInt with
    type t = int16,
    constant min = int16'minInt,
    constant max = int16'maxInt,
    function to_int = int16'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

module Int32
  use int.Int

  type int32 = < range -0x8000_0000 0x7fff_ffff >

  let constant min_int16 : int = - 0x8000_0000
  let constant max_int16 : int =   0x7fff_ffff
  function to_int (x : int32) : int = int32'int x

  clone export numeric.BoundedInt with
    type t = int32,
    constant min = int32'minInt,
    constant max = int32'maxInt,
    function to_int = int32'int,
    lemma to_int_in_bounds,
    lemma extensionality

end

module Int64
  use int.Int

  type int64 = < range -0x8000_0000_0000_0000 0x7fff_ffff_ffff_ffff >

  let constant min_int64 : int = - 0x8000_0000_0000_0000
  let constant max_int64 : int =   0x7fff_ffff_ffff_ffff
  function to_int (x : int64) : int = int64'int x

  clone export numeric.BoundedInt with
    type t = int64,
    constant min = int64'minInt,
    constant max = int64'maxInt,
    function to_int = int64'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

module IntSize
  use export Int64
  type isize = int64
end

module Int128
  use int.Int

  type int128 = < range -0x8000_0000_0000_0000_0000_0000_0000_0000 0x7fff_ffff_ffff_ffff_ffff_ffff_ffff_ffff >

  let constant min_int128 : int = - 0x8000_0000_0000_0000_0000_0000_0000_0000
  let constant max_int128 : int =   0x7fff_ffff_ffff_ffff_ffff_ffff_ffff_ffff
  function to_int (x : int128) : int = int128'int x

  clone export numeric.BoundedInt with
    type t = int128,
    constant min = int128'minInt,
    constant max = int128'maxInt,
    function to_int = int128'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

(* Unsigned Integers *)

module UInt8
  use int.Int

  type uint8 = < range 0x0 0xff >

  let constant min_uint8 : int =  0x00
  let constant max_uint8 : int =  0xff
  function to_int (x : uint8) : int = uint8'int x

  clone export numeric.Unsigned with
    type t = uint8,
    constant max = uint8'maxInt,
    function to_int = uint8'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

module UInt16
  use int.Int

  type uint16 = < range 0x0 0xffff >

  let constant min_uint16 : int =  0x00
  let constant max_uint16 : int =  0xffff
  function to_int (x : uint16) : int = uint16'int x

  clone export numeric.Unsigned with
    type t = uint16,
    constant max = uint16'maxInt,
    function to_int = uint16'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

module UInt32
 use int.Int

  type uint32 = < range 0x0 0xffff_ffff >

  let constant min_uint32 : int =  0x0
  let constant max_uint32 : int =  0xffff_ffff
  function to_int (x : uint32) : int = uint32'int x

  clone export numeric.Unsigned with
    type t = uint32,
    constant max = uint32'maxInt,
    function to_int = uint32'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

module UInt64
  use int.Int

  type uint64 = < range 0x0 0xffff_ffff_ffff_ffff >

  let constant min_uint64 : int =  0x0
  let constant max_uint64 : int =  0xffff_ffff_ffff_ffff
  function to_int (x : uint64) : int = uint64'int x

  clone export numeric.Unsigned with
    type t = uint64,
    constant max = uint64'maxInt,
    function to_int = uint64'int,
    lemma to_int_in_bounds,
    lemma extensionality
end


module UIntSize
  use export UInt64
  type usize = uint64
end
module UInt128
  use int.Int

  type uint128 = < range 0x0 0xffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff >

  let constant min_uint128 : int =  0x0
  let constant max_uint128 : int =  0xffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff
  function to_int (x : uint128) : int = uint128'int x

  clone export numeric.Unsigned with
    type t = uint128,
    constant max = uint128'maxInt,
    function to_int = uint128'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

(* Floats *)
module Float32
  use  ieee_float.Float32

  let function neg (x:t)   : t = .- x
  let function add  (x y:t) : t = x .+ y
  let function sub  (x y:t) : t =  x .- y
  let function mul  (x y:t) : t =  x .* y
  let function div  (x y:t) : t =  x ./ y

  let lt (x y : t) : bool = x .< y
  let le (x y : t) : bool = x .< y
  let gt (x y : t) : bool = x .> y
  let ge (x y : t) : bool = x .>= y
end
module Float64
  use ieee_float.Float64

  let function neg (x:t)   : t = .- x
  let function add  (x y:t) : t = x .+ y
  let function sub  (x y:t) : t =  x .- y
  let function mul  (x y:t) : t =  x .* y
  let function div  (x y:t) : t =  x ./ y

  let lt (x y : t) : bool = x .< y
  let le (x y : t) : bool = x .< y
  let gt (x y : t) : bool = x .> y
  let ge (x y : t) : bool = x .>= y
end

module Char
  (* utf8 characters (not glyphs)
      highly restricted until Why3 supports Unicode strings
  *)
  use int.Int

  type char

  function code char : int

  axiom code: forall c. 0 <= code c < 0x10FFFF

  val function chr (n: int) : char

  axiom code_chr: forall n. 0 <= n < 0x10FFFF -> code (chr n) = n

  axiom chr_code: forall c. chr (code c) = c
end

module Ghost
  type ghost_ty 't
  val function new (ghost x : 't) : ghost_ty 't
  val function inner (x : ghost_ty 't) : 't
  axiom new_spec: forall x: 't [new x]. inner (new x) = x
  axiom inner_spec: forall x: ghost_ty 't [inner x]. new (inner x) = x
end

module Slice
  use seq.Seq
  use UIntSize
  use int.Int

  type slice 'a =
    { elts : seq 'a }
    invariant { Seq.length elts <= max_uint64 }
  axiom slice_ext :
    forall x y: slice 'a. x.elts = y.elts -> x = y

  type array 'a = slice 'a

  let create (len : uint64) (f : int -> 'a) : slice 'a =
    { elts = Seq.create (to_int len) f}

  let function length (s : slice 'a) : uint64 = of_int (Seq.length s.elts)

  let function get (s : slice 'a) (ix : uint64) : 'a =
    requires { ix < Seq.length s.elts }
    Seq.get s.elts (to_int ix)

  let set (s : slice 'a) (ix : uint64) (v : 'a) : slice 'a =
    requires { 0 <= ix < Seq.length s.elts }
    ensures { Seq.length result.elts = Seq.length s.elts }
    ensures { result.elts[ix] = v }
    ensures { forall j. 0 <= j < Seq.length s.elts /\ j <> ix -> result.elts[j] = s.elts[j] }
    { elts = Seq.set s.elts (to_int ix) v }

  function id (s : slice 'a) : seq 'a = s.elts
end
